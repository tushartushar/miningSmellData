Implementation smell,Namespace,Class,File,Method,Description
Long Method,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,Write,The method has 193 lines of code.
Long Method,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Put,The method has 136 lines of code.
Long Method,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,The method has 171 lines of code.
Long Method,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Get,The method has 129 lines of code.
Long Method,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_get,The method has 136 lines of code.
Long Method,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Ls,The method has 167 lines of code.
Long Method,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Glob_remote,The method has 124 lines of code.
Long Method,NSch,_InputStream_1195,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,The method has 133 lines of code.
Long Method,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The method has 176 lines of code.
Long Method,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The method has 220 lines of code.
Long Method,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The method has 407 lines of code.
Long Method,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The method has 218 lines of code.
Long Method,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The method has 168 lines of code.
Long Method,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The method has 435 lines of code.
Long Method,NSch,KeyPairDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The method has 133 lines of code.
Long Method,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The method has 173 lines of code.
Long Method,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,SetKnownHosts,The method has 168 lines of code.
Long Method,NSch,ProxyHTTP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The method has 123 lines of code.
Long Method,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The method has 166 lines of code.
Long Method,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The method has 404 lines of code.
Long Method,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,CheckHost,The method has 126 lines of code.
Long Method,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Read,The method has 166 lines of code.
Long Method,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Write,The method has 105 lines of code.
Long Method,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Run,The method has 398 lines of code.
Long Method,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetPermissionsString,The method has 105 lines of code.
Long Method,NSch,UserAuthGSSAPIWithMIC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthGSSAPIWithMIC.cs,Start,The method has 187 lines of code.
Long Method,NSch,UserAuthKeyboardInteractive,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthKeyboardInteractive.cs,Start,The method has 177 lines of code.
Long Method,NSch,UserAuthPassword,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPassword.cs,Start,The method has 164 lines of code.
Long Method,NSch,UserAuthPublicKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The method has 233 lines of code.
Long Method,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,Glob,The method has 139 lines of code.
Long Method,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The method has 172 lines of code.
Long Method,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The method has 559 lines of code.
Long Method,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The method has 420 lines of code.
Long Method,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The method has 281 lines of code.
Long Method,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The method has 268 lines of code.
Long Method,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The method has 254 lines of code.
Long Method,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The method has 125 lines of code.
Long Method,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_fast,The method has 117 lines of code.
Long Method,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_slow,The method has 147 lines of code.
Long Method,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The method has 177 lines of code.
Complex Method,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,GetChannel,Cyclomatic complexity of the method is 10
Complex Method,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,SendChannelOpen,Cyclomatic complexity of the method is 9
Complex Method,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,Write,Cyclomatic complexity of the method is 27
Complex Method,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Put,Cyclomatic complexity of the method is 17
Complex Method,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,Cyclomatic complexity of the method is 23
Complex Method,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Get,Cyclomatic complexity of the method is 15
Complex Method,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_get,Cyclomatic complexity of the method is 20
Complex Method,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Ls,Cyclomatic complexity of the method is 19
Complex Method,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Glob_remote,Cyclomatic complexity of the method is 19
Complex Method,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Glob_local,Cyclomatic complexity of the method is 12
Complex Method,NSch,_OutputStream_686,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,NSch,_InputStream_1195,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,Cyclomatic complexity of the method is 25
Complex Method,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,Cyclomatic complexity of the method is 9
Complex Method,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,Cyclomatic complexity of the method is 59
Complex Method,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,SetPassphrase,Cyclomatic complexity of the method is 10
Complex Method,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,Cyclomatic complexity of the method is 30
Complex Method,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,Cyclomatic complexity of the method is 24
Complex Method,NSch,KeyExchange,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyExchange.cs,Guess,Cyclomatic complexity of the method is 12
Complex Method,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,GenKey,Cyclomatic complexity of the method is 9
Complex Method,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,Cyclomatic complexity of the method is 68
Complex Method,NSch,KeyPairDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,Cyclomatic complexity of the method is 19
Complex Method,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,Cyclomatic complexity of the method is 24
Complex Method,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,SetKnownHosts,Cyclomatic complexity of the method is 26
Complex Method,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,Add,Cyclomatic complexity of the method is 11
Complex Method,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,GetHostKey,Cyclomatic complexity of the method is 8
Complex Method,NSch,ProxyHTTP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,Cyclomatic complexity of the method is 15
Complex Method,NSch,ProxySOCKS4,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,Cyclomatic complexity of the method is 9
Complex Method,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,Cyclomatic complexity of the method is 12
Complex Method,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Connect,Cyclomatic complexity of the method is 47
Complex Method,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,CheckHost,Cyclomatic complexity of the method is 18
Complex Method,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Read,Cyclomatic complexity of the method is 23
Complex Method,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Write,Cyclomatic complexity of the method is 14
Complex Method,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Run,Cyclomatic complexity of the method is 41
Complex Method,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Disconnect,Cyclomatic complexity of the method is 10
Complex Method,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,CheckCiphers,Cyclomatic complexity of the method is 8
Complex Method,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,CheckKexes,Cyclomatic complexity of the method is 8
Complex Method,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetPermissionsString,Cyclomatic complexity of the method is 14
Complex Method,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetATTR,Cyclomatic complexity of the method is 9
Complex Method,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,Cyclomatic complexity of the method is 8
Complex Method,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Dump,Cyclomatic complexity of the method is 9
Complex Method,NSch,UserAuthGSSAPIWithMIC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthGSSAPIWithMIC.cs,Start,Cyclomatic complexity of the method is 20
Complex Method,NSch,UserAuthKeyboardInteractive,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthKeyboardInteractive.cs,Start,Cyclomatic complexity of the method is 25
Complex Method,NSch,UserAuthNone,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthNone.cs,Start,Cyclomatic complexity of the method is 9
Complex Method,NSch,UserAuthPassword,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPassword.cs,Start,Cyclomatic complexity of the method is 19
Complex Method,NSch,UserAuthPublicKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,Cyclomatic complexity of the method is 29
Complex Method,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,Glob,Cyclomatic complexity of the method is 30
Complex Method,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,Cyclomatic complexity of the method is 54
Complex Method,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Inflate_flush,Cyclomatic complexity of the method is 9
Complex Method,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,Cyclomatic complexity of the method is 43
Complex Method,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,Cyclomatic complexity of the method is 26
Complex Method,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_dynamic,Cyclomatic complexity of the method is 8
Complex Method,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,Cyclomatic complexity of the method is 36
Complex Method,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,InflateSync,Cyclomatic complexity of the method is 8
Complex Method,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,Cyclomatic complexity of the method is 12
Complex Method,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,Cyclomatic complexity of the method is 10
Complex Method,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,Cyclomatic complexity of the method is 10
Complex Method,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_stored,Cyclomatic complexity of the method is 11
Complex Method,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_fast,Cyclomatic complexity of the method is 14
Complex Method,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_slow,Cyclomatic complexity of the method is 18
Complex Method,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,Cyclomatic complexity of the method is 26
Long Parameter List,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The method has 6 parameters. Parameters: session' _address_to_bind' port' target' lport' factory
Long Parameter List,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The method has 5 parameters. Parameters: session' _address_to_bind' port' daemon' arg
Long Parameter List,NSch,ChannelSession,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSession.cs,SetPtyType,The method has 5 parameters. Parameters: ttype' col' row' wp' hp
Long Parameter List,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Get,The method has 5 parameters. Parameters: src' dst' monitor' mode' skip
Long Parameter List,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_get,The method has 5 parameters. Parameters: src' dst' monitor' mode' skip
Long Parameter List,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The method has 5 parameters. Parameters: handle' offset' data' start' length
Long Parameter List,NSch,Cipher,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Cipher.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch,CipherNone,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\CipherNone.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Init,The method has 5 parameters. Parameters: session' V_S' V_C' I_S' I_C
Long Parameter List,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Init,The method has 5 parameters. Parameters: session' V_S' V_C' I_S' I_C
Long Parameter List,NSch,KeyExchange,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyExchange.cs,Init,The method has 5 parameters. Parameters: session' V_S' V_C' I_S' I_C
Long Parameter List,NSch,PortWatcher,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\PortWatcher.cs,AddPort,The method has 6 parameters. Parameters: session' address' lport' host' rport' ssf
Long Parameter List,NSch,PortWatcher,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\PortWatcher.cs,PortWatcher,The method has 6 parameters. Parameters: session' address' lport' host' rport' factory
Long Parameter List,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Start_discard,The method has 5 parameters. Parameters: buf' cipher' mac' packet_length' discard
Long Parameter List,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,SetPortForwardingL,The method has 5 parameters. Parameters: boundaddress' lport' host' rport' ssf
Long Parameter List,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,SetPortForwardingR,The method has 5 parameters. Parameters: bind_address' rport' host' lport' sf
Long Parameter List,NSch,UIKeyboardInteractive,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UIKeyboardInteractive.cs,PromptKeyboardInteractive,The method has 5 parameters. Parameters: destination' name' instruction' prompt' echo
Long Parameter List,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Init,The method has 5 parameters. Parameters: session' V_S' V_C' I_S' I_C
Long Parameter List,NSch.Jce,AES128CBC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\AES128CBC.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,AES128CTR,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\AES128CTR.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,AES192CBC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\AES192CBC.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,AES192CTR,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\AES192CTR.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,AES256CBC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\AES256CBC.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,AES256CTR,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\AES256CTR.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,ARCFOUR,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\ARCFOUR.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,ARCFOUR128,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\ARCFOUR128.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,ARCFOUR256,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\ARCFOUR256.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,BlowfishCBC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\BlowfishCBC.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,TripleDESCBC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\TripleDESCBC.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,TripleDESCTR,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\TripleDESCTR.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Init,The method has 7 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' z
Long Parameter List,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,NSch.ZLib,StaticTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\StaticTree.cs,StaticTree,The method has 5 parameters. Parameters: static_tree' extra_bits' extra_base' elems' max_length
Long Parameter List,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The method has 6 parameters. Parameters: strm' level' method' windowBits' memLevel' strategy
Long Parameter List,NSch.ZLib,Config,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Config,The method has 5 parameters. Parameters: good_length' max_lazy' nice_length' max_chain' func
Long Parameter List,Sharpen,Cipher,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Sharpen\Cipher.cs,Update,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Parameter List,Sharpen,R4Cipher,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Sharpen\Cipher.cs,Update,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Parameter List,Sharpen,AesCipher,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Sharpen\Cipher.cs,Update,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Parameter List,Sharpen,DESedeCipher,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Sharpen\Cipher.cs,Update,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Identifier,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,,The length of the parameter SSH_MSG_CHANNEL_OPEN_CONFIRMATION is 33.
Long Identifier,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,,The length of the parameter SSH_OPEN_ADMINISTRATIVELY_PROHIBITED is 36.
Long Identifier,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,,The length of the parameter SSH_AGENTC_REQUEST_RSA_IDENTITIES is 33.
Long Identifier,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,,The length of the parameter SSH_AGENT_RSA_IDENTITIES_ANSWER is 31.
Long Identifier,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,,The length of the parameter SSH_AGENTC_REMOVE_RSA_IDENTITY is 30.
Long Identifier,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,,The length of the parameter SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES is 36.
Long Identifier,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,,The length of the parameter SSH2_AGENTC_REQUEST_IDENTITIES is 30.
Long Identifier,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,,The length of the parameter SSH2_AGENTC_REMOVE_ALL_IDENTITIES is 33.
Long Identifier,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,,The length of the parameter SSH_MSG_CHANNEL_OPEN_CONFIRMATION is 33.
Long Identifier,NSch,UserAuth,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuth.cs,,The length of the parameter SSH_MSG_USERAUTH_INFO_RESPONSE is 30.
Long Identifier,NSch,UserAuthGSSAPIWithMIC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthGSSAPIWithMIC.cs,,The length of the parameter SSH_MSG_USERAUTH_GSSAPI_RESPONSE is 32.
Long Identifier,NSch,UserAuthGSSAPIWithMIC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthGSSAPIWithMIC.cs,,The length of the parameter SSH_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE is 41.
Long Identifier,NSch,UserAuthGSSAPIWithMIC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthGSSAPIWithMIC.cs,,The length of the parameter SSH_MSG_USERAUTH_GSSAPI_ERRTOK is 30.
Long Identifier,NSch,UserAuthPassword,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPassword.cs,,The length of the parameter SSH_MSG_USERAUTH_PASSWD_CHANGEREQ is 33.
Long Statement,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,CheckHost,The length of the statement  "					string message = "WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\n" + "IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\n"" is 129.
Complex Conditional,NSch,ChannelDirectTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,Run,The conditional expression  "IsConnected() && thread != null && io != null && io.@in != null"  is complex.
Complex Conditional,NSch,ChannelSession,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSession.cs,Run,The conditional expression  "IsConnected() && thread != null && io != null && io.@in != null"  is complex.
Complex Conditional,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "pubkey == null && prvkey != null && (prvkey.Length > 11 && prvkey[0] == 0 &&  				prvkey[1] == 0 && prvkey[2] == 0 && prvkey[3] == 7)"  is complex.
Complex Conditional,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf 						[i + 3] == '-' && buf[i + 4] == '-'"  is complex.
Complex Conditional,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf 						[i + 3] == 'I'"  is complex.
Complex Conditional,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' && 						 buf[i + 7] == '-'"  is complex.
Complex Conditional,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' && 						 buf[i + 7] == '-'"  is complex.
Complex Conditional,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' && 						 buf[i + 7] == '-'"  is complex.
Complex Conditional,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf 						[i + 3] == '''"  is complex.
Complex Conditional,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int) 					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data 					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked(( 					byte)unchecked((int)(0xeb)))"  is complex.
Complex Conditional,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] == 					 '-'"  is complex.
Complex Conditional,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-'"  is complex.
Complex Conditional,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-'"  is complex.
Complex Conditional,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G' 						 && buf[i_1 + 3] == 'I'"  is complex.
Complex Conditional,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1 						 + 6] == '6' && buf[i_1 + 7] == '-'"  is complex.
Complex Conditional,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1 						 + 6] == '2' && buf[i_1 + 7] == '-'"  is complex.
Complex Conditional,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1 						 + 6] == '8' && buf[i_1 + 7] == '-'"  is complex.
Complex Conditional,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C' 						 && buf[i_1 + 3] == '''"  is complex.
Complex Conditional,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data 					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked( 					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb)))"  is complex.
Complex Conditional,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] == 							 '-'"  is complex.
Complex Conditional,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-'"  is complex.
Complex Conditional,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,GetHostKey,The conditional expression  "host == null || (hk.IsMatched(host) && (type == null || hk.GetType().Equals(type 						)))"  is complex.
Complex Conditional,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,GetHostKey,The conditional expression  "host == null || (hk.IsMatched(host) && (type == null || hk.GetType().Equals(type 						)))"  is complex.
Complex Conditional,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,Remove,The conditional expression  "host == null || (hk.IsMatched(host) && (type == null || (hk.GetType().Equals( 						type) && (key == null || Util.Array_equals(key' hk.key)))))"  is complex.
Complex Conditional,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The conditional expression  "i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1] 						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-'))"  is complex.
Complex Conditional,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The conditional expression  "i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=  						'9')"  is complex.
Complex Conditional,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,CheckHost,The conditional expression  "(shkc.Equals("ask") || shkc.Equals("yes")) && (i != HostKeyRepository.OK) &&  				!insert"  is complex.
Complex Conditional,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Write,The conditional expression  "command == SSH_MSG_KEXINIT || command == SSH_MSG_NEWKEYS || command == SSH_MSG_KEXDH_INIT 					 || command == SSH_MSG_KEXDH_REPLY || command == SSH_MSG_KEX_DH_GEX_GROUP || command 					 == SSH_MSG_KEX_DH_GEX_INIT || command == SSH_MSG_KEX_DH_GEX_REPLY || command == 					 SSH_MSG_KEX_DH_GEX_REQUEST || command == SSH_MSG_DISCONNECT"  is complex.
Complex Conditional,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Run,The conditional expression  "!"forwarded-tcpip".Equals(ctyp) && !("x11".Equals(ctyp) && x11_forwarding) && 								 !("auth-agent@openssh.com".Equals(ctyp) && agent_forwarding)"  is complex.
Complex Conditional,NSch,UserAuthKeyboardInteractive,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthKeyboardInteractive.cs,Start,The conditional expression  "password != null && prompt.Length == 1 && !echo[0] && prompt[0].ToLower().StartsWith 							("password:")"  is complex.
Complex Conditional,NSch.ZLib,ZStream,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\ZStream.cs,Flush_pending,The conditional expression  "dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index 				 || dstate.pending_buf.Length < (dstate.pending_out + len) || next_out.Length <  				(next_out_index + len)"  is complex.
Complex Conditional,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_slow,The conditional expression  "match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && 						 strstart - match_start > 4096))"  is complex.
Complex Conditional,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Longest_match,The conditional expression  "window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 					 || window[match] != window[scan] || window[++match] != window[scan + 1]"  is complex.
Complex Conditional,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The conditional expression  "memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits 				 < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy >  				Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateParams,The conditional expression  "_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The conditional expression  "strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (status 				 == FINISH_STATE && flush != Z_FINISH)"  is complex.
Complex Conditional,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The conditional expression  "strm.avail_in != 0 || lookahead != 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE 				)"  is complex.
Virtual Method Call from Constructor,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,ChannelAgentForwarding,The constructor "ChannelAgentForwarding" calls a virtual method "SetLocalWindowSizeMax".
Virtual Method Call from Constructor,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,ChannelAgentForwarding,The constructor "ChannelAgentForwarding" calls a virtual method "SetLocalWindowSize".
Virtual Method Call from Constructor,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,ChannelAgentForwarding,The constructor "ChannelAgentForwarding" calls a virtual method "SetLocalPacketSize".
Virtual Method Call from Constructor,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,ChannelAgentForwarding,The constructor "ChannelAgentForwarding" calls a virtual method "Reset".
Virtual Method Call from Constructor,NSch,ChannelDirectTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,ChannelDirectTCPIP,The constructor "ChannelDirectTCPIP" calls a virtual method "SetLocalWindowSizeMax".
Virtual Method Call from Constructor,NSch,ChannelDirectTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,ChannelDirectTCPIP,The constructor "ChannelDirectTCPIP" calls a virtual method "SetLocalWindowSize".
Virtual Method Call from Constructor,NSch,ChannelDirectTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,ChannelDirectTCPIP,The constructor "ChannelDirectTCPIP" calls a virtual method "SetLocalPacketSize".
Virtual Method Call from Constructor,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,ChannelForwardedTCPIP,The constructor "ChannelForwardedTCPIP" calls a virtual method "SetLocalWindowSizeMax".
Virtual Method Call from Constructor,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,ChannelForwardedTCPIP,The constructor "ChannelForwardedTCPIP" calls a virtual method "SetLocalWindowSize".
Virtual Method Call from Constructor,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,ChannelForwardedTCPIP,The constructor "ChannelForwardedTCPIP" calls a virtual method "SetLocalPacketSize".
Virtual Method Call from Constructor,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,ChannelSftp,The constructor "ChannelSftp" calls a virtual method "SetLocalWindowSizeMax".
Virtual Method Call from Constructor,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,ChannelSftp,The constructor "ChannelSftp" calls a virtual method "SetLocalWindowSize".
Virtual Method Call from Constructor,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,ChannelSftp,The constructor "ChannelSftp" calls a virtual method "SetLocalPacketSize".
Virtual Method Call from Constructor,NSch,RequestQueue,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,RequestQueue,The constructor "RequestQueue" calls a virtual method "Init".
Virtual Method Call from Constructor,NSch,LsEntry,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,LsEntry,The constructor "LsEntry" calls a virtual method "SetFilename".
Virtual Method Call from Constructor,NSch,LsEntry,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,LsEntry,The constructor "LsEntry" calls a virtual method "SetLongname".
Virtual Method Call from Constructor,NSch,LsEntry,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,LsEntry,The constructor "LsEntry" calls a virtual method "SetAttrs".
Virtual Method Call from Constructor,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,ChannelX11,The constructor "ChannelX11" calls a virtual method "SetLocalWindowSizeMax".
Virtual Method Call from Constructor,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,ChannelX11,The constructor "ChannelX11" calls a virtual method "SetLocalWindowSize".
Virtual Method Call from Constructor,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,ChannelX11,The constructor "ChannelX11" calls a virtual method "SetLocalPacketSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetBlockSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetIVSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetBlockSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetIVSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetBlockSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetIVSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetBlockSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetIVSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetInt".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetInt".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetInt".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetOffSet".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetByte".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetInt".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetOffSet".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetByte".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "IsEnabled".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "Log".
Virtual Method Call from Constructor,NSch,RequestSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\RequestSftp.cs,RequestSftp,The constructor "RequestSftp" calls a virtual method "SetReply".
Virtual Method Call from Constructor,NSch.Jcraft,HMACMD5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jcraft\HMACMD5.cs,HMACMD5,The constructor "HMACMD5" calls a virtual method "SetH".
Virtual Method Call from Constructor,NSch.Jcraft,HMACSHA1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jcraft\HMACSHA1.cs,HMACSHA1,The constructor "HMACSHA1" calls a virtual method "SetH".
Empty Catch Block,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,Write,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,Write_ext,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,Eof_remote,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,Eof,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,Close,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,SendOpenFailure,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,SendChannelOpen,The method has an empty catch block.
Empty Catch Block,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,Send,The method has an empty catch block.
Empty Catch Block,NSch,ChannelDirectTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetData,The method has an empty catch block.
Empty Catch Block,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,DelPort,The method has an empty catch block.
Empty Catch Block,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,DelPort,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSession,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSession.cs,SetPtySize,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSession,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSession.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Lcd,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Put,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Put,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,IsRemoteDir,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Glob_local,The method has an empty catch block.
Empty Catch Block,NSch,Request,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Write,The method has an empty catch block.
Empty Catch Block,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,IO,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IO.cs,Out_close,The method has an empty catch block.
Empty Catch Block,NSch,IO,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IO.cs,Close,The method has an empty catch block.
Empty Catch Block,NSch,IO,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IO.cs,Close,The method has an empty catch block.
Empty Catch Block,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,NewInstance,The method has an empty catch block.
Empty Catch Block,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,NewInstance,The method has an empty catch block.
Empty Catch Block,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetSignature_rsa,The method has an empty catch block.
Empty Catch Block,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetSignature_dss,The method has an empty catch block.
Empty Catch Block,NSch,JSch,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\JSch.cs,JSch,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,WritePrivateKey,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,WritePublicKey,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,WriteSECSHPublicKey,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Encrypt,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Decrypt,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,GenHash,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,GenCipher,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The method has an empty catch block.
Empty Catch Block,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,SetKnownHosts,The method has an empty catch block.
Empty Catch Block,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,Remove,The method has an empty catch block.
Empty Catch Block,NSch,HashedHostKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,Hash,The method has an empty catch block.
Empty Catch Block,NSch,PortWatcher,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\PortWatcher.cs,PortWatcher,The method has an empty catch block.
Empty Catch Block,NSch,PortWatcher,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\PortWatcher.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,PortWatcher,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\PortWatcher.cs,Delete,The method has an empty catch block.
Empty Catch Block,NSch,ProxyHTTP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,ProxyHTTP,The method has an empty catch block.
Empty Catch Block,NSch,ProxyHTTP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,ProxyHTTP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,ProxyHTTP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Close,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS4,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,ProxySOCKS4,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS4,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS4,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS4,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Close,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,ProxySOCKS5,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Close,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,OpenChannel,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Write,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Write,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Write,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,SetPortForwarding,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,InitDeflater,The method has an empty catch block.
Empty Catch Block,NSch,UserAuthNone,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthNone.cs,Start,The method has an empty catch block.
Empty Catch Block,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,CreateSocket,The method has an empty catch block.
Empty Catch Block,NSch,_Runnable_350,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch.Jce,HMACMD5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD5.cs,DoFinal,The method has an empty catch block.
Empty Catch Block,NSch.Jce,HMACMD596,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,DoFinal,The method has an empty catch block.
Empty Catch Block,NSch.Jce,HMACSHA1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA1.cs,DoFinal,The method has an empty catch block.
Empty Catch Block,NSch.Jce,HMACSHA196,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,DoFinal,The method has an empty catch block.
Empty Catch Block,NSch.Jcraft,HMAC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jcraft\HMAC.cs,DoFinal,The method has an empty catch block.
Empty Catch Block,NSch.Jgss,GSSContextKrb5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jgss\GSSContextKrb5.cs,Create,The method has an empty catch block.
Empty Catch Block,NSch.Jgss,GSSContextKrb5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jgss\GSSContextKrb5.cs,Dispose,The method has an empty catch block.
Empty Catch Block,NSch.Jgss,GSSContextKrb5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jgss\GSSContextKrb5.cs,SetSystemProperty,The method has an empty catch block.
Empty Catch Block,NSch.ZLib,ZOutputStream,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\ZOutputStream.cs,Close,The method has an empty catch block.
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutInt,The following statement contains a magic number: tmp[0] = unchecked((byte)((int)(((uint)val) >> 24)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutInt,The following statement contains a magic number: tmp[1] = unchecked((byte)((int)(((uint)val) >> 16)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutInt,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)val) >> 8)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutInt,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)val) >> 8)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutInt,The following statement contains a magic number: tmp[3] = unchecked((byte)(val));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutInt,The following statement contains a magic number: System.Array.Copy(tmp' 0' buffer' index' 4);
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutInt,The following statement contains a magic number: index += 4;
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[0] = unchecked((byte)((long)(((ulong)val) >> 56)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[1] = unchecked((byte)((long)(((ulong)val) >> 48)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[2] = unchecked((byte)((long)(((ulong)val) >> 40)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[2] = unchecked((byte)((long)(((ulong)val) >> 40)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[3] = unchecked((byte)((long)(((ulong)val) >> 32)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[3] = unchecked((byte)((long)(((ulong)val) >> 32)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: System.Array.Copy(tmp' 0' buffer' index' 4);
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[0] = unchecked((byte)((long)(((ulong)val) >> 24)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[1] = unchecked((byte)((long)(((ulong)val) >> 16)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[2] = unchecked((byte)((long)(((ulong)val) >> 8)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[2] = unchecked((byte)((long)(((ulong)val) >> 8)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[3] = unchecked((byte)(val));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: System.Array.Copy(tmp' 0' buffer' index + 4' 4);
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: System.Array.Copy(tmp' 0' buffer' index + 4' 4);
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: index += 8;
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetLong,The following statement contains a magic number: foo = ((foo << 32)) | (GetInt() & unchecked((long)(0xffffffffL)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetInt,The following statement contains a magic number: foo = ((foo << 16) & unchecked((int)(0xffff0000))) | (GetShort() & unchecked((int 				)(0xffff)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetUInt,The following statement contains a magic number: foo = ((foo << 8) & unchecked((int)(0xff00))) | (GetByte() & unchecked((int)(0xff 				)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetUInt,The following statement contains a magic number: bar = ((bar << 8) & unchecked((int)(0xff00))) | (GetByte() & unchecked((int)(0xff 				)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetUInt,The following statement contains a magic number: foo = ((foo << 16) & unchecked((int)(0xffff0000))) | (bar & unchecked((int)(0xffff 				)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetShort,The following statement contains a magic number: foo = ((foo << 8) & unchecked((int)(0xff00))) | (GetByte() & unchecked((int)(0xff 				)));
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetMPInt,The following statement contains a magic number: i = 8 * 1024;
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetMPInt,The following statement contains a magic number: i = 8 * 1024;
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetMPInt,The following statement contains a magic number: i < 0 || i > 8 * 1024
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetMPInt,The following statement contains a magic number: i < 0 || i > 8 * 1024
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetMPIntBits,The following statement contains a magic number: int bytes = (bits + 7) / 8;
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetMPIntBits,The following statement contains a magic number: int bytes = (bits + 7) / 8;
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetString,The following statement contains a magic number: i = 256 * 1024;
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetString,The following statement contains a magic number: i = 256 * 1024;
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetString,The following statement contains a magic number: i < 0 || i > 256 * 1024
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetString,The following statement contains a magic number: i < 0 || i > 256 * 1024
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,GetCommand,The following statement contains a magic number: return buffer[5];
Magic Number,NSch,Buffer,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Buffer.cs,CheckFreeSize,The following statement contains a magic number: byte[] tmp = new byte[buffer.Length * 2];
Magic Number,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,GetInputStream,The following statement contains a magic number: PipedInputStream @in = new Channel.MyPipedInputStream(this' 32 * 1024);
Magic Number,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,GetInputStream,The following statement contains a magic number: PipedInputStream @in = new Channel.MyPipedInputStream(this' 32 * 1024);
Magic Number,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,GetExtInputStream,The following statement contains a magic number: PipedInputStream @in = new Channel.MyPipedInputStream(this' 32 * 1024);
Magic Number,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,GetExtInputStream,The following statement contains a magic number: PipedInputStream @in = new Channel.MyPipedInputStream(this' 32 * 1024);
Magic Number,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,Eof,The following statement contains a magic number: Buffer buf = new Buffer(100);
Magic Number,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,Close,The following statement contains a magic number: Buffer buf = new Buffer(100);
Magic Number,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,SendOpenConfirmation,The following statement contains a magic number: Buffer buf = new Buffer(100);
Magic Number,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,SendOpenFailure,The following statement contains a magic number: Buffer buf = new Buffer(100);
Magic Number,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,GenChannelOpenPacket,The following statement contains a magic number: Buffer buf = new Buffer(100);
Magic Number,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,GenChannelOpenPacket,The following statement contains a magic number: buf.PutByte(unchecked((byte)90));
Magic Number,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,SendChannelOpen,The following statement contains a magic number: int retry = 10;
Magic Number,NSch,Channel,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,SendChannelOpen,The following statement contains a magic number: long t = timeout == 0L ? 5000L : timeout;
Magic Number,NSch,_OutputStream_220,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,Init,The following statement contains a magic number: _buf.Length - (14 + 0) - Session.buffer_margin <= 0
Magic Number,NSch,_OutputStream_220,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,Write,The following statement contains a magic number: _l = _bufl - (14 + this.dataLen) - Session.buffer_margin;
Magic Number,NSch,_OutputStream_220,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,Write,The following statement contains a magic number: l > _bufl - (14 + this.dataLen) - Session.buffer_margin
Magic Number,NSch,_OutputStream_220,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Channel.cs,Write,The following statement contains a magic number: System.Array.Copy(buf' s' _buf' 14 + this.dataLen' _l);
Magic Number,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,Write,The following statement contains a magic number: rbuf.s -= 4;
Magic Number,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,Send,The following statement contains a magic number: wbuf.PutInt(4 + message.Length);
Magic Number,NSch,ChannelAgentForwarding,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,Send,The following statement contains a magic number: GetSession().Write(packet' this' 4 + message.Length);
Magic Number,NSch,ChannelDirectTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,Run,The following statement contains a magic number: i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);
Magic Number,NSch,ChannelDirectTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,Run,The following statement contains a magic number: i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);
Magic Number,NSch,ChannelDirectTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,GenChannelOpenPacket,The following statement contains a magic number: Buffer buf = new Buffer(150);
Magic Number,NSch,ChannelDirectTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,GenChannelOpenPacket,The following statement contains a magic number: buf.PutByte(unchecked((byte)90));
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,Run,The following statement contains a magic number: io.SetInputStream(new Channel.PassiveInputStream(this' @out' 32 * 1024)' false);
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,Run,The following statement contains a magic number: io.SetInputStream(new Channel.PassiveInputStream(this' @out' 32 * 1024)' false);
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,Run,The following statement contains a magic number: daemon.SetArg((object[])foo[3]);
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,Run,The following statement contains a magic number: i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,Run,The following statement contains a magic number: i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetData,The following statement contains a magic number: this.target = (string)foo[2];
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetData,The following statement contains a magic number: foo[3] == null || (foo[3] is object[])
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetData,The following statement contains a magic number: foo[3] == null || (foo[3] is object[])
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetData,The following statement contains a magic number: this.factory = ((SocketFactory)foo[5]);
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetData,The following statement contains a magic number: foo.Length >= 6
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetPortForwarding,The following statement contains a magic number: foo.Add(bar[1] + ":" + bar[2] + ":");
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetPortForwarding,The following statement contains a magic number: bar[3] == null
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: object[] foo = new object[6];
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: foo[2] = target;
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: foo[3] = lport;
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: foo[4] = address_to_bind;
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: foo[5] = factory;
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: object[] foo = new object[5];
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: foo[2] = daemon;
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: foo[3] = arg;
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: foo[4] = address_to_bind;
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,DelPort,The following statement contains a magic number: address_to_bind = (string)foo[4];
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,DelPort,The following statement contains a magic number: Buffer buf = new Buffer(100);
Magic Number,NSch,ChannelForwardedTCPIP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,DelPort,The following statement contains a magic number: buf.PutByte(unchecked((byte)80));
Magic Number,NSch,ChannelSession,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSession.cs,SetPtyType,The following statement contains a magic number: SetPtyType(ttype' 80' 24' 640' 480);
Magic Number,NSch,ChannelSession,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSession.cs,SetPtyType,The following statement contains a magic number: SetPtyType(ttype' 80' 24' 640' 480);
Magic Number,NSch,ChannelSession,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSession.cs,SetPtyType,The following statement contains a magic number: SetPtyType(ttype' 80' 24' 640' 480);
Magic Number,NSch,ChannelSession,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSession.cs,SetPtyType,The following statement contains a magic number: SetPtyType(ttype' 80' 24' 640' 480);
Magic Number,NSch,ChannelSession,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSession.cs,Run,The following statement contains a magic number: i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);
Magic Number,NSch,ChannelSession,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSession.cs,Run,The following statement contains a magic number: i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,ChannelSftp,The following statement contains a magic number: rq = new ChannelSftp.RequestQueue(this' 10);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Start,The following statement contains a magic number: length -= (4 + extension_name.Length);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Start,The following statement contains a magic number: length -= (4 + extension_data.Length);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,The following statement contains a magic number: data = new byte[obuf.buffer.Length - (5 + 13 + 21 + handle.Length + Session.buffer_margin 						)];
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,The following statement contains a magic number: data = new byte[obuf.buffer.Length - (5 + 13 + 21 + handle.Length + Session.buffer_margin 						)];
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,The following statement contains a magic number: data = new byte[obuf.buffer.Length - (5 + 13 + 21 + handle.Length + Session.buffer_margin 						)];
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_get,The following statement contains a magic number: int request_len = buf.buffer.Length - 13;
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_get,The following statement contains a magic number: request_len = 1024;
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_get,The following statement contains a magic number: Fill(buf.buffer' 0' 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_get,The following statement contains a magic number: length -= 4;
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Ls,The following statement contains a magic number: Fill(buf.buffer' 0' 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Ls,The following statement contains a magic number: length -= 4;
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Ls,The following statement contains a magic number: server_version <= 3
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Readlink,The following statement contains a magic number: server_version < 3
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Readlink,The following statement contains a magic number: server_version <= 3
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Symlink,The following statement contains a magic number: server_version < 3
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Rename,The following statement contains a magic number: server_version < 2
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Rename,The following statement contains a magic number: vsize >= 2
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_realpath,The following statement contains a magic number: server_version <= 3
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendINIT,The following statement contains a magic number: PutHEAD(SSH_FXP_INIT' 5);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendINIT,The following statement contains a magic number: buf.PutInt(3);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendINIT,The following statement contains a magic number: GetSession().Write(packet' this' 5 + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendINIT,The following statement contains a magic number: GetSession().Write(packet' this' 5 + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendSETSTAT,The following statement contains a magic number: PutHEAD(SSH_FXP_SETSTAT' 9 + path.Length + attr.Length());
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendSETSTAT,The following statement contains a magic number: GetSession().Write(packet' this' 9 + path.Length + attr.Length() + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendSETSTAT,The following statement contains a magic number: GetSession().Write(packet' this' 9 + path.Length + attr.Length() + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendMKDIR,The following statement contains a magic number: PutHEAD(SSH_FXP_MKDIR' 9 + path.Length + (attr != null ? attr.Length() : 4));
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendMKDIR,The following statement contains a magic number: PutHEAD(SSH_FXP_MKDIR' 9 + path.Length + (attr != null ? attr.Length() : 4));
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendMKDIR,The following statement contains a magic number: GetSession().Write(packet' this' 9 + path.Length + (attr != null ? attr.Length() :  				4) + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendMKDIR,The following statement contains a magic number: GetSession().Write(packet' this' 9 + path.Length + (attr != null ? attr.Length() :  				4) + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendMKDIR,The following statement contains a magic number: GetSession().Write(packet' this' 9 + path.Length + (attr != null ? attr.Length() :  				4) + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendOPEN,The following statement contains a magic number: PutHEAD(SSH_FXP_OPEN' 17 + path.Length);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendOPEN,The following statement contains a magic number: GetSession().Write(packet' this' 17 + path.Length + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendOPEN,The following statement contains a magic number: GetSession().Write(packet' this' 17 + path.Length + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendPacketPath,The following statement contains a magic number: PutHEAD(fxp' 9 + path.Length);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendPacketPath,The following statement contains a magic number: GetSession().Write(packet' this' 9 + path.Length + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendPacketPath,The following statement contains a magic number: GetSession().Write(packet' this' 9 + path.Length + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendPacketPath,The following statement contains a magic number: PutHEAD(fxp' 13 + p1.Length + p2.Length);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendPacketPath,The following statement contains a magic number: GetSession().Write(packet' this' 13 + p1.Length + p2.Length + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendPacketPath,The following statement contains a magic number: GetSession().Write(packet' this' 13 + p1.Length + p2.Length + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The following statement contains a magic number: _length = obuf.buffer.Length - (obuf.index + 13 + 21 + handle.Length + Session.buffer_margin 					);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The following statement contains a magic number: _length = obuf.buffer.Length - (obuf.index + 13 + 21 + handle.Length + Session.buffer_margin 					);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The following statement contains a magic number: obuf.buffer.Length < obuf.index + 13 + 21 + handle.Length + length + Session. 				buffer_margin
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The following statement contains a magic number: obuf.buffer.Length < obuf.index + 13 + 21 + handle.Length + length + Session. 				buffer_margin
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The following statement contains a magic number: PutHEAD(obuf' SSH_FXP_WRITE' 21 + handle.Length + _length);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The following statement contains a magic number: GetSession().Write(opacket' this' 21 + handle.Length + _length + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The following statement contains a magic number: GetSession().Write(opacket' this' 21 + handle.Length + _length + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendREAD,The following statement contains a magic number: PutHEAD(SSH_FXP_READ' 21 + handle.Length);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendREAD,The following statement contains a magic number: GetSession().Write(packet' this' 21 + handle.Length + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendREAD,The following statement contains a magic number: GetSession().Write(packet' this' 21 + handle.Length + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,PutHEAD,The following statement contains a magic number: buf.PutInt(length + 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Glob_remote,The following statement contains a magic number: Fill(buf.buffer' 0' 4);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Glob_remote,The following statement contains a magic number: length -= 4;
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Glob_remote,The following statement contains a magic number: server_version <= 3
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,ThrowStatusError,The following statement contains a magic number: server_version >= 3 && buf.GetLength() >= 4
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,ThrowStatusError,The following statement contains a magic number: server_version >= 3 && buf.GetLength() >= 4
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Header,The following statement contains a magic number: int i = Fill(buf.buffer' 0' 9);
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Header,The following statement contains a magic number: header.length = buf.GetInt() - 5;
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SetFilenameEncoding,The following statement contains a magic number: 3 <= sversion && sversion <= 5 && !encoding.Equals(UTF8)
Magic Number,NSch,ChannelSftp,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SetFilenameEncoding,The following statement contains a magic number: 3 <= sversion && sversion <= 5 && !encoding.Equals(UTF8)
Magic Number,NSch,_OutputStream_686,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Write,The following statement contains a magic number: (this._enclosing.seq - 1) == this.startid || this._enclosing.io_in.Available( 							) >= 1024
Magic Number,NSch,Request,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Write,The following statement contains a magic number: Sharpen.Thread.Sleep(10);
Magic Number,NSch,_InputStream_1195,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_InputStream_1195,The following statement contains a magic number: this.rest_byte = new byte[1024];
Magic Number,NSch,_InputStream_1195,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,The following statement contains a magic number: len = this._enclosing.buf.buffer.Length - 13;
Magic Number,NSch,_InputStream_1195,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,The following statement contains a magic number: this._enclosing.buf.buffer.Length - 13 < len
Magic Number,NSch,_InputStream_1195,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,The following statement contains a magic number: len = 1024;
Magic Number,NSch,_InputStream_1195,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,The following statement contains a magic number: this._enclosing.server_version == 0 && len > 1024
Magic Number,NSch,_InputStream_1195,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,The following statement contains a magic number: this._enclosing.Fill(this._enclosing.buf.buffer' 0' 4);
Magic Number,NSch,_InputStream_1195,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,The following statement contains a magic number: this.rest_length -= 4;
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,SetCookie,The following statement contains a magic number: cookie = new byte[16];
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,SetCookie,The following statement contains a magic number: cookie[i] = unchecked((byte)(((Revtable(cookie_hex[i * 2]) << 4) & unchecked((int 					)(0xf0))) | ((Revtable(cookie_hex[i * 2 + 1])) & unchecked((int)(0xf)))));
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,SetCookie,The following statement contains a magic number: cookie[i] = unchecked((byte)(((Revtable(cookie_hex[i * 2]) << 4) & unchecked((int 					)(0xf0))) | ((Revtable(cookie_hex[i * 2 + 1])) & unchecked((int)(0xf)))));
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,SetCookie,The following statement contains a magic number: cookie[i] = unchecked((byte)(((Revtable(cookie_hex[i * 2]) << 4) & unchecked((int 					)(0xf0))) | ((Revtable(cookie_hex[i * 2 + 1])) & unchecked((int)(0xf)))));
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,SetCookie,The following statement contains a magic number: i < 16
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,GetFakedCookie,The following statement contains a magic number: foo = new byte[16];
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,GetFakedCookie,The following statement contains a magic number: random.Fill(foo' 0' 16);
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,GetFakedCookie,The following statement contains a magic number: byte[] bar = new byte[32];
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,GetFakedCookie,The following statement contains a magic number: bar[2 * i] = table[(foo[i] >> 4) & unchecked((int)(0xf))];
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,GetFakedCookie,The following statement contains a magic number: bar[2 * i] = table[(foo[i] >> 4) & unchecked((int)(0xf))];
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,GetFakedCookie,The following statement contains a magic number: bar[2 * i + 1] = table[(foo[i]) & unchecked((int)(0xf))];
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,GetFakedCookie,The following statement contains a magic number: i < 16
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Run,The following statement contains a magic number: i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Run,The following statement contains a magic number: i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: l < 9
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked( 					(int)(0xff)));
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked( 					(int)(0xff)));
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked( 					(int)(0xff)));
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked( 					(int)(0xff)));
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked( 					(int)(0xff)));
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked( 					(int)(0xff)));
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: l < 12 + plen + ((-plen) & 3) + dlen
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: l < 12 + plen + ((-plen) & 3) + dlen
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);
Magic Number,NSch,ChannelX11,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,HostKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\HostKey.cs,HostKey,The following statement contains a magic number: key[8] == 'd'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: pubkey == null && prvkey != null && (prvkey.Length > 11 && prvkey[0] == 0 &&  				prvkey[1] == 0 && prvkey[2] == 0 && prvkey[3] == 7)
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: pubkey == null && prvkey != null && (prvkey.Length > 11 && prvkey[0] == 0 &&  				prvkey[1] == 0 && prvkey[2] == 0 && prvkey[3] == 7)
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: pubkey == null && prvkey != null && (prvkey.Length > 11 && prvkey[0] == 0 &&  				prvkey[1] == 0 && prvkey[2] == 0 && prvkey[3] == 7)
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: pubkey == null && prvkey != null && (prvkey.Length > 11 && prvkey[0] == 0 &&  				prvkey[1] == 0 && prvkey[2] == 0 && prvkey[3] == 7)
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf 						[i + 3] == '-' && buf[i + 4] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf 						[i + 3] == '-' && buf[i + 4] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf 						[i + 3] == '-' && buf[i + 4] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf 						[i + 3] == '-' && buf[i + 4] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: i += 6;
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: i += 3;
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf 						[i + 3] == 'I'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf 						[i + 3] == 'I'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf 						[i + 3] == 'I'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: i += 8;
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: i += 8;
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: i += 8;
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf 						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' && 						 buf[i + 7] == '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: i += 4;
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b( 								buf[i++]) & unchecked((int)(0xf)))));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf 						[i + 3] == '''
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf 						[i + 3] == '''
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf 						[i + 3] == '''
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: i += 2;
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: i += 3;
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked( 							(int)(0x0a))
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked( 							(int)(0x0a))
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int) 					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data 					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked(( 					byte)unchecked((int)(0xeb)))
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int) 					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data 					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked(( 					byte)unchecked((int)(0xeb)))
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int) 					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data 					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked(( 					byte)unchecked((int)(0xeb)))
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: publickeyblob[8] == 'd'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: type == UNKNOWN && publickeyblob.Length > 8
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] == 					 '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] == 					 '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] == 					 '-'
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,SetPassphrase,The following statement contains a magic number: hash.Update(iv' 0' iv.Length > 8 ? 8 : iv.Length);
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,SetPassphrase,The following statement contains a magic number: hash.Update(iv' 0' iv.Length > 8 ? 8 : iv.Length);
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_rsa,The following statement contains a magic number: Buffer buf = new Buffer("ssh-rsa".Length + 4 + e_array.Length + 4 + n_array.Length 				 + 4);
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_rsa,The following statement contains a magic number: Buffer buf = new Buffer("ssh-rsa".Length + 4 + e_array.Length + 4 + n_array.Length 				 + 4);
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_rsa,The following statement contains a magic number: Buffer buf = new Buffer("ssh-rsa".Length + 4 + e_array.Length + 4 + n_array.Length 				 + 4);
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_dss,The following statement contains a magic number: Buffer buf = new Buffer("ssh-dss".Length + 4 + P_array.Length + 4 + Q_array.Length 				 + 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_dss,The following statement contains a magic number: Buffer buf = new Buffer("ssh-dss".Length + 4 + P_array.Length + 4 + Q_array.Length 				 + 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_dss,The following statement contains a magic number: Buffer buf = new Buffer("ssh-dss".Length + 4 + P_array.Length + 4 + Q_array.Length 				 + 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_dss,The following statement contains a magic number: Buffer buf = new Buffer("ssh-dss".Length + 4 + P_array.Length + 4 + Q_array.Length 				 + 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_dss,The following statement contains a magic number: Buffer buf = new Buffer("ssh-dss".Length + 4 + P_array.Length + 4 + Q_array.Length 				 + 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetSignature_rsa,The following statement contains a magic number: Buffer buf = new Buffer("ssh-rsa".Length + 4 + sig.Length + 4);
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetSignature_rsa,The following statement contains a magic number: Buffer buf = new Buffer("ssh-rsa".Length + 4 + sig.Length + 4);
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetSignature_dss,The following statement contains a magic number: Buffer buf = new Buffer("ssh-dss".Length + 4 + sig.Length + 4);
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetSignature_dss,The following statement contains a magic number: Buffer buf = new Buffer("ssh-dss".Length + 4 + sig.Length + 4);
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: plain.Length != foo + 4
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: plain.Length != foo + 4
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,A2b,The following statement contains a magic number: return unchecked((byte)(c - 'a' + 10));
Magic Number,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,A2b,The following statement contains a magic number: return unchecked((byte)(c - 'A' + 10));
Magic Number,NSch,JSch,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\JSch.cs,GetSession,The following statement contains a magic number: return GetSession(username' host' 22);
Magic Number,NSch,KeyExchange,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyExchange.cs,Guess,The following statement contains a magic number: sb.SetOffSet(17);
Magic Number,NSch,KeyExchange,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyExchange.cs,Guess,The following statement contains a magic number: cb.SetOffSet(17);
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,GenKeyPair,The following statement contains a magic number: return GenKeyPair(jsch' type' 1024);
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,WritePrivateKey,The following statement contains a magic number: @out.Write(B2a(unchecked((byte)((iv[i] >> 4) & unchecked((int)(0x0f))))));
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,WritePrivateKey,The following statement contains a magic number: @out.Write(prv' i_1' 64);
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,WritePrivateKey,The following statement contains a magic number: i_1 += 64;
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,WritePrivateKey,The following statement contains a magic number: i_1 + 64 < prv.Length
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,WriteSECSHPublicKey,The following statement contains a magic number: int len = 70;
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,CountLength,The following statement contains a magic number: len = (int)(((uint)len) >> 8);
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,WriteLength,The following statement contains a magic number: len = (int)(((uint)len) >> 8);
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,GenKey,The following statement contains a magic number: hash.Update(iv' 0' iv.Length > 8 ? 8 : iv.Length);
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,GenKey,The following statement contains a magic number: hash.Update(iv' 0' iv.Length > 8 ? 8 : iv.Length);
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: byte[] iv = new byte[8];
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: i_1 += 6;
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: i_1 += 3;
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G' 						 && buf[i_1 + 3] == 'I'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G' 						 && buf[i_1 + 3] == 'I'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G' 						 && buf[i_1 + 3] == 'I'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: i_1 += 8;
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1 						 + 6] == '6' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1 						 + 6] == '6' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1 						 + 6] == '6' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1 						 + 6] == '6' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1 						 + 6] == '6' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1 						 + 6] == '6' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1 						 + 6] == '6' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: i_1 += 8;
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1 						 + 6] == '2' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1 						 + 6] == '2' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1 						 + 6] == '2' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1 						 + 6] == '2' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1 						 + 6] == '2' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1 						 + 6] == '2' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1 						 + 6] == '2' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: i_1 += 8;
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1 						 + 6] == '8' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1 						 + 6] == '8' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1 						 + 6] == '8' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1 						 + 6] == '8' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1 						 + 6] == '8' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1 						 + 6] == '8' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S' 						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1 						 + 6] == '8' && buf[i_1 + 7] == '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: i_1 += 4;
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b 								(buf[i_1++]) & unchecked((int)(0xf)))));
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C' 						 && buf[i_1 + 3] == '''
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C' 						 && buf[i_1 + 3] == '''
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C' 						 && buf[i_1 + 3] == '''
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: i_1 += 2;
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: i_1 += 3;
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2 							] == unchecked((int)(0x0a))
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2 							] == unchecked((int)(0x0a))
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data 					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked( 					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb)))
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data 					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked( 					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb)))
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data 					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked( 					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb)))
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: publickeyblob[8] == 'd'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] == 							 '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] == 							 '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] == 							 '-'
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,A2b,The following statement contains a magic number: return unchecked((byte)(c - 'a' + 10));
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,B2a,The following statement contains a magic number: 0 <= c && ((sbyte)c) <= 9
Magic Number,NSch,KeyPair,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPair.cs,B2a,The following statement contains a magic number: return unchecked((byte)(c - 10 + 'A'));
Magic Number,NSch,KeyPairDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshdss.Length + 4 + P_array.Length + 4 + Q_array.Length + 				 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,KeyPairDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshdss.Length + 4 + P_array.Length + 4 + Q_array.Length + 				 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,KeyPairDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshdss.Length + 4 + P_array.Length + 4 + Q_array.Length + 				 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,KeyPairDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshdss.Length + 4 + P_array.Length + 4 + Q_array.Length + 				 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,KeyPairDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshdss.Length + 4 + P_array.Length + 4 + Q_array.Length + 				 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));
Magic Number,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshrsa.Length + 4 + pub_array.Length + 4 + n_array.Length 				 + 4);
Magic Number,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshrsa.Length + 4 + pub_array.Length + 4 + n_array.Length 				 + 4);
Magic Number,NSch,KeyPairRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshrsa.Length + 4 + pub_array.Length + 4 + n_array.Length 				 + 4);
Magic Number,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,SetKnownHosts,The following statement contains a magic number: byte[] buf = new byte[1024];
Magic Number,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,SetKnownHosts,The following statement contains a magic number: bufl > 1024 * 10
Magic Number,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,SetKnownHosts,The following statement contains a magic number: bufl > 1024 * 10
Magic Number,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,SetKnownHosts,The following statement contains a magic number: byte[] newbuf = new byte[buf.Length * 2];
Magic Number,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,GetType,The following statement contains a magic number: key[8] == 'd'
Magic Number,NSch,KnownHosts,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,GetType,The following statement contains a magic number: key[8] == 'r'
Magic Number,NSch,HashedHostKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,HashedHostKey,The following statement contains a magic number: this.salt.Length != 20 || this.hash.Length != 20
Magic Number,NSch,HashedHostKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\KnownHosts.cs,HashedHostKey,The following statement contains a magic number: this.salt.Length != 20 || this.hash.Length != 20
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Reset,The following statement contains a magic number: buffer.index = 5;
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: len = len + pad - 4;
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: ba4[0] = unchecked((byte)((int)(((uint)len) >> 24)));
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: ba4[1] = unchecked((byte)((int)(((uint)len) >> 16)));
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: ba4[2] = unchecked((byte)((int)(((uint)len) >> 8)));
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: ba4[2] = unchecked((byte)((int)(((uint)len) >> 8)));
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: ba4[3] = unchecked((byte)(len));
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: System.Array.Copy(ba4' 0' buffer.buffer' 0' 4);
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: buffer.buffer[4] = unchecked((byte)pad);
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: int s = len + 5 + 9;
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: int s = len + 5 + 9;
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: s += 32;
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: byte[] foo = new byte[s + buffer.index - 5 - 9 - len];
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: byte[] foo = new byte[s + buffer.index - 5 - 9 - len];
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: buffer.buffer.Length < s + buffer.index - 5 - 9 - len
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: buffer.buffer.Length < s + buffer.index - 5 - 9 - len
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: System.Array.Copy(buffer.buffer' len + 5 + 9' buffer.buffer' s' buffer.index - 5  				- 9 - len);
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: System.Array.Copy(buffer.buffer' len + 5 + 9' buffer.buffer' s' buffer.index - 5  				- 9 - len);
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: System.Array.Copy(buffer.buffer' len + 5 + 9' buffer.buffer' s' buffer.index - 5  				- 9 - len);
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: System.Array.Copy(buffer.buffer' len + 5 + 9' buffer.buffer' s' buffer.index - 5  				- 9 - len);
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: buffer.index = 10;
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: buffer.index = len + 5 + 9;
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: buffer.index = len + 5 + 9;
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Unshift,The following statement contains a magic number: System.Array.Copy(buffer.buffer' s' buffer.buffer' 5 + 9' len);
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Unshift,The following statement contains a magic number: System.Array.Copy(buffer.buffer' s' buffer.buffer' 5 + 9' len);
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Unshift,The following statement contains a magic number: buffer.buffer[5] = command;
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Unshift,The following statement contains a magic number: buffer.index = 6;
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Unshift,The following statement contains a magic number: buffer.index = len + 5 + 9;
Magic Number,NSch,Packet,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Packet.cs,Unshift,The following statement contains a magic number: buffer.index = len + 5 + 9;
Magic Number,NSch,ProxyHTTP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The following statement contains a magic number: foo != 13
Magic Number,NSch,ProxyHTTP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The following statement contains a magic number: foo != 10
Magic Number,NSch,ProxyHTTP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The following statement contains a magic number: code_1 != 200
Magic Number,NSch,ProxyHTTP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The following statement contains a magic number: foo != 13
Magic Number,NSch,ProxyHTTP,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The following statement contains a magic number: foo != 10
Magic Number,NSch,ProxySOCKS4,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,The following statement contains a magic number: byte[] buf = new byte[1024];
Magic Number,NSch,ProxySOCKS4,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,The following statement contains a magic number: buf[index++] = 4;
Magic Number,NSch,ProxySOCKS4,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,The following statement contains a magic number: buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));
Magic Number,NSch,ProxySOCKS4,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,The following statement contains a magic number: int len = 8;
Magic Number,NSch,ProxySOCKS4,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,The following statement contains a magic number: buf[1] != 90
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: byte[] buf = new byte[1024];
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: buf[index++] = 5;
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: buf[index++] = 2;
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: buf[index++] = 2;
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: Fill(@in' buf' 2);
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: switch ((buf[1]) & unchecked((int)(0xff))) 				{ 					case 0: 					{ 						// NO AUTHENTICATION REQUIRED 						check = true; 						break; 					}  					case 2: 					{ 						// USERNAME/PASSWORD 						if (user == null || passwd == null) 						{ 							break; 						} 						index = 0; 						buf[index++] = 1; 						buf[index++] = unchecked((byte)(user.Length)); 						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length); 						index += user.Length; 						buf[index++] = unchecked((byte)(passwd.Length)); 						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length); 						index += passwd.Length; 						@out.Write(buf' 0' index); 						//in.read(buf' 0' 2); 						Fill(@in' buf' 2); 						if (buf[1] == 0) 						{ 							check = true; 						} 						break; 					}  					default: 					{ 						break; 					} 				}
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: switch ((buf[1]) & unchecked((int)(0xff))) 				{ 					case 0: 					{ 						// NO AUTHENTICATION REQUIRED 						check = true; 						break; 					}  					case 2: 					{ 						// USERNAME/PASSWORD 						if (user == null || passwd == null) 						{ 							break; 						} 						index = 0; 						buf[index++] = 1; 						buf[index++] = unchecked((byte)(user.Length)); 						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length); 						index += user.Length; 						buf[index++] = unchecked((byte)(passwd.Length)); 						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length); 						index += passwd.Length; 						@out.Write(buf' 0' index); 						//in.read(buf' 0' 2); 						Fill(@in' buf' 2); 						if (buf[1] == 0) 						{ 							check = true; 						} 						break; 					}  					default: 					{ 						break; 					} 				}
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: buf[index++] = 5;
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: buf[index++] = 3;
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: Fill(@in' buf' 4);
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: switch (buf[3] & unchecked((int)(0xff))) 				{ 					case 1: 					{ 						//in.read(buf' 0' 6); 						Fill(@in' buf' 6); 						break; 					}  					case 3: 					{ 						//in.read(buf' 0' 1); 						Fill(@in' buf' 1); 						//in.read(buf' 0' buf[0]+2); 						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2); 						break; 					}  					case 4: 					{ 						//in.read(buf' 0' 18); 						Fill(@in' buf' 18); 						break; 					}  					default: 					{ 						break; 					} 				}
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: switch (buf[3] & unchecked((int)(0xff))) 				{ 					case 1: 					{ 						//in.read(buf' 0' 6); 						Fill(@in' buf' 6); 						break; 					}  					case 3: 					{ 						//in.read(buf' 0' 1); 						Fill(@in' buf' 1); 						//in.read(buf' 0' buf[0]+2); 						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2); 						break; 					}  					case 4: 					{ 						//in.read(buf' 0' 18); 						Fill(@in' buf' 18); 						break; 					}  					default: 					{ 						break; 					} 				}
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: switch (buf[3] & unchecked((int)(0xff))) 				{ 					case 1: 					{ 						//in.read(buf' 0' 6); 						Fill(@in' buf' 6); 						break; 					}  					case 3: 					{ 						//in.read(buf' 0' 1); 						Fill(@in' buf' 1); 						//in.read(buf' 0' buf[0]+2); 						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2); 						break; 					}  					case 4: 					{ 						//in.read(buf' 0' 18); 						Fill(@in' buf' 18); 						break; 					}  					default: 					{ 						break; 					} 				}
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: switch (buf[3] & unchecked((int)(0xff))) 				{ 					case 1: 					{ 						//in.read(buf' 0' 6); 						Fill(@in' buf' 6); 						break; 					}  					case 3: 					{ 						//in.read(buf' 0' 1); 						Fill(@in' buf' 1); 						//in.read(buf' 0' buf[0]+2); 						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2); 						break; 					}  					case 4: 					{ 						//in.read(buf' 0' 18); 						Fill(@in' buf' 18); 						break; 					}  					default: 					{ 						break; 					} 				}
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: switch (buf[3] & unchecked((int)(0xff))) 				{ 					case 1: 					{ 						//in.read(buf' 0' 6); 						Fill(@in' buf' 6); 						break; 					}  					case 3: 					{ 						//in.read(buf' 0' 1); 						Fill(@in' buf' 1); 						//in.read(buf' 0' buf[0]+2); 						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2); 						break; 					}  					case 4: 					{ 						//in.read(buf' 0' 18); 						Fill(@in' buf' 18); 						break; 					}  					default: 					{ 						break; 					} 				}
Magic Number,NSch,ProxySOCKS5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: switch (buf[3] & unchecked((int)(0xff))) 				{ 					case 1: 					{ 						//in.read(buf' 0' 6); 						Fill(@in' buf' 6); 						break; 					}  					case 3: 					{ 						//in.read(buf' 0' 1); 						Fill(@in' buf' 1); 						//in.read(buf' 0' buf[0]+2); 						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2); 						break; 					}  					case 4: 					{ 						//in.read(buf' 0' 18); 						Fill(@in' buf' 18); 						break; 					}  					default: 					{ 						break; 					} 				}
Magic Number,NSch,RequestExec,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\RequestExec.cs,DoRequest,The following statement contains a magic number: buf.CheckFreeSize(4 + command.Length);
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: j == 10
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: i > 0 && buf.buffer[i - 1] == 13
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: buf.buffer[i - 1] == 10
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1] 						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-'))
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1] 						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-'))
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1] 						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-'))
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=  						'9')
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=  						'9')
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=  						'9')
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Receive_kexinit,The following statement contains a magic number: I_S = new byte[buf.index - 5];
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Send_kexinit,The following statement contains a magic number: random.Fill(buf.buffer' buf.index' 16);
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Send_kexinit,The following statement contains a magic number: buf.Skip(16);
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Send_kexinit,The following statement contains a magic number: buf.SetOffSet(5);
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,CheckHost,The following statement contains a magic number: hostKeyAlias == null && port != 22
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Encode,The following statement contains a magic number: packet.buffer.buffer = deflater.Compress(packet.buffer.buffer' 5' compress_len);
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Encode,The following statement contains a magic number: int pad = packet.buffer.buffer[4];
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16 					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00 					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16 					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00 					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16 					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00 					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16 					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00 					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16 					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00 					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: j < 5 || j > PACKET_MAX_SIZE
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: int need = j + 4 - s2ccipher_size;
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: int pad = buf.buffer[4];
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: uncompress_len[0] = buf.index - 5 - pad;
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: byte[] foo = inflater.Uncompress(buf.buffer' 5' uncompress_len);
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: buf.index = 5 + uncompress_len[0];
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Write,The following statement contains a magic number: Sharpen.Thread.Sleep(10);
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Write,The following statement contains a magic number: Sharpen.Runtime.Wait(c' 100);
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Write,The following statement contains a magic number: s = packet.Shift((int)len' (c2scipher != null ? c2scipher_size : 8)' (c2smac != null 								 ? c2smac.GetBlockSize() : 0));
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Write,The following statement contains a magic number: Sharpen.Thread.Sleep(10);
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Run,The following statement contains a magic number: switch (msgType) 					{ 						case SSH_MSG_KEXINIT: 						{ 							//System.err.println("KEXINIT"); 							kex = Receive_kexinit(buf); 							break; 						}  						case SSH_MSG_NEWKEYS: 						{ 							//System.err.println("NEWKEYS"); 							Send_newkeys(); 							Receive_newkeys(buf' kex); 							kex = null; 							break; 						}  						case SSH_MSG_CHANNEL_DATA: 						{ 							buf.GetInt(); 							buf.GetByte(); 							buf.GetByte(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							foo = buf.GetString(start' length); 							if (channel == null) 							{ 								break; 							} 							if (length[0] == 0) 							{ 								break; 							} 							try 							{ 								channel.Write(foo' start[0]' length[0]); 							} 							catch (Exception) 							{ 								//System.err.println(e); 								try 								{ 									channel.Disconnect(); 								} 								catch (Exception) 								{ 								} 								break; 							} 							int len = length[0]; 							channel.SetLocalWindowSize(channel.lwsize - len); 							if (channel.lwsize < channel.lwsize_max / 2) 							{ 								packet.Reset(); 								buf.PutByte(unchecked((byte)SSH_MSG_CHANNEL_WINDOW_ADJUST)); 								buf.PutInt(channel.GetRecipient()); 								buf.PutInt(channel.lwsize_max - channel.lwsize); 								lock (channel) 								{ 									if (!channel.close) 									{ 										Write(packet); 									} 								} 								channel.SetLocalWindowSize(channel.lwsize_max); 							} 							break; 						}  						case SSH_MSG_CHANNEL_EXTENDED_DATA: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							buf.GetInt(); 							// data_type_code == 1 							foo = buf.GetString(start' length); 							//System.err.println("stderr: "+new String(foo'start[0]'length[0])); 							if (channel == null) 							{ 								break; 							} 							if (length[0] == 0) 							{ 								break; 							} 							channel.Write_ext(foo' start[0]' length[0]); 							int len = length[0]; 							channel.SetLocalWindowSize(channel.lwsize - len); 							if (channel.lwsize < channel.lwsize_max / 2) 							{ 								packet.Reset(); 								buf.PutByte(unchecked((byte)SSH_MSG_CHANNEL_WINDOW_ADJUST)); 								buf.PutInt(channel.GetRecipient()); 								buf.PutInt(channel.lwsize_max - channel.lwsize); 								lock (channel) 								{ 									if (!channel.close) 									{ 										Write(packet); 									} 								} 								channel.SetLocalWindowSize(channel.lwsize_max); 							} 							break; 						}  						case SSH_MSG_CHANNEL_WINDOW_ADJUST: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							if (channel == null) 							{ 								break; 							} 							channel.AddRemoteWindowSize(buf.GetInt()); 							break; 						}  						case SSH_MSG_CHANNEL_EOF: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							if (channel != null) 							{ 								//channel.eof_remote=true; 								//channel.eof(); 								channel.Eof_remote(); 							} 							break; 						}  						case SSH_MSG_CHANNEL_CLOSE: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							if (channel != null) 							{ 								//	      channel.close(); 								channel.Disconnect(); 							} 							break; 						}  						case SSH_MSG_CHANNEL_OPEN_CONFIRMATION: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							if (channel == null) 							{ 							} 							//break; 							int r = buf.GetInt(); 							long rws = buf.GetUInt(); 							int rps = buf.GetInt(); 							channel.SetRemoteWindowSize(rws); 							channel.SetRemotePacketSize(rps); 							channel.open_confirmation = true; 							channel.SetRecipient(r); 							break; 						}  						case SSH_MSG_CHANNEL_OPEN_FAILURE: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							if (channel == null) 							{ 							} 							//break; 							int reason_code = buf.GetInt(); 							//foo=buf.getString();  // additional textual information 							//foo=buf.getString();  // language tag  							channel.SetExitStatus(reason_code); 							channel.close = true; 							channel.eof_remote = true; 							channel.SetRecipient(0); 							break; 						}  						case SSH_MSG_CHANNEL_REQUEST: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							foo = buf.GetString(); 							bool reply = (buf.GetByte() != 0); 							channel = Channel.GetChannel(i' this); 							if (channel != null) 							{ 								byte reply_type = unchecked((byte)SSH_MSG_CHANNEL_FAILURE); 								if ((Util.Byte2str(foo)).Equals("exit-status")) 								{ 									i = buf.GetInt(); 									// exit-status 									channel.SetExitStatus(i); 									reply_type = unchecked((byte)SSH_MSG_CHANNEL_SUCCESS); 								} 								if (reply) 								{ 									packet.Reset(); 									buf.PutByte(reply_type); 									buf.PutInt(channel.GetRecipient()); 									Write(packet); 								} 							} 							break; 						}  						case SSH_MSG_CHANNEL_OPEN: 						{ 							buf.GetInt(); 							buf.GetShort(); 							foo = buf.GetString(); 							string ctyp = Util.Byte2str(foo); 							if (!"forwarded-tcpip".Equals(ctyp) && !("x11".Equals(ctyp) && x11_forwarding) && 								 !("auth-agent@openssh.com".Equals(ctyp) && agent_forwarding)) 							{ 								//System.err.println("Session.run: CHANNEL OPEN "+ctyp);  								//throw new IOException("Session.run: CHANNEL OPEN "+ctyp); 								packet.Reset(); 								buf.PutByte(unchecked((byte)SSH_MSG_CHANNEL_OPEN_FAILURE)); 								buf.PutInt(buf.GetInt()); 								buf.PutInt(Channel.SSH_OPEN_ADMINISTRATIVELY_PROHIBITED); 								buf.PutString(Util.empty); 								buf.PutString(Util.empty); 								Write(packet); 							} 							else 							{ 								channel = Channel.GetChannel(ctyp); 								AddChannel(channel); 								channel.GetData(buf); 								channel.Init(); 								Sharpen.Thread tmp = new Sharpen.Thread(channel); 								tmp.SetName("Channel " + ctyp + " " + host); 								if (daemon_thread) 								{ 									tmp.SetDaemon(daemon_thread); 								} 								tmp.Start(); 								break; 							} 							goto case SSH_MSG_CHANNEL_SUCCESS; 						}  						case SSH_MSG_CHANNEL_SUCCESS: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							if (channel == null) 							{ 								break; 							} 							channel.reply = 1; 							break; 						}  						case SSH_MSG_CHANNEL_FAILURE: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							if (channel == null) 							{ 								break; 							} 							channel.reply = 0; 							break; 						}  						case SSH_MSG_GLOBAL_REQUEST: 						{ 							buf.GetInt(); 							buf.GetShort(); 							foo = buf.GetString(); 							// request name 							bool reply = (buf.GetByte() != 0); 							if (reply) 							{ 								packet.Reset(); 								buf.PutByte(unchecked((byte)SSH_MSG_REQUEST_FAILURE)); 								Write(packet); 							} 							break; 						}  						case SSH_MSG_REQUEST_FAILURE: 						case SSH_MSG_REQUEST_SUCCESS: 						{ 							Sharpen.Thread t = grr.GetThread(); 							if (t != null) 							{ 								grr.SetReply(msgType == SSH_MSG_REQUEST_SUCCESS ? 1 : 0); 								t.Interrupt(); 							} 							break; 						}  						default: 						{ 							//System.err.println("Session.run: unsupported type "+msgType);  							throw new IOException("Unknown SSH message type " + msgType); 						} 					}
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Run,The following statement contains a magic number: switch (msgType) 					{ 						case SSH_MSG_KEXINIT: 						{ 							//System.err.println("KEXINIT"); 							kex = Receive_kexinit(buf); 							break; 						}  						case SSH_MSG_NEWKEYS: 						{ 							//System.err.println("NEWKEYS"); 							Send_newkeys(); 							Receive_newkeys(buf' kex); 							kex = null; 							break; 						}  						case SSH_MSG_CHANNEL_DATA: 						{ 							buf.GetInt(); 							buf.GetByte(); 							buf.GetByte(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							foo = buf.GetString(start' length); 							if (channel == null) 							{ 								break; 							} 							if (length[0] == 0) 							{ 								break; 							} 							try 							{ 								channel.Write(foo' start[0]' length[0]); 							} 							catch (Exception) 							{ 								//System.err.println(e); 								try 								{ 									channel.Disconnect(); 								} 								catch (Exception) 								{ 								} 								break; 							} 							int len = length[0]; 							channel.SetLocalWindowSize(channel.lwsize - len); 							if (channel.lwsize < channel.lwsize_max / 2) 							{ 								packet.Reset(); 								buf.PutByte(unchecked((byte)SSH_MSG_CHANNEL_WINDOW_ADJUST)); 								buf.PutInt(channel.GetRecipient()); 								buf.PutInt(channel.lwsize_max - channel.lwsize); 								lock (channel) 								{ 									if (!channel.close) 									{ 										Write(packet); 									} 								} 								channel.SetLocalWindowSize(channel.lwsize_max); 							} 							break; 						}  						case SSH_MSG_CHANNEL_EXTENDED_DATA: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							buf.GetInt(); 							// data_type_code == 1 							foo = buf.GetString(start' length); 							//System.err.println("stderr: "+new String(foo'start[0]'length[0])); 							if (channel == null) 							{ 								break; 							} 							if (length[0] == 0) 							{ 								break; 							} 							channel.Write_ext(foo' start[0]' length[0]); 							int len = length[0]; 							channel.SetLocalWindowSize(channel.lwsize - len); 							if (channel.lwsize < channel.lwsize_max / 2) 							{ 								packet.Reset(); 								buf.PutByte(unchecked((byte)SSH_MSG_CHANNEL_WINDOW_ADJUST)); 								buf.PutInt(channel.GetRecipient()); 								buf.PutInt(channel.lwsize_max - channel.lwsize); 								lock (channel) 								{ 									if (!channel.close) 									{ 										Write(packet); 									} 								} 								channel.SetLocalWindowSize(channel.lwsize_max); 							} 							break; 						}  						case SSH_MSG_CHANNEL_WINDOW_ADJUST: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							if (channel == null) 							{ 								break; 							} 							channel.AddRemoteWindowSize(buf.GetInt()); 							break; 						}  						case SSH_MSG_CHANNEL_EOF: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							if (channel != null) 							{ 								//channel.eof_remote=true; 								//channel.eof(); 								channel.Eof_remote(); 							} 							break; 						}  						case SSH_MSG_CHANNEL_CLOSE: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							if (channel != null) 							{ 								//	      channel.close(); 								channel.Disconnect(); 							} 							break; 						}  						case SSH_MSG_CHANNEL_OPEN_CONFIRMATION: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							if (channel == null) 							{ 							} 							//break; 							int r = buf.GetInt(); 							long rws = buf.GetUInt(); 							int rps = buf.GetInt(); 							channel.SetRemoteWindowSize(rws); 							channel.SetRemotePacketSize(rps); 							channel.open_confirmation = true; 							channel.SetRecipient(r); 							break; 						}  						case SSH_MSG_CHANNEL_OPEN_FAILURE: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							if (channel == null) 							{ 							} 							//break; 							int reason_code = buf.GetInt(); 							//foo=buf.getString();  // additional textual information 							//foo=buf.getString();  // language tag  							channel.SetExitStatus(reason_code); 							channel.close = true; 							channel.eof_remote = true; 							channel.SetRecipient(0); 							break; 						}  						case SSH_MSG_CHANNEL_REQUEST: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							foo = buf.GetString(); 							bool reply = (buf.GetByte() != 0); 							channel = Channel.GetChannel(i' this); 							if (channel != null) 							{ 								byte reply_type = unchecked((byte)SSH_MSG_CHANNEL_FAILURE); 								if ((Util.Byte2str(foo)).Equals("exit-status")) 								{ 									i = buf.GetInt(); 									// exit-status 									channel.SetExitStatus(i); 									reply_type = unchecked((byte)SSH_MSG_CHANNEL_SUCCESS); 								} 								if (reply) 								{ 									packet.Reset(); 									buf.PutByte(reply_type); 									buf.PutInt(channel.GetRecipient()); 									Write(packet); 								} 							} 							break; 						}  						case SSH_MSG_CHANNEL_OPEN: 						{ 							buf.GetInt(); 							buf.GetShort(); 							foo = buf.GetString(); 							string ctyp = Util.Byte2str(foo); 							if (!"forwarded-tcpip".Equals(ctyp) && !("x11".Equals(ctyp) && x11_forwarding) && 								 !("auth-agent@openssh.com".Equals(ctyp) && agent_forwarding)) 							{ 								//System.err.println("Session.run: CHANNEL OPEN "+ctyp);  								//throw new IOException("Session.run: CHANNEL OPEN "+ctyp); 								packet.Reset(); 								buf.PutByte(unchecked((byte)SSH_MSG_CHANNEL_OPEN_FAILURE)); 								buf.PutInt(buf.GetInt()); 								buf.PutInt(Channel.SSH_OPEN_ADMINISTRATIVELY_PROHIBITED); 								buf.PutString(Util.empty); 								buf.PutString(Util.empty); 								Write(packet); 							} 							else 							{ 								channel = Channel.GetChannel(ctyp); 								AddChannel(channel); 								channel.GetData(buf); 								channel.Init(); 								Sharpen.Thread tmp = new Sharpen.Thread(channel); 								tmp.SetName("Channel " + ctyp + " " + host); 								if (daemon_thread) 								{ 									tmp.SetDaemon(daemon_thread); 								} 								tmp.Start(); 								break; 							} 							goto case SSH_MSG_CHANNEL_SUCCESS; 						}  						case SSH_MSG_CHANNEL_SUCCESS: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							if (channel == null) 							{ 								break; 							} 							channel.reply = 1; 							break; 						}  						case SSH_MSG_CHANNEL_FAILURE: 						{ 							buf.GetInt(); 							buf.GetShort(); 							i = buf.GetInt(); 							channel = Channel.GetChannel(i' this); 							if (channel == null) 							{ 								break; 							} 							channel.reply = 0; 							break; 						}  						case SSH_MSG_GLOBAL_REQUEST: 						{ 							buf.GetInt(); 							buf.GetShort(); 							foo = buf.GetString(); 							// request name 							bool reply = (buf.GetByte() != 0); 							if (reply) 							{ 								packet.Reset(); 								buf.PutByte(unchecked((byte)SSH_MSG_REQUEST_FAILURE)); 								Write(packet); 							} 							break; 						}  						case SSH_MSG_REQUEST_FAILURE: 						case SSH_MSG_REQUEST_SUCCESS: 						{ 							Sharpen.Thread t = grr.GetThread(); 							if (t != null) 							{ 								grr.SetReply(msgType == SSH_MSG_REQUEST_SUCCESS ? 1 : 0); 								t.Interrupt(); 							} 							break; 						}  						default: 						{ 							//System.err.println("Session.run: unsupported type "+msgType);  							throw new IOException("Unknown SSH message type " + msgType); 						} 					}
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,SetPortForwarding,The following statement contains a magic number: Buffer buf = new Buffer(100);
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,SetPortForwarding,The following statement contains a magic number: Sharpen.Thread.Sleep(1000);
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,SetPortForwarding,The following statement contains a magic number: count < 10 && reply == -1
Magic Number,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,InitDeflater,The following statement contains a magic number: int level = 6;
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetPermissionsString,The following statement contains a magic number: StringBuilder buf = new StringBuilder(10);
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetMtimeString,The following statement contains a magic number: DateTime date = Sharpen.Extensions.CreateDate(((long)mtime) * 1000);
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetATTR,The following statement contains a magic number: attr.extended = new string[count * 2];
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetATTR,The following statement contains a magic number: attr.extended[i * 2] = Util.Byte2str(buf.GetString());
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetATTR,The following statement contains a magic number: attr.extended[i * 2 + 1] = Util.Byte2str(buf.GetString());
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: int len = 4;
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: len += 8;
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: len += 8;
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: len += 4;
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: len += 8;
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: len += 4;
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: int count = extended.Length / 2;
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: len += 4;
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: len += extended[i * 2].Length;
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: len += 4;
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: len += extended[i * 2 + 1].Length;
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Dump,The following statement contains a magic number: int count = extended.Length / 2;
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Dump,The following statement contains a magic number: buf.PutString(Util.Str2byte(extended[i * 2]));
Magic Number,NSch,SftpATTRS,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Dump,The following statement contains a magic number: buf.PutString(Util.Str2byte(extended[i * 2 + 1]));
Magic Number,NSch,UserAuthKeyboardInteractive,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthKeyboardInteractive.cs,Start,The following statement contains a magic number: session.port != 22
Magic Number,NSch,UserAuthPassword,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPassword.cs,Start,The following statement contains a magic number: session.port != 22
Magic Number,NSch,UserAuthPublicKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: int count = 5;
Magic Number,NSch,UserAuthPublicKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: byte[] tmp = new byte[4 + sidlen + buf.index - 5];
Magic Number,NSch,UserAuthPublicKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: byte[] tmp = new byte[4 + sidlen + buf.index - 5];
Magic Number,NSch,UserAuthPublicKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: tmp[0] = unchecked((byte)((int)(((uint)sidlen) >> 24)));
Magic Number,NSch,UserAuthPublicKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: tmp[1] = unchecked((byte)((int)(((uint)sidlen) >> 16)));
Magic Number,NSch,UserAuthPublicKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)sidlen) >> 8)));
Magic Number,NSch,UserAuthPublicKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)sidlen) >> 8)));
Magic Number,NSch,UserAuthPublicKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: tmp[3] = unchecked((byte)(sidlen));
Magic Number,NSch,UserAuthPublicKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: System.Array.Copy(sid' 0' tmp' 4' sidlen);
Magic Number,NSch,UserAuthPublicKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);
Magic Number,NSch,UserAuthPublicKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);
Magic Number,NSch,UserAuthPublicKey,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked( 					(int)(0x30)))) >> 4))));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked( 					(int)(0x30)))) >> 4))));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: buf[i + 2] == unchecked((byte)'=')
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) | 					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) | 					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) | 					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: j += 2;
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: buf[i + 3] == unchecked((byte)'=')
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) | 					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) | 					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) | 					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) | 					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: j += 3;
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: byte[] tmp = new byte[length * 2];
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: int foo = (length / 3) * 3 + start;
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: int foo = (length / 3) * 3 + start;
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: k = (buf[j] >> 2) & unchecked((int)(0x3f));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)( 					0x0f));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)( 					0x0f));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: k = (buf[j + 1] & unchecked((int)(0x0f))) << 2 | (buf[j + 2] >> 6) & unchecked((int 					)(0x03));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: k = (buf[j + 1] & unchecked((int)(0x0f))) << 2 | (buf[j + 2] >> 6) & unchecked((int 					)(0x03));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: k = (buf[j + 1] & unchecked((int)(0x0f))) << 2 | (buf[j + 2] >> 6) & unchecked((int 					)(0x03));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: k = buf[j + 2] & unchecked((int)(0x3f));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: k = (buf[j] >> 2) & unchecked((int)(0x3f));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: k = ((buf[j] & unchecked((int)(0x03))) << 4) & unchecked((int)(0x3f));
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,Glob0,The following statement contains a magic number: pattern.Length == 2 && pattern[1] == '*'
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,GetFingerPrint,The following statement contains a magic number: sb.Append(chars[((int)(((uint)bar) >> 4)) & unchecked((int)(0xf))]);
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,SkipUTF8Char,The following statement contains a magic number: return 2;
Magic Number,NSch,Util,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Util.cs,SkipUTF8Char,The following statement contains a magic number: return 3;
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Magic Number,NSch.Jce,HMACMD5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD5.cs,Update,The following statement contains a magic number: tmp[0] = unchecked((byte)((int)(((uint)i) >> 24)));
Magic Number,NSch.Jce,HMACMD5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD5.cs,Update,The following statement contains a magic number: tmp[1] = unchecked((byte)((int)(((uint)i) >> 16)));
Magic Number,NSch.Jce,HMACMD5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD5.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACMD5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD5.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACMD5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD5.cs,Update,The following statement contains a magic number: tmp[3] = unchecked((byte)i);
Magic Number,NSch.Jce,HMACMD5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD5.cs,Update,The following statement contains a magic number: Update(tmp' 0' 4);
Magic Number,NSch.Jce,HMACMD596,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Init,The following statement contains a magic number: byte[] tmp = new byte[16];
Magic Number,NSch.Jce,HMACMD596,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Init,The following statement contains a magic number: System.Array.Copy(key' 0' tmp' 0' 16);
Magic Number,NSch.Jce,HMACMD596,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Init,The following statement contains a magic number: key.Length > 16
Magic Number,NSch.Jce,HMACMD596,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Update,The following statement contains a magic number: tmp[0] = unchecked((byte)((int)(((uint)i) >> 24)));
Magic Number,NSch.Jce,HMACMD596,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Update,The following statement contains a magic number: tmp[1] = unchecked((byte)((int)(((uint)i) >> 16)));
Magic Number,NSch.Jce,HMACMD596,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACMD596,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACMD596,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Update,The following statement contains a magic number: tmp[3] = unchecked((byte)i);
Magic Number,NSch.Jce,HMACMD596,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Update,The following statement contains a magic number: Update(tmp' 0' 4);
Magic Number,NSch.Jce,HMACMD596,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,DoFinal,The following statement contains a magic number: System.Array.Copy(_buf16' 0' buf' offset' 12);
Magic Number,NSch.Jce,HMACSHA1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA1.cs,Update,The following statement contains a magic number: tmp[0] = unchecked((byte)((int)(((uint)i) >> 24)));
Magic Number,NSch.Jce,HMACSHA1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA1.cs,Update,The following statement contains a magic number: tmp[1] = unchecked((byte)((int)(((uint)i) >> 16)));
Magic Number,NSch.Jce,HMACSHA1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA1.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACSHA1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA1.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACSHA1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA1.cs,Update,The following statement contains a magic number: tmp[3] = unchecked((byte)i);
Magic Number,NSch.Jce,HMACSHA1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA1.cs,Update,The following statement contains a magic number: Update(tmp' 0' 4);
Magic Number,NSch.Jce,HMACSHA196,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Init,The following statement contains a magic number: byte[] tmp = new byte[20];
Magic Number,NSch.Jce,HMACSHA196,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Init,The following statement contains a magic number: System.Array.Copy(key' 0' tmp' 0' 20);
Magic Number,NSch.Jce,HMACSHA196,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Init,The following statement contains a magic number: key.Length > 20
Magic Number,NSch.Jce,HMACSHA196,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Update,The following statement contains a magic number: tmp[0] = unchecked((byte)((int)(((uint)i) >> 24)));
Magic Number,NSch.Jce,HMACSHA196,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Update,The following statement contains a magic number: tmp[1] = unchecked((byte)((int)(((uint)i) >> 16)));
Magic Number,NSch.Jce,HMACSHA196,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACSHA196,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACSHA196,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Update,The following statement contains a magic number: tmp[3] = unchecked((byte)i);
Magic Number,NSch.Jce,HMACSHA196,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Update,The following statement contains a magic number: Update(tmp' 0' 4);
Magic Number,NSch.Jce,HMACSHA196,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,DoFinal,The following statement contains a magic number: System.Array.Copy(_buf20' 0' buf' offset' 12);
Magic Number,NSch.Jce,MD5,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\MD5.cs,GetBlockSize,The following statement contains a magic number: return 16;
Magic Number,NSch.Jce,SHA1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SHA1.cs,GetBlockSize,The following statement contains a magic number: return 20;
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: int index = 3;
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: byte[] result = new byte[40];
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(r' (r.Length > 20) ? 1 : 0' result' (r.Length > 20) ? 0 : 20 -  				r.Length' (r.Length > 20) ? 20 : r.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(r' (r.Length > 20) ? 1 : 0' result' (r.Length > 20) ? 0 : 20 -  				r.Length' (r.Length > 20) ? 20 : r.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(r' (r.Length > 20) ? 1 : 0' result' (r.Length > 20) ? 0 : 20 -  				r.Length' (r.Length > 20) ? 20 : r.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(r' (r.Length > 20) ? 1 : 0' result' (r.Length > 20) ? 0 : 20 -  				r.Length' (r.Length > 20) ? 20 : r.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(r' (r.Length > 20) ? 1 : 0' result' (r.Length > 20) ? 0 : 20 -  				r.Length' (r.Length > 20) ? 20 : r.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(s' (s.Length > 20) ? 1 : 0' result' (s.Length > 20) ? 20 : 40 - 				 s.Length' (s.Length > 20) ? 20 : s.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(s' (s.Length > 20) ? 1 : 0' result' (s.Length > 20) ? 20 : 40 - 				 s.Length' (s.Length > 20) ? 20 : s.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(s' (s.Length > 20) ? 1 : 0' result' (s.Length > 20) ? 20 : 40 - 				 s.Length' (s.Length > 20) ? 20 : s.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(s' (s.Length > 20) ? 1 : 0' result' (s.Length > 20) ? 20 : 40 - 				 s.Length' (s.Length > 20) ? 20 : s.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(s' (s.Length > 20) ? 1 : 0' result' (s.Length > 20) ? 20 : 40 - 				 s.Length' (s.Length > 20) ? 20 : s.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(s' (s.Length > 20) ? 1 : 0' result' (s.Length > 20) ? 20 : 40 - 				 s.Length' (s.Length > 20) ? 20 : s.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked( 					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i 					++]) & unchecked((int)(0x000000ff)));
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked( 					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i 					++]) & unchecked((int)(0x000000ff)));
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked( 					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i 					++]) & unchecked((int)(0x000000ff)));
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked( 					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i 					++]) & unchecked((int)(0x000000ff)));
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked( 					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i 					++]) & unchecked((int)(0x000000ff)));
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked( 					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i 					++]) & unchecked((int)(0x000000ff)));
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: sig[0] == 0 && sig[1] == 0 && sig[2] == 0
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: byte scnd = (byte)((sig[20] & unchecked((int)(0x80))) != 0 ? 1 : 0);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: int length = sig.Length + 6 + frst + scnd;
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[2] = unchecked((byte)unchecked((int)(0x02)));
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[3] = unchecked((byte)unchecked((int)(0x14)));
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[3] += frst;
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: System.Array.Copy(sig' 0' tmp' 4 + frst' 20);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: System.Array.Copy(sig' 0' tmp' 4 + frst' 20);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[4 + tmp[3]] = unchecked((byte)unchecked((int)(0x02)));
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[4 + tmp[3]] = unchecked((byte)unchecked((int)(0x02)));
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[5 + tmp[3]] = unchecked((byte)unchecked((int)(0x14)));
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[5 + tmp[3]] = unchecked((byte)unchecked((int)(0x14)));
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[5 + tmp[3]] += scnd;
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[5 + tmp[3]] += scnd;
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: System.Array.Copy(sig' 20' tmp' 6 + tmp[3] + scnd' 20);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: System.Array.Copy(sig' 20' tmp' 6 + tmp[3] + scnd' 20);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: System.Array.Copy(sig' 20' tmp' 6 + tmp[3] + scnd' 20);
Magic Number,NSch.Jce,SignatureDSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: System.Array.Copy(sig' 20' tmp' 6 + tmp[3] + scnd' 20);
Magic Number,NSch.Jce,SignatureRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureRSA.cs,Verify,The following statement contains a magic number: j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked( 					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i 					++]) & unchecked((int)(0x000000ff)));
Magic Number,NSch.Jce,SignatureRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureRSA.cs,Verify,The following statement contains a magic number: j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked( 					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i 					++]) & unchecked((int)(0x000000ff)));
Magic Number,NSch.Jce,SignatureRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureRSA.cs,Verify,The following statement contains a magic number: j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked( 					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i 					++]) & unchecked((int)(0x000000ff)));
Magic Number,NSch.Jce,SignatureRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureRSA.cs,Verify,The following statement contains a magic number: j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked( 					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i 					++]) & unchecked((int)(0x000000ff)));
Magic Number,NSch.Jce,SignatureRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureRSA.cs,Verify,The following statement contains a magic number: j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked( 					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i 					++]) & unchecked((int)(0x000000ff)));
Magic Number,NSch.Jce,SignatureRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureRSA.cs,Verify,The following statement contains a magic number: j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked( 					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i 					++]) & unchecked((int)(0x000000ff)));
Magic Number,NSch.Jce,SignatureRSA,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jce\SignatureRSA.cs,Verify,The following statement contains a magic number: sig[0] == 0 && sig[1] == 0 && sig[2] == 0
Magic Number,NSch.Jcraft,Compression,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jcraft\Compression.cs,Compress,The following statement contains a magic number: switch (status) 				{ 					case JZlib.Z_OK: 					{ 						tmp = BUF_SIZE - stream.avail_out; 						if (outputbuf.Length < outputlen + tmp + buffer_margin) 						{ 							byte[] foo = new byte[(outputlen + tmp + buffer_margin) * 2]; 							System.Array.Copy(outputbuf' 0' foo' 0' outputbuf.Length); 							outputbuf = foo; 						} 						System.Array.Copy(tmpbuf' 0' outputbuf' outputlen' tmp); 						outputlen += tmp; 						break; 					}  					default: 					{ 						System.Console.Error.WriteLine("compress: deflate returnd " + status); 						break; 					} 				}
Magic Number,NSch.Jcraft,Compression,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jcraft\Compression.cs,Uncompress,The following statement contains a magic number: switch (status) 				{ 					case JZlib.Z_OK: 					{ 						if (inflated_buf.Length < inflated_end + BUF_SIZE - stream.avail_out) 						{ 							int len = inflated_buf.Length * 2; 							if (len < inflated_end + BUF_SIZE - stream.avail_out) 							{ 								len = inflated_end + BUF_SIZE - stream.avail_out; 							} 							byte[] foo = new byte[len]; 							System.Array.Copy(inflated_buf' 0' foo' 0' inflated_end); 							inflated_buf = foo; 						} 						System.Array.Copy(tmpbuf' 0' inflated_buf' inflated_end' BUF_SIZE - stream.avail_out 							); 						inflated_end += (BUF_SIZE - stream.avail_out); 						length[0] = inflated_end; 						break; 					}  					case JZlib.Z_BUF_ERROR: 					{ 						if (inflated_end > buffer.Length - start) 						{ 							byte[] foo = new byte[inflated_end + start]; 							System.Array.Copy(buffer' 0' foo' 0' start); 							System.Array.Copy(inflated_buf' 0' foo' start' inflated_end); 							buffer = foo; 						} 						else 						{ 							System.Array.Copy(inflated_buf' 0' buffer' start' inflated_end); 						} 						length[0] = inflated_end; 						return buffer; 					}  					default: 					{ 						System.Console.Error.WriteLine("uncompress: inflate returnd " + status); 						return null; 						break; 					} 				}
Magic Number,NSch.Jcraft,HMAC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jcraft\HMAC.cs,Update,The following statement contains a magic number: tmp[0] = unchecked((byte)((int)(((uint)i) >> 24)));
Magic Number,NSch.Jcraft,HMAC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jcraft\HMAC.cs,Update,The following statement contains a magic number: tmp[1] = unchecked((byte)((int)(((uint)i) >> 16)));
Magic Number,NSch.Jcraft,HMAC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jcraft\HMAC.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jcraft,HMAC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jcraft\HMAC.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jcraft,HMAC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jcraft\HMAC.cs,Update,The following statement contains a magic number: tmp[3] = unchecked((byte)i);
Magic Number,NSch.Jcraft,HMAC,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.Jcraft\HMAC.cs,Update,The following statement contains a magic number: Update(tmp' 0' 4);
Magic Number,NSch.ZLib,Adler32,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Adler32.cs,Adler,The following statement contains a magic number: long s2 = (adler >> 16) & unchecked((int)(0xffff));
Magic Number,NSch.ZLib,Adler32,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Adler32.cs,Adler,The following statement contains a magic number: k -= 16;
Magic Number,NSch.ZLib,Adler32,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Adler32.cs,Adler,The following statement contains a magic number: k >= 16
Magic Number,NSch.ZLib,Adler32,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Adler32.cs,Adler,The following statement contains a magic number: return (s2 << 16) | s1;
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,InfBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case TYPE: 					{ 						while (k < (3)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						t = (int)(b & 7); 						last = t & 1; 						switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						} 						break; 					}  					case LENS: 					{ 						while (k < (32)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int 							)(0xffff)))) 						{ 							mode = BAD; 							z.msg = "invalid stored block lengths"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						left = (b & unchecked((int)(0xffff))); 						b = k = 0; 						// dump bits 						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE); 						break; 					}  					case STORED: 					{ 						if (n == 0) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						if (m == 0) 						{ 							if (q == end && read != 0) 							{ 								q = 0; 								m = (int)(q < read ? read - q - 1 : end - q); 							} 							if (m == 0) 							{ 								write = q; 								r = Inflate_flush(z' r); 								q = write; 								m = (int)(q < read ? read - q - 1 : end - q); 								if (q == end && read != 0) 								{ 									q = 0; 									m = (int)(q < read ? read - q - 1 : end - q); 								} 								if (m == 0) 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						t = left; 						if (t > n) 						{ 							t = n; 						} 						if (t > m) 						{ 							t = m; 						} 						System.Array.Copy(z.next_in' p' window' q' t); 						p += t; 						n -= t; 						q += t; 						m -= t; 						if ((left -= t) != 0) 						{ 							break; 						} 						mode = last != 0 ? DRY : TYPE; 						break; 					}  					case TABLE: 					{ 						while (k < (14)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						table = t = (b & unchecked((int)(0x3fff))); 						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29) 						{ 							mode = BAD; 							z.msg = "too many length or distance symbols"; 							r = Z_DATA_ERROR; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f))); 						if (blens == null || blens.Length < t) 						{ 							blens = new int[t]; 						} 						else 						{ 							for (int i = 0; i < t; i++) 							{ 								blens[i] = 0; 							} 						} 						b = (int)(((uint)b) >> (14)); 						k -= (14); 						index = 0; 						mode = BTREE; 						goto case BTREE; 					}  					case BTREE: 					{ 						while (index < 4 + ((int)(((uint)table) >> 10))) 						{ 							while (k < (3)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							blens[border[index++]] = b & 7; 							{ 								b = (int)(((uint)b) >> (3)); 								k -= (3); 							} 						} 						while (index < 19) 						{ 							blens[border[index++]] = 0; 						} 						bb[0] = 7; 						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z); 						if (t != Z_OK) 						{ 							r = t; 							if (r == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						index = 0; 						mode = DTREE; 						goto case DTREE; 					}  					case DTREE: 					{ 						while (true) 						{ 							t = table; 							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 								))))) 							{ 								break; 							} 							int[] h; 							int i; 							int j; 							int c; 							t = bb[0]; 							while (k < (t)) 							{ 								if (n != 0) 								{ 									r = Z_OK; 								} 								else 								{ 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								n--; 								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 								k += 8; 							} 							if (tb[0] == -1) 							{ 							} 							//System.err.println("null..."); 							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1]; 							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2]; 							if (c < 16) 							{ 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								blens[index++] = c; 							} 							else 							{ 								// c == 16..18 								i = c == 18 ? 7 : c - 14; 								j = c == 18 ? 11 : 3; 								while (k < (t + i)) 								{ 									if (n != 0) 									{ 										r = Z_OK; 									} 									else 									{ 										bitb = b; 										bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										write = q; 										return Inflate_flush(z' r); 									} 									n--; 									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 									k += 8; 								} 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								j += (b & inflate_mask[i]); 								b = (int)(((uint)b) >> (i)); 								k -= (i); 								i = index; 								t = table; 								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f 									))) || (c == 16 && i < 1)) 								{ 									blens = null; 									mode = BAD; 									z.msg = "invalid bit length repeat"; 									r = Z_DATA_ERROR; 									bitb = b; 									bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									write = q; 									return Inflate_flush(z' r); 								} 								c = c == 16 ? blens[i - 1] : 0; 								do 								{ 									blens[i++] = c; 								} 								while (--j != 0); 								index = i; 							} 						} 						tb[0] = -1; 						int[] bl = new int[1]; 						int[] bd = new int[1]; 						int[] tl = new int[1]; 						int[] td = new int[1]; 						bl[0] = 9; 						// must be <= 9 for lookahead assumptions 						bd[0] = 6; 						// must be <= 9 for lookahead assumptions 						t = table; 						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>  							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z); 						if (t != Z_OK) 						{ 							if (t == Z_DATA_ERROR) 							{ 								blens = null; 								mode = BAD; 							} 							r = t; 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z); 						mode = CODES; 						goto case CODES; 					}  					case CODES: 					{ 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END) 						{ 							return Inflate_flush(z' r); 						} 						r = Z_OK; 						codes.Free(z); 						p = z.next_in_index; 						n = z.avail_in; 						b = bitb; 						k = bitk; 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (last == 0) 						{ 							mode = TYPE; 							break; 						} 						mode = DRY; 						goto case DRY; 					}  					case DRY: 					{ 						write = q; 						r = Inflate_flush(z' r); 						q = write; 						m = (int)(q < read ? read - q - 1 : end - q); 						if (read != write) 						{ 							bitb = b; 							bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							write = q; 							return Inflate_flush(z' r); 						} 						mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						r = Z_STREAM_END; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					case BAD: 					{ 						r = Z_DATA_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						bitb = b; 						bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						write = q; 						return Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: switch (mode) 				{ 					case START: 					{ 						// waiting for "i:"=input' "o:"=output' "x:"=nothing 						// x: set up for LEN 						if (m >= 258 && n >= 10) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z); 							p = z.next_in_index; 							n = z.avail_in; 							b = s.bitb; 							k = s.bitk; 							q = s.write; 							m = q < s.read ? s.read - q - 1 : s.end - q; 							if (r != Z_OK) 							{ 								mode = r == Z_STREAM_END ? WASH : BADCODE; 								break; 							} 						} 						need = lbits; 						tree = ltree; 						tree_index = ltree_index; 						mode = LEN; 						goto case LEN; 					}  					case LEN: 					{ 						// i: get length/literal/eob next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b = (int)(((uint)b) >> (tree[tindex + 1])); 						k -= (tree[tindex + 1]); 						e = tree[tindex]; 						if (e == 0) 						{ 							// literal 							lit = tree[tindex + 2]; 							mode = LIT; 							break; 						} 						if ((e & 16) != 0) 						{ 							// length 							get = e & 15; 							len = tree[tindex + 2]; 							mode = LENEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						if ((e & 32) != 0) 						{ 							// end of block 							mode = WASH; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid literal/length code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case LENEXT: 					{ 						// i: getting length extra (have base) 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						len += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						need = dbits; 						tree = dtree; 						tree_index = dtree_index; 						mode = DIST; 						goto case DIST; 					}  					case DIST: 					{ 						// i: get distance next 						j = need; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						tindex = (tree_index + (b & inflate_mask[j])) * 3; 						b >>= tree[tindex + 1]; 						k -= tree[tindex + 1]; 						e = (tree[tindex]); 						if ((e & 16) != 0) 						{ 							// distance 							get = e & 15; 							dist = tree[tindex + 2]; 							mode = DISTEXT; 							break; 						} 						if ((e & 64) == 0) 						{ 							// next table 							need = e; 							tree_index = tindex / 3 + tree[tindex + 2]; 							break; 						} 						mode = BADCODE; 						// invalid code 						z.msg = "invalid distance code"; 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case DISTEXT: 					{ 						// i: getting distance extra 						j = get; 						while (k < (j)) 						{ 							if (n != 0) 							{ 								r = Z_OK; 							} 							else 							{ 								s.bitb = b; 								s.bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								s.write = q; 								return s.Inflate_flush(z' r); 							} 							n--; 							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k; 							k += 8; 						} 						dist += (b & inflate_mask[j]); 						b >>= j; 						k -= j; 						mode = COPY; 						goto case COPY; 					}  					case COPY: 					{ 						// o: copying bytes in window' waiting for space 						f = q - dist; 						while (f < 0) 						{ 							// modulo window size-"while" instead 							f += s.end; 						} 						// of "if" handles invalid distances 						while (len != 0) 						{ 							if (m == 0) 							{ 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.write = q; 									r = s.Inflate_flush(z' r); 									q = s.write; 									m = q < s.read ? s.read - q - 1 : s.end - q; 									if (q == s.end && s.read != 0) 									{ 										q = 0; 										m = q < s.read ? s.read - q - 1 : s.end - q; 									} 									if (m == 0) 									{ 										s.bitb = b; 										s.bitk = k; 										z.avail_in = n; 										z.total_in += p - z.next_in_index; 										z.next_in_index = p; 										s.write = q; 										return s.Inflate_flush(z' r); 									} 								} 							} 							s.window[q++] = s.window[f++]; 							m--; 							if (f == s.end) 							{ 								f = 0; 							} 							len--; 						} 						mode = START; 						break; 					}  					case LIT: 					{ 						// o: got literal' waiting for output space 						if (m == 0) 						{ 							if (q == s.end && s.read != 0) 							{ 								q = 0; 								m = q < s.read ? s.read - q - 1 : s.end - q; 							} 							if (m == 0) 							{ 								s.write = q; 								r = s.Inflate_flush(z' r); 								q = s.write; 								m = q < s.read ? s.read - q - 1 : s.end - q; 								if (q == s.end && s.read != 0) 								{ 									q = 0; 									m = q < s.read ? s.read - q - 1 : s.end - q; 								} 								if (m == 0) 								{ 									s.bitb = b; 									s.bitk = k; 									z.avail_in = n; 									z.total_in += p - z.next_in_index; 									z.next_in_index = p; 									s.write = q; 									return s.Inflate_flush(z' r); 								} 							} 						} 						r = Z_OK; 						s.window[q++] = unchecked((byte)lit); 						m--; 						mode = START; 						break; 					}  					case WASH: 					{ 						// o: got eob' possibly more output 						if (k > 7) 						{ 							// return unused byte' if any 							k -= 8; 							n++; 							p--; 						} 						// can always return one 						s.write = q; 						r = s.Inflate_flush(z' r); 						q = s.write; 						m = q < s.read ? s.read - q - 1 : s.end - q; 						if (s.read != s.write) 						{ 							s.bitb = b; 							s.bitk = k; 							z.avail_in = n; 							z.total_in += p - z.next_in_index; 							z.next_in_index = p; 							s.write = q; 							return s.Inflate_flush(z' r); 						} 						mode = END; 						goto case END; 					}  					case END: 					{ 						r = Z_STREAM_END; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					case BADCODE: 					{ 						// x: got error 						r = Z_DATA_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 					}  					default: 					{ 						r = Z_STREAM_ERROR; 						s.bitb = b; 						s.bitk = k; 						z.avail_in = n; 						z.total_in += p - z.next_in_index; 						z.next_in_index = p; 						s.write = q; 						return s.Inflate_flush(z' r); 						break; 					} 				}
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: k += 8;
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: k < (20)
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: e &= 15;
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: k += 8;
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: k < (15)
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: e &= 15;
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: k += 8;
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: c -= 2;
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: q - r > 0 && 2 > (q - r)
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: (e & 16) != 0
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: (e & 16) != 0
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: t += tp[tp_index_t_3 + 2];
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: (e & 64) == 0
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: k -= c << 3;
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: xp = 2;
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: r[2] = (int)(q - u[h - 1] - j);
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: System.Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: System.Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_bits,The following statement contains a magic number: InitWorkArea(19);
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_bits,The following statement contains a magic number: result = Huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_bits,The following statement contains a magic number: result = Huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_dynamic,The following statement contains a magic number: InitWorkArea(288);
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_dynamic,The following statement contains a magic number: result = Huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_dynamic,The following statement contains a magic number: InitWorkArea(288);
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_dynamic,The following statement contains a magic number: result != Z_OK || (bd[0] == 0 && nl > 257)
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,InitWorkArea,The following statement contains a magic number: r = new int[3];
Magic Number,NSch.ZLib,InfTree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,InitWorkArea,The following statement contains a magic number: i_2 < 3
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,InflateInit,The following statement contains a magic number: w < 8 || w > 15
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,InflateInit,The following statement contains a magic number: w < 8 || w > 15
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: switch (z.istate.mode) 				{ 					case METHOD: 					{ 						//System.out.println("mode: "+z.istate.mode); 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) != 							 Z_DEFLATED) 						{ 							z.istate.mode = BAD; 							z.msg = "unknown compression method"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((z.istate.method >> 4) + 8 > z.istate.wbits) 						{ 							z.istate.mode = BAD; 							z.msg = "invalid window size"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = FLAG; 						goto case FLAG; 					}  					case FLAG: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff)); 						if ((((z.istate.method << 8) + b) % 31) != 0) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect header check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((b & PRESET_DICT) == 0) 						{ 							z.istate.mode = BLOCKS; 							break; 						} 						z.istate.mode = DICT4; 						goto case DICT4; 					}  					case DICT4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = DICT3; 						goto case DICT3; 					}  					case DICT3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = DICT2; 						goto case DICT2; 					}  					case DICT2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = DICT1; 						goto case DICT1; 					}  					case DICT1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						z.adler = z.istate.need; 						z.istate.mode = DICT0; 						return Z_NEED_DICT; 					}  					case DICT0: 					{ 						z.istate.mode = BAD; 						z.msg = "need dictionary"; 						z.istate.marker = 0; 						// can try inflateSync 						return Z_STREAM_ERROR; 					}  					case BLOCKS: 					{ 						r = z.istate.blocks.Proc(z' r); 						if (r == Z_DATA_ERROR) 						{ 							z.istate.mode = BAD; 							z.istate.marker = 0; 							// can try inflateSync 							break; 						} 						if (r == Z_OK) 						{ 							r = f; 						} 						if (r != Z_STREAM_END) 						{ 							return r; 						} 						r = f; 						z.istate.blocks.Reset(z' z.istate.was); 						if (z.istate.nowrap != 0) 						{ 							z.istate.mode = DONE; 							break; 						} 						z.istate.mode = CHECK4; 						goto case CHECK4; 					}  					case CHECK4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = CHECK3; 						goto case CHECK3; 					}  					case CHECK3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = CHECK2; 						goto case CHECK2; 					}  					case CHECK2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = CHECK1; 						goto case CHECK1; 					}  					case CHECK1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						if (((int)(z.istate.was[0])) != ((int)(z.istate.need))) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect data check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						return Z_STREAM_END; 					}  					case BAD: 					{ 						return Z_DATA_ERROR; 					}  					default: 					{ 						return Z_STREAM_ERROR; 						break; 					} 				}
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: switch (z.istate.mode) 				{ 					case METHOD: 					{ 						//System.out.println("mode: "+z.istate.mode); 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) != 							 Z_DEFLATED) 						{ 							z.istate.mode = BAD; 							z.msg = "unknown compression method"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((z.istate.method >> 4) + 8 > z.istate.wbits) 						{ 							z.istate.mode = BAD; 							z.msg = "invalid window size"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = FLAG; 						goto case FLAG; 					}  					case FLAG: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff)); 						if ((((z.istate.method << 8) + b) % 31) != 0) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect header check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((b & PRESET_DICT) == 0) 						{ 							z.istate.mode = BLOCKS; 							break; 						} 						z.istate.mode = DICT4; 						goto case DICT4; 					}  					case DICT4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = DICT3; 						goto case DICT3; 					}  					case DICT3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = DICT2; 						goto case DICT2; 					}  					case DICT2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = DICT1; 						goto case DICT1; 					}  					case DICT1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						z.adler = z.istate.need; 						z.istate.mode = DICT0; 						return Z_NEED_DICT; 					}  					case DICT0: 					{ 						z.istate.mode = BAD; 						z.msg = "need dictionary"; 						z.istate.marker = 0; 						// can try inflateSync 						return Z_STREAM_ERROR; 					}  					case BLOCKS: 					{ 						r = z.istate.blocks.Proc(z' r); 						if (r == Z_DATA_ERROR) 						{ 							z.istate.mode = BAD; 							z.istate.marker = 0; 							// can try inflateSync 							break; 						} 						if (r == Z_OK) 						{ 							r = f; 						} 						if (r != Z_STREAM_END) 						{ 							return r; 						} 						r = f; 						z.istate.blocks.Reset(z' z.istate.was); 						if (z.istate.nowrap != 0) 						{ 							z.istate.mode = DONE; 							break; 						} 						z.istate.mode = CHECK4; 						goto case CHECK4; 					}  					case CHECK4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = CHECK3; 						goto case CHECK3; 					}  					case CHECK3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = CHECK2; 						goto case CHECK2; 					}  					case CHECK2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = CHECK1; 						goto case CHECK1; 					}  					case CHECK1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						if (((int)(z.istate.was[0])) != ((int)(z.istate.need))) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect data check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						return Z_STREAM_END; 					}  					case BAD: 					{ 						return Z_DATA_ERROR; 					}  					default: 					{ 						return Z_STREAM_ERROR; 						break; 					} 				}
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: switch (z.istate.mode) 				{ 					case METHOD: 					{ 						//System.out.println("mode: "+z.istate.mode); 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) != 							 Z_DEFLATED) 						{ 							z.istate.mode = BAD; 							z.msg = "unknown compression method"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((z.istate.method >> 4) + 8 > z.istate.wbits) 						{ 							z.istate.mode = BAD; 							z.msg = "invalid window size"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = FLAG; 						goto case FLAG; 					}  					case FLAG: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff)); 						if ((((z.istate.method << 8) + b) % 31) != 0) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect header check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((b & PRESET_DICT) == 0) 						{ 							z.istate.mode = BLOCKS; 							break; 						} 						z.istate.mode = DICT4; 						goto case DICT4; 					}  					case DICT4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = DICT3; 						goto case DICT3; 					}  					case DICT3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = DICT2; 						goto case DICT2; 					}  					case DICT2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = DICT1; 						goto case DICT1; 					}  					case DICT1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						z.adler = z.istate.need; 						z.istate.mode = DICT0; 						return Z_NEED_DICT; 					}  					case DICT0: 					{ 						z.istate.mode = BAD; 						z.msg = "need dictionary"; 						z.istate.marker = 0; 						// can try inflateSync 						return Z_STREAM_ERROR; 					}  					case BLOCKS: 					{ 						r = z.istate.blocks.Proc(z' r); 						if (r == Z_DATA_ERROR) 						{ 							z.istate.mode = BAD; 							z.istate.marker = 0; 							// can try inflateSync 							break; 						} 						if (r == Z_OK) 						{ 							r = f; 						} 						if (r != Z_STREAM_END) 						{ 							return r; 						} 						r = f; 						z.istate.blocks.Reset(z' z.istate.was); 						if (z.istate.nowrap != 0) 						{ 							z.istate.mode = DONE; 							break; 						} 						z.istate.mode = CHECK4; 						goto case CHECK4; 					}  					case CHECK4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = CHECK3; 						goto case CHECK3; 					}  					case CHECK3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = CHECK2; 						goto case CHECK2; 					}  					case CHECK2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = CHECK1; 						goto case CHECK1; 					}  					case CHECK1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						if (((int)(z.istate.was[0])) != ((int)(z.istate.need))) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect data check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						return Z_STREAM_END; 					}  					case BAD: 					{ 						return Z_DATA_ERROR; 					}  					default: 					{ 						return Z_STREAM_ERROR; 						break; 					} 				}
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: switch (z.istate.mode) 				{ 					case METHOD: 					{ 						//System.out.println("mode: "+z.istate.mode); 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) != 							 Z_DEFLATED) 						{ 							z.istate.mode = BAD; 							z.msg = "unknown compression method"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((z.istate.method >> 4) + 8 > z.istate.wbits) 						{ 							z.istate.mode = BAD; 							z.msg = "invalid window size"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = FLAG; 						goto case FLAG; 					}  					case FLAG: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff)); 						if ((((z.istate.method << 8) + b) % 31) != 0) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect header check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((b & PRESET_DICT) == 0) 						{ 							z.istate.mode = BLOCKS; 							break; 						} 						z.istate.mode = DICT4; 						goto case DICT4; 					}  					case DICT4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = DICT3; 						goto case DICT3; 					}  					case DICT3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = DICT2; 						goto case DICT2; 					}  					case DICT2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = DICT1; 						goto case DICT1; 					}  					case DICT1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						z.adler = z.istate.need; 						z.istate.mode = DICT0; 						return Z_NEED_DICT; 					}  					case DICT0: 					{ 						z.istate.mode = BAD; 						z.msg = "need dictionary"; 						z.istate.marker = 0; 						// can try inflateSync 						return Z_STREAM_ERROR; 					}  					case BLOCKS: 					{ 						r = z.istate.blocks.Proc(z' r); 						if (r == Z_DATA_ERROR) 						{ 							z.istate.mode = BAD; 							z.istate.marker = 0; 							// can try inflateSync 							break; 						} 						if (r == Z_OK) 						{ 							r = f; 						} 						if (r != Z_STREAM_END) 						{ 							return r; 						} 						r = f; 						z.istate.blocks.Reset(z' z.istate.was); 						if (z.istate.nowrap != 0) 						{ 							z.istate.mode = DONE; 							break; 						} 						z.istate.mode = CHECK4; 						goto case CHECK4; 					}  					case CHECK4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = CHECK3; 						goto case CHECK3; 					}  					case CHECK3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = CHECK2; 						goto case CHECK2; 					}  					case CHECK2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = CHECK1; 						goto case CHECK1; 					}  					case CHECK1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						if (((int)(z.istate.was[0])) != ((int)(z.istate.need))) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect data check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						return Z_STREAM_END; 					}  					case BAD: 					{ 						return Z_DATA_ERROR; 					}  					default: 					{ 						return Z_STREAM_ERROR; 						break; 					} 				}
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: switch (z.istate.mode) 				{ 					case METHOD: 					{ 						//System.out.println("mode: "+z.istate.mode); 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) != 							 Z_DEFLATED) 						{ 							z.istate.mode = BAD; 							z.msg = "unknown compression method"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((z.istate.method >> 4) + 8 > z.istate.wbits) 						{ 							z.istate.mode = BAD; 							z.msg = "invalid window size"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = FLAG; 						goto case FLAG; 					}  					case FLAG: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff)); 						if ((((z.istate.method << 8) + b) % 31) != 0) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect header check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((b & PRESET_DICT) == 0) 						{ 							z.istate.mode = BLOCKS; 							break; 						} 						z.istate.mode = DICT4; 						goto case DICT4; 					}  					case DICT4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = DICT3; 						goto case DICT3; 					}  					case DICT3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = DICT2; 						goto case DICT2; 					}  					case DICT2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = DICT1; 						goto case DICT1; 					}  					case DICT1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						z.adler = z.istate.need; 						z.istate.mode = DICT0; 						return Z_NEED_DICT; 					}  					case DICT0: 					{ 						z.istate.mode = BAD; 						z.msg = "need dictionary"; 						z.istate.marker = 0; 						// can try inflateSync 						return Z_STREAM_ERROR; 					}  					case BLOCKS: 					{ 						r = z.istate.blocks.Proc(z' r); 						if (r == Z_DATA_ERROR) 						{ 							z.istate.mode = BAD; 							z.istate.marker = 0; 							// can try inflateSync 							break; 						} 						if (r == Z_OK) 						{ 							r = f; 						} 						if (r != Z_STREAM_END) 						{ 							return r; 						} 						r = f; 						z.istate.blocks.Reset(z' z.istate.was); 						if (z.istate.nowrap != 0) 						{ 							z.istate.mode = DONE; 							break; 						} 						z.istate.mode = CHECK4; 						goto case CHECK4; 					}  					case CHECK4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = CHECK3; 						goto case CHECK3; 					}  					case CHECK3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = CHECK2; 						goto case CHECK2; 					}  					case CHECK2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = CHECK1; 						goto case CHECK1; 					}  					case CHECK1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						if (((int)(z.istate.was[0])) != ((int)(z.istate.need))) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect data check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						return Z_STREAM_END; 					}  					case BAD: 					{ 						return Z_DATA_ERROR; 					}  					default: 					{ 						return Z_STREAM_ERROR; 						break; 					} 				}
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: switch (z.istate.mode) 				{ 					case METHOD: 					{ 						//System.out.println("mode: "+z.istate.mode); 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) != 							 Z_DEFLATED) 						{ 							z.istate.mode = BAD; 							z.msg = "unknown compression method"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((z.istate.method >> 4) + 8 > z.istate.wbits) 						{ 							z.istate.mode = BAD; 							z.msg = "invalid window size"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = FLAG; 						goto case FLAG; 					}  					case FLAG: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff)); 						if ((((z.istate.method << 8) + b) % 31) != 0) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect header check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((b & PRESET_DICT) == 0) 						{ 							z.istate.mode = BLOCKS; 							break; 						} 						z.istate.mode = DICT4; 						goto case DICT4; 					}  					case DICT4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = DICT3; 						goto case DICT3; 					}  					case DICT3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = DICT2; 						goto case DICT2; 					}  					case DICT2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = DICT1; 						goto case DICT1; 					}  					case DICT1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						z.adler = z.istate.need; 						z.istate.mode = DICT0; 						return Z_NEED_DICT; 					}  					case DICT0: 					{ 						z.istate.mode = BAD; 						z.msg = "need dictionary"; 						z.istate.marker = 0; 						// can try inflateSync 						return Z_STREAM_ERROR; 					}  					case BLOCKS: 					{ 						r = z.istate.blocks.Proc(z' r); 						if (r == Z_DATA_ERROR) 						{ 							z.istate.mode = BAD; 							z.istate.marker = 0; 							// can try inflateSync 							break; 						} 						if (r == Z_OK) 						{ 							r = f; 						} 						if (r != Z_STREAM_END) 						{ 							return r; 						} 						r = f; 						z.istate.blocks.Reset(z' z.istate.was); 						if (z.istate.nowrap != 0) 						{ 							z.istate.mode = DONE; 							break; 						} 						z.istate.mode = CHECK4; 						goto case CHECK4; 					}  					case CHECK4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = CHECK3; 						goto case CHECK3; 					}  					case CHECK3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = CHECK2; 						goto case CHECK2; 					}  					case CHECK2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = CHECK1; 						goto case CHECK1; 					}  					case CHECK1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						if (((int)(z.istate.was[0])) != ((int)(z.istate.need))) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect data check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						return Z_STREAM_END; 					}  					case BAD: 					{ 						return Z_DATA_ERROR; 					}  					default: 					{ 						return Z_STREAM_ERROR; 						break; 					} 				}
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: switch (z.istate.mode) 				{ 					case METHOD: 					{ 						//System.out.println("mode: "+z.istate.mode); 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) != 							 Z_DEFLATED) 						{ 							z.istate.mode = BAD; 							z.msg = "unknown compression method"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((z.istate.method >> 4) + 8 > z.istate.wbits) 						{ 							z.istate.mode = BAD; 							z.msg = "invalid window size"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = FLAG; 						goto case FLAG; 					}  					case FLAG: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff)); 						if ((((z.istate.method << 8) + b) % 31) != 0) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect header check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((b & PRESET_DICT) == 0) 						{ 							z.istate.mode = BLOCKS; 							break; 						} 						z.istate.mode = DICT4; 						goto case DICT4; 					}  					case DICT4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = DICT3; 						goto case DICT3; 					}  					case DICT3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = DICT2; 						goto case DICT2; 					}  					case DICT2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = DICT1; 						goto case DICT1; 					}  					case DICT1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						z.adler = z.istate.need; 						z.istate.mode = DICT0; 						return Z_NEED_DICT; 					}  					case DICT0: 					{ 						z.istate.mode = BAD; 						z.msg = "need dictionary"; 						z.istate.marker = 0; 						// can try inflateSync 						return Z_STREAM_ERROR; 					}  					case BLOCKS: 					{ 						r = z.istate.blocks.Proc(z' r); 						if (r == Z_DATA_ERROR) 						{ 							z.istate.mode = BAD; 							z.istate.marker = 0; 							// can try inflateSync 							break; 						} 						if (r == Z_OK) 						{ 							r = f; 						} 						if (r != Z_STREAM_END) 						{ 							return r; 						} 						r = f; 						z.istate.blocks.Reset(z' z.istate.was); 						if (z.istate.nowrap != 0) 						{ 							z.istate.mode = DONE; 							break; 						} 						z.istate.mode = CHECK4; 						goto case CHECK4; 					}  					case CHECK4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = CHECK3; 						goto case CHECK3; 					}  					case CHECK3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = CHECK2; 						goto case CHECK2; 					}  					case CHECK2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = CHECK1; 						goto case CHECK1; 					}  					case CHECK1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						if (((int)(z.istate.was[0])) != ((int)(z.istate.need))) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect data check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						return Z_STREAM_END; 					}  					case BAD: 					{ 						return Z_DATA_ERROR; 					}  					default: 					{ 						return Z_STREAM_ERROR; 						break; 					} 				}
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: switch (z.istate.mode) 				{ 					case METHOD: 					{ 						//System.out.println("mode: "+z.istate.mode); 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) != 							 Z_DEFLATED) 						{ 							z.istate.mode = BAD; 							z.msg = "unknown compression method"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((z.istate.method >> 4) + 8 > z.istate.wbits) 						{ 							z.istate.mode = BAD; 							z.msg = "invalid window size"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = FLAG; 						goto case FLAG; 					}  					case FLAG: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff)); 						if ((((z.istate.method << 8) + b) % 31) != 0) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect header check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((b & PRESET_DICT) == 0) 						{ 							z.istate.mode = BLOCKS; 							break; 						} 						z.istate.mode = DICT4; 						goto case DICT4; 					}  					case DICT4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = DICT3; 						goto case DICT3; 					}  					case DICT3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = DICT2; 						goto case DICT2; 					}  					case DICT2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = DICT1; 						goto case DICT1; 					}  					case DICT1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						z.adler = z.istate.need; 						z.istate.mode = DICT0; 						return Z_NEED_DICT; 					}  					case DICT0: 					{ 						z.istate.mode = BAD; 						z.msg = "need dictionary"; 						z.istate.marker = 0; 						// can try inflateSync 						return Z_STREAM_ERROR; 					}  					case BLOCKS: 					{ 						r = z.istate.blocks.Proc(z' r); 						if (r == Z_DATA_ERROR) 						{ 							z.istate.mode = BAD; 							z.istate.marker = 0; 							// can try inflateSync 							break; 						} 						if (r == Z_OK) 						{ 							r = f; 						} 						if (r != Z_STREAM_END) 						{ 							return r; 						} 						r = f; 						z.istate.blocks.Reset(z' z.istate.was); 						if (z.istate.nowrap != 0) 						{ 							z.istate.mode = DONE; 							break; 						} 						z.istate.mode = CHECK4; 						goto case CHECK4; 					}  					case CHECK4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = CHECK3; 						goto case CHECK3; 					}  					case CHECK3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = CHECK2; 						goto case CHECK2; 					}  					case CHECK2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = CHECK1; 						goto case CHECK1; 					}  					case CHECK1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						if (((int)(z.istate.was[0])) != ((int)(z.istate.need))) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect data check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						return Z_STREAM_END; 					}  					case BAD: 					{ 						return Z_DATA_ERROR; 					}  					default: 					{ 						return Z_STREAM_ERROR; 						break; 					} 				}
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: switch (z.istate.mode) 				{ 					case METHOD: 					{ 						//System.out.println("mode: "+z.istate.mode); 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) != 							 Z_DEFLATED) 						{ 							z.istate.mode = BAD; 							z.msg = "unknown compression method"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((z.istate.method >> 4) + 8 > z.istate.wbits) 						{ 							z.istate.mode = BAD; 							z.msg = "invalid window size"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = FLAG; 						goto case FLAG; 					}  					case FLAG: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff)); 						if ((((z.istate.method << 8) + b) % 31) != 0) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect header check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((b & PRESET_DICT) == 0) 						{ 							z.istate.mode = BLOCKS; 							break; 						} 						z.istate.mode = DICT4; 						goto case DICT4; 					}  					case DICT4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = DICT3; 						goto case DICT3; 					}  					case DICT3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = DICT2; 						goto case DICT2; 					}  					case DICT2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = DICT1; 						goto case DICT1; 					}  					case DICT1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						z.adler = z.istate.need; 						z.istate.mode = DICT0; 						return Z_NEED_DICT; 					}  					case DICT0: 					{ 						z.istate.mode = BAD; 						z.msg = "need dictionary"; 						z.istate.marker = 0; 						// can try inflateSync 						return Z_STREAM_ERROR; 					}  					case BLOCKS: 					{ 						r = z.istate.blocks.Proc(z' r); 						if (r == Z_DATA_ERROR) 						{ 							z.istate.mode = BAD; 							z.istate.marker = 0; 							// can try inflateSync 							break; 						} 						if (r == Z_OK) 						{ 							r = f; 						} 						if (r != Z_STREAM_END) 						{ 							return r; 						} 						r = f; 						z.istate.blocks.Reset(z' z.istate.was); 						if (z.istate.nowrap != 0) 						{ 							z.istate.mode = DONE; 							break; 						} 						z.istate.mode = CHECK4; 						goto case CHECK4; 					}  					case CHECK4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = CHECK3; 						goto case CHECK3; 					}  					case CHECK3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = CHECK2; 						goto case CHECK2; 					}  					case CHECK2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = CHECK1; 						goto case CHECK1; 					}  					case CHECK1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						if (((int)(z.istate.was[0])) != ((int)(z.istate.need))) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect data check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						return Z_STREAM_END; 					}  					case BAD: 					{ 						return Z_DATA_ERROR; 					}  					default: 					{ 						return Z_STREAM_ERROR; 						break; 					} 				}
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: switch (z.istate.mode) 				{ 					case METHOD: 					{ 						//System.out.println("mode: "+z.istate.mode); 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) != 							 Z_DEFLATED) 						{ 							z.istate.mode = BAD; 							z.msg = "unknown compression method"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((z.istate.method >> 4) + 8 > z.istate.wbits) 						{ 							z.istate.mode = BAD; 							z.msg = "invalid window size"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = FLAG; 						goto case FLAG; 					}  					case FLAG: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff)); 						if ((((z.istate.method << 8) + b) % 31) != 0) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect header check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((b & PRESET_DICT) == 0) 						{ 							z.istate.mode = BLOCKS; 							break; 						} 						z.istate.mode = DICT4; 						goto case DICT4; 					}  					case DICT4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = DICT3; 						goto case DICT3; 					}  					case DICT3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = DICT2; 						goto case DICT2; 					}  					case DICT2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = DICT1; 						goto case DICT1; 					}  					case DICT1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						z.adler = z.istate.need; 						z.istate.mode = DICT0; 						return Z_NEED_DICT; 					}  					case DICT0: 					{ 						z.istate.mode = BAD; 						z.msg = "need dictionary"; 						z.istate.marker = 0; 						// can try inflateSync 						return Z_STREAM_ERROR; 					}  					case BLOCKS: 					{ 						r = z.istate.blocks.Proc(z' r); 						if (r == Z_DATA_ERROR) 						{ 							z.istate.mode = BAD; 							z.istate.marker = 0; 							// can try inflateSync 							break; 						} 						if (r == Z_OK) 						{ 							r = f; 						} 						if (r != Z_STREAM_END) 						{ 							return r; 						} 						r = f; 						z.istate.blocks.Reset(z' z.istate.was); 						if (z.istate.nowrap != 0) 						{ 							z.istate.mode = DONE; 							break; 						} 						z.istate.mode = CHECK4; 						goto case CHECK4; 					}  					case CHECK4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = CHECK3; 						goto case CHECK3; 					}  					case CHECK3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = CHECK2; 						goto case CHECK2; 					}  					case CHECK2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = CHECK1; 						goto case CHECK1; 					}  					case CHECK1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						if (((int)(z.istate.was[0])) != ((int)(z.istate.need))) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect data check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						return Z_STREAM_END; 					}  					case BAD: 					{ 						return Z_DATA_ERROR; 					}  					default: 					{ 						return Z_STREAM_ERROR; 						break; 					} 				}
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: switch (z.istate.mode) 				{ 					case METHOD: 					{ 						//System.out.println("mode: "+z.istate.mode); 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) != 							 Z_DEFLATED) 						{ 							z.istate.mode = BAD; 							z.msg = "unknown compression method"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((z.istate.method >> 4) + 8 > z.istate.wbits) 						{ 							z.istate.mode = BAD; 							z.msg = "invalid window size"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = FLAG; 						goto case FLAG; 					}  					case FLAG: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff)); 						if ((((z.istate.method << 8) + b) % 31) != 0) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect header check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((b & PRESET_DICT) == 0) 						{ 							z.istate.mode = BLOCKS; 							break; 						} 						z.istate.mode = DICT4; 						goto case DICT4; 					}  					case DICT4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = DICT3; 						goto case DICT3; 					}  					case DICT3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = DICT2; 						goto case DICT2; 					}  					case DICT2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = DICT1; 						goto case DICT1; 					}  					case DICT1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						z.adler = z.istate.need; 						z.istate.mode = DICT0; 						return Z_NEED_DICT; 					}  					case DICT0: 					{ 						z.istate.mode = BAD; 						z.msg = "need dictionary"; 						z.istate.marker = 0; 						// can try inflateSync 						return Z_STREAM_ERROR; 					}  					case BLOCKS: 					{ 						r = z.istate.blocks.Proc(z' r); 						if (r == Z_DATA_ERROR) 						{ 							z.istate.mode = BAD; 							z.istate.marker = 0; 							// can try inflateSync 							break; 						} 						if (r == Z_OK) 						{ 							r = f; 						} 						if (r != Z_STREAM_END) 						{ 							return r; 						} 						r = f; 						z.istate.blocks.Reset(z' z.istate.was); 						if (z.istate.nowrap != 0) 						{ 							z.istate.mode = DONE; 							break; 						} 						z.istate.mode = CHECK4; 						goto case CHECK4; 					}  					case CHECK4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = CHECK3; 						goto case CHECK3; 					}  					case CHECK3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = CHECK2; 						goto case CHECK2; 					}  					case CHECK2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = CHECK1; 						goto case CHECK1; 					}  					case CHECK1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						if (((int)(z.istate.was[0])) != ((int)(z.istate.need))) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect data check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						return Z_STREAM_END; 					}  					case BAD: 					{ 						return Z_DATA_ERROR; 					}  					default: 					{ 						return Z_STREAM_ERROR; 						break; 					} 				}
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: switch (z.istate.mode) 				{ 					case METHOD: 					{ 						//System.out.println("mode: "+z.istate.mode); 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) != 							 Z_DEFLATED) 						{ 							z.istate.mode = BAD; 							z.msg = "unknown compression method"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((z.istate.method >> 4) + 8 > z.istate.wbits) 						{ 							z.istate.mode = BAD; 							z.msg = "invalid window size"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = FLAG; 						goto case FLAG; 					}  					case FLAG: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff)); 						if ((((z.istate.method << 8) + b) % 31) != 0) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect header check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((b & PRESET_DICT) == 0) 						{ 							z.istate.mode = BLOCKS; 							break; 						} 						z.istate.mode = DICT4; 						goto case DICT4; 					}  					case DICT4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = DICT3; 						goto case DICT3; 					}  					case DICT3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = DICT2; 						goto case DICT2; 					}  					case DICT2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = DICT1; 						goto case DICT1; 					}  					case DICT1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						z.adler = z.istate.need; 						z.istate.mode = DICT0; 						return Z_NEED_DICT; 					}  					case DICT0: 					{ 						z.istate.mode = BAD; 						z.msg = "need dictionary"; 						z.istate.marker = 0; 						// can try inflateSync 						return Z_STREAM_ERROR; 					}  					case BLOCKS: 					{ 						r = z.istate.blocks.Proc(z' r); 						if (r == Z_DATA_ERROR) 						{ 							z.istate.mode = BAD; 							z.istate.marker = 0; 							// can try inflateSync 							break; 						} 						if (r == Z_OK) 						{ 							r = f; 						} 						if (r != Z_STREAM_END) 						{ 							return r; 						} 						r = f; 						z.istate.blocks.Reset(z' z.istate.was); 						if (z.istate.nowrap != 0) 						{ 							z.istate.mode = DONE; 							break; 						} 						z.istate.mode = CHECK4; 						goto case CHECK4; 					}  					case CHECK4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = CHECK3; 						goto case CHECK3; 					}  					case CHECK3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = CHECK2; 						goto case CHECK2; 					}  					case CHECK2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = CHECK1; 						goto case CHECK1; 					}  					case CHECK1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						if (((int)(z.istate.was[0])) != ((int)(z.istate.need))) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect data check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						return Z_STREAM_END; 					}  					case BAD: 					{ 						return Z_DATA_ERROR; 					}  					default: 					{ 						return Z_STREAM_ERROR; 						break; 					} 				}
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: switch (z.istate.mode) 				{ 					case METHOD: 					{ 						//System.out.println("mode: "+z.istate.mode); 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) != 							 Z_DEFLATED) 						{ 							z.istate.mode = BAD; 							z.msg = "unknown compression method"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((z.istate.method >> 4) + 8 > z.istate.wbits) 						{ 							z.istate.mode = BAD; 							z.msg = "invalid window size"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = FLAG; 						goto case FLAG; 					}  					case FLAG: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff)); 						if ((((z.istate.method << 8) + b) % 31) != 0) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect header check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((b & PRESET_DICT) == 0) 						{ 							z.istate.mode = BLOCKS; 							break; 						} 						z.istate.mode = DICT4; 						goto case DICT4; 					}  					case DICT4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = DICT3; 						goto case DICT3; 					}  					case DICT3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = DICT2; 						goto case DICT2; 					}  					case DICT2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = DICT1; 						goto case DICT1; 					}  					case DICT1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						z.adler = z.istate.need; 						z.istate.mode = DICT0; 						return Z_NEED_DICT; 					}  					case DICT0: 					{ 						z.istate.mode = BAD; 						z.msg = "need dictionary"; 						z.istate.marker = 0; 						// can try inflateSync 						return Z_STREAM_ERROR; 					}  					case BLOCKS: 					{ 						r = z.istate.blocks.Proc(z' r); 						if (r == Z_DATA_ERROR) 						{ 							z.istate.mode = BAD; 							z.istate.marker = 0; 							// can try inflateSync 							break; 						} 						if (r == Z_OK) 						{ 							r = f; 						} 						if (r != Z_STREAM_END) 						{ 							return r; 						} 						r = f; 						z.istate.blocks.Reset(z' z.istate.was); 						if (z.istate.nowrap != 0) 						{ 							z.istate.mode = DONE; 							break; 						} 						z.istate.mode = CHECK4; 						goto case CHECK4; 					}  					case CHECK4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = CHECK3; 						goto case CHECK3; 					}  					case CHECK3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = CHECK2; 						goto case CHECK2; 					}  					case CHECK2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = CHECK1; 						goto case CHECK1; 					}  					case CHECK1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						if (((int)(z.istate.was[0])) != ((int)(z.istate.need))) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect data check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						return Z_STREAM_END; 					}  					case BAD: 					{ 						return Z_DATA_ERROR; 					}  					default: 					{ 						return Z_STREAM_ERROR; 						break; 					} 				}
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: switch (z.istate.mode) 				{ 					case METHOD: 					{ 						//System.out.println("mode: "+z.istate.mode); 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) != 							 Z_DEFLATED) 						{ 							z.istate.mode = BAD; 							z.msg = "unknown compression method"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((z.istate.method >> 4) + 8 > z.istate.wbits) 						{ 							z.istate.mode = BAD; 							z.msg = "invalid window size"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = FLAG; 						goto case FLAG; 					}  					case FLAG: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff)); 						if ((((z.istate.method << 8) + b) % 31) != 0) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect header check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						if ((b & PRESET_DICT) == 0) 						{ 							z.istate.mode = BLOCKS; 							break; 						} 						z.istate.mode = DICT4; 						goto case DICT4; 					}  					case DICT4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = DICT3; 						goto case DICT3; 					}  					case DICT3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = DICT2; 						goto case DICT2; 					}  					case DICT2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = DICT1; 						goto case DICT1; 					}  					case DICT1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						z.adler = z.istate.need; 						z.istate.mode = DICT0; 						return Z_NEED_DICT; 					}  					case DICT0: 					{ 						z.istate.mode = BAD; 						z.msg = "need dictionary"; 						z.istate.marker = 0; 						// can try inflateSync 						return Z_STREAM_ERROR; 					}  					case BLOCKS: 					{ 						r = z.istate.blocks.Proc(z' r); 						if (r == Z_DATA_ERROR) 						{ 							z.istate.mode = BAD; 							z.istate.marker = 0; 							// can try inflateSync 							break; 						} 						if (r == Z_OK) 						{ 							r = f; 						} 						if (r != Z_STREAM_END) 						{ 							return r; 						} 						r = f; 						z.istate.blocks.Reset(z' z.istate.was); 						if (z.istate.nowrap != 0) 						{ 							z.istate.mode = DONE; 							break; 						} 						z.istate.mode = CHECK4; 						goto case CHECK4; 					}  					case CHECK4: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) & 							 unchecked((long)(0xff000000L)); 						z.istate.mode = CHECK3; 						goto case CHECK3; 					}  					case CHECK3: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)  							& unchecked((long)(0xff0000L)); 						z.istate.mode = CHECK2; 						goto case CHECK2; 					}  					case CHECK2: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) & 							 unchecked((long)(0xff00L)); 						z.istate.mode = CHECK1; 						goto case CHECK1; 					}  					case CHECK1: 					{ 						if (z.avail_in == 0) 						{ 							return r; 						} 						r = f; 						z.avail_in--; 						z.total_in++; 						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL))); 						if (((int)(z.istate.was[0])) != ((int)(z.istate.need))) 						{ 							z.istate.mode = BAD; 							z.msg = "incorrect data check"; 							z.istate.marker = 5; 							// can't try inflateSync 							break; 						} 						z.istate.mode = DONE; 						goto case DONE; 					}  					case DONE: 					{ 						return Z_STREAM_END; 					}  					case BAD: 					{ 						return Z_DATA_ERROR; 					}  					default: 					{ 						return Z_STREAM_ERROR; 						break; 					} 				}
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,InflateSync,The following statement contains a magic number: n != 0 && m < 4
Magic Number,NSch.ZLib,Inflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,InflateSync,The following statement contains a magic number: m != 4
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,D_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((int)(((uint)(dist))  				>> 7))]);
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,D_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((int)(((uint)(dist))  				>> 7))]);
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,D_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((int)(((uint)(dist))  				>> 7))]);
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: tree[s.heap[s.heap_max] * 2 + 1] = 0;
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: tree[n * 2 + 1] = (short)bits;
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: f = tree[n * 2];
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: s.static_len += f * (stree[n * 2 + 1] + xbits);
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: s.bl_count[bits + 1] += 2;
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: overflow -= 2;
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: s.opt_len += (int)(((long)bits - (long)tree[m * 2 + 1]) * (long)tree[m * 2]);
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: s.opt_len += (int)(((long)bits - (long)tree[m * 2 + 1]) * (long)tree[m * 2]);
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: tree[m * 2 + 1] = (short)bits;
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: tree[m * 2 + 1] != bits
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: tree[n * 2] != 0
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: tree[node * 2] = 1;
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: s.static_len -= stree[node * 2 + 1];
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: s.heap_len < 2
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_codes,The following statement contains a magic number: int len = tree[n * 2 + 1];
Magic Number,NSch.ZLib,Tree,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_codes,The following statement contains a magic number: tree[n * 2] = (short)(Bi_reverse(next_code[len]++' len));
Magic Number,NSch.ZLib,ZInputStream,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\ZInputStream.cs,Skip,The following statement contains a magic number: int len = 512;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table = new Deflate.Config[10];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Deflate.Config(4' 4' 8' 4' FAST);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Deflate.Config(4' 4' 8' 4' FAST);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Deflate.Config(4' 4' 8' 4' FAST);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Deflate.Config(4' 4' 8' 4' FAST);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Deflate.Config(4' 5' 16' 8' FAST);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Deflate.Config(4' 5' 16' 8' FAST);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Deflate.Config(4' 5' 16' 8' FAST);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Deflate.Config(4' 5' 16' 8' FAST);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Deflate.Config(4' 5' 16' 8' FAST);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Deflate.Config(4' 6' 32' 32' FAST);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Deflate.Config(4' 6' 32' 32' FAST);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Deflate.Config(4' 6' 32' 32' FAST);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Deflate.Config(4' 6' 32' 32' FAST);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Deflate.Config(4' 6' 32' 32' FAST);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Deflate.Config(4' 4' 16' 16' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Deflate.Config(4' 4' 16' 16' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Deflate.Config(4' 4' 16' 16' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Deflate.Config(4' 4' 16' 16' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Deflate.Config(4' 4' 16' 16' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Deflate.Config(8' 16' 32' 32' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Deflate.Config(8' 16' 32' 32' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Deflate.Config(8' 16' 32' 32' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Deflate.Config(8' 16' 32' 32' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Deflate.Config(8' 16' 32' 32' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Deflate.Config(8' 16' 128' 128' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Deflate.Config(8' 16' 128' 128' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Deflate.Config(8' 16' 128' 128' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Deflate.Config(8' 16' 128' 128' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Deflate.Config(8' 16' 128' 128' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Deflate.Config(8' 32' 128' 256' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Deflate.Config(8' 32' 128' 256' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Deflate.Config(8' 32' 128' 256' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Deflate.Config(8' 32' 128' 256' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Deflate.Config(8' 32' 128' 256' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Deflate.Config(32' 128' 258' 1024' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Deflate.Config(32' 128' 258' 1024' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Deflate.Config(32' 128' 258' 1024' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Deflate.Config(32' 128' 258' 1024' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Deflate.Config(32' 128' 258' 1024' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Deflate.Config(32' 258' 258' 4096' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Deflate.Config(32' 258' 258' 4096' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Deflate.Config(32' 258' 258' 4096' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Deflate.Config(32' 258' 258' 4096' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Deflate.Config(32' 258' 258' 4096' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Lm_init,The following statement contains a magic number: window_size = 2 * w_size;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Tr_init,The following statement contains a magic number: last_eob_len = 8;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Init_block,The following statement contains a magic number: dyn_ltree[i * 2] = 0;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Init_block,The following statement contains a magic number: dyn_dtree[i_1 * 2] = 0;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Init_block,The following statement contains a magic number: bl_tree[i_2 * 2] = 0;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Init_block,The following statement contains a magic number: dyn_ltree[END_BLOCK * 2] = 1;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Smaller,The following statement contains a magic number: short tn2 = tree[n * 2];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Smaller,The following statement contains a magic number: short tm2 = tree[m * 2];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: max_count = 138;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: min_count = 3;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: tree[(max_code + 1) * 2 + 1] = unchecked((short)0xffff);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: nextlen = tree[(n + 1) * 2 + 1];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: max_count = 138;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: min_count = 3;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Build_bl_tree,The following statement contains a magic number: bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Build_bl_tree,The following statement contains a magic number: max_blindex >= 3
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_all_trees,The following statement contains a magic number: Send_bits(lcodes - 257' 5);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_all_trees,The following statement contains a magic number: Send_bits(lcodes - 257' 5);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_all_trees,The following statement contains a magic number: Send_bits(dcodes - 1' 5);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_all_trees,The following statement contains a magic number: Send_bits(blcodes - 4' 4);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_all_trees,The following statement contains a magic number: Send_bits(blcodes - 4' 4);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_all_trees,The following statement contains a magic number: Send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_all_trees,The following statement contains a magic number: Send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: max_count = 138;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: min_count = 3;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: nextlen = tree[(n + 1) * 2 + 1];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: max_count = 138;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: min_count = 3;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Put_short,The following statement contains a magic number: Put_byte(unchecked((byte)((int)(((uint)w) >> 8))));
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,PutShortMSB,The following statement contains a magic number: Put_byte(unchecked((byte)(b >> 8)));
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_code,The following statement contains a magic number: int c2 = c * 2;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: Send_bits(STATIC_TREES << 1' 3);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: Send_bits(STATIC_TREES << 1' 3);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: 1 + last_eob_len + 10 - bi_valid < 9
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: 1 + last_eob_len + 10 - bi_valid < 9
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = unchecked((byte)((int)(((uint)dist) >> 8)));
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = unchecked((byte)((int)(((uint)dist) >> 8)));
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2 + 1] = unchecked((byte)dist);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: dyn_ltree[lc * 2]++;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: int out_length = last_lit * 8;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length += (int)dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length += (int)dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int)(((uint)out_length) >> 3);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: (matches < (last_lit / 2)) && out_length < in_length / 2
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: (matches < (last_lit / 2)) && out_length < in_length / 2
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: (last_lit & unchecked((int)(0x1fff))) == 0 && level > 2
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Compress_block,The following statement contains a magic number: dist = ((pending_buf[d_buf + lx * 2] << 8) & unchecked((int)(0xff00))) | (pending_buf 						[d_buf + lx * 2 + 1] & unchecked((int)(0xff)));
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Compress_block,The following statement contains a magic number: dist = ((pending_buf[d_buf + lx * 2] << 8) & unchecked((int)(0xff00))) | (pending_buf 						[d_buf + lx * 2 + 1] & unchecked((int)(0xff)));
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Compress_block,The following statement contains a magic number: dist = ((pending_buf[d_buf + lx * 2] << 8) & unchecked((int)(0xff00))) | (pending_buf 						[d_buf + lx * 2 + 1] & unchecked((int)(0xff)));
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Compress_block,The following statement contains a magic number: last_eob_len = ltree[END_BLOCK * 2 + 1];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree[n * 2];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Set_data_type,The following statement contains a magic number: n < 7
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Set_data_type,The following statement contains a magic number: ascii_freq += dyn_ltree[n * 2];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Set_data_type,The following statement contains a magic number: n < 128
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree[n * 2];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Set_data_type,The following statement contains a magic number: data_type = unchecked((byte)(bin_freq > ((int)(((uint)ascii_freq) >> 2)) ? Z_BINARY 				 : Z_ASCII));
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Bi_flush,The following statement contains a magic number: bi_valid == 16
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Bi_windup,The following statement contains a magic number: bi_valid > 8
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Copy_block,The following statement contains a magic number: last_eob_len = 8;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_stored,The following statement contains a magic number: max_block_size = pending_buf_size - 5;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_stored,The following statement contains a magic number: max_block_size > pending_buf_size - 5
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_stored_block,The following statement contains a magic number: Send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0)' 3);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (int)(((uint)(opt_len + 3 + 7)) >> 3);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (int)(((uint)(opt_len + 3 + 7)) >> 3);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (int)(((uint)(opt_len + 3 + 7)) >> 3);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (int)(((uint)(static_len + 3 + 7)) >> 3);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (int)(((uint)(static_len + 3 + 7)) >> 3);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (int)(((uint)(static_len + 3 + 7)) >> 3);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: stored_len + 4 <= opt_lenb && buf != -1
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_slow,The following statement contains a magic number: match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && 						 strstart - match_start > 4096))
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_slow,The following statement contains a magic number: match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && 						 strstart - match_start > 4096))
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_slow,The following statement contains a magic number: prev_length -= 2;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Longest_match,The following statement contains a magic number: chain_length >>= 2;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Longest_match,The following statement contains a magic number: scan += 2;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: level = 6;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits 				 < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy >  				Z_HUFFMAN_ONLY
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits 				 < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy >  				Z_HUFFMAN_ONLY
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits 				 < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy >  				Z_HUFFMAN_ONLY
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: hash_bits = memLevel + 7;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: window = new byte[w_size * 2];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: pending_buf = new byte[lit_bufsize * 4];
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: pending_buf_size = lit_bufsize * 4;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: d_buf = lit_bufsize / 2;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: l_buf = (1 + 2) * lit_bufsize;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateParams,The following statement contains a magic number: _level = 6;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateParams,The following statement contains a magic number: _level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: level_flags = 3;
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: level_flags > 3
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: header |= (level_flags << 6);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: header += 31 - (header % 31);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: header += 31 - (header % 31);
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: PutShortMSB((int)((long)(((ulong)strm.adler) >> 16)));
Magic Number,NSch.ZLib,Deflate,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: PutShortMSB((int)((long)(((ulong)strm.adler) >> 16)));
Duplicate Code,NSch,IdentityFile,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\IdentityFile.cs,NewInstance,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (55' 74))
Duplicate Code,NSch,Session,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Session.cs,Run,The method contains a code clone-set at the following line numbers (starting from the method definition): ((100' 119)' (139' 158))
Duplicate Code,NSch.ZLib,Adler32,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Adler32.cs,Adler,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (17' 36)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46))
Duplicate Code,NSch.ZLib,Adler32,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Adler32.cs,Adler,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 43)' (17' 45))
Duplicate Code,NSch.ZLib,Adler32,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\Adler32.cs,Adler,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46))
Duplicate Code,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((33' 53)' (282' 302))
Duplicate Code,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((71' 92)' (174' 195))
Duplicate Code,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((72' 91)' (141' 160))
Duplicate Code,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((72' 91)' (141' 160)' (175' 194)' (231' 250))
Duplicate Code,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((72' 91)' (231' 250)' (141' 160)' (175' 194))
Duplicate Code,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((140' 159)' (230' 249))
Duplicate Code,NSch.ZLib,InfCodes,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((270' 299)' (315' 344))
Missing Default,NSch,DHG1,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following switch statement is missing a default case: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Missing Default,NSch,DHGEX,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following switch statement is missing a default case: switch (state) 			{ 				case SSH_MSG_KEX_DH_GEX_GROUP: 				{ 					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31) 					// mpint p' safe prime 					// mpint g' generator for subgroup in GF (p) 					_buf.GetInt(); 					_buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_GROUP) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j); 						return false; 					} 					p = _buf.GetMPInt(); 					g = _buf.GetMPInt(); 					dh.SetP(p); 					dh.SetG(g); 					// The client responds with: 					// byte  SSH_MSG_KEX_DH_GEX_INIT(32) 					// mpint e <- g^x mod p 					//         x is a random number (1 < x < (p-1)/2) 					e = dh.GetE(); 					packet.Reset(); 					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT)); 					buf.PutMPInt(e); 					session.Write(packet); 					if (JSch.GetLogger().IsEnabled(Logger.INFO)) 					{ 						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent"); 						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY"); 					} 					state = SSH_MSG_KEX_DH_GEX_REPLY; 					return true; 				}  				case SSH_MSG_KEX_DH_GEX_REPLY: 				{ 					//break; 					// The server responds with: 					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != SSH_MSG_KEX_DH_GEX_REPLY) 					{ 						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// uint32    min' minimal size in bits of an acceptable group 					// uint32   n' preferred size in bits of the group the server should send 					// uint32    max' maximal size in bits of an acceptable group 					// mpint     p' safe prime 					// mpint     g' generator for subgroup 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutInt(min); 					buf.PutInt(preferred); 					buf.PutInt(max); 					buf.PutMPInt(p); 					buf.PutMPInt(g); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					// System.err.print("H -> "); dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						//	SignatureRSA sig=new SignatureRSA(); 						//	sig.init(); 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							//	SignatureDSA sig=new SignatureDSA(); 							//	sig.init(); 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Missing Default,NSch,DHG14,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following switch statement is missing a default case: switch (state) 			{ 				case SSH_MSG_KEXDH_REPLY: 				{ 					// The server responds with: 					// byte      SSH_MSG_KEXDH_REPLY(31) 					// string    server public host key and certificates (K_S) 					// mpint     f 					// string    signature of H 					j = _buf.GetInt(); 					j = _buf.GetByte(); 					j = _buf.GetByte(); 					if (j != 31) 					{ 						System.Console.Error.WriteLine("type: must be 31 " + j); 						return false; 					} 					K_S = _buf.GetString(); 					// K_S is server_key_blob' which includes .... 					// string ssh-dss 					// impint p of dsa 					// impint q of dsa 					// impint g of dsa 					// impint pub_key of dsa 					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length); 					byte[] f = _buf.GetMPInt(); 					byte[] sig_of_H = _buf.GetString(); 					dh.SetF(f); 					K = dh.GetK(); 					//The hash H is computed as the HASH hash of the concatenation of the 					//following: 					// string    V_C' the client's version string (CR and NL excluded) 					// string    V_S' the server's version string (CR and NL excluded) 					// string    I_C' the payload of the client's SSH_MSG_KEXINIT 					// string    I_S' the payload of the server's SSH_MSG_KEXINIT 					// string    K_S' the host key 					// mpint     e' exchange value sent by the client 					// mpint     f' exchange value sent by the server 					// mpint     K' the shared secret 					// This value is called the exchange hash' and it is used to authenti- 					// cate the key exchange. 					buf.Reset(); 					buf.PutString(V_C); 					buf.PutString(V_S); 					buf.PutString(I_C); 					buf.PutString(I_S); 					buf.PutString(K_S); 					buf.PutMPInt(e); 					buf.PutMPInt(f); 					buf.PutMPInt(K); 					byte[] foo = new byte[buf.GetLength()]; 					buf.GetByte(foo); 					sha.Update(foo' 0' foo.Length); 					H = sha.Digest(); 					//System.err.print("H -> "); //dump(H' 0' H.length); 					i = 0; 					j = 0; 					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 						++]) & unchecked((int)(0x000000ff))); 					string alg = Util.Byte2str(K_S' i' j); 					i += j; 					bool result = false; 					if (alg.Equals("ssh-rsa")) 					{ 						byte[] tmp; 						byte[] ee; 						byte[] n; 						type = RSA; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						ee = tmp; 						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 							++]) & unchecked((int)(0x000000ff))); 						tmp = new byte[j]; 						System.Array.Copy(K_S' i' tmp' 0' j); 						i += j; 						n = tmp; 						NSch.SignatureRSA sig = null; 						try 						{ 							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa")); 							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c)); 							sig.Init(); 						} 						catch (Exception ex) 						{ 							System.Console.Error.WriteLine(ex); 						} 						sig.SetPubKey(ee' n); 						sig.Update(H); 						result = sig.Verify(sig_of_H); 						if (JSch.GetLogger().IsEnabled(Logger.INFO)) 						{ 							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result); 						} 					} 					else 					{ 						if (alg.Equals("ssh-dss")) 						{ 							byte[] q = null; 							byte[] tmp; 							byte[] p; 							byte[] g; 							type = DSS; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							p = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							q = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							g = tmp; 							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked( 								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i 								++]) & unchecked((int)(0x000000ff))); 							tmp = new byte[j]; 							System.Array.Copy(K_S' i' tmp' 0' j); 							i += j; 							f = tmp; 							NSch.SignatureDSA sig = null; 							try 							{ 								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss")); 								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c)); 								sig.Init(); 							} 							catch (Exception ex) 							{ 								System.Console.Error.WriteLine(ex); 							} 							sig.SetPubKey(f' p' q' g); 							sig.Update(H); 							result = sig.Verify(sig_of_H); 							if (JSch.GetLogger().IsEnabled(Logger.INFO)) 							{ 								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result); 							} 						} 						else 						{ 							System.Console.Error.WriteLine("unknown alg"); 						} 					} 					state = STATE_END; 					return result; 				} 			}
Missing Default,NSch.ZLib,InfBlocks,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following switch statement is missing a default case: switch ((int)(((uint)t) >> 1)) 						{ 							case 0: 							{ 								// stored  								b = (int)(((uint)b) >> (3)); 								k -= (3); 								t = k & 7; 								// go to byte boundary 								b = (int)(((uint)b) >> (t)); 								k -= (t); 								mode = LENS; 								// get length of stored block 								break; 							}  							case 1: 							{ 								// fixed 								int[] bl = new int[1]; 								int[] bd = new int[1]; 								int[][] tl = new int[1][]; 								int[][] td = new int[1][]; 								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z); 								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z); 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = CODES; 								break; 							}  							case 2: 							{ 								// dynamic 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = TABLE; 								break; 							}  							case 3: 							{ 								// illegal 								b = (int)(((uint)b) >> (3)); 								k -= (3); 								mode = BAD; 								z.msg = "invalid block type"; 								r = Z_DATA_ERROR; 								bitb = b; 								bitk = k; 								z.avail_in = n; 								z.total_in += p - z.next_in_index; 								z.next_in_index = p; 								write = q; 								return Inflate_flush(z' r); 							} 						}
Missing Default,Sharpen,Cipher,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Sharpen\Cipher.cs,GetInstance,The following switch statement is missing a default case: switch (name) { 			case "RC4": return new R4Cipher (); 			case "AES/CBC/NoPadding": return new AesCipher (CipherMode.CBC); 			case "AES/CTR/NoPadding": throw new NotSupportedException (); 			case "Blowfish/CBC/NoPadding": return new BlowfishCipher (CipherMode.CBC); 			case "DESede/CBC/NoPadding": return new DESedeCipher (CipherMode.CBC); 			case "DESede/CTR/NoPadding": throw new NotSupportedException (); 			}
Missing Default,Sharpen,KeyPairGenerator,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Sharpen\KeyPairGenerator.cs,GetInstance,The following switch statement is missing a default case: switch (name.ToUpper ()) { 			case "DH": return new DHKeyPairGenerator (); 			case "DSA": return new DSAKeyPairGenerator (); 			case "RSA": return new RSAKeyPairGenerator (); 			}
Missing Default,Sharpen,Mac,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Sharpen\Mac.cs,GetInstance,The following switch statement is missing a default case: switch (name.ToUpper ()) { 			case "HMACMD5": m.mac = new HMACMD5 (); break; 			case "HMACSHA1": m.mac = new HMACSHA1 (); break; 			}
Missing Default,Sharpen,KeyFactory,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Sharpen\KeyFactory.cs,GetInstance,The following switch statement is missing a default case: switch (id.ToUpper ()) { 			case "DSA": return new DSAKeyFactory (); 			case "DH": return new DHKeyFactory (); 			case "RSA": return new RSAKeyFactory (); 			}
Missing Default,Sharpen,Signature,C:\research\architectureSmells\repos\mono_ngit\NSch\NSch\Sharpen\Signature.cs,GetInstance,The following switch statement is missing a default case: switch (id) { 			case "SHA1withDSA": return new SHA1withDSASignature (); 			case "SHA1withRSA": return new SHA1withRSASignature (); 			}
