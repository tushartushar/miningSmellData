Implementation smell,Namespace,Class,File,Method,Description
Long Method,NGit,Config,C:\repos\mono_ngit\NGit\NGit\Config.cs,ReadValue,The method has 107 lines of code.
Long Method,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,IsModified,The method has 123 lines of code.
Long Method,NGit,IndexDiff,C:\repos\mono_ngit\NGit\NGit\IndexDiff.cs,Diff,The method has 121 lines of code.
Long Method,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,Resolve,The method has 451 lines of code.
Long Method,NGit.Api,AddCommand,C:\repos\mono_ngit\NGit\NGit.Api\AddCommand.cs,Call,The method has 116 lines of code.
Long Method,NGit.Api,CommitCommand,C:\repos\mono_ngit\NGit\NGit.Api\CommitCommand.cs,Call,The method has 171 lines of code.
Long Method,NGit.Api,CommitCommand,C:\repos\mono_ngit\NGit\NGit.Api\CommitCommand.cs,CreateTemporaryIndex,The method has 140 lines of code.
Long Method,NGit.Api,MergeCommand,C:\repos\mono_ngit\NGit\NGit.Api\MergeCommand.cs,Call,The method has 197 lines of code.
Long Method,NGit.Api,PullCommand,C:\repos\mono_ngit\NGit\NGit.Api\PullCommand.cs,Call,The method has 154 lines of code.
Long Method,NGit.Api,CreateBranchCommand,C:\repos\mono_ngit\NGit\NGit.Api\CreateBranchCommand.cs,Call,The method has 203 lines of code.
Long Method,NGit.Api,RenameBranchCommand,C:\repos\mono_ngit\NGit\NGit.Api\RenameBranchCommand.cs,Call,The method has 104 lines of code.
Long Method,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,Call,The method has 152 lines of code.
Long Method,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,InitFilesAndRewind,The method has 111 lines of code.
Long Method,NGit.Api,CheckoutCommand,C:\repos\mono_ngit\NGit\NGit.Api\CheckoutCommand.cs,Call,The method has 128 lines of code.
Long Method,NGit.Api,ResetCommand,C:\repos\mono_ngit\NGit\NGit.Api\ResetCommand.cs,Call,The method has 122 lines of code.
Long Method,NGit.Api,StashCreateCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashCreateCommand.cs,Call,The method has 124 lines of code.
Long Method,NGit.Diff,RenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\RenameDetector.cs,FindExactRenames,The method has 184 lines of code.
Long Method,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,BuildMatrix,The method has 112 lines of code.
Long Method,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The method has 105 lines of code.
Long Method,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,ProcessEntry,The method has 348 lines of code.
Long Method,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,IsValidPathSegment,The method has 116 lines of code.
Long Method,NGit.Fnmatch,GroupHead,C:\repos\mono_ngit\NGit\NGit.Fnmatch\GroupHead.cs,GroupHead,The method has 135 lines of code.
Long Method,NGit.Merge,MergeAlgorithm,C:\repos\mono_ngit\NGit\NGit.Merge\MergeAlgorithm.cs,Merge,The method has 242 lines of code.
Long Method,NGit.Merge,ResolveMerger,C:\repos\mono_ngit\NGit\NGit.Merge\ResolveMerger.cs,ProcessEntry,The method has 223 lines of code.
Long Method,NGit.Patch,FileHeader,C:\repos\mono_ngit\NGit\NGit.Patch\FileHeader.cs,ParseGitHeaders,The method has 131 lines of code.
Long Method,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,NextObject,The method has 116 lines of code.
Long Method,NGit.Revwalk,RewriteTreeFilter,C:\repos\mono_ngit\NGit\NGit.Revwalk\RewriteTreeFilter.cs,Include,The method has 152 lines of code.
Long Method,NGit.Revwalk,StartGenerator,C:\repos\mono_ngit\NGit\NGit.Revwalk\StartGenerator.cs,Next,The method has 116 lines of code.
Long Method,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,CopyAsIs2,The method has 220 lines of code.
Long Method,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Load,The method has 165 lines of code.
Long Method,NGit.Storage.File,RefDirectoryRename,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectoryRename.cs,DoRename,The method has 114 lines of code.
Long Method,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Open,The method has 105 lines of code.
Long Method,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,Prune,The method has 186 lines of code.
Long Method,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,WritePack,The method has 113 lines of code.
Long Method,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Apply,The method has 109 lines of code.
Long Method,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,Encode,The method has 122 lines of code.
Long Method,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,SearchForDeltas,The method has 133 lines of code.
Long Method,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,SearchForDeltas,The method has 147 lines of code.
Long Method,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,FindObjectsToPack,The method has 287 lines of code.
Long Method,NGit.Util,GitPathStyle,C:\repos\mono_ngit\NGit\NGit.Util\QuotedString.cs,Dq,The method has 106 lines of code.
Long Method,NGit.Util,GitDateParser,C:\repos\mono_ngit\NGit\NGit.Util\GitDateParser.cs,Parse_relative,The method has 102 lines of code.
Long Method,NGit.Transport,FetchProcess,C:\repos\mono_ngit\NGit\NGit.Transport\FetchProcess.cs,ExecuteImp,The method has 146 lines of code.
Long Method,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,Negotiate,The method has 184 lines of code.
Long Method,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,ProcessHaveLines,The method has 208 lines of code.
Long Method,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,SendPack,The method has 157 lines of code.
Long Method,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,DownloadObject,The method has 109 lines of code.
Long Method,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,DownloadPackedObject,The method has 106 lines of code.
Long Method,NGit.Transport,OpenSshConfig,C:\repos\mono_ngit\NGit\NGit.Transport\OpenSshConfig.cs,Parse,The method has 139 lines of code.
Long Method,NGit.Transport,TransportHttp,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,Connect,The method has 100 lines of code.
Long Method,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,ValidateCommands,The method has 133 lines of code.
Long Method,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,SendStatusReport,The method has 112 lines of code.
Long Method,NGit.Blame,BlameGenerator,C:\repos\mono_ngit\NGit\NGit.Blame\BlameGenerator.cs,ProcessMerge,The method has 210 lines of code.
Complex Method,NGit,BaseRepositoryBuilder<B;R>,C:\repos\mono_ngit\NGit\NGit\BaseRepositoryBuilder.cs,ReadEnvironment,Cyclomatic complexity of the method is 15
Complex Method,NGit,Config,C:\repos\mono_ngit\NGit\NGit\Config.cs,ReplaceStringList,Cyclomatic complexity of the method is 10
Complex Method,NGit,Config,C:\repos\mono_ngit\NGit\NGit\Config.cs,ToText,Cyclomatic complexity of the method is 8
Complex Method,NGit,Config,C:\repos\mono_ngit\NGit\NGit\Config.cs,ReadSectionName,Cyclomatic complexity of the method is 10
Complex Method,NGit,Config,C:\repos\mono_ngit\NGit\NGit\Config.cs,ReadKeyName,Cyclomatic complexity of the method is 11
Complex Method,NGit,Config,C:\repos\mono_ngit\NGit\NGit\Config.cs,ReadValue,Cyclomatic complexity of the method is 15
Complex Method,NGit,GitIndex,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,NGit,GitIndex,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,WriteTree,Cyclomatic complexity of the method is 8
Complex Method,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,IsModified,Cyclomatic complexity of the method is 11
Complex Method,NGit,IndexDiff,C:\repos\mono_ngit\NGit\NGit\IndexDiff.cs,Diff,Cyclomatic complexity of the method is 15
Complex Method,NGit,ObjectChecker,C:\repos\mono_ngit\NGit\NGit\ObjectChecker.cs,CheckCommit,Cyclomatic complexity of the method is 9
Complex Method,NGit,ObjectChecker,C:\repos\mono_ngit\NGit\NGit\ObjectChecker.cs,DuplicateName,Cyclomatic complexity of the method is 10
Complex Method,NGit,ObjectChecker,C:\repos\mono_ngit\NGit\NGit\ObjectChecker.cs,CheckTree,Cyclomatic complexity of the method is 20
Complex Method,NGit,RefUpdate,C:\repos\mono_ngit\NGit\NGit\RefUpdate.cs,Link,Cyclomatic complexity of the method is 8
Complex Method,NGit,RefUpdate,C:\repos\mono_ngit\NGit\NGit\RefUpdate.cs,UpdateImpl,Cyclomatic complexity of the method is 10
Complex Method,NGit,RefWriter,C:\repos\mono_ngit\NGit\NGit\RefWriter.cs,WritePackedRefs,Cyclomatic complexity of the method is 8
Complex Method,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,Resolve,Cyclomatic complexity of the method is 8
Complex Method,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,GetRepositoryState,Cyclomatic complexity of the method is 14
Complex Method,NGit,Tree,C:\repos\mono_ngit\NGit\NGit\Tree.cs,CompareNames,Cyclomatic complexity of the method is 9
Complex Method,NGit,Tree,C:\repos\mono_ngit\NGit\NGit\Tree.cs,ReadTree,Cyclomatic complexity of the method is 9
Complex Method,NGit.Api,CommitCommand,C:\repos\mono_ngit\NGit\NGit.Api\CommitCommand.cs,Call,Cyclomatic complexity of the method is 14
Complex Method,NGit.Api,CommitCommand,C:\repos\mono_ngit\NGit\NGit.Api\CommitCommand.cs,CreateTemporaryIndex,Cyclomatic complexity of the method is 12
Complex Method,NGit.Api,MergeCommandResult,C:\repos\mono_ngit\NGit\NGit.Api\MergeCommandResult.cs,AddConflict,Cyclomatic complexity of the method is 11
Complex Method,NGit.Api,PushCommand,C:\repos\mono_ngit\NGit\NGit.Api\PushCommand.cs,Call,Cyclomatic complexity of the method is 8
Complex Method,NGit.Api,PullCommand,C:\repos\mono_ngit\NGit\NGit.Api\PullCommand.cs,Call,Cyclomatic complexity of the method is 15
Complex Method,NGit.Api,CreateBranchCommand,C:\repos\mono_ngit\NGit\NGit.Api\CreateBranchCommand.cs,Call,Cyclomatic complexity of the method is 15
Complex Method,NGit.Api,DeleteBranchCommand,C:\repos\mono_ngit\NGit\NGit.Api\DeleteBranchCommand.cs,Call,Cyclomatic complexity of the method is 14
Complex Method,NGit.Api,RenameBranchCommand,C:\repos\mono_ngit\NGit\NGit.Api\RenameBranchCommand.cs,Call,Cyclomatic complexity of the method is 14
Complex Method,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,Call,Cyclomatic complexity of the method is 13
Complex Method,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,PopSteps,Cyclomatic complexity of the method is 11
Complex Method,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,InitFilesAndRewind,Cyclomatic complexity of the method is 8
Complex Method,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,ParseAuthor,Cyclomatic complexity of the method is 8
Complex Method,NGit.Api,CheckoutCommand,C:\repos\mono_ngit\NGit\NGit.Api\CheckoutCommand.cs,Call,Cyclomatic complexity of the method is 10
Complex Method,NGit.Api,ResetCommand,C:\repos\mono_ngit\NGit\NGit.Api\ResetCommand.cs,Call,Cyclomatic complexity of the method is 8
Complex Method,NGit.Api,SubmoduleInitCommand,C:\repos\mono_ngit\NGit\NGit.Api\SubmoduleInitCommand.cs,Call,Cyclomatic complexity of the method is 8
Complex Method,NGit.Api,SubmoduleSyncCommand,C:\repos\mono_ngit\NGit\NGit.Api\SubmoduleSyncCommand.cs,Call,Cyclomatic complexity of the method is 8
Complex Method,NGit.Api,SubmoduleUpdateCommand,C:\repos\mono_ngit\NGit\NGit.Api\SubmoduleUpdateCommand.cs,Call,Cyclomatic complexity of the method is 8
Complex Method,NGit.Api,ApplyCommand,C:\repos\mono_ngit\NGit\NGit.Api\ApplyCommand.cs,Apply,Cyclomatic complexity of the method is 12
Complex Method,NGit.Api,StashDropCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashDropCommand.cs,Call,Cyclomatic complexity of the method is 9
Complex Method,NGit.Diff,EditPaths,C:\repos\mono_ngit\NGit\NGit.Diff\MyersDiff.cs,Calculate,Cyclomatic complexity of the method is 8
Complex Method,NGit.Diff,RenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\RenameDetector.cs,FindExactRenames,Cyclomatic complexity of the method is 15
Complex Method,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,BuildMatrix,Cyclomatic complexity of the method is 12
Complex Method,NGit.Diff,HistogramDiffIndex<S>,C:\repos\mono_ngit\NGit\NGit.Diff\HistogramDiffIndex.cs,TryLongestCommonSequence,Cyclomatic complexity of the method is 15
Complex Method,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,Cyclomatic complexity of the method is 9
Complex Method,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,UpdateSmudgedEntries,Cyclomatic complexity of the method is 8
Complex Method,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,DoCheckout,Cyclomatic complexity of the method is 12
Complex Method,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,ProcessEntry,Cyclomatic complexity of the method is 16
Complex Method,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,CheckoutEntry,Cyclomatic complexity of the method is 8
Complex Method,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,IsValidPathSegment,Cyclomatic complexity of the method is 19
Complex Method,NGit.Dircache,DirCacheEditor,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEditor.cs,ApplyEdits,Cyclomatic complexity of the method is 9
Complex Method,NGit.Dircache,DirCacheTree,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheTree.cs,Validate,Cyclomatic complexity of the method is 9
Complex Method,NGit.Ignore,IgnoreRule,C:\repos\mono_ngit\NGit\NGit.Ignore\IgnoreRule.cs,IsMatch,Cyclomatic complexity of the method is 9
Complex Method,NGit.Merge,MergeAlgorithm,C:\repos\mono_ngit\NGit\NGit.Merge\MergeAlgorithm.cs,Merge,Cyclomatic complexity of the method is 8
Complex Method,NGit.Merge,ResolveMerger,C:\repos\mono_ngit\NGit\NGit.Merge\ResolveMerger.cs,MergeImpl,Cyclomatic complexity of the method is 9
Complex Method,NGit.Merge,ResolveMerger,C:\repos\mono_ngit\NGit\NGit.Merge\ResolveMerger.cs,ProcessEntry,Cyclomatic complexity of the method is 22
Complex Method,NGit.Merge,MergeMessageFormatter,C:\repos\mono_ngit\NGit\NGit.Merge\MergeMessageFormatter.cs,Format,Cyclomatic complexity of the method is 9
Complex Method,NGit.Patch,CombinedHunkHeader,C:\repos\mono_ngit\NGit\NGit.Patch\CombinedHunkHeader.cs,ParseBody,Cyclomatic complexity of the method is 11
Complex Method,NGit.Patch,CombinedHunkHeader,C:\repos\mono_ngit\NGit\NGit.Patch\CombinedHunkHeader.cs,ExtractFileLines,Cyclomatic complexity of the method is 8
Complex Method,NGit.Patch,CombinedHunkHeader,C:\repos\mono_ngit\NGit\NGit.Patch\CombinedHunkHeader.cs,ExtractFileLines,Cyclomatic complexity of the method is 8
Complex Method,NGit.Patch,FileHeader,C:\repos\mono_ngit\NGit\NGit.Patch\FileHeader.cs,ParseGitFileName,Cyclomatic complexity of the method is 9
Complex Method,NGit.Patch,Patch,C:\repos\mono_ngit\NGit\NGit.Patch\Patch.cs,ParseFile,Cyclomatic complexity of the method is 11
Complex Method,NGit.Patch,Patch,C:\repos\mono_ngit\NGit\NGit.Patch\Patch.cs,ParseHunks,Cyclomatic complexity of the method is 13
Complex Method,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,Cyclomatic complexity of the method is 9
Complex Method,NGit.Revplot,PlotCommitList<L>,C:\repos\mono_ngit\NGit\NGit.Revplot\PlotCommitList.cs,HandleBlockedLanes,Cyclomatic complexity of the method is 10
Complex Method,NGit.Revwalk,InitialGenerator,C:\repos\mono_ngit\NGit\NGit.Revwalk\BoundaryGenerator.cs,Next,Cyclomatic complexity of the method is 8
Complex Method,NGit.Revwalk,MergeBaseGenerator,C:\repos\mono_ngit\NGit\NGit.Revwalk\MergeBaseGenerator.cs,Next,Cyclomatic complexity of the method is 10
Complex Method,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,NextObject,Cyclomatic complexity of the method is 10
Complex Method,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,FindObjectId,Cyclomatic complexity of the method is 18
Complex Method,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ParseMode,Cyclomatic complexity of the method is 9
Complex Method,NGit.Revwalk,PendingGenerator,C:\repos\mono_ngit\NGit\NGit.Revwalk\PendingGenerator.cs,Next,Cyclomatic complexity of the method is 12
Complex Method,NGit.Revwalk,RevCommit,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommit.cs,ParseCanonical,Cyclomatic complexity of the method is 8
Complex Method,NGit.Revwalk,RevCommit,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommit.cs,GetFooterLines,Cyclomatic complexity of the method is 8
Complex Method,NGit.Revwalk,RevCommitList<E>,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommitList.cs,FillTo,Cyclomatic complexity of the method is 9
Complex Method,NGit.Revwalk,RevCommitList<E>,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommitList.cs,FillTo,Cyclomatic complexity of the method is 9
Complex Method,NGit.Revwalk,RevWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevWalk.cs,Reset,Cyclomatic complexity of the method is 8
Complex Method,NGit.Revwalk,RewriteGenerator,C:\repos\mono_ngit\NGit\NGit.Revwalk\RewriteGenerator.cs,Cleanup,Cyclomatic complexity of the method is 8
Complex Method,NGit.Revwalk,RewriteTreeFilter,C:\repos\mono_ngit\NGit\NGit.Revwalk\RewriteTreeFilter.cs,Include,Cyclomatic complexity of the method is 16
Complex Method,NGit.Revwalk,StartGenerator,C:\repos\mono_ngit\NGit\NGit.Revwalk\StartGenerator.cs,Next,Cyclomatic complexity of the method is 12
Complex Method,NGit.Revwalk,DepthGenerator,C:\repos\mono_ngit\NGit\NGit.Revwalk\DepthGenerator.cs,Next,Cyclomatic complexity of the method is 10
Complex Method,NGit.Revwalk,RevWalkUtils,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevWalkUtils.cs,FindBranchesReachableFrom,Cyclomatic complexity of the method is 8
Complex Method,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,ScanCachedPacks,Cyclomatic complexity of the method is 8
Complex Method,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,Resolve,Cyclomatic complexity of the method is 13
Complex Method,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,ScanPacksImpl,Cyclomatic complexity of the method is 8
Complex Method,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,CopyAsIs2,Cyclomatic complexity of the method is 8
Complex Method,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,PackIndexV2,Cyclomatic complexity of the method is 12
Complex Method,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,Pack,Cyclomatic complexity of the method is 11
Complex Method,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,ParsePackedRefs,Cyclomatic complexity of the method is 9
Complex Method,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,ReadRef,Cyclomatic complexity of the method is 10
Complex Method,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,ScanRef,Cyclomatic complexity of the method is 11
Complex Method,NGit.Storage.File,RefDirectoryRename,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectoryRename.cs,DoRename,Cyclomatic complexity of the method is 13
Complex Method,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Open,Cyclomatic complexity of the method is 8
Complex Method,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,WindowCache,Cyclomatic complexity of the method is 8
Complex Method,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,Evict,Cyclomatic complexity of the method is 8
Complex Method,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,RenameAndOpenPack,Cyclomatic complexity of the method is 10
Complex Method,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,PrunePacked,Cyclomatic complexity of the method is 10
Complex Method,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,Prune,Cyclomatic complexity of the method is 28
Complex Method,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,Repack,Cyclomatic complexity of the method is 11
Complex Method,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,WritePack,Cyclomatic complexity of the method is 9
Complex Method,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,GetStatistics,Cyclomatic complexity of the method is 11
Complex Method,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Apply,Cyclomatic complexity of the method is 13
Complex Method,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Format,Cyclomatic complexity of the method is 12
Complex Method,NGit.Storage.Pack,DeltaEncoder,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaEncoder.cs,EncodeCopy,Cyclomatic complexity of the method is 9
Complex Method,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,Encode,Cyclomatic complexity of the method is 10
Complex Method,NGit.Storage.Pack,DeltaStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaStream.cs,Next,Cyclomatic complexity of the method is 11
Complex Method,NGit.Storage.Pack,DeltaWindow,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaWindow.cs,Delta,Cyclomatic complexity of the method is 9
Complex Method,NGit.Storage.Pack,ObjectToPack,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\ObjectToPack.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,WritePack,Cyclomatic complexity of the method is 13
Complex Method,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,SearchForDeltas,Cyclomatic complexity of the method is 12
Complex Method,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,SearchForDeltas,Cyclomatic complexity of the method is 11
Complex Method,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,FindObjectsToPack,Cyclomatic complexity of the method is 36
Complex Method,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,Select,Cyclomatic complexity of the method is 8
Complex Method,NGit.Storage.Pack,BaseSearch,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BaseSearch.cs,AddBase,Cyclomatic complexity of the method is 12
Complex Method,NGit.Treewalk,NameConflictTreeWalk,C:\repos\mono_ngit\NGit\NGit.Treewalk\NameConflictTreeWalk.cs,FastMin,Cyclomatic complexity of the method is 8
Complex Method,NGit.Treewalk,NameConflictTreeWalk,C:\repos\mono_ngit\NGit\NGit.Treewalk\NameConflictTreeWalk.cs,CombineDF,Cyclomatic complexity of the method is 10
Complex Method,NGit.Treewalk,TreeWalk,C:\repos\mono_ngit\NGit\NGit.Treewalk\TreeWalk.cs,Next,Cyclomatic complexity of the method is 8
Complex Method,NGit.Treewalk,WorkingTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\WorkingTreeIterator.cs,Init,Cyclomatic complexity of the method is 8
Complex Method,NGit.Treewalk.Filter,IndexDiffFilter,C:\repos\mono_ngit\NGit\NGit.Treewalk.Filter\IndexDiffFilter.cs,Include,Cyclomatic complexity of the method is 15
Complex Method,NGit.Util,ChangeIdUtil,C:\repos\mono_ngit\NGit\NGit.Util\ChangeIdUtil.cs,InsertId,Cyclomatic complexity of the method is 13
Complex Method,NGit.Util,FS,C:\repos\mono_ngit\NGit\NGit.Util\FS.cs,ReadPipe,Cyclomatic complexity of the method is 9
Complex Method,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,RawParseUtils,Cyclomatic complexity of the method is 8
Complex Method,NGit.Util,IOUtil,C:\repos\mono_ngit\NGit\NGit.Util\IOUtil.cs,ReadFully,Cyclomatic complexity of the method is 8
Complex Method,NGit.Util,FileUtils,C:\repos\mono_ngit\NGit\NGit.Util\FileUtils.cs,Delete,Cyclomatic complexity of the method is 10
Complex Method,NGit.Util,RelativeDateFormatter,C:\repos\mono_ngit\NGit\NGit.Util\RelativeDateFormatter.cs,Format,Cyclomatic complexity of the method is 9
Complex Method,NGit.Util.IO,EolCanonicalizingInputStream,C:\repos\mono_ngit\NGit\NGit.Util.IO\EolCanonicalizingInputStream.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,NGit.Util.IO,AutoCRLFOutputStream,C:\repos\mono_ngit\NGit\NGit.Util.IO\AutoCRLFOutputStream.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,Cyclomatic complexity of the method is 8
Complex Method,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,Format,Cyclomatic complexity of the method is 12
Complex Method,NGit.Transport,FetchProcess,C:\repos\mono_ngit\NGit\NGit.Transport\FetchProcess.cs,ExecuteImp,Cyclomatic complexity of the method is 21
Complex Method,NGit.Transport,FetchProcess,C:\repos\mono_ngit\NGit\NGit.Transport\FetchProcess.cs,ExpandAutoFollowTags,Cyclomatic complexity of the method is 8
Complex Method,NGit.Transport,PushProcess,C:\repos\mono_ngit\NGit\NGit.Transport\PushProcess.cs,PrepareRemoteUpdates,Cyclomatic complexity of the method is 8
Complex Method,NGit.Transport,BasePackConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackConnection.cs,ReadAdvertisedRefsImpl,Cyclomatic complexity of the method is 9
Complex Method,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,MarkReachable,Cyclomatic complexity of the method is 10
Complex Method,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,EnableCapabilities,Cyclomatic complexity of the method is 8
Complex Method,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,Negotiate,Cyclomatic complexity of the method is 19
Complex Method,NGit.Transport,BasePackPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackPushConnection.cs,ReadStatusReport,Cyclomatic complexity of the method is 10
Complex Method,NGit.Transport,BundleFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BundleFetchConnection.cs,VerifyPrerequisites,Cyclomatic complexity of the method is 12
Complex Method,NGit.Transport,ReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\ReceivePack.cs,Service,Cyclomatic complexity of the method is 9
Complex Method,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,ProcessHaveLines,Cyclomatic complexity of the method is 27
Complex Method,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,SendPack,Cyclomatic complexity of the method is 21
Complex Method,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,DownloadObject,Cyclomatic complexity of the method is 17
Complex Method,NGit.Transport,WalkRemoteObjectDatabase,C:\repos\mono_ngit\NGit\NGit.Transport\WalkRemoteObjectDatabase.cs,ReadPackedRefsImpl,Cyclomatic complexity of the method is 9
Complex Method,NGit.Transport,WalkPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkPushConnection.cs,Push,Cyclomatic complexity of the method is 9
Complex Method,NGit.Transport,OpenSshConfig,C:\repos\mono_ngit\NGit\NGit.Transport\OpenSshConfig.cs,Lookup,Cyclomatic complexity of the method is 9
Complex Method,NGit.Transport,OpenSshConfig,C:\repos\mono_ngit\NGit\NGit.Transport\OpenSshConfig.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,NGit.Transport,Host,C:\repos\mono_ngit\NGit\NGit.Transport\OpenSshConfig.cs,CopyFrom,Cyclomatic complexity of the method is 8
Complex Method,NGit.Transport,Digest,C:\repos\mono_ngit\NGit\NGit.Transport\HttpAuthMethod.cs,ConfigureRequest,Cyclomatic complexity of the method is 9
Complex Method,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,Parse,Cyclomatic complexity of the method is 12
Complex Method,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ResolveDeltasWithExternalBases,Cyclomatic complexity of the method is 9
Complex Method,NGit.Transport,TransportProtocol,C:\repos\mono_ngit\NGit\NGit.Transport\TransportProtocol.cs,CanHandle,Cyclomatic complexity of the method is 9
Complex Method,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,CheckConnectivity,Cyclomatic complexity of the method is 21
Complex Method,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,ValidateCommands,Cyclomatic complexity of the method is 16
Complex Method,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,SendStatusReport,Cyclomatic complexity of the method is 11
Complex Method,NGit.Transport.Resolver,FileResolver<C>,C:\repos\mono_ngit\NGit\NGit.Transport.Resolver\FileResolver.cs,IsUnreasonableName,Cyclomatic complexity of the method is 8
Complex Method,NGit.Blame,BlameGenerator,C:\repos\mono_ngit\NGit\NGit.Blame\BlameGenerator.cs,Next,Cyclomatic complexity of the method is 9
Complex Method,NGit.Blame,BlameGenerator,C:\repos\mono_ngit\NGit\NGit.Blame\BlameGenerator.cs,ProcessOne,Cyclomatic complexity of the method is 8
Complex Method,NGit.Blame,BlameGenerator,C:\repos\mono_ngit\NGit\NGit.Blame\BlameGenerator.cs,ProcessMerge,Cyclomatic complexity of the method is 33
Complex Method,NGit.Blame,Candidate,C:\repos\mono_ngit\NGit\NGit.Blame\Candidate.cs,Blame,Cyclomatic complexity of the method is 11
Complex Method,NGit.Submodule,SubmoduleWalk,C:\repos\mono_ngit\NGit\NGit.Submodule\SubmoduleWalk.cs,GetSubmoduleRemoteUrl,Cyclomatic complexity of the method is 10
Long Parameter List,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,AbbreviatedObjectId,The method has 6 parameters. Parameters: n' new_1' new_2' new_3' new_4' new_5
Long Parameter List,NGit,Config,C:\repos\mono_ngit\NGit\NGit\Config.cs,GetEnum,The method has 5 parameters. Parameters: all' section' subsection' name' defaultValue
Long Parameter List,NGit,Config,C:\repos\mono_ngit\NGit\NGit\Config.cs,ReplaceStringList,The method has 5 parameters. Parameters: srcState' section' subsection' name' values
Long Parameter List,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The method has 5 parameters. Parameters: _enclosing' key' f' stage' newContent
Long Parameter List,NGit,ObjectChecker,C:\repos\mono_ngit\NGit\NGit\ObjectChecker.cs,PathCompare,The method has 7 parameters. Parameters: raw' aPos' aEnd' aMode' bPos' bEnd' bMode
Long Parameter List,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,ObjectId,The method has 5 parameters. Parameters: new_1' new_2' new_3' new_4' new_5
Long Parameter List,NGit,TextProgressMonitor,C:\repos\mono_ngit\NGit\NGit\TextProgressMonitor.cs,Format,The method has 5 parameters. Parameters: s' taskName' cmp' totalWork' pcnt
Long Parameter List,NGit,Tree,C:\repos\mono_ngit\NGit\NGit\Tree.cs,CompareNames,The method has 6 parameters. Parameters: a' nameUTF8' nameStart' nameEnd' lasta' lastb
Long Parameter List,NGit,Tree,C:\repos\mono_ngit\NGit\NGit\Tree.cs,BinarySearch,The method has 5 parameters. Parameters: entries' nameUTF8' nameUTF8last' nameStart' nameEnd
Long Parameter List,NGit,TreeFormatter,C:\repos\mono_ngit\NGit\NGit\TreeFormatter.cs,Append,The method has 5 parameters. Parameters: nameBuf' namePos' nameLen' mode' id
Long Parameter List,NGit,TreeFormatter,C:\repos\mono_ngit\NGit\NGit\TreeFormatter.cs,Append,The method has 6 parameters. Parameters: nameBuf' namePos' nameLen' mode' idBuf' idPos
Long Parameter List,NGit,ConfigSnapshot,C:\repos\mono_ngit\NGit\NGit\ConfigSnapshot.cs,First,The method has 5 parameters. Parameters: s' i' s1' s2' n
Long Parameter List,NGit,ConfigSnapshot,C:\repos\mono_ngit\NGit\NGit\ConfigSnapshot.cs,End,The method has 5 parameters. Parameters: s' i' s1' s2' n
Long Parameter List,NGit,ConfigSnapshot,C:\repos\mono_ngit\NGit\NGit\ConfigSnapshot.cs,Compare2,The method has 6 parameters. Parameters: aSection' aSubsection' aName' bSection' bSubsection' bName
Long Parameter List,NGit.Api,MergeCommandResult,C:\repos\mono_ngit\NGit\NGit.Api\MergeCommandResult.cs,MergeCommandResult,The method has 6 parameters. Parameters: newHead' base' mergedCommits' mergeStatus' mergeStrategy' lowLevelResults
Long Parameter List,NGit.Api,MergeCommandResult,C:\repos\mono_ngit\NGit\NGit.Api\MergeCommandResult.cs,MergeCommandResult,The method has 7 parameters. Parameters: newHead' base' mergedCommits' mergeStatus' mergeStrategy' lowLevelResults' description
Long Parameter List,NGit.Api,MergeCommandResult,C:\repos\mono_ngit\NGit\NGit.Api\MergeCommandResult.cs,MergeCommandResult,The method has 8 parameters. Parameters: newHead' base' mergedCommits' mergeStatus' mergeStrategy' lowLevelResults' failingPaths' description
Long Parameter List,NGit.Api,_PathEdit_349,C:\repos\mono_ngit\NGit\NGit.Api\CheckoutCommand.cs,_PathEdit_349,The method has 7 parameters. Parameters: _enclosing' checkoutIndex' blobId' mode' workTree' r' baseArg1
Long Parameter List,NGit.Api,AddNoteCommand,C:\repos\mono_ngit\NGit\NGit.Api\AddNoteCommand.cs,CommitNoteMap,The method has 5 parameters. Parameters: walk' map' notesCommit' inserter' msg
Long Parameter List,NGit.Api,RemoveNoteCommand,C:\repos\mono_ngit\NGit\NGit.Api\RemoveNoteCommand.cs,CommitNoteMap,The method has 5 parameters. Parameters: walk' map' notesCommit' inserter' msg
Long Parameter List,NGit.Api,StashApplyCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashApplyCommand.cs,IsConflict,The method has 5 parameters. Parameters: stashIndexIter' stashWorkingTreeIter' headIter' indexIter' workingTreeIter
Long Parameter List,NGit.Diff,MyersDiff<S>,C:\repos\mono_ngit\NGit\NGit.Diff\MyersDiff.cs,MyersDiff,The method has 5 parameters. Parameters: edits' cmp' a' b' region
Long Parameter List,NGit.Diff,_LowLevelDiffAlgorithm_114,C:\repos\mono_ngit\NGit\NGit.Diff\MyersDiff.cs,DiffNonCommon,The method has 5 parameters. Parameters: edits' cmp' a' b' region
Long Parameter List,NGit.Diff,HistogramDiff,C:\repos\mono_ngit\NGit\NGit.Diff\HistogramDiff.cs,DiffNonCommon,The method has 5 parameters. Parameters: edits' cmp' a' b' region
Long Parameter List,NGit.Diff,State<S>,C:\repos\mono_ngit\NGit\NGit.Diff\HistogramDiff.cs,State,The method has 5 parameters. Parameters: _enclosing' edits' cmp' a' b
Long Parameter List,NGit.Diff,HistogramDiffIndex<S>,C:\repos\mono_ngit\NGit\NGit.Diff\HistogramDiffIndex.cs,HistogramDiffIndex,The method has 5 parameters. Parameters: maxChainLength' cmp' a' b' r
Long Parameter List,NGit.Diff,LowLevelDiffAlgorithm,C:\repos\mono_ngit\NGit\NGit.Diff\LowLevelDiffAlgorithm.cs,DiffNonCommon,The method has 5 parameters. Parameters: edits' cmp' a' b' region
Long Parameter List,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,DirCacheCheckout,The method has 5 parameters. Parameters: repo' headCommitTree' dc' mergeCommitTree' workingTree
Long Parameter List,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DirCacheEntry,The method has 6 parameters. Parameters: sharedInfo' infoAt' in' md' smudge_s' smudge_ns
Long Parameter List,NGit.Merge,MergeFormatter,C:\repos\mono_ngit\NGit\NGit.Merge\MergeFormatter.cs,FormatMerge,The method has 6 parameters. Parameters: out' res' baseName' oursName' theirsName' charsetName
Long Parameter List,NGit.Merge,ResolveMerger,C:\repos\mono_ngit\NGit\NGit.Merge\ResolveMerger.cs,Add,The method has 5 parameters. Parameters: path' p' stage' lastMod' len
Long Parameter List,NGit.Merge,ResolveMerger,C:\repos\mono_ngit\NGit\NGit.Merge\ResolveMerger.cs,ProcessEntry,The method has 5 parameters. Parameters: base' ours' theirs' index' work
Long Parameter List,NGit.Merge,ResolveMerger,C:\repos\mono_ngit\NGit\NGit.Merge\ResolveMerger.cs,UpdateIndex,The method has 5 parameters. Parameters: base' ours' theirs' result' of
Long Parameter List,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,DrawLine,The method has 6 parameters. Parameters: color' x1' y1' x2' y2' width
Long Parameter List,NGit.Revwalk,FooterLine,C:\repos\mono_ngit\NGit\NGit.Revwalk\FooterLine.cs,FooterLine,The method has 6 parameters. Parameters: b' e' ks' ke' vs' ve
Long Parameter List,NGit.Storage.File,LargePackedDeltaObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\LargePackedDeltaObject.cs,LargePackedDeltaObject,The method has 5 parameters. Parameters: objectOffset' baseOffset' headerLength' pack' db
Long Parameter List,NGit.Storage.File,_Filter_195,C:\repos\mono_ngit\NGit\NGit.Storage.File\LargePackedDeltaObject.cs,_Filter_195,The method has 8 parameters. Parameters: _enclosing' odi' wc' tmp' myId' baseArg1' baseArg2' baseArg3
Long Parameter List,NGit.Storage.File,LargePackedWholeObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\LargePackedWholeObject.cs,LargePackedWholeObject,The method has 6 parameters. Parameters: type' size' objectOffset' headerLength' pack' db
Long Parameter List,NGit.Storage.File,Delta,C:\repos\mono_ngit\NGit\NGit.Storage.File\LocalObjectRepresentation.cs,Delta,The method has 5 parameters. Parameters: next' ofs' sz' hdrLen' baseOffset
Long Parameter List,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,ReadFully,The method has 5 parameters. Parameters: position' dstbuf' dstoff' cnt' curs
Long Parameter List,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,Resolve,The method has 5 parameters. Parameters: ref' depth' prefix' loose' packed
Long Parameter List,NGit.Storage.File,_RefWriter_826,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,_RefWriter_826,The method has 5 parameters. Parameters: _enclosing' lck' oldPackedList' refs' baseArg1
Long Parameter List,NGit.Storage.File,LargeObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,LargeObject,The method has 5 parameters. Parameters: type' size' path' id' db
Long Parameter List,NGit.Storage.File,WindowCursor,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCursor.cs,Copy,The method has 5 parameters. Parameters: pack' position' dstbuf' dstoff' cnt
Long Parameter List,NGit.Storage.File,ReflogWriter,C:\repos\mono_ngit\NGit\NGit.Storage.File\ReflogWriter.cs,Log,The method has 5 parameters. Parameters: refName' oldId' newId' ident' message
Long Parameter List,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,Negmatch,The method has 5 parameters. Parameters: res' resPtr' src' srcPtr' limit
Long Parameter List,NGit.Storage.Pack,DeltaTask,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaTask.cs,DeltaTask,The method has 7 parameters. Parameters: config' reader' dc' pm' batchSize' start' list
Long Parameter List,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,UseCachedPack,The method has 5 parameters. Parameters: walker' keepOnRestart' wantObj' baseObj' pack
Long Parameter List,NGit.Storage.Pack,BaseSearch,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BaseSearch.cs,BaseSearch,The method has 5 parameters. Parameters: countingMonitor' bases' objects' edges' or
Long Parameter List,NGit.Treewalk,AbstractTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\AbstractTreeIterator.cs,PathCompare,The method has 5 parameters. Parameters: b' bPos' bEnd' bMode' aPos
Long Parameter List,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The method has 5 parameters. Parameters: source' srcOffset' numSigBytes' destination' destOffset
Long Parameter List,NGit.Util,ChangeIdUtil,C:\repos\mono_ngit\NGit\NGit.Util\ChangeIdUtil.cs,ComputeChangeId,The method has 5 parameters. Parameters: treeId' firstParentId' author' committer' message
Long Parameter List,NGit.Transport,RemoteRefUpdate,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteRefUpdate.cs,RemoteRefUpdate,The method has 6 parameters. Parameters: localDb' srcRef' remoteName' forceUpdate' localName' expectedOldObjectId
Long Parameter List,NGit.Transport,RemoteRefUpdate,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteRefUpdate.cs,RemoteRefUpdate,The method has 6 parameters. Parameters: localDb' srcRef' remoteName' forceUpdate' localName' expectedOldObjectId
Long Parameter List,NGit.Transport,RemoteRefUpdate,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteRefUpdate.cs,RemoteRefUpdate,The method has 7 parameters. Parameters: localDb' srcRef' srcId' remoteName' forceUpdate' localName' expectedOldObjectId
Long Parameter List,NGit.Transport,TrackingRefUpdate,C:\repos\mono_ngit\NGit\NGit.Transport\TrackingRefUpdate.cs,TrackingRefUpdate,The method has 5 parameters. Parameters: canForceUpdate' remoteName' localName' oldValue' newValue
Long Parameter List,NGit.Transport,SideBandProgressMonitor,C:\repos\mono_ngit\NGit\NGit.Transport\SideBandProgressMonitor.cs,Format,The method has 5 parameters. Parameters: s' taskName' cmp' totalWork' pcnt
Long Parameter List,NGit.Transport,_Thread_233,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,_Thread_233,The method has 5 parameters. Parameters: _enclosing' dst' out_r' in_w' baseArg1
Long Parameter List,NGit.Transport,_Thread_365,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,_Thread_365,The method has 5 parameters. Parameters: _enclosing' dst' out_r' in_w' baseArg1
Long Parameter List,NGit.Transport,CredentialsProviderUserInfo,C:\repos\mono_ngit\NGit\NGit.Transport\CredentialsProviderUserInfo.cs,PromptKeyboardInteractive,The method has 5 parameters. Parameters: destination' name' instruction' prompt' echo
Long Parameter List,NGit.Transport,JschConfigSessionFactory,C:\repos\mono_ngit\NGit\NGit.Transport\JschConfigSessionFactory.cs,CreateSession,The method has 7 parameters. Parameters: credentialsProvider' fs' user' pass' host' port' hc
Long Parameter List,NGit.Transport,JschConfigSessionFactory,C:\repos\mono_ngit\NGit\NGit.Transport\JschConfigSessionFactory.cs,CreateSession,The method has 5 parameters. Parameters: hc' user' host' port' fs
Long Parameter List,NGit.Transport,PreUploadHook,C:\repos\mono_ngit\NGit\NGit.Transport\PreUploadHook.cs,OnEndNegotiateRound,The method has 5 parameters. Parameters: up' wants' cntCommon' cntNotFound' ready
Long Parameter List,NGit.Transport,_PreUploadHook_60,C:\repos\mono_ngit\NGit\NGit.Transport\PreUploadHook.cs,OnEndNegotiateRound,The method has 5 parameters. Parameters: up' wants' cntCommon' cntNotFound' ready
Long Parameter List,NGit.Transport,PreUploadHookChain,C:\repos\mono_ngit\NGit\NGit.Transport\PreUploadHookChain.cs,OnEndNegotiateRound,The method has 5 parameters. Parameters: up' wants' cntCommon' cntNotFound' ready
Long Parameter List,NGit.Notes,NonNoteEntry,C:\repos\mono_ngit\NGit\NGit.Notes\NonNoteEntry.cs,PathCompare,The method has 8 parameters. Parameters: aBuf' aPos' aEnd' aMode' bBuf' bPos' bEnd' bMode
Long Parameter List,NGit.Notes,DefaultNoteMerger,C:\repos\mono_ngit\NGit\NGit.Notes\DefaultNoteMerger.cs,Merge,The method has 5 parameters. Parameters: base' ours' theirs' reader' inserter
Long Parameter List,NGit.Notes,NoteMerger,C:\repos\mono_ngit\NGit\NGit.Notes\NoteMerger.cs,Merge,The method has 5 parameters. Parameters: base' ours' their' reader' inserter
Long Identifier,NGit,ConfigConstants,C:\repos\mono_ngit\NGit\NGit\ConfigConstants.cs,,The length of the parameter CONFIG_KEY_REPO_FORMAT_VERSION is 30.
Long Identifier,NGit,ConfigConstants,C:\repos\mono_ngit\NGit\NGit\ConfigConstants.cs,,The length of the parameter CONFIG_KEY_DELTA_BASE_CACHE_LIMIT is 33.
Long Identifier,NGit,ConfigConstants,C:\repos\mono_ngit\NGit\NGit\ConfigConstants.cs,,The length of the parameter CONFIG_KEY_STREAM_FILE_TRESHOLD is 31.
Long Identifier,NGit,ConfigConstants,C:\repos\mono_ngit\NGit\NGit\ConfigConstants.cs,,The length of the parameter CONFIG_KEY_DEFBRANCHSTARTPOINT is 30.
Long Identifier,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,,The length of the parameter GIT_ALTERNATE_OBJECT_DIRECTORIES_KEY is 36.
Long Identifier,NGit.Storage.Pack,PackConfig,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackConfig.cs,,The length of the parameter DEFAULT_DELTA_SEARCH_WINDOW_SIZE is 32.
Long Identifier,NGit.Storage.Pack,PackOutputStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackOutputStream.cs,,The length of the parameter BYTES_TO_WRITE_BEFORE_CANCEL_CHECK is 34.
Long Identifier,NGit.Treewalk,WorkingTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\WorkingTreeIterator.cs,,The length of the parameter MAXIMUM_FILE_SIZE_TO_READ_FULLY is 31.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter abbreviationLengthMustBeNonNegative is 35.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter anExceptionOccurredWhileTryingToAddTheIdOfHEAD is 46.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter anSSHSessionHasBeenAlreadyCreated is 33.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter bareRepositoryNoWorkdirAndIndex is 31.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter cachedPacksPreventsIndexCreation is 32.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter cannotBeRecursiveWhenTreesAreIncluded is 37.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter cannotCombineTreeFilterWithRevFilter is 36.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter cannotRebaseWithoutCurrentHead is 30.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter cannotResolveLocalTrackingRefForUpdating is 40.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter cannotWorkWithOtherStagesThanZeroRightNow is 41.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter canOnlyCherryPickCommitsWithOneParent is 37.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter canOnlyRevertCommitsWithOneParent is 33.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter cantFindObjectInReversePackIndexForTheSpecifiedOffset is 53.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter commandWasCalledInTheWrongState is 31.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter commitOnRepoWithoutHEADCurrentlyNotSupported is 44.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter commitAmendOnInitialNotPossible is 31.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter corruptObjectBadStreamCorruptHeader is 35.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter corruptObjectNoTaggerBadHeader is 30.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter corruptObjectPackfileChecksumIncorrect is 38.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter couldNotCheckOutBecauseOfConflicts is 34.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter couldNotDeleteLockFileShouldNotHappen is 37.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter couldNotDeleteTemporaryIndexFileShouldNotHappen is 47.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter couldNotReadObjectWhileParsingCommit is 36.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter couldNotRenameTemporaryIndexFileToIndex is 39.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter createBranchFailedUnknownReason is 31.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter dirCacheDoesNotHaveABackingFile is 31.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter DIRCExtensionNotSupportedByThisVersion is 38.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter downloadCancelledDuringIndexing is 31.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter duplicateRemoteRefUpdateIsIllegal is 33.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter eitherGitDirOrWorkTreeRequired is 30.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter errorInBase64CodeReadingStream is 30.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter errorInvalidProtocolWantedOldNewRef is 35.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter errorOccurredDuringUnpackingOnTheRemoteEnd is 42.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter exceptionCaughtDuringExecutionOfAddCommand is 42.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter exceptionCaughtDuringExecutionOfCherryPickCommand is 49.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter exceptionCaughtDuringExecutionOfCommitCommand is 45.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter exceptionCaughtDuringExecutionOfFetchCommand is 44.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter exceptionCaughtDuringExecutionOfLsRemoteCommand is 47.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter exceptionCaughtDuringExecutionOfMergeCommand is 44.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter exceptionCaughtDuringExecutionOfPullCommand is 43.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter exceptionCaughtDuringExecutionOfPushCommand is 43.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter exceptionCaughtDuringExecutionOfResetCommand is 44.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter exceptionCaughtDuringExecutionOfRevertCommand is 45.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter exceptionCaughtDuringExecutionOfRmCommand is 41.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter exceptionCaughtDuringExecutionOfTagCommand is 42.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter exceptionOccurredDuringAddingOfOptionToALogCommand is 50.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter exceptionOccurredDuringReadingOfGIT_DIR is 39.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter expectedCharacterEncodingGuesses is 32.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter expectedReportForRefNotReceived is 31.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter fileIsTooBigForThisConvenienceMethod is 36.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter hugeIndexesAreNotSupportedByJgitYet is 35.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter hunkHeaderDoesNotMatchBodyLineCountOf is 37.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter isAStaticFlagAndHasNorevWalkInstance is 36.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter lockCountMustBeGreaterOrEqual1 is 30.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter mergeStrategyAlreadyExistsAsDefault is 35.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter mergeStrategyDoesNotSupportHeads is 32.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter mergeUsingStrategyResultedInDescription is 39.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter missingForwardImageInGITBinaryPatch is 35.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter noHEADExistsAndNoExplicitStartingRevisionWasSpecified is 53.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter offsetWrittenDeltaBaseForObjectNotFoundInAPack is 46.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter onlyAlreadyUpToDateAndFastForwardMergesAreAvailable is 51.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter onlyOneOperationCallPerConnectionIsSupported is 44.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter packCorruptedWhileWritingToFilesystem is 37.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter packingCancelledDuringObjectsWriting is 36.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter peerDidNotSupplyACompleteObjectGraph is 36.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter problemWithResolvingPushRefSpecsLocally is 39.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter pullOnRepoWithoutHEADCurrentlyNotSupported is 42.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter pushIsNotSupportedForBundleTransport is 36.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter rawLogMessageDoesNotParseAsLogEntry is 35.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter readingObjectsFromLocalRepositoryFailed is 39.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter remoteConfigHasNoURIAssociated is 30.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter remoteDoesNotSupportSmartHTTPPush is 33.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter renameBranchFailedUnknownReason is 31.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter repositoryState_rebaseInteractive is 33.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter repositoryState_rebaseOrApplyMailbox is 36.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter repositoryState_rebaseWithMerge is 31.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter requiredHashFunctionNotAvailable is 32.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter sequenceTooLargeForDiffAlgorithm is 32.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter shortReadOfOptionalDIRCExtensionExpectedAnotherBytes is 52.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter similarityScoreMustBeWithinBounds is 33.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter sourceRefDoesntResolveToAnyObject is 33.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter sourceRefNotSpecifiedForRefspec is 31.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter startingReadStageWithoutWrittenRequestDataPendingIsNotSupported is 63.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter statelessRPCRequiresOptionToBeEnabled is 37.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter submoduleParentRemoteUrlInvalid is 31.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter symlinkCannotBeWrittenAsTheLinkTarget is 37.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter tagOnRepoWithoutHEADCurrentlyNotSupported is 41.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter transportExceptionMissingAssumed is 32.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter treeIteratorDoesNotSupportRemove is 32.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter treeWalkMustHaveExactlyTwoTrees is 31.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter truncatedHunkLinesMissingForAncestor is 36.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter unknownIndexVersionOrCorruptIndex is 33.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter unsupportedEncryptionAlgorithm is 30.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter unsupportedOperationNotAddAtEnd is 31.
Long Identifier,NGit.Internal,JGitText,C:\repos\mono_ngit\NGit\NGit.Internal\JGitText.cs,,The length of the parameter windowSizeMustBeLesserThanLimit is 31.
Long Statement,NGit,IndexDiff,C:\repos\mono_ngit\NGit\NGit\IndexDiff.cs,GetUntrackedFolders,The length of the statement  "			return ((indexDiffFilter == null || indexDiffFilter.GetUntrackedFolders ().Count == 0) ? Sharpen.Collections.EmptySet<string>() : new  " is 133.
Long Statement,NGit.Storage.File,PackReverseIndex,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackReverseIndex.cs,FindNextOffset,The length of the statement  "					throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().cantFindObjectInReversePackIndexForTheSpecifiedOffset " is 122.
Long Statement,NGit.Storage.File,PackReverseIndex,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackReverseIndex.cs,FindNextOffset,The length of the statement  "					throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().cantFindObjectInReversePackIndexForTheSpecifiedOffset " is 122.
Long Statement,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,FindObjectsToPack,The length of the statement  "			stats.uninterestingObjects = Sharpen.Collections.UnmodifiableSet(new HashSet<ObjectId>(have.UpcastTo<_T1'ObjectId> ())); " is 120.
Long Statement,NGit.Transport,MultiRequestService,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,Execute,The length of the statement  "						throw new TransportException(this._enclosing.uri' JGitText.Get().startingReadStageWithoutWrittenRequestDataPendingIsNotSupported " is 128.
Complex Conditional,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The conditional expression  "typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark"  is complex.
Complex Conditional,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The conditional expression  "typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark"  is complex.
Complex Conditional,NGit,IndexDiff,C:\repos\mono_ngit\NGit\NGit\IndexDiff.cs,Diff,The conditional expression  "added.IsEmpty() && changed.IsEmpty() && removed.IsEmpty() && missing.IsEmpty(  				) && modified.IsEmpty() && untracked.IsEmpty()"  is complex.
Complex Conditional,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,ResolveSimple,The conditional expression  "(dashg + 5) < revstr.Length && 0 <= dashg && IsHex(revstr[dashg + 2]) && IsHex  				(revstr[dashg + 3]) && IsAllHex(revstr' dashg + 4)"  is complex.
Complex Conditional,NGit,TreeEntry,C:\repos\mono_ngit\NGit\NGit\TreeEntry.cs,SetId,The conditional expression  "(id == null && n != null) || (id != null && n == null) || !id.Equals(n)"  is complex.
Complex Conditional,NGit.Api,CommitCommand,C:\repos\mono_ngit\NGit\NGit.Api\CommitCommand.cs,CreateTemporaryIndex,The conditional expression  "emptyCommit && (hTree == null || !hTree.IdEqual(fTree) || hTree.EntryRawMode   							!= fTree.EntryRawMode)"  is complex.
Complex Conditional,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,CheckParameters,The conditional expression  "s != RepositoryState.REBASING_INTERACTIVE && s != RepositoryState.REBASING &&  					 s != RepositoryState.REBASING_REBASING && s != RepositoryState.REBASING_MERGE"  is complex.
Complex Conditional,NGit.Api,CheckoutCommand,C:\repos\mono_ngit\NGit\NGit.Api\CheckoutCommand.cs,ProcessOptions,The conditional expression  "(!checkoutAllPaths && paths.IsEmpty()) && (name == null || !Repository.IsValidRefName  				(Constants.R_HEADS + name))"  is complex.
Complex Conditional,NGit.Api,StashApplyCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashApplyCommand.cs,IsConflict,The conditional expression  "indexDirty && stashIndexIter != null && indexIter != null && !IsEqualEntry(stashIndexIter  				' indexIter)"  is complex.
Complex Conditional,NGit.Api,StashApplyCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashApplyCommand.cs,IsConflict,The conditional expression  "workingTreeDirty && stashWorkingTreeIter != null && workingTreeIter != null &&  				 !IsEqualEntry(stashWorkingTreeIter' workingTreeIter)"  is complex.
Complex Conditional,NGit.Diff,DiffFormatter,C:\repos\mono_ngit\NGit\NGit.Diff\DiffFormatter.cs,CreateFormatResult,The conditional expression  "aRaw == BINARY || bRaw == BINARY || RawText.IsBinary(aRaw) || RawText.IsBinary  					(bRaw)"  is complex.
Complex Conditional,NGit.Diff,RawTextComparator,C:\repos\mono_ngit\NGit\NGit.Diff\RawTextComparator.cs,ReduceCommonStartEnd,The conditional expression  "aPtr < 0 || bPtr < 0 || aEnd > aRaw.Length || bEnd > bRaw.Length"  is complex.
Complex Conditional,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,ProcessEntry,The conditional expression  "((ffMask & unchecked((int)(0x222))) != unchecked((int)(0x000))) && (((ffMask   				& unchecked((int)(0x00F))) == unchecked((int)(0x00D))) || ((ffMask & unchecked((  				int)(0x0F0))) == unchecked((int)(0x0D0))) || ((ffMask & unchecked((int)(0xF00)))  				 == unchecked((int)(0xD00))))"  is complex.
Complex Conditional,NGit.Merge,ResolveMerger,C:\repos\mono_ngit\NGit\NGit.Merge\ResolveMerger.cs,ProcessEntry,The conditional expression  "((modeO != 0 && !tw.IdEqual(T_BASE' T_OURS)) || (modeT != 0 && !tw.IdEqual(T_BASE  						' T_THEIRS)))"  is complex.
Complex Conditional,NGit.Patch,HunkHeader,C:\repos\mono_ngit\NGit\NGit.Patch\HunkHeader.cs,ParseBody,The conditional expression  "last < end && nContext + old.nDeleted - 1 == old.lineCount && nContext + old.  				nAdded == newLineCount && RawParseUtils.Match(buf' last' NGit.Patch.Patch.SIG_FOOTER  				) >= 0"  is complex.
Complex Conditional,NGit.Patch,Patch,C:\repos\mono_ngit\NGit\NGit.Patch\Patch.cs,ParseHunks,The conditional expression  "fh.GetHunks().IsEmpty() && BIN_TRAILER.Length < eol - c && RawParseUtils.Match  					(buf' eol - BIN_TRAILER.Length' BIN_TRAILER) >= 0 && MatchAny(buf' c' BIN_HEADERS  					)"  is complex.
Complex Conditional,NGit.Revwalk,RevCommitList<E>,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommitList.cs,FillTo,The conditional expression  "walker == null || commitToLoad == null || (highMark > 0 && size > highMark)"  is complex.
Complex Conditional,NGit.Revwalk,RevCommitList<E>,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommitList.cs,FillTo,The conditional expression  "(highMark == 0 || size <= highMark) && index < BLOCK_SIZE && !c.Equals(commitToLoad  					)"  is complex.
Complex Conditional,NGit.Storage.File,FileBasedConfig,C:\repos\mono_ngit\NGit\NGit.Storage.File\FileBasedConfig.cs,Load,The conditional expression  "@in.Length >= 3 && @in[0] == unchecked((byte)unchecked((int)(0xEF))) && @in[1  						] == unchecked((byte)unchecked((int)(0xBB))) && @in[2] == unchecked((byte)unchecked(  						(int)(0xBF)))"  is complex.
Complex Conditional,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,FindObjectsToPack,The conditional expression  "obj_1 is RevCommit && obj_1.Has(include) && !obj_1.Has(RevFlag.UNINTERESTING)  								 && !obj_1.Has(added)"  is complex.
Complex Conditional,NGit.Treewalk,NameConflictTreeWalk,C:\repos\mono_ngit\NGit\NGit.Treewalk\NameConflictTreeWalk.cs,FastMin,The conditional expression  "fastMinHasMatch && IsTree(minRef) && !IsTree(t) && NameEqual(minRef' t)"  is complex.
Complex Conditional,NGit.Treewalk,NameConflictTreeWalk,C:\repos\mono_ngit\NGit\NGit.Treewalk\NameConflictTreeWalk.cs,FastMin,The conditional expression  "fastMinHasMatch && IsTree(t) && !IsTree(minRef) && NameEqual(t' minRef)"  is complex.
Complex Conditional,NGit.Util,FS,C:\repos\mono_ngit\NGit\NGit.Util\FS.cs,ReadPipe,The conditional expression  "rc == 0 && r != null && r.Length > 0 && !gooblerFail.Get()"  is complex.
Complex Conditional,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParsePersonIdent,The conditional expression  "emailB >= raw.Length || raw[emailB] == '\n' || (emailE >= raw.Length - 1 && raw  				[emailE - 1] != '>')"  is complex.
Complex Conditional,NGit.Util,StringUtils,C:\repos\mono_ngit\NGit\NGit.Util\StringUtils.cs,ToBooleanOrNull,The conditional expression  "EqualsIgnoreCase("yes"' stringValue) || EqualsIgnoreCase("true"' stringValue)  				 || EqualsIgnoreCase("1"' stringValue) || EqualsIgnoreCase("on"' stringValue)"  is complex.
Complex Conditional,NGit.Util,StringUtils,C:\repos\mono_ngit\NGit\NGit.Util\StringUtils.cs,ToBooleanOrNull,The conditional expression  "EqualsIgnoreCase("no"' stringValue) || EqualsIgnoreCase("false"' stringValue)  					 || EqualsIgnoreCase("0"' stringValue) || EqualsIgnoreCase("off"' stringValue)"  is complex.
Complex Conditional,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,Escape,The conditional expression  "b <= 32 || (encodeNonAscii && b > 127) || b == '%' || (escapeReservedChars &&  					 reservedChars.Get(b))"  is complex.
Complex Conditional,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,CleanLeadingSlashes,The conditional expression  "p.Length >= 3 && p[0] == '/' && p[2] == ':' && (p[1] >= 'A' && p[1] <= 'Z' ||  				 p[1] >= 'a' && p[1] <= 'z')"  is complex.
Complex Conditional,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,CleanLeadingSlashes,The conditional expression  "s != null && p.Length >= 2 && p[0] == '/' && p[1] == '~'"  is complex.
Complex Conditional,NGit.Transport,_TransportProtocol_64,C:\repos\mono_ngit\NGit\NGit.Transport\TransportBundleFile.cs,CanHandle,The conditional expression  "uri.GetPath() == null || uri.GetPort() > 0 || uri.GetUser() != null || uri.GetPass  					() != null || uri.GetHost() != null || (uri.GetScheme() != null && !this.GetSchemes  					().Contains(uri.GetScheme()))"  is complex.
Complex Conditional,NGit.Transport,_TransportProtocol_96,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,CanHandle,The conditional expression  "uri.GetPath() == null || uri.GetPort() > 0 || uri.GetUser() != null || uri.GetPass  					() != null || uri.GetHost() != null || (uri.GetScheme() != null && !this.GetSchemes  					().Contains(uri.GetScheme()))"  is complex.
Complex Conditional,NGit.Transport,JschConfigSessionFactory,C:\repos\mono_ngit\NGit\NGit.Transport\JschConfigSessionFactory.cs,GetSession,The conditional expression  "credentialsProvider != null && e.InnerException == null && e.Message.Equals("Auth fail"  								) && retries < 3"  is complex.
Complex Conditional,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,ValidateCommands,The conditional expression  "cmd.GetType() == ReceiveCommand.Type.DELETE && @ref != null && !ObjectId.ZeroId  					.Equals(cmd.GetOldId()) && !@ref.GetObjectId().Equals(cmd.GetOldId())"  is complex.
Virtual Method Call from Constructor,NGit,BlobBasedConfig,C:\repos\mono_ngit\NGit\NGit\BlobBasedConfig.cs,BlobBasedConfig,The constructor "BlobBasedConfig" calls a virtual method "FromText".
Virtual Method Call from Constructor,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,Constants,The constructor "Constants" calls a virtual method "GetDigestLength".
Virtual Method Call from Constructor,NGit,CoreConfig,C:\repos\mono_ngit\NGit\NGit\CoreConfig.cs,CoreConfig,The constructor "CoreConfig" calls a virtual method "GetInt".
Virtual Method Call from Constructor,NGit,CoreConfig,C:\repos\mono_ngit\NGit\NGit\CoreConfig.cs,CoreConfig,The constructor "CoreConfig" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit,CoreConfig,C:\repos\mono_ngit\NGit\NGit\CoreConfig.cs,CoreConfig,The constructor "CoreConfig" calls a virtual method "GetString".
Virtual Method Call from Constructor,NGit,FileTreeEntry,C:\repos\mono_ngit\NGit\NGit\FileTreeEntry.cs,FileTreeEntry,The constructor "FileTreeEntry" calls a virtual method "SetExecutable".
Virtual Method Call from Constructor,NGit,GitIndex,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,GitIndex,The constructor "GitIndex" calls a virtual method "GetIndexFile".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "GetBits".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "GetBits".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "NewObjectInserter".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "Insert".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "Close".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "Flush".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "Release".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "GetStage".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "GetBits".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "GetBits".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "NewObjectInserter".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "Insert".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "Close".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "Flush".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "Release".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "GetStage".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "GetBits".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "GetMode".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "GetSize".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "Open".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "GetId".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "GetId".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "GetFullName".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "GetStage".
Virtual Method Call from Constructor,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The constructor "Entry" calls a virtual method "GetStage".
Virtual Method Call from Constructor,NGit,IndexDiff,C:\repos\mono_ngit\NGit\NGit\IndexDiff.cs,IndexDiff,The constructor "IndexDiff" calls a virtual method "Resolve".
Virtual Method Call from Constructor,NGit,IndexDiff,C:\repos\mono_ngit\NGit\NGit\IndexDiff.cs,IndexDiff,The constructor "IndexDiff" calls a virtual method "ParseTree".
Virtual Method Call from Constructor,NGit,IndexDiff,C:\repos\mono_ngit\NGit\NGit\IndexDiff.cs,IndexDiff,The constructor "IndexDiff" calls a virtual method "ParseTree".
Virtual Method Call from Constructor,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,MutableObjectId,The constructor "MutableObjectId" calls a virtual method "FromObjectId".
Virtual Method Call from Constructor,NGit,SmallStream,C:\repos\mono_ngit\NGit\NGit\ObjectStream.cs,SmallStream,The constructor "SmallStream" calls a virtual method "GetType".
Virtual Method Call from Constructor,NGit,SmallStream,C:\repos\mono_ngit\NGit\NGit\ObjectStream.cs,SmallStream,The constructor "SmallStream" calls a virtual method "GetCachedBytes".
Virtual Method Call from Constructor,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "Get".
Virtual Method Call from Constructor,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "GetConfig".
Virtual Method Call from Constructor,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "GetName".
Virtual Method Call from Constructor,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "GetEmailAddress".
Virtual Method Call from Constructor,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "GetCurrentTime".
Virtual Method Call from Constructor,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "GetName".
Virtual Method Call from Constructor,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "GetEmailAddress".
Virtual Method Call from Constructor,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "GetName".
Virtual Method Call from Constructor,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "GetEmailAddress".
Virtual Method Call from Constructor,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "GetName".
Virtual Method Call from Constructor,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "GetEmailAddress".
Virtual Method Call from Constructor,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "GetTimezone".
Virtual Method Call from Constructor,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "GetCommitterName".
Virtual Method Call from Constructor,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "GetCommitterEmail".
Virtual Method Call from Constructor,NGit,RefRename,C:\repos\mono_ngit\NGit\NGit\RefRename.cs,RefRename,The constructor "RefRename" calls a virtual method "GetName".
Virtual Method Call from Constructor,NGit,RefRename,C:\repos\mono_ngit\NGit\NGit\RefRename.cs,RefRename,The constructor "RefRename" calls a virtual method "GetName".
Virtual Method Call from Constructor,NGit,RefRename,C:\repos\mono_ngit\NGit\NGit\RefRename.cs,RefRename,The constructor "RefRename" calls a virtual method "SetRefLogMessage".
Virtual Method Call from Constructor,NGit,RefRename,C:\repos\mono_ngit\NGit\NGit\RefRename.cs,RefRename,The constructor "RefRename" calls a virtual method "GetName".
Virtual Method Call from Constructor,NGit,RefRename,C:\repos\mono_ngit\NGit\NGit\RefRename.cs,RefRename,The constructor "RefRename" calls a virtual method "GetName".
Virtual Method Call from Constructor,NGit,TransferConfig,C:\repos\mono_ngit\NGit\NGit\TransferConfig.cs,TransferConfig,The constructor "TransferConfig" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit.Api,MergeCommandResult,C:\repos\mono_ngit\NGit\NGit.Api\MergeCommandResult.cs,MergeCommandResult,The constructor "MergeCommandResult" calls a virtual method "AddConflict".
Virtual Method Call from Constructor,NGit.Api,Status,C:\repos\mono_ngit\NGit\NGit.Api\RebaseResult.cs,Status,The constructor "Status" calls a virtual method "GetAdded".
Virtual Method Call from Constructor,NGit.Api,Status,C:\repos\mono_ngit\NGit\NGit.Api\RebaseResult.cs,Status,The constructor "Status" calls a virtual method "GetChanged".
Virtual Method Call from Constructor,NGit.Api,Status,C:\repos\mono_ngit\NGit\NGit.Api\RebaseResult.cs,Status,The constructor "Status" calls a virtual method "GetRemoved".
Virtual Method Call from Constructor,NGit.Api,Status,C:\repos\mono_ngit\NGit\NGit.Api\RebaseResult.cs,Status,The constructor "Status" calls a virtual method "GetMissing".
Virtual Method Call from Constructor,NGit.Api,Status,C:\repos\mono_ngit\NGit\NGit.Api\RebaseResult.cs,Status,The constructor "Status" calls a virtual method "GetModified".
Virtual Method Call from Constructor,NGit.Api,Status,C:\repos\mono_ngit\NGit\NGit.Api\RebaseResult.cs,Status,The constructor "Status" calls a virtual method "GetUntracked".
Virtual Method Call from Constructor,NGit.Api,Status,C:\repos\mono_ngit\NGit\NGit.Api\RebaseResult.cs,Status,The constructor "Status" calls a virtual method "GetConflicting".
Virtual Method Call from Constructor,NGit.Diff,DiffConfig,C:\repos\mono_ngit\NGit\NGit.Diff\DiffConfig.cs,DiffConfig,The constructor "DiffConfig" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit.Diff,DiffConfig,C:\repos\mono_ngit\NGit\NGit.Diff\DiffConfig.cs,DiffConfig,The constructor "DiffConfig" calls a virtual method "GetString".
Virtual Method Call from Constructor,NGit.Diff,DiffConfig,C:\repos\mono_ngit\NGit\NGit.Diff\DiffConfig.cs,DiffConfig,The constructor "DiffConfig" calls a virtual method "GetInt".
Virtual Method Call from Constructor,NGit.Diff,RenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\RenameDetector.cs,RenameDetector,The constructor "RenameDetector" calls a virtual method "Get".
Virtual Method Call from Constructor,NGit.Diff,RenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\RenameDetector.cs,RenameDetector,The constructor "RenameDetector" calls a virtual method "GetConfig".
Virtual Method Call from Constructor,NGit.Diff,RenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\RenameDetector.cs,RenameDetector,The constructor "RenameDetector" calls a virtual method "GetRenameLimit".
Virtual Method Call from Constructor,NGit.Diff,RenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\RenameDetector.cs,RenameDetector,The constructor "RenameDetector" calls a virtual method "Reset".
Virtual Method Call from Constructor,NGit.Diff,PatchIdDiffFormatter,C:\repos\mono_ngit\NGit\NGit.Diff\PatchIdDiffFormatter.cs,PatchIdDiffFormatter,The constructor "PatchIdDiffFormatter" calls a virtual method "GetOutputStream".
Virtual Method Call from Constructor,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,DirCache,The constructor "DirCache" calls a virtual method "Clear".
Virtual Method Call from Constructor,NGit.Dircache,DirCacheBuildIterator,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheBuildIterator.cs,DirCacheBuildIterator,The constructor "DirCacheBuildIterator" calls a virtual method "GetDirCache".
Virtual Method Call from Constructor,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DirCacheEntry,The constructor "DirCacheEntry" calls a virtual method "Update".
Virtual Method Call from Constructor,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DirCacheEntry,The constructor "DirCacheEntry" calls a virtual method "Update".
Virtual Method Call from Constructor,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DirCacheEntry,The constructor "DirCacheEntry" calls a virtual method "Write".
Virtual Method Call from Constructor,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DirCacheEntry,The constructor "DirCacheEntry" calls a virtual method "Read".
Virtual Method Call from Constructor,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DirCacheEntry,The constructor "DirCacheEntry" calls a virtual method "Write".
Virtual Method Call from Constructor,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DirCacheEntry,The constructor "DirCacheEntry" calls a virtual method "Update".
Virtual Method Call from Constructor,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DirCacheEntry,The constructor "DirCacheEntry" calls a virtual method "Update".
Virtual Method Call from Constructor,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DirCacheEntry,The constructor "DirCacheEntry" calls a virtual method "Update".
Virtual Method Call from Constructor,NGit.Dircache,DirCacheIterator,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheIterator.cs,DirCacheIterator,The constructor "DirCacheIterator" calls a virtual method "GetCacheTree".
Virtual Method Call from Constructor,NGit.Dircache,DirCacheIterator,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheIterator.cs,DirCacheIterator,The constructor "DirCacheIterator" calls a virtual method "GetEntrySpan".
Virtual Method Call from Constructor,NGit.Dircache,DirCacheIterator,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheIterator.cs,DirCacheIterator,The constructor "DirCacheIterator" calls a virtual method "GetEntrySpan".
Virtual Method Call from Constructor,NGit.Errors,CorruptObjectException,C:\repos\mono_ngit\NGit\NGit.Errors\CorruptObjectException.cs,CorruptObjectException,The constructor "CorruptObjectException" calls a virtual method "ToObjectId".
Virtual Method Call from Constructor,NGit.Errors,LargeObjectException,C:\repos\mono_ngit\NGit\NGit.Errors\LargeObjectException.cs,LargeObjectException,The constructor "LargeObjectException" calls a virtual method "SetObjectId".
Virtual Method Call from Constructor,NGit.Errors,TransportException,C:\repos\mono_ngit\NGit\NGit.Errors\TransportException.cs,TransportException,The constructor "TransportException" calls a virtual method "SetPass".
Virtual Method Call from Constructor,NGit.Errors,TransportException,C:\repos\mono_ngit\NGit\NGit.Errors\TransportException.cs,TransportException,The constructor "TransportException" calls a virtual method "SetPass".
Virtual Method Call from Constructor,NGit.Errors,UnsupportedCredentialItem,C:\repos\mono_ngit\NGit\NGit.Errors\UnsupportedCredentialItem.cs,UnsupportedCredentialItem,The constructor "UnsupportedCredentialItem" calls a virtual method "SetPass".
Virtual Method Call from Constructor,NGit.Merge,Merger,C:\repos\mono_ngit\NGit\NGit.Merge\Merger.cs,Merger,The constructor "Merger" calls a virtual method "NewObjectReader".
Virtual Method Call from Constructor,NGit.Merge,ResolveMerger,C:\repos\mono_ngit\NGit\NGit.Merge\ResolveMerger.cs,ResolveMerger,The constructor "ResolveMerger" calls a virtual method "GetEnum".
Virtual Method Call from Constructor,NGit.Merge,ResolveMerger,C:\repos\mono_ngit\NGit\NGit.Merge\ResolveMerger.cs,ResolveMerger,The constructor "ResolveMerger" calls a virtual method "GetConfig".
Virtual Method Call from Constructor,NGit.Patch,FileHeader,C:\repos\mono_ngit\NGit\NGit.Patch\FileHeader.cs,FileHeader,The constructor "FileHeader" calls a virtual method "ParseGitFileName".
Virtual Method Call from Constructor,NGit.Patch,FileHeader,C:\repos\mono_ngit\NGit\NGit.Patch\FileHeader.cs,FileHeader,The constructor "FileHeader" calls a virtual method "ParseGitHeaders".
Virtual Method Call from Constructor,NGit.Patch,FileHeader,C:\repos\mono_ngit\NGit\NGit.Patch\FileHeader.cs,FileHeader,The constructor "FileHeader" calls a virtual method "AddHunk".
Virtual Method Call from Constructor,NGit.Revplot,PlotWalk,C:\repos\mono_ngit\NGit\NGit.Revplot\PlotWalk.cs,PlotWalk,The constructor "PlotWalk" calls a virtual method "Sort".
Virtual Method Call from Constructor,NGit.Revplot,PlotWalk,C:\repos\mono_ngit\NGit\NGit.Revplot\PlotWalk.cs,PlotWalk,The constructor "PlotWalk" calls a virtual method "GetAllRefsByPeeledObjectId".
Virtual Method Call from Constructor,NGit.Revwalk,BlockRevQueue,C:\repos\mono_ngit\NGit\NGit.Revwalk\BlockRevQueue.cs,BlockRevQueue,The constructor "BlockRevQueue" calls a virtual method "OutputType".
Virtual Method Call from Constructor,NGit.Revwalk,BlockRevQueue,C:\repos\mono_ngit\NGit\NGit.Revwalk\BlockRevQueue.cs,BlockRevQueue,The constructor "BlockRevQueue" calls a virtual method "ShareFreeList".
Virtual Method Call from Constructor,NGit.Revwalk,BlockRevQueue,C:\repos\mono_ngit\NGit\NGit.Revwalk\BlockRevQueue.cs,BlockRevQueue,The constructor "BlockRevQueue" calls a virtual method "Next".
Virtual Method Call from Constructor,NGit.Revwalk,BlockRevQueue,C:\repos\mono_ngit\NGit\NGit.Revwalk\BlockRevQueue.cs,BlockRevQueue,The constructor "BlockRevQueue" calls a virtual method "Add".
Virtual Method Call from Constructor,NGit.Revwalk,InitialGenerator,C:\repos\mono_ngit\NGit\NGit.Revwalk\BoundaryGenerator.cs,InitialGenerator,The constructor "InitialGenerator" calls a virtual method "ShareFreeList".
Virtual Method Call from Constructor,NGit.Revwalk,DateRevQueue,C:\repos\mono_ngit\NGit\NGit.Revwalk\DateRevQueue.cs,DateRevQueue,The constructor "DateRevQueue" calls a virtual method "Next".
Virtual Method Call from Constructor,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ObjectWalk,The constructor "ObjectWalk" calls a virtual method "NewObjectReader".
Virtual Method Call from Constructor,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ObjectWalk,The constructor "ObjectWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ObjectWalk,The constructor "ObjectWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ObjectWalk,The constructor "ObjectWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ObjectWalk,The constructor "ObjectWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk,RevWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevWalk.cs,RevWalk,The constructor "RevWalk" calls a virtual method "NewObjectReader".
Virtual Method Call from Constructor,NGit.Revwalk,RevWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevWalk.cs,RevWalk,The constructor "RevWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk,RevWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevWalk.cs,RevWalk,The constructor "RevWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk,RevWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevWalk.cs,RevWalk,The constructor "RevWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk,RevWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevWalk.cs,RevWalk,The constructor "RevWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk,RewriteTreeFilter,C:\repos\mono_ngit\NGit\NGit.Revwalk\RewriteTreeFilter.cs,RewriteTreeFilter,The constructor "RewriteTreeFilter" calls a virtual method "ShouldBeRecursive".
Virtual Method Call from Constructor,NGit.Revwalk,TopoSortGenerator,C:\repos\mono_ngit\NGit\NGit.Revwalk\TopoSortGenerator.cs,TopoSortGenerator,The constructor "TopoSortGenerator" calls a virtual method "OutputType".
Virtual Method Call from Constructor,NGit.Revwalk,TopoSortGenerator,C:\repos\mono_ngit\NGit\NGit.Revwalk\TopoSortGenerator.cs,TopoSortGenerator,The constructor "TopoSortGenerator" calls a virtual method "ShareFreeList".
Virtual Method Call from Constructor,NGit.Revwalk,TopoSortGenerator,C:\repos\mono_ngit\NGit\NGit.Revwalk\TopoSortGenerator.cs,TopoSortGenerator,The constructor "TopoSortGenerator" calls a virtual method "Next".
Virtual Method Call from Constructor,NGit.Revwalk,DepthGenerator,C:\repos\mono_ngit\NGit\NGit.Revwalk\DepthGenerator.cs,DepthGenerator,The constructor "DepthGenerator" calls a virtual method "ShareFreeList".
Virtual Method Call from Constructor,NGit.Revwalk,DepthGenerator,C:\repos\mono_ngit\NGit\NGit.Revwalk\DepthGenerator.cs,DepthGenerator,The constructor "DepthGenerator" calls a virtual method "Next".
Virtual Method Call from Constructor,NGit.Revwalk,DepthGenerator,C:\repos\mono_ngit\NGit\NGit.Revwalk\DepthGenerator.cs,DepthGenerator,The constructor "DepthGenerator" calls a virtual method "GetDepth".
Virtual Method Call from Constructor,NGit.Revwalk.Filter,Binary,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\AndRevFilter.cs,Binary,The constructor "Binary" calls a virtual method "RequiresCommitBody".
Virtual Method Call from Constructor,NGit.Revwalk.Filter,Binary,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\AndRevFilter.cs,Binary,The constructor "Binary" calls a virtual method "RequiresCommitBody".
Virtual Method Call from Constructor,NGit.Revwalk.Filter,Binary,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\AndRevFilter.cs,Binary,The constructor "Binary" calls a virtual method "RequiresCommitBody".
Virtual Method Call from Constructor,NGit.Revwalk.Filter,Binary,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\AndRevFilter.cs,Binary,The constructor "Binary" calls a virtual method "RequiresCommitBody".
Virtual Method Call from Constructor,NGit.Revwalk.Filter,List,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\AndRevFilter.cs,List,The constructor "List" calls a virtual method "RequiresCommitBody".
Virtual Method Call from Constructor,NGit.Revwalk.Filter,List,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\AndRevFilter.cs,List,The constructor "List" calls a virtual method "RequiresCommitBody".
Virtual Method Call from Constructor,NGit.Storage.File,FileRepository,C:\repos\mono_ngit\NGit\NGit.Storage.File\FileRepository.cs,FileRepository,The constructor "FileRepository" calls a virtual method "OpenSystemConfig".
Virtual Method Call from Constructor,NGit.Storage.File,FileRepository,C:\repos\mono_ngit\NGit\NGit.Storage.File\FileRepository.cs,FileRepository,The constructor "FileRepository" calls a virtual method "OpenUserConfig".
Virtual Method Call from Constructor,NGit.Storage.File,FileRepository,C:\repos\mono_ngit\NGit\NGit.Storage.File\FileRepository.cs,FileRepository,The constructor "FileRepository" calls a virtual method "Resolve".
Virtual Method Call from Constructor,NGit.Storage.File,FileRepository,C:\repos\mono_ngit\NGit\NGit.Storage.File\FileRepository.cs,FileRepository,The constructor "FileRepository" calls a virtual method "AddChangeListener".
Virtual Method Call from Constructor,NGit.Storage.File,FileRepository,C:\repos\mono_ngit\NGit\NGit.Storage.File\FileRepository.cs,FileRepository,The constructor "FileRepository" calls a virtual method "GetLong".
Virtual Method Call from Constructor,NGit.Storage.File,FileRepository,C:\repos\mono_ngit\NGit\NGit.Storage.File\FileRepository.cs,FileRepository,The constructor "FileRepository" calls a virtual method "GetIndexFile".
Virtual Method Call from Constructor,NGit.Storage.File,ObjectDirectoryInserter,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryInserter.cs,ObjectDirectoryInserter,The constructor "ObjectDirectoryInserter" calls a virtual method "Get".
Virtual Method Call from Constructor,NGit.Storage.File,EntriesIterator,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndex.cs,EntriesIterator,The constructor "EntriesIterator" calls a virtual method "InitEntry".
Virtual Method Call from Constructor,NGit.Storage.File,PackReverseIndex,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackReverseIndex.cs,PackReverseIndex,The constructor "PackReverseIndex" calls a virtual method "GetObjectCount".
Virtual Method Call from Constructor,NGit.Storage.File,PackReverseIndex,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackReverseIndex.cs,PackReverseIndex,The constructor "PackReverseIndex" calls a virtual method "GetOffset64Count".
Virtual Method Call from Constructor,NGit.Storage.File,PackReverseIndex,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackReverseIndex.cs,PackReverseIndex,The constructor "PackReverseIndex" calls a virtual method "GetOffset".
Virtual Method Call from Constructor,NGit.Storage.File,PackReverseIndex,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackReverseIndex.cs,PackReverseIndex,The constructor "PackReverseIndex" calls a virtual method "GetOffset".
Virtual Method Call from Constructor,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,RefDirectory,The constructor "RefDirectory" calls a virtual method "Resolve".
Virtual Method Call from Constructor,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,RefDirectory,The constructor "RefDirectory" calls a virtual method "Resolve".
Virtual Method Call from Constructor,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,WindowCache,The constructor "WindowCache" calls a virtual method "GetPackedGitOpenFiles".
Virtual Method Call from Constructor,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,WindowCache,The constructor "WindowCache" calls a virtual method "GetPackedGitLimit".
Virtual Method Call from Constructor,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,WindowCache,The constructor "WindowCache" calls a virtual method "IsPackedGitMMAP".
Virtual Method Call from Constructor,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,WindowCache,The constructor "WindowCache" calls a virtual method "GetPackedGitWindowSize".
Virtual Method Call from Constructor,NGit.Storage.File,WriteConfig,C:\repos\mono_ngit\NGit\NGit.Storage.File\WriteConfig.cs,WriteConfig,The constructor "WriteConfig" calls a virtual method "GetCompression".
Virtual Method Call from Constructor,NGit.Storage.File,WriteConfig,C:\repos\mono_ngit\NGit\NGit.Storage.File\WriteConfig.cs,WriteConfig,The constructor "WriteConfig" calls a virtual method "Get".
Virtual Method Call from Constructor,NGit.Storage.File,WriteConfig,C:\repos\mono_ngit\NGit\NGit.Storage.File\WriteConfig.cs,WriteConfig,The constructor "WriteConfig" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit.Storage.File,WriteConfig,C:\repos\mono_ngit\NGit\NGit.Storage.File\WriteConfig.cs,WriteConfig,The constructor "WriteConfig" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,ObjectDirectoryPackParser,The constructor "ObjectDirectoryPackParser" calls a virtual method "GetPackIndexVersion".
Virtual Method Call from Constructor,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,ObjectDirectoryPackParser,The constructor "ObjectDirectoryPackParser" calls a virtual method "Get".
Virtual Method Call from Constructor,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,ObjectDirectoryPackParser,The constructor "ObjectDirectoryPackParser" calls a virtual method "GetConfig".
Virtual Method Call from Constructor,NGit.Storage.File,CheckoutEntry,C:\repos\mono_ngit\NGit\NGit.Storage.File\CheckoutEntry.cs,CheckoutEntry,The constructor "CheckoutEntry" calls a virtual method "GetComment".
Virtual Method Call from Constructor,NGit.Storage.File,ReflogWriter,C:\repos\mono_ngit\NGit\NGit.Storage.File\ReflogWriter.cs,ReflogWriter,The constructor "ReflogWriter" calls a virtual method "Resolve".
Virtual Method Call from Constructor,NGit.Storage.File,ReflogWriter,C:\repos\mono_ngit\NGit\NGit.Storage.File\ReflogWriter.cs,ReflogWriter,The constructor "ReflogWriter" calls a virtual method "Resolve".
Virtual Method Call from Constructor,NGit.Storage.Pack,DeltaCache,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaCache.cs,DeltaCache,The constructor "DeltaCache" calls a virtual method "GetDeltaCacheSize".
Virtual Method Call from Constructor,NGit.Storage.Pack,DeltaCache,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaCache.cs,DeltaCache,The constructor "DeltaCache" calls a virtual method "GetDeltaCacheLimit".
Virtual Method Call from Constructor,NGit.Storage.Pack,DeltaWindow,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaWindow.cs,DeltaWindow,The constructor "DeltaWindow" calls a virtual method "GetDeltaSearchWindowSize".
Virtual Method Call from Constructor,NGit.Storage.Pack,DeltaWindow,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaWindow.cs,DeltaWindow,The constructor "DeltaWindow" calls a virtual method "GetDeltaSearchMemoryLimit".
Virtual Method Call from Constructor,NGit.Storage.Pack,DeltaWindow,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaWindow.cs,DeltaWindow,The constructor "DeltaWindow" calls a virtual method "GetMaxDeltaDepth".
Virtual Method Call from Constructor,NGit.Storage.Pack,PackConfig,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackConfig.cs,PackConfig,The constructor "PackConfig" calls a virtual method "FromConfig".
Virtual Method Call from Constructor,NGit.Storage.Pack,PackConfig,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackConfig.cs,PackConfig,The constructor "PackConfig" calls a virtual method "GetConfig".
Virtual Method Call from Constructor,NGit.Storage.Pack,PackConfig,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackConfig.cs,PackConfig,The constructor "PackConfig" calls a virtual method "FromConfig".
Virtual Method Call from Constructor,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,PackWriter,The constructor "PackWriter" calls a virtual method "NewObjectReader".
Virtual Method Call from Constructor,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,PackWriter,The constructor "PackWriter" calls a virtual method "IsDeltaBaseAsOffset".
Virtual Method Call from Constructor,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,PackWriter,The constructor "PackWriter" calls a virtual method "IsReuseDeltas".
Virtual Method Call from Constructor,NGit.Storage.Pack,MutableState,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,MutableState,The constructor "MutableState" calls a virtual method "IsDeltaCompress".
Virtual Method Call from Constructor,NGit.Storage.Pack,MutableState,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,MutableState,The constructor "MutableState" calls a virtual method "GetThreads".
Virtual Method Call from Constructor,NGit.Storage.Pack,MutableState,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,MutableState,The constructor "MutableState" calls a virtual method "GetDeltaSearchMemoryLimit".
Virtual Method Call from Constructor,NGit.Storage.Pack,MutableState,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,MutableState,The constructor "MutableState" calls a virtual method "GetBigFileThreshold".
Virtual Method Call from Constructor,NGit.Treewalk,AbstractTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\AbstractTreeIterator.cs,AbstractTreeIterator,The constructor "AbstractTreeIterator" calls a virtual method "GrowPath".
Virtual Method Call from Constructor,NGit.Treewalk,CanonicalTreeParser,C:\repos\mono_ngit\NGit\NGit.Treewalk\CanonicalTreeParser.cs,CanonicalTreeParser,The constructor "CanonicalTreeParser" calls a virtual method "Reset".
Virtual Method Call from Constructor,NGit.Treewalk,CanonicalTreeParser,C:\repos\mono_ngit\NGit\NGit.Treewalk\CanonicalTreeParser.cs,CanonicalTreeParser,The constructor "CanonicalTreeParser" calls a virtual method "Reset".
Virtual Method Call from Constructor,NGit.Treewalk,FileTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\FileTreeIterator.cs,FileTreeIterator,The constructor "FileTreeIterator" calls a virtual method "Get".
Virtual Method Call from Constructor,NGit.Treewalk,FileTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\FileTreeIterator.cs,FileTreeIterator,The constructor "FileTreeIterator" calls a virtual method "GetConfig".
Virtual Method Call from Constructor,NGit.Treewalk,FileTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\FileTreeIterator.cs,FileTreeIterator,The constructor "FileTreeIterator" calls a virtual method "InitRootIterator".
Virtual Method Call from Constructor,NGit.Treewalk,FileTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\FileTreeIterator.cs,FileTreeIterator,The constructor "FileTreeIterator" calls a virtual method "Init".
Virtual Method Call from Constructor,NGit.Treewalk,FileTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\FileTreeIterator.cs,FileTreeIterator,The constructor "FileTreeIterator" calls a virtual method "Init".
Virtual Method Call from Constructor,NGit.Treewalk,FileEntry,C:\repos\mono_ngit\NGit\NGit.Treewalk\FileTreeIterator.cs,FileEntry,The constructor "FileEntry" calls a virtual method "CanExecute".
Virtual Method Call from Constructor,NGit.Treewalk,NameConflictTreeWalk,C:\repos\mono_ngit\NGit\NGit.Treewalk\NameConflictTreeWalk.cs,NameConflictTreeWalk,The constructor "NameConflictTreeWalk" calls a virtual method "NewObjectReader".
Virtual Method Call from Constructor,NGit.Treewalk,TreeWalk,C:\repos\mono_ngit\NGit\NGit.Treewalk\TreeWalk.cs,TreeWalk,The constructor "TreeWalk" calls a virtual method "NewObjectReader".
Virtual Method Call from Constructor,NGit.Treewalk,WorkingTreeOptions,C:\repos\mono_ngit\NGit\NGit.Treewalk\WorkingTreeOptions.cs,WorkingTreeOptions,The constructor "WorkingTreeOptions" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit.Treewalk,WorkingTreeOptions,C:\repos\mono_ngit\NGit\NGit.Treewalk\WorkingTreeOptions.cs,WorkingTreeOptions,The constructor "WorkingTreeOptions" calls a virtual method "GetEnum".
Virtual Method Call from Constructor,NGit.Util,TemporaryBuffer,C:\repos\mono_ngit\NGit\NGit.Util\TemporaryBuffer.cs,TemporaryBuffer,The constructor "TemporaryBuffer" calls a virtual method "Reset".
Virtual Method Call from Constructor,NGit.Util,GitDateFormatter,C:\repos\mono_ngit\NGit\NGit.Util\GitDateFormatter.cs,GitDateFormatter,The constructor "GitDateFormatter" calls a virtual method "GetDateTimeInstance".
Virtual Method Call from Constructor,NGit.Util,GitDateFormatter,C:\repos\mono_ngit\NGit\NGit.Util\GitDateFormatter.cs,GitDateFormatter,The constructor "GitDateFormatter" calls a virtual method "GetSimpleDateFormat".
Virtual Method Call from Constructor,NGit.Util.IO,MessageWriter,C:\repos\mono_ngit\NGit\NGit.Util.IO\MessageWriter.cs,MessageWriter,The constructor "MessageWriter" calls a virtual method "GetRawStream".
Virtual Method Call from Constructor,NGit.Util.IO,UnionInputStream,C:\repos\mono_ngit\NGit\NGit.Util.IO\UnionInputStream.cs,UnionInputStream,The constructor "UnionInputStream" calls a virtual method "Add".
Virtual Method Call from Constructor,NGit.Transport,RemoteConfig,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteConfig.cs,RemoteConfig,The constructor "RemoteConfig" calls a virtual method "GetStringList".
Virtual Method Call from Constructor,NGit.Transport,RemoteConfig,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteConfig.cs,RemoteConfig,The constructor "RemoteConfig" calls a virtual method "GetStringList".
Virtual Method Call from Constructor,NGit.Transport,RemoteConfig,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteConfig.cs,RemoteConfig,The constructor "RemoteConfig" calls a virtual method "GetStringList".
Virtual Method Call from Constructor,NGit.Transport,RemoteConfig,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteConfig.cs,RemoteConfig,The constructor "RemoteConfig" calls a virtual method "GetStringList".
Virtual Method Call from Constructor,NGit.Transport,RemoteConfig,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteConfig.cs,RemoteConfig,The constructor "RemoteConfig" calls a virtual method "GetString".
Virtual Method Call from Constructor,NGit.Transport,RemoteConfig,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteConfig.cs,RemoteConfig,The constructor "RemoteConfig" calls a virtual method "GetString".
Virtual Method Call from Constructor,NGit.Transport,RemoteConfig,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteConfig.cs,RemoteConfig,The constructor "RemoteConfig" calls a virtual method "GetString".
Virtual Method Call from Constructor,NGit.Transport,RemoteConfig,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteConfig.cs,RemoteConfig,The constructor "RemoteConfig" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit.Transport,RemoteConfig,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteConfig.cs,RemoteConfig,The constructor "RemoteConfig" calls a virtual method "GetInt".
Virtual Method Call from Constructor,NGit.Transport,RefSpec,C:\repos\mono_ngit\NGit\NGit.Transport\RefSpec.cs,RefSpec,The constructor "RefSpec" calls a virtual method "IsForceUpdate".
Virtual Method Call from Constructor,NGit.Transport,RefSpec,C:\repos\mono_ngit\NGit\NGit.Transport\RefSpec.cs,RefSpec,The constructor "RefSpec" calls a virtual method "IsWildcard".
Virtual Method Call from Constructor,NGit.Transport,RefSpec,C:\repos\mono_ngit\NGit\NGit.Transport\RefSpec.cs,RefSpec,The constructor "RefSpec" calls a virtual method "GetSource".
Virtual Method Call from Constructor,NGit.Transport,RefSpec,C:\repos\mono_ngit\NGit\NGit.Transport\RefSpec.cs,RefSpec,The constructor "RefSpec" calls a virtual method "GetDestination".
Virtual Method Call from Constructor,NGit.Transport,Transport,C:\repos\mono_ngit\NGit\NGit.Transport\Transport.cs,Transport,The constructor "Transport" calls a virtual method "Get".
Virtual Method Call from Constructor,NGit.Transport,Transport,C:\repos\mono_ngit\NGit\NGit.Transport\Transport.cs,Transport,The constructor "Transport" calls a virtual method "GetConfig".
Virtual Method Call from Constructor,NGit.Transport,Transport,C:\repos\mono_ngit\NGit\NGit.Transport\Transport.cs,Transport,The constructor "Transport" calls a virtual method "IsFsckObjects".
Virtual Method Call from Constructor,NGit.Transport,RemoteRefUpdate,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteRefUpdate.cs,RemoteRefUpdate,The constructor "RemoteRefUpdate" calls a virtual method "Resolve".
Virtual Method Call from Constructor,NGit.Transport,RemoteRefUpdate,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteRefUpdate.cs,RemoteRefUpdate,The constructor "RemoteRefUpdate" calls a virtual method "UpdateRef".
Virtual Method Call from Constructor,NGit.Transport,RemoteRefUpdate,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteRefUpdate.cs,RemoteRefUpdate,The constructor "RemoteRefUpdate" calls a virtual method "SetForceUpdate".
Virtual Method Call from Constructor,NGit.Transport,RemoteRefUpdate,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteRefUpdate.cs,RemoteRefUpdate,The constructor "RemoteRefUpdate" calls a virtual method "SetRefLogMessage".
Virtual Method Call from Constructor,NGit.Transport,RemoteRefUpdate,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteRefUpdate.cs,RemoteRefUpdate,The constructor "RemoteRefUpdate" calls a virtual method "SetNewObjectId".
Virtual Method Call from Constructor,NGit.Transport,RemoteRefUpdate,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteRefUpdate.cs,RemoteRefUpdate,The constructor "RemoteRefUpdate" calls a virtual method "GetOldObjectId".
Virtual Method Call from Constructor,NGit.Transport,RemoteRefUpdate,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteRefUpdate.cs,RemoteRefUpdate,The constructor "RemoteRefUpdate" calls a virtual method "GetOldObjectId".
Virtual Method Call from Constructor,NGit.Transport,RemoteRefUpdate,C:\repos\mono_ngit\NGit\NGit.Transport\RemoteRefUpdate.cs,RemoteRefUpdate,The constructor "RemoteRefUpdate" calls a virtual method "GetLocalName".
Virtual Method Call from Constructor,NGit.Transport,PushProcess,C:\repos\mono_ngit\NGit\NGit.Transport\PushProcess.cs,PushProcess,The constructor "PushProcess" calls a virtual method "GetRemoteName".
Virtual Method Call from Constructor,NGit.Transport,PushProcess,C:\repos\mono_ngit\NGit\NGit.Transport\PushProcess.cs,PushProcess,The constructor "PushProcess" calls a virtual method "GetRemoteName".
Virtual Method Call from Constructor,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,BasePackFetchConnection,The constructor "BasePackFetchConnection" calls a virtual method "Get".
Virtual Method Call from Constructor,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,BasePackFetchConnection,The constructor "BasePackFetchConnection" calls a virtual method "GetConfig".
Virtual Method Call from Constructor,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,BasePackFetchConnection,The constructor "BasePackFetchConnection" calls a virtual method "GetTagOpt".
Virtual Method Call from Constructor,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,BasePackFetchConnection,The constructor "BasePackFetchConnection" calls a virtual method "IsFetchThin".
Virtual Method Call from Constructor,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,BasePackFetchConnection,The constructor "BasePackFetchConnection" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,BasePackFetchConnection,The constructor "BasePackFetchConnection" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,BasePackFetchConnection,The constructor "BasePackFetchConnection" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,BasePackFetchConnection,The constructor "BasePackFetchConnection" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,BasePackFetchConnection,The constructor "BasePackFetchConnection" calls a virtual method "Carry".
Virtual Method Call from Constructor,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,BasePackFetchConnection,The constructor "BasePackFetchConnection" calls a virtual method "Carry".
Virtual Method Call from Constructor,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,BasePackFetchConnection,The constructor "BasePackFetchConnection" calls a virtual method "Carry".
Virtual Method Call from Constructor,NGit.Transport,FetchConfig,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,FetchConfig,The constructor "FetchConfig" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit.Transport,BasePackPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackPushConnection.cs,BasePackPushConnection,The constructor "BasePackPushConnection" calls a virtual method "IsPushThin".
Virtual Method Call from Constructor,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,UploadPack,The constructor "UploadPack" calls a virtual method "SetRetainBody".
Virtual Method Call from Constructor,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,UploadPack,The constructor "UploadPack" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,UploadPack,The constructor "UploadPack" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,UploadPack,The constructor "UploadPack" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,UploadPack,The constructor "UploadPack" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,UploadPack,The constructor "UploadPack" calls a virtual method "Carry".
Virtual Method Call from Constructor,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,WalkFetchConnection,The constructor "WalkFetchConnection" calls a virtual method "IsCheckFetchedObjects".
Virtual Method Call from Constructor,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,WalkFetchConnection,The constructor "WalkFetchConnection" calls a virtual method "NewObjectInserter".
Virtual Method Call from Constructor,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,WalkFetchConnection,The constructor "WalkFetchConnection" calls a virtual method "NewObjectReader".
Virtual Method Call from Constructor,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,WalkFetchConnection,The constructor "WalkFetchConnection" calls a virtual method "SetRetainBody".
Virtual Method Call from Constructor,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,WalkFetchConnection,The constructor "WalkFetchConnection" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,WalkFetchConnection,The constructor "WalkFetchConnection" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,WalkFetchConnection,The constructor "WalkFetchConnection" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Transport,WalkPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkPushConnection.cs,WalkPushConnection,The constructor "WalkPushConnection" calls a virtual method "GetURI".
Virtual Method Call from Constructor,NGit.Transport,_DaemonService_143,C:\repos\mono_ngit\NGit\NGit.Transport\Daemon.cs,_DaemonService_143,The constructor "_DaemonService_143" calls a virtual method "SetEnabled".
Virtual Method Call from Constructor,NGit.Transport,_DaemonService_158,C:\repos\mono_ngit\NGit\NGit.Transport\Daemon.cs,_DaemonService_158,The constructor "_DaemonService_158" calls a virtual method "SetEnabled".
Virtual Method Call from Constructor,NGit.Transport,ServiceConfig,C:\repos\mono_ngit\NGit\NGit.Transport\DaemonService.cs,ServiceConfig,The constructor "ServiceConfig" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit.Transport,ServiceConfig,C:\repos\mono_ngit\NGit\NGit.Transport\DaemonService.cs,ServiceConfig,The constructor "ServiceConfig" calls a virtual method "IsEnabled".
Virtual Method Call from Constructor,NGit.Transport,TcpFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitAnon.cs,TcpFetchConnection,The constructor "TcpFetchConnection" calls a virtual method "OpenConnection".
Virtual Method Call from Constructor,NGit.Transport,TcpFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitAnon.cs,TcpFetchConnection,The constructor "TcpFetchConnection" calls a virtual method "Service".
Virtual Method Call from Constructor,NGit.Transport,TcpFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitAnon.cs,TcpFetchConnection,The constructor "TcpFetchConnection" calls a virtual method "ReadAdvertisedRefs".
Virtual Method Call from Constructor,NGit.Transport,TcpPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitAnon.cs,TcpPushConnection,The constructor "TcpPushConnection" calls a virtual method "OpenConnection".
Virtual Method Call from Constructor,NGit.Transport,TcpPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitAnon.cs,TcpPushConnection,The constructor "TcpPushConnection" calls a virtual method "Service".
Virtual Method Call from Constructor,NGit.Transport,TcpPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitAnon.cs,TcpPushConnection,The constructor "TcpPushConnection" calls a virtual method "ReadAdvertisedRefs".
Virtual Method Call from Constructor,NGit.Transport,TransportHttp,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,TransportHttp,The constructor "TransportHttp" calls a virtual method "Get".
Virtual Method Call from Constructor,NGit.Transport,TransportHttp,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,TransportHttp,The constructor "TransportHttp" calls a virtual method "GetConfig".
Virtual Method Call from Constructor,NGit.Transport,HttpConfig,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,HttpConfig,The constructor "HttpConfig" calls a virtual method "GetInt".
Virtual Method Call from Constructor,NGit.Transport,HttpConfig,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,HttpConfig,The constructor "HttpConfig" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit.Transport,SmartHttpFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,SmartHttpFetchConnection,The constructor "SmartHttpFetchConnection" calls a virtual method "ReadAdvertisedRefs".
Virtual Method Call from Constructor,NGit.Transport,SmartHttpPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,SmartHttpPushConnection,The constructor "SmartHttpPushConnection" calls a virtual method "ReadAdvertisedRefs".
Virtual Method Call from Constructor,NGit.Transport,InternalLocalFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,InternalLocalFetchConnection,The constructor "InternalLocalFetchConnection" calls a virtual method "Close".
Virtual Method Call from Constructor,NGit.Transport,InternalLocalFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,InternalLocalFetchConnection,The constructor "InternalLocalFetchConnection" calls a virtual method "ReadAdvertisedRefs".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalFetchConnection,The constructor "ForkLocalFetchConnection" calls a virtual method "SetMessageWriter".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalFetchConnection,The constructor "ForkLocalFetchConnection" calls a virtual method "Spawn".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalFetchConnection,The constructor "ForkLocalFetchConnection" calls a virtual method "GetOptionUploadPack".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalFetchConnection,The constructor "ForkLocalFetchConnection" calls a virtual method "GetErrorStream".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalFetchConnection,The constructor "ForkLocalFetchConnection" calls a virtual method "GetRawStream".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalFetchConnection,The constructor "ForkLocalFetchConnection" calls a virtual method "GetInputStream".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalFetchConnection,The constructor "ForkLocalFetchConnection" calls a virtual method "GetOutputStream".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalFetchConnection,The constructor "ForkLocalFetchConnection" calls a virtual method "ReadAdvertisedRefs".
Virtual Method Call from Constructor,NGit.Transport,InternalLocalPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,InternalLocalPushConnection,The constructor "InternalLocalPushConnection" calls a virtual method "Close".
Virtual Method Call from Constructor,NGit.Transport,InternalLocalPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,InternalLocalPushConnection,The constructor "InternalLocalPushConnection" calls a virtual method "ReadAdvertisedRefs".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalPushConnection,The constructor "ForkLocalPushConnection" calls a virtual method "SetMessageWriter".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalPushConnection,The constructor "ForkLocalPushConnection" calls a virtual method "Spawn".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalPushConnection,The constructor "ForkLocalPushConnection" calls a virtual method "GetOptionReceivePack".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalPushConnection,The constructor "ForkLocalPushConnection" calls a virtual method "GetErrorStream".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalPushConnection,The constructor "ForkLocalPushConnection" calls a virtual method "GetRawStream".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalPushConnection,The constructor "ForkLocalPushConnection" calls a virtual method "GetInputStream".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalPushConnection,The constructor "ForkLocalPushConnection" calls a virtual method "GetOutputStream".
Virtual Method Call from Constructor,NGit.Transport,ForkLocalPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,ForkLocalPushConnection,The constructor "ForkLocalPushConnection" calls a virtual method "ReadAdvertisedRefs".
Virtual Method Call from Constructor,NGit.Transport,TransportGitSsh,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,TransportGitSsh,The constructor "TransportGitSsh" calls a virtual method "SetSshSessionFactory".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "GetSession".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "CommandFor".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "GetOptionUploadPack".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "GetTimeout".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "SetMessageWriter".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "GetErrorStream".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "GetRawStream".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "GetInputStream".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "GetOutputStream".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "ReadAdvertisedRefs".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "GetMessages".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "CheckExecFailure".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "ExitValue".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "GetOptionUploadPack".
Virtual Method Call from Constructor,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshFetchConnection,The constructor "SshFetchConnection" calls a virtual method "CleanNotFound".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "GetSession".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "CommandFor".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "GetOptionReceivePack".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "GetTimeout".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "SetMessageWriter".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "GetErrorStream".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "GetRawStream".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "GetInputStream".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "GetOutputStream".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "ReadAdvertisedRefs".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "GetMessages".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "CheckExecFailure".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "ExitValue".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "GetOptionReceivePack".
Virtual Method Call from Constructor,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,SshPushConnection,The constructor "SshPushConnection" calls a virtual method "CleanNotFound".
Virtual Method Call from Constructor,NGit.Transport,SftpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportSftp.cs,SftpObjectDB,The constructor "SftpObjectDB" calls a virtual method "NewSftp".
Virtual Method Call from Constructor,NGit.Transport,SftpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportSftp.cs,SftpObjectDB,The constructor "SftpObjectDB" calls a virtual method "Cd".
Virtual Method Call from Constructor,NGit.Transport,SftpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportSftp.cs,SftpObjectDB,The constructor "SftpObjectDB" calls a virtual method "Cd".
Virtual Method Call from Constructor,NGit.Transport,SftpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportSftp.cs,SftpObjectDB,The constructor "SftpObjectDB" calls a virtual method "Pwd".
Virtual Method Call from Constructor,NGit.Transport,SftpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportSftp.cs,SftpObjectDB,The constructor "SftpObjectDB" calls a virtual method "NewSftp".
Virtual Method Call from Constructor,NGit.Transport,SftpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportSftp.cs,SftpObjectDB,The constructor "SftpObjectDB" calls a virtual method "Cd".
Virtual Method Call from Constructor,NGit.Transport,SftpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportSftp.cs,SftpObjectDB,The constructor "SftpObjectDB" calls a virtual method "Cd".
Virtual Method Call from Constructor,NGit.Transport,SftpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportSftp.cs,SftpObjectDB,The constructor "SftpObjectDB" calls a virtual method "Pwd".
Virtual Method Call from Constructor,NGit.Transport,TransferConfig,C:\repos\mono_ngit\NGit\NGit.Transport\TransferConfig.cs,TransferConfig,The constructor "TransferConfig" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,PackParser,The constructor "PackParser" calls a virtual method "NewCachedDatabase".
Virtual Method Call from Constructor,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,PackParser,The constructor "PackParser" calls a virtual method "NewReader".
Virtual Method Call from Constructor,NGit.Transport,JschProcess,C:\repos\mono_ngit\NGit\NGit.Transport\JschSession.cs,JschProcess,The constructor "JschProcess" calls a virtual method "OpenChannel".
Virtual Method Call from Constructor,NGit.Transport,JschProcess,C:\repos\mono_ngit\NGit\NGit.Transport\JschSession.cs,JschProcess,The constructor "JschProcess" calls a virtual method "SetCommand".
Virtual Method Call from Constructor,NGit.Transport,JschProcess,C:\repos\mono_ngit\NGit\NGit.Transport\JschSession.cs,JschProcess,The constructor "JschProcess" calls a virtual method "Connect".
Virtual Method Call from Constructor,NGit.Transport,JschProcess,C:\repos\mono_ngit\NGit\NGit.Transport\JschSession.cs,JschProcess,The constructor "JschProcess" calls a virtual method "IsConnected".
Virtual Method Call from Constructor,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,BaseReceivePack,The constructor "BaseReceivePack" calls a virtual method "Get".
Virtual Method Call from Constructor,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,BaseReceivePack,The constructor "BaseReceivePack" calls a virtual method "GetConfig".
Virtual Method Call from Constructor,NGit.Transport,ReceiveConfig,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,ReceiveConfig,The constructor "ReceiveConfig" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit.Transport,ReceiveConfig,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,ReceiveConfig,The constructor "ReceiveConfig" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit.Transport,ReceiveConfig,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,ReceiveConfig,The constructor "ReceiveConfig" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit.Transport,ReceiveConfig,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,ReceiveConfig,The constructor "ReceiveConfig" calls a virtual method "GetBoolean".
Virtual Method Call from Constructor,NGit.Notes,NoteMapMerger,C:\repos\mono_ngit\NGit\NGit.Notes\NoteMapMerger.cs,NoteMapMerger,The constructor "NoteMapMerger" calls a virtual method "NewObjectReader".
Virtual Method Call from Constructor,NGit.Notes,NoteMapMerger,C:\repos\mono_ngit\NGit\NGit.Notes\NoteMapMerger.cs,NoteMapMerger,The constructor "NoteMapMerger" calls a virtual method "NewObjectInserter".
Virtual Method Call from Constructor,NGit.Blame,BlameGenerator,C:\repos\mono_ngit\NGit\NGit.Blame\BlameGenerator.cs,BlameGenerator,The constructor "BlameGenerator" calls a virtual method "SetFollowFileRenames".
Virtual Method Call from Constructor,NGit.Submodule,SubmoduleWalk,C:\repos\mono_ngit\NGit\NGit.Submodule\SubmoduleWalk.cs,SubmoduleWalk,The constructor "SubmoduleWalk" calls a virtual method "GetConfig".
Virtual Method Call from Constructor,NGit.Revwalk.Depthwalk,RevWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\DepthWalk.cs,RevWalk,The constructor "RevWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk.Depthwalk,RevWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\DepthWalk.cs,RevWalk,The constructor "RevWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk.Depthwalk,RevWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\DepthWalk.cs,RevWalk,The constructor "RevWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk.Depthwalk,RevWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\DepthWalk.cs,RevWalk,The constructor "RevWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk.Depthwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\DepthWalk.cs,ObjectWalk,The constructor "ObjectWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk.Depthwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\DepthWalk.cs,ObjectWalk,The constructor "ObjectWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk.Depthwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\DepthWalk.cs,ObjectWalk,The constructor "ObjectWalk" calls a virtual method "NewFlag".
Virtual Method Call from Constructor,NGit.Revwalk.Depthwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\DepthWalk.cs,ObjectWalk,The constructor "ObjectWalk" calls a virtual method "NewFlag".
Empty Catch Block,NGit,BaseRepositoryBuilder<B;R>,C:\repos\mono_ngit\NGit\NGit\BaseRepositoryBuilder.cs,FindGitDir,The method has an empty catch block.
Empty Catch Block,NGit,Config,C:\repos\mono_ngit\NGit\NGit\Config.cs,GetEnum,The method has an empty catch block.
Empty Catch Block,NGit,GitIndex,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The method has an empty catch block.
Empty Catch Block,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,GetRepositoryState,The method has an empty catch block.
Empty Catch Block,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,GetRepositoryState,The method has an empty catch block.
Empty Catch Block,NGit.Diff,DiffFormatter,C:\repos\mono_ngit\NGit\NGit.Diff\DiffFormatter.cs,Format,The method has an empty catch block.
Empty Catch Block,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,Read,The method has an empty catch block.
Empty Catch Block,NGit.Ignore,IgnoreRule,C:\repos\mono_ngit\NGit\NGit.Ignore\IgnoreRule.cs,Setup,The method has an empty catch block.
Empty Catch Block,NGit.Patch,FileHeader,C:\repos\mono_ngit\NGit\NGit.Patch\FileHeader.cs,GetScriptText,The method has an empty catch block.
Empty Catch Block,NGit.Revplot,PlotRefComparator,C:\repos\mono_ngit\NGit\NGit.Revplot\PlotWalk.cs,Compare,The method has an empty catch block.
Empty Catch Block,NGit.Revwalk,RevCommitList<E>,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommitList.cs,ClearFlag,The method has an empty catch block.
Empty Catch Block,NGit.Storage.File,CachedObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\CachedObjectDirectory.cs,CachedObjectDirectory,The method has an empty catch block.
Empty Catch Block,NGit.Storage.File,LargePackedDeltaObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\LargePackedDeltaObject.cs,GetType,The method has an empty catch block.
Empty Catch Block,NGit.Storage.File,LargePackedDeltaObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\LargePackedDeltaObject.cs,GetSize,The method has an empty catch block.
Empty Catch Block,NGit.Storage.File,LargePackedDeltaObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\LargePackedDeltaObject.cs,GetSize,The method has an empty catch block.
Empty Catch Block,NGit.Storage.File,LockFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\LockFile.cs,Unlock,The method has an empty catch block.
Empty Catch Block,NGit.Storage.File,LockFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\LockFile.cs,CopyCurrentContent,The method has an empty catch block.
Empty Catch Block,NGit.Storage.File,LockFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\LockFile.cs,Unlock,The method has an empty catch block.
Empty Catch Block,NGit.Storage.File,LockFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\LockFile.cs,Unlock,The method has an empty catch block.
Empty Catch Block,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,DoClose,The method has an empty catch block.
Empty Catch Block,NGit.Storage.File,PackIndex,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndex.cs,Open,The method has an empty catch block.
Empty Catch Block,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,Parse,The method has an empty catch block.
Empty Catch Block,NGit.Treewalk,WorkingTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\WorkingTreeIterator.cs,SafeClose,The method has an empty catch block.
Empty Catch Block,NGit.Util,FS,C:\repos\mono_ngit\NGit\NGit.Util\FS.cs,ReadPipe,The method has an empty catch block.
Empty Catch Block,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseBase10,The method has an empty catch block.
Empty Catch Block,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseLongBase10,The method has an empty catch block.
Empty Catch Block,NGit.Util,TemporaryBuffer,C:\repos\mono_ngit\NGit\NGit.Util\TemporaryBuffer.cs,Destroy,The method has an empty catch block.
Empty Catch Block,NGit.Util,IOUtil,C:\repos\mono_ngit\NGit\NGit.Util\IOUtil.cs,ReadSome,The method has an empty catch block.
Empty Catch Block,NGit.Util,IOUtil,C:\repos\mono_ngit\NGit\NGit.Util\IOUtil.cs,ReadFully,The method has an empty catch block.
Empty Catch Block,NGit.Util,FileUtils,C:\repos\mono_ngit\NGit\NGit.Util\FileUtils.cs,Delete,The method has an empty catch block.
Empty Catch Block,NGit.Util,GitDateParser,C:\repos\mono_ngit\NGit\NGit.Util\GitDateParser.cs,Parse,The method has an empty catch block.
Empty Catch Block,NGit.Util.IO,InterruptTimer,C:\repos\mono_ngit\NGit\NGit.Util.IO\InterruptTimer.cs,Terminate,The method has an empty catch block.
Empty Catch Block,NGit.Util.IO,AlarmState,C:\repos\mono_ngit\NGit\NGit.Util.IO\InterruptTimer.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Util.IO,StreamCopyThread,C:\repos\mono_ngit\NGit\NGit.Util.IO\StreamCopyThread.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Util.IO,StreamCopyThread,C:\repos\mono_ngit\NGit\NGit.Util.IO\StreamCopyThread.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Transport,PushProcess,C:\repos\mono_ngit\NGit\NGit.Transport\PushProcess.cs,UpdateTrackingRefs,The method has an empty catch block.
Empty Catch Block,NGit.Transport,BasePackConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackConnection.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,BasePackConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackConnection.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,BasePackConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackConnection.cs,EndOut,The method has an empty catch block.
Empty Catch Block,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,MaxTimeWanted,The method has an empty catch block.
Empty Catch Block,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,ParseReachable,The method has an empty catch block.
Empty Catch Block,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,SendWants,The method has an empty catch block.
Empty Catch Block,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,MarkAdvertised,The method has an empty catch block.
Empty Catch Block,NGit.Transport,BasePackPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackPushConnection.cs,NoRepository,The method has an empty catch block.
Empty Catch Block,NGit.Transport,BasePackPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackPushConnection.cs,NoRepository,The method has an empty catch block.
Empty Catch Block,NGit.Transport,BundleFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BundleFetchConnection.cs,VerifyPrerequisites,The method has an empty catch block.
Empty Catch Block,NGit.Transport,BundleFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BundleFetchConnection.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,ReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\ReceivePack.cs,Service,The method has an empty catch block.
Empty Catch Block,NGit.Transport,TransportBundleStream,C:\repos\mono_ngit\NGit\NGit.Transport\TransportBundleStream.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,Service,The method has an empty catch block.
Empty Catch Block,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,ReportErrorDuringNegotiate,The method has an empty catch block.
Empty Catch Block,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,ProcessShallow,The method has an empty catch block.
Empty Catch Block,NGit.Transport,RemotePack,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,OpenIndex,The method has an empty catch block.
Empty Catch Block,NGit.Transport,WalkRemoteObjectDatabase,C:\repos\mono_ngit\NGit\NGit.Transport\WalkRemoteObjectDatabase.cs,ReadPackedRefs,The method has an empty catch block.
Empty Catch Block,NGit.Transport,WalkPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkPushConnection.cs,SafeDelete,The method has an empty catch block.
Empty Catch Block,NGit.Transport,_Thread_289,C:\repos\mono_ngit\NGit\NGit.Transport\Daemon.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Transport,_Thread_289,C:\repos\mono_ngit\NGit\NGit.Transport\Daemon.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Transport,_Thread_335,C:\repos\mono_ngit\NGit\NGit.Transport\Daemon.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Transport,_Thread_335,C:\repos\mono_ngit\NGit\NGit.Transport\Daemon.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Transport,_Thread_335,C:\repos\mono_ngit\NGit\NGit.Transport\Daemon.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Transport,_Thread_335,C:\repos\mono_ngit\NGit\NGit.Transport\Daemon.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Transport,_Thread_335,C:\repos\mono_ngit\NGit\NGit.Transport\Daemon.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Transport,OpenSshConfig,C:\repos\mono_ngit\NGit\NGit.Transport\OpenSshConfig.cs,Parse,The method has an empty catch block.
Empty Catch Block,NGit.Transport,TransportGitAnon,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitAnon.cs,OpenConnection,The method has an empty catch block.
Empty Catch Block,NGit.Transport,TcpFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitAnon.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,TcpPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitAnon.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,HttpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,GetAlternates,The method has an empty catch block.
Empty Catch Block,NGit.Transport,HttpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,GetAlternates,The method has an empty catch block.
Empty Catch Block,NGit.Transport,InternalLocalFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,_Thread_233,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Transport,_Thread_233,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Transport,ForkLocalFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,ForkLocalFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,InternalLocalPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,_Thread_365,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Transport,_Thread_365,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Transport,_Thread_365,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Transport,_Thread_365,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,Run,The method has an empty catch block.
Empty Catch Block,NGit.Transport,ForkLocalPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,ForkLocalPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportLocal.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,SshFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,SshPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,SftpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportSftp.cs,WriteFile,The method has an empty catch block.
Empty Catch Block,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,VerifySafeObject,The method has an empty catch block.
Empty Catch Block,NGit.Transport,JschConfigSessionFactory,C:\repos\mono_ngit\NGit\NGit.Transport\JschConfigSessionFactory.cs,KnownHosts,The method has an empty catch block.
Empty Catch Block,NGit.Transport,JschConfigSessionFactory,C:\repos\mono_ngit\NGit\NGit.Transport\JschConfigSessionFactory.cs,KnownHosts,The method has an empty catch block.
Empty Catch Block,NGit.Transport,JschConfigSessionFactory,C:\repos\mono_ngit\NGit\NGit.Transport\JschConfigSessionFactory.cs,LoadIdentity,The method has an empty catch block.
Empty Catch Block,NGit.Transport,_PipedOutputStream_173,C:\repos\mono_ngit\NGit\NGit.Transport\JschSession.cs,Close,The method has an empty catch block.
Empty Catch Block,NGit.Transport,MessageOutputWrapper,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,Write,The method has an empty catch block.
Empty Catch Block,NGit.Transport,MessageOutputWrapper,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,Write,The method has an empty catch block.
Empty Catch Block,NGit.Transport,MessageOutputWrapper,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,Flush,The method has an empty catch block.
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,IsId,The following statement contains a magic number: if (id.Length < 2 || Constants.OBJECT_ID_STRING_LENGTH < id.Length)  			{  				return false;  			}
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = HexUInt32(bs' ptr' end);  				int b = HexUInt32(bs' ptr + 8' end);  				int c = HexUInt32(bs' ptr + 16' end);  				int d = HexUInt32(bs' ptr + 24' end);  				int e = HexUInt32(bs' ptr + 32' end);  				return new NGit.AbbreviatedObjectId(end - ptr' a' b' c' d' e);  			}  			catch (IndexOutOfRangeException)  			{  				throw new InvalidObjectIdException(bs' ptr' end - ptr);  			}
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = HexUInt32(bs' ptr' end);  				int b = HexUInt32(bs' ptr + 8' end);  				int c = HexUInt32(bs' ptr + 16' end);  				int d = HexUInt32(bs' ptr + 24' end);  				int e = HexUInt32(bs' ptr + 32' end);  				return new NGit.AbbreviatedObjectId(end - ptr' a' b' c' d' e);  			}  			catch (IndexOutOfRangeException)  			{  				throw new InvalidObjectIdException(bs' ptr' end - ptr);  			}
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = HexUInt32(bs' ptr' end);  				int b = HexUInt32(bs' ptr + 8' end);  				int c = HexUInt32(bs' ptr + 16' end);  				int d = HexUInt32(bs' ptr + 24' end);  				int e = HexUInt32(bs' ptr + 32' end);  				return new NGit.AbbreviatedObjectId(end - ptr' a' b' c' d' e);  			}  			catch (IndexOutOfRangeException)  			{  				throw new InvalidObjectIdException(bs' ptr' end - ptr);  			}
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = HexUInt32(bs' ptr' end);  				int b = HexUInt32(bs' ptr + 8' end);  				int c = HexUInt32(bs' ptr + 16' end);  				int d = HexUInt32(bs' ptr + 24' end);  				int e = HexUInt32(bs' ptr + 32' end);  				return new NGit.AbbreviatedObjectId(end - ptr' a' b' c' d' e);  			}  			catch (IndexOutOfRangeException)  			{  				throw new InvalidObjectIdException(bs' ptr' end - ptr);  			}
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,HexUInt32,The following statement contains a magic number: if (8 <= end - p)  			{  				return RawParseUtils.ParseHexInt32(bs' p);  			}
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,HexUInt32,The following statement contains a magic number: while (n < 8 && p < end)  			{  				r <<= 4;  				r |= RawParseUtils.ParseHexInt4(bs[p++]);  				n++;  			}
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,HexUInt32,The following statement contains a magic number: while (n < 8 && p < end)  			{  				r <<= 4;  				r |= RawParseUtils.ParseHexInt4(bs[p++]);  				n++;  			}
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,HexUInt32,The following statement contains a magic number: return r << (8 - n) * 4;
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,HexUInt32,The following statement contains a magic number: return r << (8 - n) * 4;
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,Mask,The following statement contains a magic number: int b = (word - 1) * 8;
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,Mask,The following statement contains a magic number: if (b + 8 <= nibbles)  			{  				// We have all of the bits required for this word.  				//  				return v;  			}
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,Mask,The following statement contains a magic number: int s = 32 - (nibbles - b) * 4;
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,Mask,The following statement contains a magic number: int s = 32 - (nibbles - b) * 4;
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(w2' Mask(2' other.w2));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(w3' Mask(3' other.w3));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(w4' Mask(4' other.w4));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: return NB.CompareUInt32(w5' Mask(5' other.w5));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(w2' Mask(2' NB.DecodeInt32(bs' p + 4)));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(w2' Mask(2' NB.DecodeInt32(bs' p + 4)));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(w3' Mask(3' NB.DecodeInt32(bs' p + 8)));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(w3' Mask(3' NB.DecodeInt32(bs' p + 8)));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(w4' Mask(4' NB.DecodeInt32(bs' p + 12)));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(w4' Mask(4' NB.DecodeInt32(bs' p + 12)));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: return NB.CompareUInt32(w5' Mask(5' NB.DecodeInt32(bs' p + 16)));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: return NB.CompareUInt32(w5' Mask(5' NB.DecodeInt32(bs' p + 16)));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(w2' Mask(2' bs[p + 1]));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(w3' Mask(3' bs[p + 2]));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(w3' Mask(3' bs[p + 2]));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(w4' Mask(4' bs[p + 3]));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(w4' Mask(4' bs[p + 3]));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: return NB.CompareUInt32(w5' Mask(5' bs[p + 4]));
Magic Number,NGit,AbbreviatedObjectId,C:\repos\mono_ngit\NGit\NGit\AbbreviatedObjectId.cs,PrefixCompare,The following statement contains a magic number: return NB.CompareUInt32(w5' Mask(5' bs[p + 4]));
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,GetByte,The following statement contains a magic number: switch (index >> 2)  			{  				case 0:  				{  					w = w1;  					break;  				}    				case 1:  				{  					w = w2;  					break;  				}    				case 2:  				{  					w = w3;  					break;  				}    				case 3:  				{  					w = w4;  					break;  				}    				case 4:  				{  					w = w5;  					break;  				}    				default:  				{  					throw Sharpen.Extensions.CreateIndexOutOfRangeException(index);  				}  			}
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,GetByte,The following statement contains a magic number: switch (index >> 2)  			{  				case 0:  				{  					w = w1;  					break;  				}    				case 1:  				{  					w = w2;  					break;  				}    				case 2:  				{  					w = w3;  					break;  				}    				case 3:  				{  					w = w4;  					break;  				}    				case 4:  				{  					w = w5;  					break;  				}    				default:  				{  					throw Sharpen.Extensions.CreateIndexOutOfRangeException(index);  				}  			}
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,GetByte,The following statement contains a magic number: switch (index >> 2)  			{  				case 0:  				{  					w = w1;  					break;  				}    				case 1:  				{  					w = w2;  					break;  				}    				case 2:  				{  					w = w3;  					break;  				}    				case 3:  				{  					w = w4;  					break;  				}    				case 4:  				{  					w = w5;  					break;  				}    				default:  				{  					throw Sharpen.Extensions.CreateIndexOutOfRangeException(index);  				}  			}
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,GetByte,The following statement contains a magic number: switch (index >> 2)  			{  				case 0:  				{  					w = w1;  					break;  				}    				case 1:  				{  					w = w2;  					break;  				}    				case 2:  				{  					w = w3;  					break;  				}    				case 3:  				{  					w = w4;  					break;  				}    				case 4:  				{  					w = w5;  					break;  				}    				default:  				{  					throw Sharpen.Extensions.CreateIndexOutOfRangeException(index);  				}  			}
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,GetByte,The following statement contains a magic number: return ((int)(((uint)w) >> (8 * (3 - (index & 3))))) & unchecked((int)(0xff));
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,GetByte,The following statement contains a magic number: return ((int)(((uint)w) >> (8 * (3 - (index & 3))))) & unchecked((int)(0xff));
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,GetByte,The following statement contains a magic number: return ((int)(((uint)w) >> (8 * (3 - (index & 3))))) & unchecked((int)(0xff));
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32(w2' NB.DecodeInt32(bs' p + 4));
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32(w3' NB.DecodeInt32(bs' p + 8));
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32(w4' NB.DecodeInt32(bs' p + 12));
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CompareTo,The following statement contains a magic number: return NB.CompareUInt32(w5' NB.DecodeInt32(bs' p + 16));
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32(w3' bs[p + 2]);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32(w4' bs[p + 3]);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CompareTo,The following statement contains a magic number: return NB.CompareUInt32(w5' bs[p + 4]);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CopyRawTo,The following statement contains a magic number: NB.EncodeInt32(b' o + 4' w2);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CopyRawTo,The following statement contains a magic number: NB.EncodeInt32(b' o + 8' w3);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CopyRawTo,The following statement contains a magic number: NB.EncodeInt32(b' o + 12' w4);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CopyRawTo,The following statement contains a magic number: NB.EncodeInt32(b' o + 16' w5);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CopyRawTo,The following statement contains a magic number: b[o + 2] = w3;
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CopyRawTo,The following statement contains a magic number: b[o + 3] = w4;
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CopyRawTo,The following statement contains a magic number: b[o + 4] = w5;
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,WriteRawInt,The following statement contains a magic number: w.Write((int)(((uint)v) >> 24));
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,WriteRawInt,The following statement contains a magic number: w.Write((int)(((uint)v) >> 16));
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,WriteRawInt,The following statement contains a magic number: w.Write((int)(((uint)v) >> 8));
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CopyTo,The following statement contains a magic number: FormatHexByte(b' o + 8' w2);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CopyTo,The following statement contains a magic number: FormatHexByte(b' o + 16' w3);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CopyTo,The following statement contains a magic number: FormatHexByte(b' o + 24' w4);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,CopyTo,The following statement contains a magic number: FormatHexByte(b' o + 32' w5);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,ToHexByteArray,The following statement contains a magic number: FormatHexByte(dst' 8' w2);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,ToHexByteArray,The following statement contains a magic number: FormatHexByte(dst' 16' w3);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,ToHexByteArray,The following statement contains a magic number: FormatHexByte(dst' 24' w4);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,ToHexByteArray,The following statement contains a magic number: FormatHexByte(dst' 32' w5);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,FormatHexByte,The following statement contains a magic number: int o = p + 7;
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,FormatHexByte,The following statement contains a magic number: while (o >= p && w != 0)  			{  				dst[o--] = hexbyte[w & unchecked((int)(0xf))];  				w = (int)(((uint)w) >> 4);  			}
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,ToHexCharArray,The following statement contains a magic number: FormatHexChar(dst' 8' w2);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,ToHexCharArray,The following statement contains a magic number: FormatHexChar(dst' 16' w3);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,ToHexCharArray,The following statement contains a magic number: FormatHexChar(dst' 24' w4);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,ToHexCharArray,The following statement contains a magic number: FormatHexChar(dst' 32' w5);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,FormatHexChar,The following statement contains a magic number: int o = p + 7;
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,FormatHexChar,The following statement contains a magic number: while (o >= p && w != 0)  			{  				dst[o--] = hexchar[w & unchecked((int)(0xf))];  				w = (int)(((uint)w) >> 4);  			}
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,Abbreviate,The following statement contains a magic number: int b = AbbreviatedObjectId.Mask(len' 2' w2);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,Abbreviate,The following statement contains a magic number: int c = AbbreviatedObjectId.Mask(len' 3' w3);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,Abbreviate,The following statement contains a magic number: int d = AbbreviatedObjectId.Mask(len' 4' w4);
Magic Number,NGit,AnyObjectId,C:\repos\mono_ngit\NGit\NGit\AnyObjectId.cs,Abbreviate,The following statement contains a magic number: int e = AbbreviatedObjectId.Mask(len' 5' w5);
Magic Number,NGit,BaseRepositoryBuilder<B;R>,C:\repos\mono_ngit\NGit\NGit\BaseRepositoryBuilder.cs,IsSymRef,The following statement contains a magic number: if (@ref.Length < 9)  			{  				return false;  			}
Magic Number,NGit,BaseRepositoryBuilder<B;R>,C:\repos\mono_ngit\NGit\NGit\BaseRepositoryBuilder.cs,IsSymRef,The following statement contains a magic number: return @ref[0] == 'g' && @ref[1] == 'i' && @ref[2] == 't' && @ref[3] == 'd' && @ref  				[4] == 'i' && @ref[5] == 'r' && @ref[6] == ':' && @ref[7] == ' ';
Magic Number,NGit,BaseRepositoryBuilder<B;R>,C:\repos\mono_ngit\NGit\NGit\BaseRepositoryBuilder.cs,IsSymRef,The following statement contains a magic number: return @ref[0] == 'g' && @ref[1] == 'i' && @ref[2] == 't' && @ref[3] == 'd' && @ref  				[4] == 'i' && @ref[5] == 'r' && @ref[6] == ':' && @ref[7] == ' ';
Magic Number,NGit,BaseRepositoryBuilder<B;R>,C:\repos\mono_ngit\NGit\NGit\BaseRepositoryBuilder.cs,IsSymRef,The following statement contains a magic number: return @ref[0] == 'g' && @ref[1] == 'i' && @ref[2] == 't' && @ref[3] == 'd' && @ref  				[4] == 'i' && @ref[5] == 'r' && @ref[6] == ':' && @ref[7] == ' ';
Magic Number,NGit,BaseRepositoryBuilder<B;R>,C:\repos\mono_ngit\NGit\NGit\BaseRepositoryBuilder.cs,IsSymRef,The following statement contains a magic number: return @ref[0] == 'g' && @ref[1] == 'i' && @ref[2] == 't' && @ref[3] == 'd' && @ref  				[4] == 'i' && @ref[5] == 'r' && @ref[6] == ':' && @ref[7] == ' ';
Magic Number,NGit,BaseRepositoryBuilder<B;R>,C:\repos\mono_ngit\NGit\NGit\BaseRepositoryBuilder.cs,IsSymRef,The following statement contains a magic number: return @ref[0] == 'g' && @ref[1] == 'i' && @ref[2] == 't' && @ref[3] == 'd' && @ref  				[4] == 'i' && @ref[5] == 'r' && @ref[6] == ':' && @ref[7] == ' ';
Magic Number,NGit,BaseRepositoryBuilder<B;R>,C:\repos\mono_ngit\NGit\NGit\BaseRepositoryBuilder.cs,IsSymRef,The following statement contains a magic number: return @ref[0] == 'g' && @ref[1] == 'i' && @ref[2] == 't' && @ref[3] == 'd' && @ref  				[4] == 'i' && @ref[5] == 'r' && @ref[6] == ':' && @ref[7] == ' ';
Magic Number,NGit,BaseRepositoryBuilder<B;R>,C:\repos\mono_ngit\NGit\NGit\BaseRepositoryBuilder.cs,GetSymRef,The following statement contains a magic number: int pathStart = 8;
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,DecodeTypeString,The following statement contains a magic number: try  			{  				int position = offset.value;  				switch (typeString[position])  				{  					case (byte)('b'):  					{  						if (typeString[position + 1] != 'l' || typeString[position + 2] != 'o' || typeString  							[position + 3] != 'b' || typeString[position + 4] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 5;  						return NGit.Constants.OBJ_BLOB;  					}    					case (byte)('c'):  					{  						if (typeString[position + 1] != 'o' || typeString[position + 2] != 'm' || typeString  							[position + 3] != 'm' || typeString[position + 4] != 'i' || typeString[position   							+ 5] != 't' || typeString[position + 6] != endMark)  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  						offset.value = position + 7;  						return NGit.Constants.OBJ_COMMIT;  					}    					case (byte)('t'):  					{  						switch (typeString[position + 1])  						{  							case (byte)('a'):  							{  								if (typeString[position + 2] != 'g' || typeString[position + 3] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 4;  								return NGit.Constants.OBJ_TAG;  							}    							case (byte)('r'):  							{  								if (typeString[position + 2] != 'e' || typeString[position + 3] != 'e' || typeString  									[position + 4] != endMark)  								{  									throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  								}  								offset.value = position + 5;  								return NGit.Constants.OBJ_TREE;  							}    							default:  							{  								throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  							}  						}  						goto default;  					}    					default:  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  					}  				}  			}  			catch (IndexOutOfRangeException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  			}
Magic Number,NGit,Constants,C:\repos\mono_ngit\NGit\NGit\Constants.cs,EncodeASCII,The following statement contains a magic number: for (int k = r.Length - 1; k >= 0; k--)  			{  				char c = s[k];  				if (c > 127)  				{  					throw new ArgumentException(MessageFormat.Format(JGitText.Get().notASCIIString' s  						));  				}  				r[k] = unchecked((byte)c);  			}
Magic Number,NGit,CoreConfig,C:\repos\mono_ngit\NGit\NGit\CoreConfig.cs,CoreConfig,The following statement contains a magic number: packIndexVersion = rc.GetInt(ConfigConstants.CONFIG_PACK_SECTION' ConfigConstants  				.CONFIG_KEY_INDEXVERSION' 2);
Magic Number,NGit,FileMode,C:\repos\mono_ngit\NGit\NGit\FileMode.cs,FileMode,The following statement contains a magic number: if (mode != 0)  			{  				byte[] tmp = new byte[10];  				int p = tmp.Length;  				while (mode != 0)  				{  					tmp[--p] = unchecked((byte)((byte)('0') + (mode & 0x7)));  					mode >>= 3;  				}  				octalBytes = new byte[tmp.Length - p];  				for (int k = 0; k < octalBytes.Length; k++)  				{  					octalBytes[k] = tmp[p + k];  				}  			}  			else  			{  				octalBytes = new byte[] { (byte)('0') };  			}
Magic Number,NGit,FileMode,C:\repos\mono_ngit\NGit\NGit\FileMode.cs,FileMode,The following statement contains a magic number: if (mode != 0)  			{  				byte[] tmp = new byte[10];  				int p = tmp.Length;  				while (mode != 0)  				{  					tmp[--p] = unchecked((byte)((byte)('0') + (mode & 0x7)));  					mode >>= 3;  				}  				octalBytes = new byte[tmp.Length - p];  				for (int k = 0; k < octalBytes.Length; k++)  				{  					octalBytes[k] = tmp[p + k];  				}  			}  			else  			{  				octalBytes = new byte[] { (byte)('0') };  			}
Magic Number,NGit,GitIndex,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: try  			{  				FileOutputStream fileOutputStream = new FileOutputStream(tmpIndex);  				FileChannel fc = fileOutputStream.GetChannel();  				ByteBuffer buf = ByteBuffer.Allocate(4096);  				MessageDigest newMessageDigest = Constants.NewMessageDigest();  				header = new GitIndex.Header(entries);  				header.Write(buf);  				buf.Flip();  				newMessageDigest.Update(((byte[])buf.Array())' buf.ArrayOffset()' buf.Limit());  				fc.Write(buf);  				buf.Flip();  				buf.Clear();  				for (Iterator i = entries.Values.Iterator(); i.HasNext(); )  				{  					GitIndex.Entry e = (GitIndex.Entry)i.Next();  					e.Write(buf);  					buf.Flip();  					newMessageDigest.Update(((byte[])buf.Array())' buf.ArrayOffset()' buf.Limit());  					fc.Write(buf);  					buf.Flip();  					buf.Clear();  				}  				buf.Put(newMessageDigest.Digest());  				buf.Flip();  				fc.Write(buf);  				fc.Close();  				fileOutputStream.Close();  				if (cacheFile.Exists())  				{  					if (db.FileSystem.RetryFailedLockFileCommit())  					{  						// file deletion fails on windows if another  						// thread is reading the file concurrently  						// So let's try 10 times...  						bool deleted = false;  						for (int i_1 = 0; i_1 < 10; i_1++)  						{  							if (cacheFile.Delete())  							{  								deleted = true;  								break;  							}  							try  							{  								Sharpen.Thread.Sleep(100);  							}  							catch (Exception)  							{  							}  						}  						// ignore  						if (!deleted)  						{  							throw new IOException(JGitText.Get().couldNotRenameDeleteOldIndex);  						}  					}  					else  					{  						if (!cacheFile.Delete())  						{  							throw new IOException(JGitText.Get().couldNotRenameDeleteOldIndex);  						}  					}  				}  				if (!tmpIndex.RenameTo(cacheFile))  				{  					throw new IOException(JGitText.Get().couldNotRenameTemporaryIndexFileToIndex);  				}  				changed = false;  				statDirty = false;  				lastCacheTime = cacheFile.LastModified();  				db.FireEvent(new IndexChangedEvent());  			}  			finally  			{  				if (!Lock.Delete())  				{  					throw new IOException(JGitText.Get().couldNotDeleteLockFileShouldNotHappen);  				}  				if (tmpIndex.Exists() && !tmpIndex.Delete())  				{  					throw new IOException(JGitText.Get().couldNotDeleteTemporaryIndexFileShouldNotHappen  						);  				}  			}
Magic Number,NGit,GitIndex,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: try  			{  				FileOutputStream fileOutputStream = new FileOutputStream(tmpIndex);  				FileChannel fc = fileOutputStream.GetChannel();  				ByteBuffer buf = ByteBuffer.Allocate(4096);  				MessageDigest newMessageDigest = Constants.NewMessageDigest();  				header = new GitIndex.Header(entries);  				header.Write(buf);  				buf.Flip();  				newMessageDigest.Update(((byte[])buf.Array())' buf.ArrayOffset()' buf.Limit());  				fc.Write(buf);  				buf.Flip();  				buf.Clear();  				for (Iterator i = entries.Values.Iterator(); i.HasNext(); )  				{  					GitIndex.Entry e = (GitIndex.Entry)i.Next();  					e.Write(buf);  					buf.Flip();  					newMessageDigest.Update(((byte[])buf.Array())' buf.ArrayOffset()' buf.Limit());  					fc.Write(buf);  					buf.Flip();  					buf.Clear();  				}  				buf.Put(newMessageDigest.Digest());  				buf.Flip();  				fc.Write(buf);  				fc.Close();  				fileOutputStream.Close();  				if (cacheFile.Exists())  				{  					if (db.FileSystem.RetryFailedLockFileCommit())  					{  						// file deletion fails on windows if another  						// thread is reading the file concurrently  						// So let's try 10 times...  						bool deleted = false;  						for (int i_1 = 0; i_1 < 10; i_1++)  						{  							if (cacheFile.Delete())  							{  								deleted = true;  								break;  							}  							try  							{  								Sharpen.Thread.Sleep(100);  							}  							catch (Exception)  							{  							}  						}  						// ignore  						if (!deleted)  						{  							throw new IOException(JGitText.Get().couldNotRenameDeleteOldIndex);  						}  					}  					else  					{  						if (!cacheFile.Delete())  						{  							throw new IOException(JGitText.Get().couldNotRenameDeleteOldIndex);  						}  					}  				}  				if (!tmpIndex.RenameTo(cacheFile))  				{  					throw new IOException(JGitText.Get().couldNotRenameTemporaryIndexFileToIndex);  				}  				changed = false;  				statDirty = false;  				lastCacheTime = cacheFile.LastModified();  				db.FireEvent(new IndexChangedEvent());  			}  			finally  			{  				if (!Lock.Delete())  				{  					throw new IOException(JGitText.Get().couldNotDeleteLockFileShouldNotHappen);  				}  				if (tmpIndex.Exists() && !tmpIndex.Delete())  				{  					throw new IOException(JGitText.Get().couldNotDeleteTemporaryIndexFileShouldNotHappen  						);  				}  			}
Magic Number,NGit,GitIndex,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: try  			{  				FileOutputStream fileOutputStream = new FileOutputStream(tmpIndex);  				FileChannel fc = fileOutputStream.GetChannel();  				ByteBuffer buf = ByteBuffer.Allocate(4096);  				MessageDigest newMessageDigest = Constants.NewMessageDigest();  				header = new GitIndex.Header(entries);  				header.Write(buf);  				buf.Flip();  				newMessageDigest.Update(((byte[])buf.Array())' buf.ArrayOffset()' buf.Limit());  				fc.Write(buf);  				buf.Flip();  				buf.Clear();  				for (Iterator i = entries.Values.Iterator(); i.HasNext(); )  				{  					GitIndex.Entry e = (GitIndex.Entry)i.Next();  					e.Write(buf);  					buf.Flip();  					newMessageDigest.Update(((byte[])buf.Array())' buf.ArrayOffset()' buf.Limit());  					fc.Write(buf);  					buf.Flip();  					buf.Clear();  				}  				buf.Put(newMessageDigest.Digest());  				buf.Flip();  				fc.Write(buf);  				fc.Close();  				fileOutputStream.Close();  				if (cacheFile.Exists())  				{  					if (db.FileSystem.RetryFailedLockFileCommit())  					{  						// file deletion fails on windows if another  						// thread is reading the file concurrently  						// So let's try 10 times...  						bool deleted = false;  						for (int i_1 = 0; i_1 < 10; i_1++)  						{  							if (cacheFile.Delete())  							{  								deleted = true;  								break;  							}  							try  							{  								Sharpen.Thread.Sleep(100);  							}  							catch (Exception)  							{  							}  						}  						// ignore  						if (!deleted)  						{  							throw new IOException(JGitText.Get().couldNotRenameDeleteOldIndex);  						}  					}  					else  					{  						if (!cacheFile.Delete())  						{  							throw new IOException(JGitText.Get().couldNotRenameDeleteOldIndex);  						}  					}  				}  				if (!tmpIndex.RenameTo(cacheFile))  				{  					throw new IOException(JGitText.Get().couldNotRenameTemporaryIndexFileToIndex);  				}  				changed = false;  				statDirty = false;  				lastCacheTime = cacheFile.LastModified();  				db.FireEvent(new IndexChangedEvent());  			}  			finally  			{  				if (!Lock.Delete())  				{  					throw new IOException(JGitText.Get().couldNotDeleteLockFileShouldNotHappen);  				}  				if (tmpIndex.Exists() && !tmpIndex.Delete())  				{  					throw new IOException(JGitText.Get().couldNotDeleteTemporaryIndexFileShouldNotHappen  						);  				}  			}
Magic Number,NGit,GitIndex,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,SplitDirPath,The following statement contains a magic number: string[] tmp = new string[name.Length / 2 + 1];
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: this.flags = (short)((stage << 12) | this.name.Length);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: this.flags = (short)((stage << 12) | this.name.Length);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: this.flags = (short)((stage << 12) | this.name.Length);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: b.Position(startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7));
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: b.Position(startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7));
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: b.Position(startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7));
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: b.Position(startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7));
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: b.Position(startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7));
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: b.Position(startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7));
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: b.Position(startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7));
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: b.Position(startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7));
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: b.Position(startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7));
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: b.Position(startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7));
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: b.Position(startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7));
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Entry,The following statement contains a magic number: b.Position(startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7));
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: int end = startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: int end = startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: int end = startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: int end = startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: int end = startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: int end = startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: int end = startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: int end = startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: int end = startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: int end = startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: int end = startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Write,The following statement contains a magic number: int end = startposition + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + this.name.Length  					 + 8) & ~7);
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,IsModified,The following statement contains a magic number: if (javamtime % 1000 == 0)  				{  					lastm = lastm - lastm % 1000;  				}
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,IsModified,The following statement contains a magic number: if (javamtime % 1000 == 0)  				{  					lastm = lastm - lastm % 1000;  				}
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,ToString,The following statement contains a magic number: return this.GetName() + "/SHA-1(" + this.sha1.Name + ")/M:" + Sharpen.Extensions.CreateDate  					(this.ctime / 1000000L) + "/C:" + Sharpen.Extensions.CreateDate(this.mtime / 1000000L  					) + "/d" + this.dev + "/i" + this.ino + "/m" + Sharpen.Extensions.ToString(this.  					mode' 8) + "/u" + this.uid + "/g" + this.gid + "/s" + this.size + "/f" + this.flags  					 + "/@" + this.GetStage();
Magic Number,NGit,Entry,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,GetStage,The following statement contains a magic number: return (this.flags & unchecked((int)(0x3000))) >> 12;
Magic Number,NGit,Header,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Read,The following statement contains a magic number: if (version != 2)  				{  					throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().unknownIndexVersionOrCorruptIndex  						' version));  				}
Magic Number,NGit,Header,C:\repos\mono_ngit\NGit\NGit\GitIndex.cs,Header,The following statement contains a magic number: version = 2;
Magic Number,NGit,IndexDiff,C:\repos\mono_ngit\NGit\NGit\IndexDiff.cs,Diff,The following statement contains a magic number: ICollection<TreeFilter> filters = new AList<TreeFilter>(4);
Magic Number,NGit,IndexDiff,C:\repos\mono_ngit\NGit\NGit\IndexDiff.cs,Diff,The following statement contains a magic number: if (monitor != null)  			{  				// Get the maximum size of the work tree and index  				// and add some (quite arbitrary)  				if (estIndexSize == 0)  				{  					estIndexSize = dirCache.GetEntryCount();  				}  				int total = Math.Max(estIndexSize * 10 / 9' estWorkTreeSize * 10 / 9);  				monitor.BeginTask(title' total);  				filters.AddItem(new IndexDiff.ProgressReportingFilter(monitor' total));  			}
Magic Number,NGit,IndexDiff,C:\repos\mono_ngit\NGit\NGit\IndexDiff.cs,Diff,The following statement contains a magic number: if (monitor != null)  			{  				// Get the maximum size of the work tree and index  				// and add some (quite arbitrary)  				if (estIndexSize == 0)  				{  					estIndexSize = dirCache.GetEntryCount();  				}  				int total = Math.Max(estIndexSize * 10 / 9' estWorkTreeSize * 10 / 9);  				monitor.BeginTask(title' total);  				filters.AddItem(new IndexDiff.ProgressReportingFilter(monitor' total));  			}
Magic Number,NGit,IndexDiff,C:\repos\mono_ngit\NGit\NGit\IndexDiff.cs,Diff,The following statement contains a magic number: if (monitor != null)  			{  				// Get the maximum size of the work tree and index  				// and add some (quite arbitrary)  				if (estIndexSize == 0)  				{  					estIndexSize = dirCache.GetEntryCount();  				}  				int total = Math.Max(estIndexSize * 10 / 9' estWorkTreeSize * 10 / 9);  				monitor.BeginTask(title' total);  				filters.AddItem(new IndexDiff.ProgressReportingFilter(monitor' total));  			}
Magic Number,NGit,IndexDiff,C:\repos\mono_ngit\NGit\NGit\IndexDiff.cs,Diff,The following statement contains a magic number: if (monitor != null)  			{  				// Get the maximum size of the work tree and index  				// and add some (quite arbitrary)  				if (estIndexSize == 0)  				{  					estIndexSize = dirCache.GetEntryCount();  				}  				int total = Math.Max(estIndexSize * 10 / 9' estWorkTreeSize * 10 / 9);  				monitor.BeginTask(title' total);  				filters.AddItem(new IndexDiff.ProgressReportingFilter(monitor' total));  			}
Magic Number,NGit,ProgressReportingFilter,C:\repos\mono_ngit\NGit\NGit\IndexDiff.cs,ProgressReportingFilter,The following statement contains a magic number: stepSize = total / 100;
Magic Number,NGit,ProgressReportingFilter,C:\repos\mono_ngit\NGit\NGit\IndexDiff.cs,ProgressReportingFilter,The following statement contains a magic number: if (stepSize == 0)  				{  					stepSize = 1000;  				}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,SetByte,The following statement contains a magic number: switch (index >> 2)  			{  				case 0:  				{  					w1 = Set(w1' index & 3' value);  					break;  				}    				case 1:  				{  					w2 = Set(w2' index & 3' value);  					break;  				}    				case 2:  				{  					w3 = Set(w3' index & 3' value);  					break;  				}    				case 3:  				{  					w4 = Set(w4' index & 3' value);  					break;  				}    				case 4:  				{  					w5 = Set(w5' index & 3' value);  					break;  				}    				default:  				{  					throw Sharpen.Extensions.CreateIndexOutOfRangeException(index);  				}  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,SetByte,The following statement contains a magic number: switch (index >> 2)  			{  				case 0:  				{  					w1 = Set(w1' index & 3' value);  					break;  				}    				case 1:  				{  					w2 = Set(w2' index & 3' value);  					break;  				}    				case 2:  				{  					w3 = Set(w3' index & 3' value);  					break;  				}    				case 3:  				{  					w4 = Set(w4' index & 3' value);  					break;  				}    				case 4:  				{  					w5 = Set(w5' index & 3' value);  					break;  				}    				default:  				{  					throw Sharpen.Extensions.CreateIndexOutOfRangeException(index);  				}  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,SetByte,The following statement contains a magic number: switch (index >> 2)  			{  				case 0:  				{  					w1 = Set(w1' index & 3' value);  					break;  				}    				case 1:  				{  					w2 = Set(w2' index & 3' value);  					break;  				}    				case 2:  				{  					w3 = Set(w3' index & 3' value);  					break;  				}    				case 3:  				{  					w4 = Set(w4' index & 3' value);  					break;  				}    				case 4:  				{  					w5 = Set(w5' index & 3' value);  					break;  				}    				default:  				{  					throw Sharpen.Extensions.CreateIndexOutOfRangeException(index);  				}  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,SetByte,The following statement contains a magic number: switch (index >> 2)  			{  				case 0:  				{  					w1 = Set(w1' index & 3' value);  					break;  				}    				case 1:  				{  					w2 = Set(w2' index & 3' value);  					break;  				}    				case 2:  				{  					w3 = Set(w3' index & 3' value);  					break;  				}    				case 3:  				{  					w4 = Set(w4' index & 3' value);  					break;  				}    				case 4:  				{  					w5 = Set(w5' index & 3' value);  					break;  				}    				default:  				{  					throw Sharpen.Extensions.CreateIndexOutOfRangeException(index);  				}  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,SetByte,The following statement contains a magic number: switch (index >> 2)  			{  				case 0:  				{  					w1 = Set(w1' index & 3' value);  					break;  				}    				case 1:  				{  					w2 = Set(w2' index & 3' value);  					break;  				}    				case 2:  				{  					w3 = Set(w3' index & 3' value);  					break;  				}    				case 3:  				{  					w4 = Set(w4' index & 3' value);  					break;  				}    				case 4:  				{  					w5 = Set(w5' index & 3' value);  					break;  				}    				default:  				{  					throw Sharpen.Extensions.CreateIndexOutOfRangeException(index);  				}  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,SetByte,The following statement contains a magic number: switch (index >> 2)  			{  				case 0:  				{  					w1 = Set(w1' index & 3' value);  					break;  				}    				case 1:  				{  					w2 = Set(w2' index & 3' value);  					break;  				}    				case 2:  				{  					w3 = Set(w3' index & 3' value);  					break;  				}    				case 3:  				{  					w4 = Set(w4' index & 3' value);  					break;  				}    				case 4:  				{  					w5 = Set(w5' index & 3' value);  					break;  				}    				default:  				{  					throw Sharpen.Extensions.CreateIndexOutOfRangeException(index);  				}  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,SetByte,The following statement contains a magic number: switch (index >> 2)  			{  				case 0:  				{  					w1 = Set(w1' index & 3' value);  					break;  				}    				case 1:  				{  					w2 = Set(w2' index & 3' value);  					break;  				}    				case 2:  				{  					w3 = Set(w3' index & 3' value);  					break;  				}    				case 3:  				{  					w4 = Set(w4' index & 3' value);  					break;  				}    				case 4:  				{  					w5 = Set(w5' index & 3' value);  					break;  				}    				default:  				{  					throw Sharpen.Extensions.CreateIndexOutOfRangeException(index);  				}  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,SetByte,The following statement contains a magic number: switch (index >> 2)  			{  				case 0:  				{  					w1 = Set(w1' index & 3' value);  					break;  				}    				case 1:  				{  					w2 = Set(w2' index & 3' value);  					break;  				}    				case 2:  				{  					w3 = Set(w3' index & 3' value);  					break;  				}    				case 3:  				{  					w4 = Set(w4' index & 3' value);  					break;  				}    				case 4:  				{  					w5 = Set(w5' index & 3' value);  					break;  				}    				default:  				{  					throw Sharpen.Extensions.CreateIndexOutOfRangeException(index);  				}  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,SetByte,The following statement contains a magic number: switch (index >> 2)  			{  				case 0:  				{  					w1 = Set(w1' index & 3' value);  					break;  				}    				case 1:  				{  					w2 = Set(w2' index & 3' value);  					break;  				}    				case 2:  				{  					w3 = Set(w3' index & 3' value);  					break;  				}    				case 3:  				{  					w4 = Set(w4' index & 3' value);  					break;  				}    				case 4:  				{  					w5 = Set(w5' index & 3' value);  					break;  				}    				default:  				{  					throw Sharpen.Extensions.CreateIndexOutOfRangeException(index);  				}  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,Set,The following statement contains a magic number: switch (index)  			{  				case 0:  				{  					return (w & unchecked((int)(0x00ffffff))) | (value << 24);  				}    				case 1:  				{  					return (w & unchecked((int)(0xff00ffff))) | (value << 16);  				}    				case 2:  				{  					return (w & unchecked((int)(0xffff00ff))) | (value << 8);  				}    				case 3:  				{  					return (w & unchecked((int)(0xffffff00))) | value;  				}    				default:  				{  					throw new IndexOutOfRangeException();  				}  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,Set,The following statement contains a magic number: switch (index)  			{  				case 0:  				{  					return (w & unchecked((int)(0x00ffffff))) | (value << 24);  				}    				case 1:  				{  					return (w & unchecked((int)(0xff00ffff))) | (value << 16);  				}    				case 2:  				{  					return (w & unchecked((int)(0xffff00ff))) | (value << 8);  				}    				case 3:  				{  					return (w & unchecked((int)(0xffffff00))) | value;  				}    				default:  				{  					throw new IndexOutOfRangeException();  				}  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,Set,The following statement contains a magic number: switch (index)  			{  				case 0:  				{  					return (w & unchecked((int)(0x00ffffff))) | (value << 24);  				}    				case 1:  				{  					return (w & unchecked((int)(0xff00ffff))) | (value << 16);  				}    				case 2:  				{  					return (w & unchecked((int)(0xffff00ff))) | (value << 8);  				}    				case 3:  				{  					return (w & unchecked((int)(0xffffff00))) | value;  				}    				default:  				{  					throw new IndexOutOfRangeException();  				}  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,Set,The following statement contains a magic number: switch (index)  			{  				case 0:  				{  					return (w & unchecked((int)(0x00ffffff))) | (value << 24);  				}    				case 1:  				{  					return (w & unchecked((int)(0xff00ffff))) | (value << 16);  				}    				case 2:  				{  					return (w & unchecked((int)(0xffff00ff))) | (value << 8);  				}    				case 3:  				{  					return (w & unchecked((int)(0xffffff00))) | value;  				}    				default:  				{  					throw new IndexOutOfRangeException();  				}  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,Set,The following statement contains a magic number: switch (index)  			{  				case 0:  				{  					return (w & unchecked((int)(0x00ffffff))) | (value << 24);  				}    				case 1:  				{  					return (w & unchecked((int)(0xff00ffff))) | (value << 16);  				}    				case 2:  				{  					return (w & unchecked((int)(0xffff00ff))) | (value << 8);  				}    				case 3:  				{  					return (w & unchecked((int)(0xffffff00))) | value;  				}    				default:  				{  					throw new IndexOutOfRangeException();  				}  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,FromRaw,The following statement contains a magic number: w2 = NB.DecodeInt32(bs' p + 4);
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,FromRaw,The following statement contains a magic number: w3 = NB.DecodeInt32(bs' p + 8);
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,FromRaw,The following statement contains a magic number: w4 = NB.DecodeInt32(bs' p + 12);
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,FromRaw,The following statement contains a magic number: w5 = NB.DecodeInt32(bs' p + 16);
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,FromRaw,The following statement contains a magic number: w3 = ints[p + 2];
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,FromRaw,The following statement contains a magic number: w4 = ints[p + 3];
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,FromRaw,The following statement contains a magic number: w5 = ints[p + 4];
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				w1 = RawParseUtils.ParseHexInt32(bs' p);  				w2 = RawParseUtils.ParseHexInt32(bs' p + 8);  				w3 = RawParseUtils.ParseHexInt32(bs' p + 16);  				w4 = RawParseUtils.ParseHexInt32(bs' p + 24);  				w5 = RawParseUtils.ParseHexInt32(bs' p + 32);  			}  			catch (IndexOutOfRangeException)  			{  				throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH);  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				w1 = RawParseUtils.ParseHexInt32(bs' p);  				w2 = RawParseUtils.ParseHexInt32(bs' p + 8);  				w3 = RawParseUtils.ParseHexInt32(bs' p + 16);  				w4 = RawParseUtils.ParseHexInt32(bs' p + 24);  				w5 = RawParseUtils.ParseHexInt32(bs' p + 32);  			}  			catch (IndexOutOfRangeException)  			{  				throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH);  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				w1 = RawParseUtils.ParseHexInt32(bs' p);  				w2 = RawParseUtils.ParseHexInt32(bs' p + 8);  				w3 = RawParseUtils.ParseHexInt32(bs' p + 16);  				w4 = RawParseUtils.ParseHexInt32(bs' p + 24);  				w5 = RawParseUtils.ParseHexInt32(bs' p + 32);  			}  			catch (IndexOutOfRangeException)  			{  				throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH);  			}
Magic Number,NGit,MutableObjectId,C:\repos\mono_ngit\NGit\NGit\MutableObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				w1 = RawParseUtils.ParseHexInt32(bs' p);  				w2 = RawParseUtils.ParseHexInt32(bs' p + 8);  				w3 = RawParseUtils.ParseHexInt32(bs' p + 16);  				w4 = RawParseUtils.ParseHexInt32(bs' p + 24);  				w5 = RawParseUtils.ParseHexInt32(bs' p + 32);  			}  			catch (IndexOutOfRangeException)  			{  				throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH);  			}
Magic Number,NGit,ObjectChecker,C:\repos\mono_ngit\NGit\NGit\ObjectChecker.cs,DuplicateName,The following statement contains a magic number: for (; ; )  			{  				int nextMode = 0;  				for (; ; )  				{  					if (nextPtr >= sz)  					{  						return false;  					}  					byte c = raw[nextPtr++];  					if (' ' == c)  					{  						break;  					}  					nextMode <<= 3;  					nextMode += c - '0';  				}  				int nextNamePos = nextPtr;  				for (; ; )  				{  					if (nextPtr == sz)  					{  						return false;  					}  					byte c = raw[nextPtr++];  					if (c == 0)  					{  						break;  					}  				}  				if (nextNamePos + 1 == nextPtr)  				{  					return false;  				}  				int cmp = PathCompare(raw' thisNamePos' thisNameEnd' FileMode.TREE.GetBits()' nextNamePos  					' nextPtr - 1' nextMode);  				if (cmp < 0)  				{  					return false;  				}  				else  				{  					if (cmp == 0)  					{  						return true;  					}  				}  				nextPtr += Constants.OBJECT_ID_LENGTH;  			}
Magic Number,NGit,ObjectChecker,C:\repos\mono_ngit\NGit\NGit\ObjectChecker.cs,CheckTree,The following statement contains a magic number: while (ptr < sz)  			{  				int thisMode = 0;  				for (; ; )  				{  					if (ptr == sz)  					{  						throw new CorruptObjectException("truncated in mode");  					}  					byte c = raw[ptr++];  					if (' ' == c)  					{  						break;  					}  					if (((sbyte)c) < '0' || c > '7')  					{  						throw new CorruptObjectException("invalid mode character");  					}  					if (thisMode == 0 && c == '0')  					{  						throw new CorruptObjectException("mode starts with '0'");  					}  					thisMode <<= 3;  					thisMode += c - '0';  				}  				if (FileMode.FromBits(thisMode).GetObjectType() == Constants.OBJ_BAD)  				{  					throw new CorruptObjectException("invalid mode " + thisMode);  				}  				int thisNameB = ptr;  				for (; ; )  				{  					if (ptr == sz)  					{  						throw new CorruptObjectException("truncated in name");  					}  					byte c = raw[ptr++];  					if (c == 0)  					{  						break;  					}  					if (c == '/')  					{  						throw new CorruptObjectException("name contains '/'");  					}  				}  				if (thisNameB + 1 == ptr)  				{  					throw new CorruptObjectException("zero length name");  				}  				if (raw[thisNameB] == '.')  				{  					int nameLen = (ptr - 1) - thisNameB;  					if (nameLen == 1)  					{  						throw new CorruptObjectException("invalid name '.'");  					}  					if (nameLen == 2 && raw[thisNameB + 1] == '.')  					{  						throw new CorruptObjectException("invalid name '..'");  					}  				}  				if (DuplicateName(raw' thisNameB' ptr - 1))  				{  					throw new CorruptObjectException("duplicate entry names");  				}  				if (lastNameB != 0)  				{  					int cmp = PathCompare(raw' lastNameB' lastNameE' lastMode' thisNameB' ptr - 1' thisMode  						);  					if (cmp > 0)  					{  						throw new CorruptObjectException("incorrectly sorted");  					}  				}  				lastNameB = thisNameB;  				lastNameE = ptr - 1;  				lastMode = thisMode;  				ptr += Constants.OBJECT_ID_LENGTH;  				if (ptr > sz)  				{  					throw new CorruptObjectException("truncated in object id");  				}  			}
Magic Number,NGit,ObjectChecker,C:\repos\mono_ngit\NGit\NGit\ObjectChecker.cs,CheckTree,The following statement contains a magic number: while (ptr < sz)  			{  				int thisMode = 0;  				for (; ; )  				{  					if (ptr == sz)  					{  						throw new CorruptObjectException("truncated in mode");  					}  					byte c = raw[ptr++];  					if (' ' == c)  					{  						break;  					}  					if (((sbyte)c) < '0' || c > '7')  					{  						throw new CorruptObjectException("invalid mode character");  					}  					if (thisMode == 0 && c == '0')  					{  						throw new CorruptObjectException("mode starts with '0'");  					}  					thisMode <<= 3;  					thisMode += c - '0';  				}  				if (FileMode.FromBits(thisMode).GetObjectType() == Constants.OBJ_BAD)  				{  					throw new CorruptObjectException("invalid mode " + thisMode);  				}  				int thisNameB = ptr;  				for (; ; )  				{  					if (ptr == sz)  					{  						throw new CorruptObjectException("truncated in name");  					}  					byte c = raw[ptr++];  					if (c == 0)  					{  						break;  					}  					if (c == '/')  					{  						throw new CorruptObjectException("name contains '/'");  					}  				}  				if (thisNameB + 1 == ptr)  				{  					throw new CorruptObjectException("zero length name");  				}  				if (raw[thisNameB] == '.')  				{  					int nameLen = (ptr - 1) - thisNameB;  					if (nameLen == 1)  					{  						throw new CorruptObjectException("invalid name '.'");  					}  					if (nameLen == 2 && raw[thisNameB + 1] == '.')  					{  						throw new CorruptObjectException("invalid name '..'");  					}  				}  				if (DuplicateName(raw' thisNameB' ptr - 1))  				{  					throw new CorruptObjectException("duplicate entry names");  				}  				if (lastNameB != 0)  				{  					int cmp = PathCompare(raw' lastNameB' lastNameE' lastMode' thisNameB' ptr - 1' thisMode  						);  					if (cmp > 0)  					{  						throw new CorruptObjectException("incorrectly sorted");  					}  				}  				lastNameB = thisNameB;  				lastNameE = ptr - 1;  				lastMode = thisMode;  				ptr += Constants.OBJECT_ID_LENGTH;  				if (ptr > sz)  				{  					throw new CorruptObjectException("truncated in object id");  				}  			}
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si] && firstBuffer[fi + 1] == secondBuffer  				[si + 1] && firstBuffer[fi + 2] == secondBuffer[si + 2] && firstBuffer[fi + 3] ==  				 secondBuffer[si + 3] && firstBuffer[fi + 4] == secondBuffer[si + 4] && firstBuffer  				[fi + 5] == secondBuffer[si + 5] && firstBuffer[fi + 6] == secondBuffer[si + 6]   				&& firstBuffer[fi + 7] == secondBuffer[si + 7] && firstBuffer[fi + 8] == secondBuffer  				[si + 8] && firstBuffer[fi + 9] == secondBuffer[si + 9] && firstBuffer[fi + 10]   				== secondBuffer[si + 10] && firstBuffer[fi + 11] == secondBuffer[si + 11] && firstBuffer  				[fi + 12] == secondBuffer[si + 12] && firstBuffer[fi + 13] == secondBuffer[si +   				13] && firstBuffer[fi + 14] == secondBuffer[si + 14] && firstBuffer[fi + 15] ==   				secondBuffer[si + 15] && firstBuffer[fi + 16] == secondBuffer[si + 16] && firstBuffer  				[fi + 17] == secondBuffer[si + 17] && firstBuffer[fi + 18] == secondBuffer[si +   				18] && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,FromRaw,The following statement contains a magic number: int b = NB.DecodeInt32(bs' p + 4);
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,FromRaw,The following statement contains a magic number: int c = NB.DecodeInt32(bs' p + 8);
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,FromRaw,The following statement contains a magic number: int d = NB.DecodeInt32(bs' p + 12);
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,FromRaw,The following statement contains a magic number: int e = NB.DecodeInt32(bs' p + 16);
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,FromRaw,The following statement contains a magic number: return new NGit.ObjectId(@is[p]' @is[p + 1]' @is[p + 2]' @is[p + 3]' @is[p + 4]);
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,FromRaw,The following statement contains a magic number: return new NGit.ObjectId(@is[p]' @is[p + 1]' @is[p + 2]' @is[p + 3]' @is[p + 4]);
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,FromRaw,The following statement contains a magic number: return new NGit.ObjectId(@is[p]' @is[p + 1]' @is[p + 2]' @is[p + 3]' @is[p + 4]);
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = RawParseUtils.ParseHexInt32(bs' p);  				int b = RawParseUtils.ParseHexInt32(bs' p + 8);  				int c = RawParseUtils.ParseHexInt32(bs' p + 16);  				int d = RawParseUtils.ParseHexInt32(bs' p + 24);  				int e = RawParseUtils.ParseHexInt32(bs' p + 32);  				return new NGit.ObjectId(a' b' c' d' e);  			}  			catch (IndexOutOfRangeException)  			{  				throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH);  			}
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = RawParseUtils.ParseHexInt32(bs' p);  				int b = RawParseUtils.ParseHexInt32(bs' p + 8);  				int c = RawParseUtils.ParseHexInt32(bs' p + 16);  				int d = RawParseUtils.ParseHexInt32(bs' p + 24);  				int e = RawParseUtils.ParseHexInt32(bs' p + 32);  				return new NGit.ObjectId(a' b' c' d' e);  			}  			catch (IndexOutOfRangeException)  			{  				throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH);  			}
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = RawParseUtils.ParseHexInt32(bs' p);  				int b = RawParseUtils.ParseHexInt32(bs' p + 8);  				int c = RawParseUtils.ParseHexInt32(bs' p + 16);  				int d = RawParseUtils.ParseHexInt32(bs' p + 24);  				int e = RawParseUtils.ParseHexInt32(bs' p + 32);  				return new NGit.ObjectId(a' b' c' d' e);  			}  			catch (IndexOutOfRangeException)  			{  				throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH);  			}
Magic Number,NGit,ObjectId,C:\repos\mono_ngit\NGit\NGit\ObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = RawParseUtils.ParseHexInt32(bs' p);  				int b = RawParseUtils.ParseHexInt32(bs' p + 8);  				int c = RawParseUtils.ParseHexInt32(bs' p + 16);  				int d = RawParseUtils.ParseHexInt32(bs' p + 24);  				int e = RawParseUtils.ParseHexInt32(bs' p + 32);  				return new NGit.ObjectId(a' b' c' d' e);  			}  			catch (IndexOutOfRangeException)  			{  				throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH);  			}
Magic Number,NGit,ObjectInserter,C:\repos\mono_ngit\NGit\NGit\ObjectInserter.cs,Buffer,The following statement contains a magic number: if (b == null)  			{  				tempBuffer = b = new byte[8192];  			}
Magic Number,NGit,ObjectLoader,C:\repos\mono_ngit\NGit\NGit\ObjectLoader.cs,CopyTo,The following statement contains a magic number: if (IsLarge())  			{  				ObjectStream @in = OpenStream();  				try  				{  					long sz = @in.GetSize();  					byte[] tmp = new byte[8192];  					long copied = 0;  					while (copied < sz)  					{  						int n = @in.Read(tmp);  						if (n < 0)  						{  							throw new EOFException();  						}  						@out.Write(tmp' 0' n);  						copied += n;  					}  					if (0 <= @in.Read())  					{  						throw new EOFException();  					}  				}  				finally  				{  					@in.Close();  				}  			}  			else  			{  				@out.Write(GetCachedBytes());  			}
Magic Number,NGit,ObjectReader,C:\repos\mono_ngit\NGit\NGit\ObjectReader.cs,Abbreviate,The following statement contains a magic number: return Abbreviate(objectId' 7);
Magic Number,NGit,ObjectReader,C:\repos\mono_ngit\NGit\NGit\ObjectReader.cs,Abbreviate,The following statement contains a magic number: while (1 < matches.Count && len < Constants.OBJECT_ID_STRING_LENGTH)  			{  				abbrev = objectId.Abbreviate(++len);  				IList<ObjectId> n = new AList<ObjectId>(8);  				foreach (ObjectId candidate in matches)  				{  					if (abbrev.PrefixCompare(candidate) == 0)  					{  						n.AddItem(candidate);  					}  				}  				if (1 < n.Count)  				{  					matches = n;  				}  				else  				{  					matches = Resolve(abbrev);  				}  			}
Magic Number,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,GetTimeZone,The following statement contains a magic number: StringBuilder tzId = new StringBuilder(8);
Magic Number,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,GetHashCode,The following statement contains a magic number: hc *= 31;
Magic Number,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,ToExternalString,The following statement contains a magic number: r.Append(when / 1000);
Magic Number,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,AppendTimezone,The following statement contains a magic number: offsetHours = offset / 60;
Magic Number,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,AppendTimezone,The following statement contains a magic number: offsetMins = offset % 60;
Magic Number,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,AppendTimezone,The following statement contains a magic number: if (offsetHours < 10)  			{  				r.Append('0');  			}
Magic Number,NGit,PersonIdent,C:\repos\mono_ngit\NGit\NGit\PersonIdent.cs,AppendTimezone,The following statement contains a magic number: if (offsetMins < 10)  			{  				r.Append('0');  			}
Magic Number,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revChars.Length; ++i)  			{  				switch (revChars[i])  				{  					case '^':  					{  						if (rev == null)  						{  							if (name == null)  							{  								if (done == 0)  								{  									name = new string(revChars' done' i);  								}  								else  								{  									done = i + 1;  									break;  								}  							}  							rev = ParseSimple(rw' name);  							name = null;  							if (rev == null)  							{  								return null;  							}  						}  						if (i + 1 < revChars.Length)  						{  							switch (revChars[i + 1])  							{  								case '0':  								case '1':  								case '2':  								case '3':  								case '4':  								case '5':  								case '6':  								case '7':  								case '8':  								case '9':  								{  									int j;  									rev = rw.ParseCommit(rev);  									for (j = i + 1; j < revChars.Length; ++j)  									{  										if (!char.IsDigit(revChars[j]))  										{  											break;  										}  									}  									string parentnum = new string(revChars' i + 1' j - i - 1);  									int pnum;  									try  									{  										pnum = System.Convert.ToInt32(parentnum);  									}  									catch (FormatException)  									{  										throw new RevisionSyntaxException(JGitText.Get().invalidCommitParentNumber' revstr  											);  									}  									if (pnum != 0)  									{  										RevCommit commit = (RevCommit)rev;  										if (pnum > commit.ParentCount)  										{  											rev = null;  										}  										else  										{  											rev = commit.GetParent(pnum - 1);  										}  									}  									i = j - 1;  									done = j;  									break;  								}    								case '{':  								{  									int k;  									string item = null;  									for (k = i + 2; k < revChars.Length; ++k)  									{  										if (revChars[k] == '}')  										{  											item = new string(revChars' i + 2' k - i - 2);  											break;  										}  									}  									i = k;  									if (item != null)  									{  										if (item.Equals("tree"))  										{  											rev = rw.ParseTree(rev);  										}  										else  										{  											if (item.Equals("commit"))  											{  												rev = rw.ParseCommit(rev);  											}  											else  											{  												if (item.Equals("blob"))  												{  													rev = rw.Peel(rev);  													if (!(rev is RevBlob))  													{  														throw new IncorrectObjectTypeException(rev' Constants.TYPE_BLOB);  													}  												}  												else  												{  													if (item.Equals(string.Empty))  													{  														rev = rw.Peel(rev);  													}  													else  													{  														throw new RevisionSyntaxException(revstr);  													}  												}  											}  										}  									}  									else  									{  										throw new RevisionSyntaxException(revstr);  									}  									done = k;  									break;  								}    								default:  								{  									rev = rw.ParseAny(rev);  									if (rev is RevCommit)  									{  										RevCommit commit = ((RevCommit)rev);  										if (commit.ParentCount == 0)  										{  											rev = null;  										}  										else  										{  											rev = commit.GetParent(0);  										}  									}  									else  									{  										throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  									}  									break;  								}  							}  						}  						else  						{  							rev = rw.Peel(rev);  							if (rev is RevCommit)  							{  								RevCommit commit = ((RevCommit)rev);  								if (commit.ParentCount == 0)  								{  									rev = null;  								}  								else  								{  									rev = commit.GetParent(0);  								}  							}  							else  							{  								throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  							}  						}  						done = i + 1;  						break;  					}    					case '~':  					{  						if (rev == null)  						{  							if (name == null)  							{  								if (done == 0)  								{  									name = new string(revChars' done' i);  								}  								else  								{  									done = i + 1;  									break;  								}  							}  							rev = ParseSimple(rw' name);  							name = null;  							if (rev == null)  							{  								return null;  							}  						}  						rev = rw.Peel(rev);  						if (!(rev is RevCommit))  						{  							throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  						}  						int l;  						for (l = i + 1; l < revChars.Length; ++l)  						{  							if (!char.IsDigit(revChars[l]))  							{  								break;  							}  						}  						int dist;  						if (l - i > 1)  						{  							string distnum = new string(revChars' i + 1' l - i - 1);  							try  							{  								dist = System.Convert.ToInt32(distnum);  							}  							catch (FormatException)  							{  								throw new RevisionSyntaxException(JGitText.Get().invalidAncestryLength' revstr);  							}  						}  						else  						{  							dist = 1;  						}  						while (dist > 0)  						{  							RevCommit commit = (RevCommit)rev;  							if (commit.ParentCount == 0)  							{  								rev = null;  								break;  							}  							commit = commit.GetParent(0);  							rw.ParseHeaders(commit);  							rev = commit;  							--dist;  						}  						i = l - 1;  						done = l;  						break;  					}    					case '@':  					{  						if (rev != null)  						{  							throw new RevisionSyntaxException(revstr);  						}  						if (i + 1 < revChars.Length && revChars[i + 1] != '{')  						{  							continue;  						}  						int m;  						string time = null;  						for (m = i + 2; m < revChars.Length; ++m)  						{  							if (revChars[m] == '}')  							{  								time = new string(revChars' i + 2' m - i - 2);  								break;  							}  						}  						if (time != null)  						{  							if (time.Equals("upstream"))  							{  								if (name == null)  								{  									name = new string(revChars' done' i);  								}  								if (name.Equals(string.Empty))  								{  									// Currently checked out branch' HEAD if  									// detached  									name = Constants.HEAD;  								}  								if (!NGit.Repository.IsValidRefName("x/" + name))  								{  									throw new RevisionSyntaxException(revstr);  								}  								Ref @ref = GetRef(name);  								name = null;  								if (@ref == null)  								{  									return null;  								}  								if (@ref.IsSymbolic())  								{  									@ref = @ref.GetLeaf();  								}  								name = @ref.GetName();  								RemoteConfig remoteConfig;  								try  								{  									remoteConfig = new RemoteConfig(GetConfig()' "origin");  								}  								catch (URISyntaxException)  								{  									throw new RevisionSyntaxException(revstr);  								}  								string remoteBranchName = GetConfig().GetString(ConfigConstants.CONFIG_BRANCH_SECTION  									' NGit.Repository.ShortenRefName(@ref.GetName())' ConfigConstants.CONFIG_KEY_MERGE  									);  								IList<RefSpec> fetchRefSpecs = remoteConfig.FetchRefSpecs;  								foreach (RefSpec refSpec in fetchRefSpecs)  								{  									if (refSpec.MatchSource(remoteBranchName))  									{  										RefSpec expandFromSource = refSpec.ExpandFromSource(remoteBranchName);  										name = expandFromSource.GetDestination();  										break;  									}  								}  								if (name == null)  								{  									throw new RevisionSyntaxException(revstr);  								}  							}  							else  							{  								if (time.Matches("^-\\d+$"))  								{  									if (name != null)  									{  										throw new RevisionSyntaxException(revstr);  									}  									else  									{  										string previousCheckout = ResolveReflogCheckout(-System.Convert.ToInt32(time));  										if (ObjectId.IsId(previousCheckout))  										{  											rev = ParseSimple(rw' previousCheckout);  										}  										else  										{  											name = previousCheckout;  										}  									}  								}  								else  								{  									if (name == null)  									{  										name = new string(revChars' done' i);  									}  									if (name.Equals(string.Empty))  									{  										name = Constants.HEAD;  									}  									if (!NGit.Repository.IsValidRefName("x/" + name))  									{  										throw new RevisionSyntaxException(revstr);  									}  									Ref @ref = GetRef(name);  									name = null;  									if (@ref == null)  									{  										return null;  									}  									// @{n} means current branch' not HEAD@{1} unless  									// detached  									if (@ref.IsSymbolic())  									{  										@ref = @ref.GetLeaf();  									}  									rev = ResolveReflog(rw' @ref' time);  								}  							}  							i = m;  						}  						else  						{  							throw new RevisionSyntaxException(revstr);  						}  						break;  					}    					case ':':  					{  						RevTree tree;  						if (rev == null)  						{  							if (name == null)  							{  								name = new string(revChars' done' i);  							}  							if (name.Equals(string.Empty))  							{  								name = Constants.HEAD;  							}  							rev = ParseSimple(rw' name);  							name = null;  						}  						if (rev == null)  						{  							return null;  						}  						tree = rw.ParseTree(rev);  						if (i == revChars.Length - 1)  						{  							return tree.Copy();  						}  						TreeWalk tw = TreeWalk.ForPath(rw.GetObjectReader()' new string(revChars' i + 1'   							revChars.Length - i - 1)' tree);  						return tw != null ? tw.GetObjectId(0) : null;  					}    					default:  					{  						if (rev != null)  						{  							throw new RevisionSyntaxException(revstr);  						}  						break;  					}  				}  			}
Magic Number,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revChars.Length; ++i)  			{  				switch (revChars[i])  				{  					case '^':  					{  						if (rev == null)  						{  							if (name == null)  							{  								if (done == 0)  								{  									name = new string(revChars' done' i);  								}  								else  								{  									done = i + 1;  									break;  								}  							}  							rev = ParseSimple(rw' name);  							name = null;  							if (rev == null)  							{  								return null;  							}  						}  						if (i + 1 < revChars.Length)  						{  							switch (revChars[i + 1])  							{  								case '0':  								case '1':  								case '2':  								case '3':  								case '4':  								case '5':  								case '6':  								case '7':  								case '8':  								case '9':  								{  									int j;  									rev = rw.ParseCommit(rev);  									for (j = i + 1; j < revChars.Length; ++j)  									{  										if (!char.IsDigit(revChars[j]))  										{  											break;  										}  									}  									string parentnum = new string(revChars' i + 1' j - i - 1);  									int pnum;  									try  									{  										pnum = System.Convert.ToInt32(parentnum);  									}  									catch (FormatException)  									{  										throw new RevisionSyntaxException(JGitText.Get().invalidCommitParentNumber' revstr  											);  									}  									if (pnum != 0)  									{  										RevCommit commit = (RevCommit)rev;  										if (pnum > commit.ParentCount)  										{  											rev = null;  										}  										else  										{  											rev = commit.GetParent(pnum - 1);  										}  									}  									i = j - 1;  									done = j;  									break;  								}    								case '{':  								{  									int k;  									string item = null;  									for (k = i + 2; k < revChars.Length; ++k)  									{  										if (revChars[k] == '}')  										{  											item = new string(revChars' i + 2' k - i - 2);  											break;  										}  									}  									i = k;  									if (item != null)  									{  										if (item.Equals("tree"))  										{  											rev = rw.ParseTree(rev);  										}  										else  										{  											if (item.Equals("commit"))  											{  												rev = rw.ParseCommit(rev);  											}  											else  											{  												if (item.Equals("blob"))  												{  													rev = rw.Peel(rev);  													if (!(rev is RevBlob))  													{  														throw new IncorrectObjectTypeException(rev' Constants.TYPE_BLOB);  													}  												}  												else  												{  													if (item.Equals(string.Empty))  													{  														rev = rw.Peel(rev);  													}  													else  													{  														throw new RevisionSyntaxException(revstr);  													}  												}  											}  										}  									}  									else  									{  										throw new RevisionSyntaxException(revstr);  									}  									done = k;  									break;  								}    								default:  								{  									rev = rw.ParseAny(rev);  									if (rev is RevCommit)  									{  										RevCommit commit = ((RevCommit)rev);  										if (commit.ParentCount == 0)  										{  											rev = null;  										}  										else  										{  											rev = commit.GetParent(0);  										}  									}  									else  									{  										throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  									}  									break;  								}  							}  						}  						else  						{  							rev = rw.Peel(rev);  							if (rev is RevCommit)  							{  								RevCommit commit = ((RevCommit)rev);  								if (commit.ParentCount == 0)  								{  									rev = null;  								}  								else  								{  									rev = commit.GetParent(0);  								}  							}  							else  							{  								throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  							}  						}  						done = i + 1;  						break;  					}    					case '~':  					{  						if (rev == null)  						{  							if (name == null)  							{  								if (done == 0)  								{  									name = new string(revChars' done' i);  								}  								else  								{  									done = i + 1;  									break;  								}  							}  							rev = ParseSimple(rw' name);  							name = null;  							if (rev == null)  							{  								return null;  							}  						}  						rev = rw.Peel(rev);  						if (!(rev is RevCommit))  						{  							throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  						}  						int l;  						for (l = i + 1; l < revChars.Length; ++l)  						{  							if (!char.IsDigit(revChars[l]))  							{  								break;  							}  						}  						int dist;  						if (l - i > 1)  						{  							string distnum = new string(revChars' i + 1' l - i - 1);  							try  							{  								dist = System.Convert.ToInt32(distnum);  							}  							catch (FormatException)  							{  								throw new RevisionSyntaxException(JGitText.Get().invalidAncestryLength' revstr);  							}  						}  						else  						{  							dist = 1;  						}  						while (dist > 0)  						{  							RevCommit commit = (RevCommit)rev;  							if (commit.ParentCount == 0)  							{  								rev = null;  								break;  							}  							commit = commit.GetParent(0);  							rw.ParseHeaders(commit);  							rev = commit;  							--dist;  						}  						i = l - 1;  						done = l;  						break;  					}    					case '@':  					{  						if (rev != null)  						{  							throw new RevisionSyntaxException(revstr);  						}  						if (i + 1 < revChars.Length && revChars[i + 1] != '{')  						{  							continue;  						}  						int m;  						string time = null;  						for (m = i + 2; m < revChars.Length; ++m)  						{  							if (revChars[m] == '}')  							{  								time = new string(revChars' i + 2' m - i - 2);  								break;  							}  						}  						if (time != null)  						{  							if (time.Equals("upstream"))  							{  								if (name == null)  								{  									name = new string(revChars' done' i);  								}  								if (name.Equals(string.Empty))  								{  									// Currently checked out branch' HEAD if  									// detached  									name = Constants.HEAD;  								}  								if (!NGit.Repository.IsValidRefName("x/" + name))  								{  									throw new RevisionSyntaxException(revstr);  								}  								Ref @ref = GetRef(name);  								name = null;  								if (@ref == null)  								{  									return null;  								}  								if (@ref.IsSymbolic())  								{  									@ref = @ref.GetLeaf();  								}  								name = @ref.GetName();  								RemoteConfig remoteConfig;  								try  								{  									remoteConfig = new RemoteConfig(GetConfig()' "origin");  								}  								catch (URISyntaxException)  								{  									throw new RevisionSyntaxException(revstr);  								}  								string remoteBranchName = GetConfig().GetString(ConfigConstants.CONFIG_BRANCH_SECTION  									' NGit.Repository.ShortenRefName(@ref.GetName())' ConfigConstants.CONFIG_KEY_MERGE  									);  								IList<RefSpec> fetchRefSpecs = remoteConfig.FetchRefSpecs;  								foreach (RefSpec refSpec in fetchRefSpecs)  								{  									if (refSpec.MatchSource(remoteBranchName))  									{  										RefSpec expandFromSource = refSpec.ExpandFromSource(remoteBranchName);  										name = expandFromSource.GetDestination();  										break;  									}  								}  								if (name == null)  								{  									throw new RevisionSyntaxException(revstr);  								}  							}  							else  							{  								if (time.Matches("^-\\d+$"))  								{  									if (name != null)  									{  										throw new RevisionSyntaxException(revstr);  									}  									else  									{  										string previousCheckout = ResolveReflogCheckout(-System.Convert.ToInt32(time));  										if (ObjectId.IsId(previousCheckout))  										{  											rev = ParseSimple(rw' previousCheckout);  										}  										else  										{  											name = previousCheckout;  										}  									}  								}  								else  								{  									if (name == null)  									{  										name = new string(revChars' done' i);  									}  									if (name.Equals(string.Empty))  									{  										name = Constants.HEAD;  									}  									if (!NGit.Repository.IsValidRefName("x/" + name))  									{  										throw new RevisionSyntaxException(revstr);  									}  									Ref @ref = GetRef(name);  									name = null;  									if (@ref == null)  									{  										return null;  									}  									// @{n} means current branch' not HEAD@{1} unless  									// detached  									if (@ref.IsSymbolic())  									{  										@ref = @ref.GetLeaf();  									}  									rev = ResolveReflog(rw' @ref' time);  								}  							}  							i = m;  						}  						else  						{  							throw new RevisionSyntaxException(revstr);  						}  						break;  					}    					case ':':  					{  						RevTree tree;  						if (rev == null)  						{  							if (name == null)  							{  								name = new string(revChars' done' i);  							}  							if (name.Equals(string.Empty))  							{  								name = Constants.HEAD;  							}  							rev = ParseSimple(rw' name);  							name = null;  						}  						if (rev == null)  						{  							return null;  						}  						tree = rw.ParseTree(rev);  						if (i == revChars.Length - 1)  						{  							return tree.Copy();  						}  						TreeWalk tw = TreeWalk.ForPath(rw.GetObjectReader()' new string(revChars' i + 1'   							revChars.Length - i - 1)' tree);  						return tw != null ? tw.GetObjectId(0) : null;  					}    					default:  					{  						if (rev != null)  						{  							throw new RevisionSyntaxException(revstr);  						}  						break;  					}  				}  			}
Magic Number,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revChars.Length; ++i)  			{  				switch (revChars[i])  				{  					case '^':  					{  						if (rev == null)  						{  							if (name == null)  							{  								if (done == 0)  								{  									name = new string(revChars' done' i);  								}  								else  								{  									done = i + 1;  									break;  								}  							}  							rev = ParseSimple(rw' name);  							name = null;  							if (rev == null)  							{  								return null;  							}  						}  						if (i + 1 < revChars.Length)  						{  							switch (revChars[i + 1])  							{  								case '0':  								case '1':  								case '2':  								case '3':  								case '4':  								case '5':  								case '6':  								case '7':  								case '8':  								case '9':  								{  									int j;  									rev = rw.ParseCommit(rev);  									for (j = i + 1; j < revChars.Length; ++j)  									{  										if (!char.IsDigit(revChars[j]))  										{  											break;  										}  									}  									string parentnum = new string(revChars' i + 1' j - i - 1);  									int pnum;  									try  									{  										pnum = System.Convert.ToInt32(parentnum);  									}  									catch (FormatException)  									{  										throw new RevisionSyntaxException(JGitText.Get().invalidCommitParentNumber' revstr  											);  									}  									if (pnum != 0)  									{  										RevCommit commit = (RevCommit)rev;  										if (pnum > commit.ParentCount)  										{  											rev = null;  										}  										else  										{  											rev = commit.GetParent(pnum - 1);  										}  									}  									i = j - 1;  									done = j;  									break;  								}    								case '{':  								{  									int k;  									string item = null;  									for (k = i + 2; k < revChars.Length; ++k)  									{  										if (revChars[k] == '}')  										{  											item = new string(revChars' i + 2' k - i - 2);  											break;  										}  									}  									i = k;  									if (item != null)  									{  										if (item.Equals("tree"))  										{  											rev = rw.ParseTree(rev);  										}  										else  										{  											if (item.Equals("commit"))  											{  												rev = rw.ParseCommit(rev);  											}  											else  											{  												if (item.Equals("blob"))  												{  													rev = rw.Peel(rev);  													if (!(rev is RevBlob))  													{  														throw new IncorrectObjectTypeException(rev' Constants.TYPE_BLOB);  													}  												}  												else  												{  													if (item.Equals(string.Empty))  													{  														rev = rw.Peel(rev);  													}  													else  													{  														throw new RevisionSyntaxException(revstr);  													}  												}  											}  										}  									}  									else  									{  										throw new RevisionSyntaxException(revstr);  									}  									done = k;  									break;  								}    								default:  								{  									rev = rw.ParseAny(rev);  									if (rev is RevCommit)  									{  										RevCommit commit = ((RevCommit)rev);  										if (commit.ParentCount == 0)  										{  											rev = null;  										}  										else  										{  											rev = commit.GetParent(0);  										}  									}  									else  									{  										throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  									}  									break;  								}  							}  						}  						else  						{  							rev = rw.Peel(rev);  							if (rev is RevCommit)  							{  								RevCommit commit = ((RevCommit)rev);  								if (commit.ParentCount == 0)  								{  									rev = null;  								}  								else  								{  									rev = commit.GetParent(0);  								}  							}  							else  							{  								throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  							}  						}  						done = i + 1;  						break;  					}    					case '~':  					{  						if (rev == null)  						{  							if (name == null)  							{  								if (done == 0)  								{  									name = new string(revChars' done' i);  								}  								else  								{  									done = i + 1;  									break;  								}  							}  							rev = ParseSimple(rw' name);  							name = null;  							if (rev == null)  							{  								return null;  							}  						}  						rev = rw.Peel(rev);  						if (!(rev is RevCommit))  						{  							throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  						}  						int l;  						for (l = i + 1; l < revChars.Length; ++l)  						{  							if (!char.IsDigit(revChars[l]))  							{  								break;  							}  						}  						int dist;  						if (l - i > 1)  						{  							string distnum = new string(revChars' i + 1' l - i - 1);  							try  							{  								dist = System.Convert.ToInt32(distnum);  							}  							catch (FormatException)  							{  								throw new RevisionSyntaxException(JGitText.Get().invalidAncestryLength' revstr);  							}  						}  						else  						{  							dist = 1;  						}  						while (dist > 0)  						{  							RevCommit commit = (RevCommit)rev;  							if (commit.ParentCount == 0)  							{  								rev = null;  								break;  							}  							commit = commit.GetParent(0);  							rw.ParseHeaders(commit);  							rev = commit;  							--dist;  						}  						i = l - 1;  						done = l;  						break;  					}    					case '@':  					{  						if (rev != null)  						{  							throw new RevisionSyntaxException(revstr);  						}  						if (i + 1 < revChars.Length && revChars[i + 1] != '{')  						{  							continue;  						}  						int m;  						string time = null;  						for (m = i + 2; m < revChars.Length; ++m)  						{  							if (revChars[m] == '}')  							{  								time = new string(revChars' i + 2' m - i - 2);  								break;  							}  						}  						if (time != null)  						{  							if (time.Equals("upstream"))  							{  								if (name == null)  								{  									name = new string(revChars' done' i);  								}  								if (name.Equals(string.Empty))  								{  									// Currently checked out branch' HEAD if  									// detached  									name = Constants.HEAD;  								}  								if (!NGit.Repository.IsValidRefName("x/" + name))  								{  									throw new RevisionSyntaxException(revstr);  								}  								Ref @ref = GetRef(name);  								name = null;  								if (@ref == null)  								{  									return null;  								}  								if (@ref.IsSymbolic())  								{  									@ref = @ref.GetLeaf();  								}  								name = @ref.GetName();  								RemoteConfig remoteConfig;  								try  								{  									remoteConfig = new RemoteConfig(GetConfig()' "origin");  								}  								catch (URISyntaxException)  								{  									throw new RevisionSyntaxException(revstr);  								}  								string remoteBranchName = GetConfig().GetString(ConfigConstants.CONFIG_BRANCH_SECTION  									' NGit.Repository.ShortenRefName(@ref.GetName())' ConfigConstants.CONFIG_KEY_MERGE  									);  								IList<RefSpec> fetchRefSpecs = remoteConfig.FetchRefSpecs;  								foreach (RefSpec refSpec in fetchRefSpecs)  								{  									if (refSpec.MatchSource(remoteBranchName))  									{  										RefSpec expandFromSource = refSpec.ExpandFromSource(remoteBranchName);  										name = expandFromSource.GetDestination();  										break;  									}  								}  								if (name == null)  								{  									throw new RevisionSyntaxException(revstr);  								}  							}  							else  							{  								if (time.Matches("^-\\d+$"))  								{  									if (name != null)  									{  										throw new RevisionSyntaxException(revstr);  									}  									else  									{  										string previousCheckout = ResolveReflogCheckout(-System.Convert.ToInt32(time));  										if (ObjectId.IsId(previousCheckout))  										{  											rev = ParseSimple(rw' previousCheckout);  										}  										else  										{  											name = previousCheckout;  										}  									}  								}  								else  								{  									if (name == null)  									{  										name = new string(revChars' done' i);  									}  									if (name.Equals(string.Empty))  									{  										name = Constants.HEAD;  									}  									if (!NGit.Repository.IsValidRefName("x/" + name))  									{  										throw new RevisionSyntaxException(revstr);  									}  									Ref @ref = GetRef(name);  									name = null;  									if (@ref == null)  									{  										return null;  									}  									// @{n} means current branch' not HEAD@{1} unless  									// detached  									if (@ref.IsSymbolic())  									{  										@ref = @ref.GetLeaf();  									}  									rev = ResolveReflog(rw' @ref' time);  								}  							}  							i = m;  						}  						else  						{  							throw new RevisionSyntaxException(revstr);  						}  						break;  					}    					case ':':  					{  						RevTree tree;  						if (rev == null)  						{  							if (name == null)  							{  								name = new string(revChars' done' i);  							}  							if (name.Equals(string.Empty))  							{  								name = Constants.HEAD;  							}  							rev = ParseSimple(rw' name);  							name = null;  						}  						if (rev == null)  						{  							return null;  						}  						tree = rw.ParseTree(rev);  						if (i == revChars.Length - 1)  						{  							return tree.Copy();  						}  						TreeWalk tw = TreeWalk.ForPath(rw.GetObjectReader()' new string(revChars' i + 1'   							revChars.Length - i - 1)' tree);  						return tw != null ? tw.GetObjectId(0) : null;  					}    					default:  					{  						if (rev != null)  						{  							throw new RevisionSyntaxException(revstr);  						}  						break;  					}  				}  			}
Magic Number,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revChars.Length; ++i)  			{  				switch (revChars[i])  				{  					case '^':  					{  						if (rev == null)  						{  							if (name == null)  							{  								if (done == 0)  								{  									name = new string(revChars' done' i);  								}  								else  								{  									done = i + 1;  									break;  								}  							}  							rev = ParseSimple(rw' name);  							name = null;  							if (rev == null)  							{  								return null;  							}  						}  						if (i + 1 < revChars.Length)  						{  							switch (revChars[i + 1])  							{  								case '0':  								case '1':  								case '2':  								case '3':  								case '4':  								case '5':  								case '6':  								case '7':  								case '8':  								case '9':  								{  									int j;  									rev = rw.ParseCommit(rev);  									for (j = i + 1; j < revChars.Length; ++j)  									{  										if (!char.IsDigit(revChars[j]))  										{  											break;  										}  									}  									string parentnum = new string(revChars' i + 1' j - i - 1);  									int pnum;  									try  									{  										pnum = System.Convert.ToInt32(parentnum);  									}  									catch (FormatException)  									{  										throw new RevisionSyntaxException(JGitText.Get().invalidCommitParentNumber' revstr  											);  									}  									if (pnum != 0)  									{  										RevCommit commit = (RevCommit)rev;  										if (pnum > commit.ParentCount)  										{  											rev = null;  										}  										else  										{  											rev = commit.GetParent(pnum - 1);  										}  									}  									i = j - 1;  									done = j;  									break;  								}    								case '{':  								{  									int k;  									string item = null;  									for (k = i + 2; k < revChars.Length; ++k)  									{  										if (revChars[k] == '}')  										{  											item = new string(revChars' i + 2' k - i - 2);  											break;  										}  									}  									i = k;  									if (item != null)  									{  										if (item.Equals("tree"))  										{  											rev = rw.ParseTree(rev);  										}  										else  										{  											if (item.Equals("commit"))  											{  												rev = rw.ParseCommit(rev);  											}  											else  											{  												if (item.Equals("blob"))  												{  													rev = rw.Peel(rev);  													if (!(rev is RevBlob))  													{  														throw new IncorrectObjectTypeException(rev' Constants.TYPE_BLOB);  													}  												}  												else  												{  													if (item.Equals(string.Empty))  													{  														rev = rw.Peel(rev);  													}  													else  													{  														throw new RevisionSyntaxException(revstr);  													}  												}  											}  										}  									}  									else  									{  										throw new RevisionSyntaxException(revstr);  									}  									done = k;  									break;  								}    								default:  								{  									rev = rw.ParseAny(rev);  									if (rev is RevCommit)  									{  										RevCommit commit = ((RevCommit)rev);  										if (commit.ParentCount == 0)  										{  											rev = null;  										}  										else  										{  											rev = commit.GetParent(0);  										}  									}  									else  									{  										throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  									}  									break;  								}  							}  						}  						else  						{  							rev = rw.Peel(rev);  							if (rev is RevCommit)  							{  								RevCommit commit = ((RevCommit)rev);  								if (commit.ParentCount == 0)  								{  									rev = null;  								}  								else  								{  									rev = commit.GetParent(0);  								}  							}  							else  							{  								throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  							}  						}  						done = i + 1;  						break;  					}    					case '~':  					{  						if (rev == null)  						{  							if (name == null)  							{  								if (done == 0)  								{  									name = new string(revChars' done' i);  								}  								else  								{  									done = i + 1;  									break;  								}  							}  							rev = ParseSimple(rw' name);  							name = null;  							if (rev == null)  							{  								return null;  							}  						}  						rev = rw.Peel(rev);  						if (!(rev is RevCommit))  						{  							throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  						}  						int l;  						for (l = i + 1; l < revChars.Length; ++l)  						{  							if (!char.IsDigit(revChars[l]))  							{  								break;  							}  						}  						int dist;  						if (l - i > 1)  						{  							string distnum = new string(revChars' i + 1' l - i - 1);  							try  							{  								dist = System.Convert.ToInt32(distnum);  							}  							catch (FormatException)  							{  								throw new RevisionSyntaxException(JGitText.Get().invalidAncestryLength' revstr);  							}  						}  						else  						{  							dist = 1;  						}  						while (dist > 0)  						{  							RevCommit commit = (RevCommit)rev;  							if (commit.ParentCount == 0)  							{  								rev = null;  								break;  							}  							commit = commit.GetParent(0);  							rw.ParseHeaders(commit);  							rev = commit;  							--dist;  						}  						i = l - 1;  						done = l;  						break;  					}    					case '@':  					{  						if (rev != null)  						{  							throw new RevisionSyntaxException(revstr);  						}  						if (i + 1 < revChars.Length && revChars[i + 1] != '{')  						{  							continue;  						}  						int m;  						string time = null;  						for (m = i + 2; m < revChars.Length; ++m)  						{  							if (revChars[m] == '}')  							{  								time = new string(revChars' i + 2' m - i - 2);  								break;  							}  						}  						if (time != null)  						{  							if (time.Equals("upstream"))  							{  								if (name == null)  								{  									name = new string(revChars' done' i);  								}  								if (name.Equals(string.Empty))  								{  									// Currently checked out branch' HEAD if  									// detached  									name = Constants.HEAD;  								}  								if (!NGit.Repository.IsValidRefName("x/" + name))  								{  									throw new RevisionSyntaxException(revstr);  								}  								Ref @ref = GetRef(name);  								name = null;  								if (@ref == null)  								{  									return null;  								}  								if (@ref.IsSymbolic())  								{  									@ref = @ref.GetLeaf();  								}  								name = @ref.GetName();  								RemoteConfig remoteConfig;  								try  								{  									remoteConfig = new RemoteConfig(GetConfig()' "origin");  								}  								catch (URISyntaxException)  								{  									throw new RevisionSyntaxException(revstr);  								}  								string remoteBranchName = GetConfig().GetString(ConfigConstants.CONFIG_BRANCH_SECTION  									' NGit.Repository.ShortenRefName(@ref.GetName())' ConfigConstants.CONFIG_KEY_MERGE  									);  								IList<RefSpec> fetchRefSpecs = remoteConfig.FetchRefSpecs;  								foreach (RefSpec refSpec in fetchRefSpecs)  								{  									if (refSpec.MatchSource(remoteBranchName))  									{  										RefSpec expandFromSource = refSpec.ExpandFromSource(remoteBranchName);  										name = expandFromSource.GetDestination();  										break;  									}  								}  								if (name == null)  								{  									throw new RevisionSyntaxException(revstr);  								}  							}  							else  							{  								if (time.Matches("^-\\d+$"))  								{  									if (name != null)  									{  										throw new RevisionSyntaxException(revstr);  									}  									else  									{  										string previousCheckout = ResolveReflogCheckout(-System.Convert.ToInt32(time));  										if (ObjectId.IsId(previousCheckout))  										{  											rev = ParseSimple(rw' previousCheckout);  										}  										else  										{  											name = previousCheckout;  										}  									}  								}  								else  								{  									if (name == null)  									{  										name = new string(revChars' done' i);  									}  									if (name.Equals(string.Empty))  									{  										name = Constants.HEAD;  									}  									if (!NGit.Repository.IsValidRefName("x/" + name))  									{  										throw new RevisionSyntaxException(revstr);  									}  									Ref @ref = GetRef(name);  									name = null;  									if (@ref == null)  									{  										return null;  									}  									// @{n} means current branch' not HEAD@{1} unless  									// detached  									if (@ref.IsSymbolic())  									{  										@ref = @ref.GetLeaf();  									}  									rev = ResolveReflog(rw' @ref' time);  								}  							}  							i = m;  						}  						else  						{  							throw new RevisionSyntaxException(revstr);  						}  						break;  					}    					case ':':  					{  						RevTree tree;  						if (rev == null)  						{  							if (name == null)  							{  								name = new string(revChars' done' i);  							}  							if (name.Equals(string.Empty))  							{  								name = Constants.HEAD;  							}  							rev = ParseSimple(rw' name);  							name = null;  						}  						if (rev == null)  						{  							return null;  						}  						tree = rw.ParseTree(rev);  						if (i == revChars.Length - 1)  						{  							return tree.Copy();  						}  						TreeWalk tw = TreeWalk.ForPath(rw.GetObjectReader()' new string(revChars' i + 1'   							revChars.Length - i - 1)' tree);  						return tw != null ? tw.GetObjectId(0) : null;  					}    					default:  					{  						if (rev != null)  						{  							throw new RevisionSyntaxException(revstr);  						}  						break;  					}  				}  			}
Magic Number,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revChars.Length; ++i)  			{  				switch (revChars[i])  				{  					case '^':  					{  						if (rev == null)  						{  							if (name == null)  							{  								if (done == 0)  								{  									name = new string(revChars' done' i);  								}  								else  								{  									done = i + 1;  									break;  								}  							}  							rev = ParseSimple(rw' name);  							name = null;  							if (rev == null)  							{  								return null;  							}  						}  						if (i + 1 < revChars.Length)  						{  							switch (revChars[i + 1])  							{  								case '0':  								case '1':  								case '2':  								case '3':  								case '4':  								case '5':  								case '6':  								case '7':  								case '8':  								case '9':  								{  									int j;  									rev = rw.ParseCommit(rev);  									for (j = i + 1; j < revChars.Length; ++j)  									{  										if (!char.IsDigit(revChars[j]))  										{  											break;  										}  									}  									string parentnum = new string(revChars' i + 1' j - i - 1);  									int pnum;  									try  									{  										pnum = System.Convert.ToInt32(parentnum);  									}  									catch (FormatException)  									{  										throw new RevisionSyntaxException(JGitText.Get().invalidCommitParentNumber' revstr  											);  									}  									if (pnum != 0)  									{  										RevCommit commit = (RevCommit)rev;  										if (pnum > commit.ParentCount)  										{  											rev = null;  										}  										else  										{  											rev = commit.GetParent(pnum - 1);  										}  									}  									i = j - 1;  									done = j;  									break;  								}    								case '{':  								{  									int k;  									string item = null;  									for (k = i + 2; k < revChars.Length; ++k)  									{  										if (revChars[k] == '}')  										{  											item = new string(revChars' i + 2' k - i - 2);  											break;  										}  									}  									i = k;  									if (item != null)  									{  										if (item.Equals("tree"))  										{  											rev = rw.ParseTree(rev);  										}  										else  										{  											if (item.Equals("commit"))  											{  												rev = rw.ParseCommit(rev);  											}  											else  											{  												if (item.Equals("blob"))  												{  													rev = rw.Peel(rev);  													if (!(rev is RevBlob))  													{  														throw new IncorrectObjectTypeException(rev' Constants.TYPE_BLOB);  													}  												}  												else  												{  													if (item.Equals(string.Empty))  													{  														rev = rw.Peel(rev);  													}  													else  													{  														throw new RevisionSyntaxException(revstr);  													}  												}  											}  										}  									}  									else  									{  										throw new RevisionSyntaxException(revstr);  									}  									done = k;  									break;  								}    								default:  								{  									rev = rw.ParseAny(rev);  									if (rev is RevCommit)  									{  										RevCommit commit = ((RevCommit)rev);  										if (commit.ParentCount == 0)  										{  											rev = null;  										}  										else  										{  											rev = commit.GetParent(0);  										}  									}  									else  									{  										throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  									}  									break;  								}  							}  						}  						else  						{  							rev = rw.Peel(rev);  							if (rev is RevCommit)  							{  								RevCommit commit = ((RevCommit)rev);  								if (commit.ParentCount == 0)  								{  									rev = null;  								}  								else  								{  									rev = commit.GetParent(0);  								}  							}  							else  							{  								throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  							}  						}  						done = i + 1;  						break;  					}    					case '~':  					{  						if (rev == null)  						{  							if (name == null)  							{  								if (done == 0)  								{  									name = new string(revChars' done' i);  								}  								else  								{  									done = i + 1;  									break;  								}  							}  							rev = ParseSimple(rw' name);  							name = null;  							if (rev == null)  							{  								return null;  							}  						}  						rev = rw.Peel(rev);  						if (!(rev is RevCommit))  						{  							throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  						}  						int l;  						for (l = i + 1; l < revChars.Length; ++l)  						{  							if (!char.IsDigit(revChars[l]))  							{  								break;  							}  						}  						int dist;  						if (l - i > 1)  						{  							string distnum = new string(revChars' i + 1' l - i - 1);  							try  							{  								dist = System.Convert.ToInt32(distnum);  							}  							catch (FormatException)  							{  								throw new RevisionSyntaxException(JGitText.Get().invalidAncestryLength' revstr);  							}  						}  						else  						{  							dist = 1;  						}  						while (dist > 0)  						{  							RevCommit commit = (RevCommit)rev;  							if (commit.ParentCount == 0)  							{  								rev = null;  								break;  							}  							commit = commit.GetParent(0);  							rw.ParseHeaders(commit);  							rev = commit;  							--dist;  						}  						i = l - 1;  						done = l;  						break;  					}    					case '@':  					{  						if (rev != null)  						{  							throw new RevisionSyntaxException(revstr);  						}  						if (i + 1 < revChars.Length && revChars[i + 1] != '{')  						{  							continue;  						}  						int m;  						string time = null;  						for (m = i + 2; m < revChars.Length; ++m)  						{  							if (revChars[m] == '}')  							{  								time = new string(revChars' i + 2' m - i - 2);  								break;  							}  						}  						if (time != null)  						{  							if (time.Equals("upstream"))  							{  								if (name == null)  								{  									name = new string(revChars' done' i);  								}  								if (name.Equals(string.Empty))  								{  									// Currently checked out branch' HEAD if  									// detached  									name = Constants.HEAD;  								}  								if (!NGit.Repository.IsValidRefName("x/" + name))  								{  									throw new RevisionSyntaxException(revstr);  								}  								Ref @ref = GetRef(name);  								name = null;  								if (@ref == null)  								{  									return null;  								}  								if (@ref.IsSymbolic())  								{  									@ref = @ref.GetLeaf();  								}  								name = @ref.GetName();  								RemoteConfig remoteConfig;  								try  								{  									remoteConfig = new RemoteConfig(GetConfig()' "origin");  								}  								catch (URISyntaxException)  								{  									throw new RevisionSyntaxException(revstr);  								}  								string remoteBranchName = GetConfig().GetString(ConfigConstants.CONFIG_BRANCH_SECTION  									' NGit.Repository.ShortenRefName(@ref.GetName())' ConfigConstants.CONFIG_KEY_MERGE  									);  								IList<RefSpec> fetchRefSpecs = remoteConfig.FetchRefSpecs;  								foreach (RefSpec refSpec in fetchRefSpecs)  								{  									if (refSpec.MatchSource(remoteBranchName))  									{  										RefSpec expandFromSource = refSpec.ExpandFromSource(remoteBranchName);  										name = expandFromSource.GetDestination();  										break;  									}  								}  								if (name == null)  								{  									throw new RevisionSyntaxException(revstr);  								}  							}  							else  							{  								if (time.Matches("^-\\d+$"))  								{  									if (name != null)  									{  										throw new RevisionSyntaxException(revstr);  									}  									else  									{  										string previousCheckout = ResolveReflogCheckout(-System.Convert.ToInt32(time));  										if (ObjectId.IsId(previousCheckout))  										{  											rev = ParseSimple(rw' previousCheckout);  										}  										else  										{  											name = previousCheckout;  										}  									}  								}  								else  								{  									if (name == null)  									{  										name = new string(revChars' done' i);  									}  									if (name.Equals(string.Empty))  									{  										name = Constants.HEAD;  									}  									if (!NGit.Repository.IsValidRefName("x/" + name))  									{  										throw new RevisionSyntaxException(revstr);  									}  									Ref @ref = GetRef(name);  									name = null;  									if (@ref == null)  									{  										return null;  									}  									// @{n} means current branch' not HEAD@{1} unless  									// detached  									if (@ref.IsSymbolic())  									{  										@ref = @ref.GetLeaf();  									}  									rev = ResolveReflog(rw' @ref' time);  								}  							}  							i = m;  						}  						else  						{  							throw new RevisionSyntaxException(revstr);  						}  						break;  					}    					case ':':  					{  						RevTree tree;  						if (rev == null)  						{  							if (name == null)  							{  								name = new string(revChars' done' i);  							}  							if (name.Equals(string.Empty))  							{  								name = Constants.HEAD;  							}  							rev = ParseSimple(rw' name);  							name = null;  						}  						if (rev == null)  						{  							return null;  						}  						tree = rw.ParseTree(rev);  						if (i == revChars.Length - 1)  						{  							return tree.Copy();  						}  						TreeWalk tw = TreeWalk.ForPath(rw.GetObjectReader()' new string(revChars' i + 1'   							revChars.Length - i - 1)' tree);  						return tw != null ? tw.GetObjectId(0) : null;  					}    					default:  					{  						if (rev != null)  						{  							throw new RevisionSyntaxException(revstr);  						}  						break;  					}  				}  			}
Magic Number,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revChars.Length; ++i)  			{  				switch (revChars[i])  				{  					case '^':  					{  						if (rev == null)  						{  							if (name == null)  							{  								if (done == 0)  								{  									name = new string(revChars' done' i);  								}  								else  								{  									done = i + 1;  									break;  								}  							}  							rev = ParseSimple(rw' name);  							name = null;  							if (rev == null)  							{  								return null;  							}  						}  						if (i + 1 < revChars.Length)  						{  							switch (revChars[i + 1])  							{  								case '0':  								case '1':  								case '2':  								case '3':  								case '4':  								case '5':  								case '6':  								case '7':  								case '8':  								case '9':  								{  									int j;  									rev = rw.ParseCommit(rev);  									for (j = i + 1; j < revChars.Length; ++j)  									{  										if (!char.IsDigit(revChars[j]))  										{  											break;  										}  									}  									string parentnum = new string(revChars' i + 1' j - i - 1);  									int pnum;  									try  									{  										pnum = System.Convert.ToInt32(parentnum);  									}  									catch (FormatException)  									{  										throw new RevisionSyntaxException(JGitText.Get().invalidCommitParentNumber' revstr  											);  									}  									if (pnum != 0)  									{  										RevCommit commit = (RevCommit)rev;  										if (pnum > commit.ParentCount)  										{  											rev = null;  										}  										else  										{  											rev = commit.GetParent(pnum - 1);  										}  									}  									i = j - 1;  									done = j;  									break;  								}    								case '{':  								{  									int k;  									string item = null;  									for (k = i + 2; k < revChars.Length; ++k)  									{  										if (revChars[k] == '}')  										{  											item = new string(revChars' i + 2' k - i - 2);  											break;  										}  									}  									i = k;  									if (item != null)  									{  										if (item.Equals("tree"))  										{  											rev = rw.ParseTree(rev);  										}  										else  										{  											if (item.Equals("commit"))  											{  												rev = rw.ParseCommit(rev);  											}  											else  											{  												if (item.Equals("blob"))  												{  													rev = rw.Peel(rev);  													if (!(rev is RevBlob))  													{  														throw new IncorrectObjectTypeException(rev' Constants.TYPE_BLOB);  													}  												}  												else  												{  													if (item.Equals(string.Empty))  													{  														rev = rw.Peel(rev);  													}  													else  													{  														throw new RevisionSyntaxException(revstr);  													}  												}  											}  										}  									}  									else  									{  										throw new RevisionSyntaxException(revstr);  									}  									done = k;  									break;  								}    								default:  								{  									rev = rw.ParseAny(rev);  									if (rev is RevCommit)  									{  										RevCommit commit = ((RevCommit)rev);  										if (commit.ParentCount == 0)  										{  											rev = null;  										}  										else  										{  											rev = commit.GetParent(0);  										}  									}  									else  									{  										throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  									}  									break;  								}  							}  						}  						else  						{  							rev = rw.Peel(rev);  							if (rev is RevCommit)  							{  								RevCommit commit = ((RevCommit)rev);  								if (commit.ParentCount == 0)  								{  									rev = null;  								}  								else  								{  									rev = commit.GetParent(0);  								}  							}  							else  							{  								throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  							}  						}  						done = i + 1;  						break;  					}    					case '~':  					{  						if (rev == null)  						{  							if (name == null)  							{  								if (done == 0)  								{  									name = new string(revChars' done' i);  								}  								else  								{  									done = i + 1;  									break;  								}  							}  							rev = ParseSimple(rw' name);  							name = null;  							if (rev == null)  							{  								return null;  							}  						}  						rev = rw.Peel(rev);  						if (!(rev is RevCommit))  						{  							throw new IncorrectObjectTypeException(rev' Constants.TYPE_COMMIT);  						}  						int l;  						for (l = i + 1; l < revChars.Length; ++l)  						{  							if (!char.IsDigit(revChars[l]))  							{  								break;  							}  						}  						int dist;  						if (l - i > 1)  						{  							string distnum = new string(revChars' i + 1' l - i - 1);  							try  							{  								dist = System.Convert.ToInt32(distnum);  							}  							catch (FormatException)  							{  								throw new RevisionSyntaxException(JGitText.Get().invalidAncestryLength' revstr);  							}  						}  						else  						{  							dist = 1;  						}  						while (dist > 0)  						{  							RevCommit commit = (RevCommit)rev;  							if (commit.ParentCount == 0)  							{  								rev = null;  								break;  							}  							commit = commit.GetParent(0);  							rw.ParseHeaders(commit);  							rev = commit;  							--dist;  						}  						i = l - 1;  						done = l;  						break;  					}    					case '@':  					{  						if (rev != null)  						{  							throw new RevisionSyntaxException(revstr);  						}  						if (i + 1 < revChars.Length && revChars[i + 1] != '{')  						{  							continue;  						}  						int m;  						string time = null;  						for (m = i + 2; m < revChars.Length; ++m)  						{  							if (revChars[m] == '}')  							{  								time = new string(revChars' i + 2' m - i - 2);  								break;  							}  						}  						if (time != null)  						{  							if (time.Equals("upstream"))  							{  								if (name == null)  								{  									name = new string(revChars' done' i);  								}  								if (name.Equals(string.Empty))  								{  									// Currently checked out branch' HEAD if  									// detached  									name = Constants.HEAD;  								}  								if (!NGit.Repository.IsValidRefName("x/" + name))  								{  									throw new RevisionSyntaxException(revstr);  								}  								Ref @ref = GetRef(name);  								name = null;  								if (@ref == null)  								{  									return null;  								}  								if (@ref.IsSymbolic())  								{  									@ref = @ref.GetLeaf();  								}  								name = @ref.GetName();  								RemoteConfig remoteConfig;  								try  								{  									remoteConfig = new RemoteConfig(GetConfig()' "origin");  								}  								catch (URISyntaxException)  								{  									throw new RevisionSyntaxException(revstr);  								}  								string remoteBranchName = GetConfig().GetString(ConfigConstants.CONFIG_BRANCH_SECTION  									' NGit.Repository.ShortenRefName(@ref.GetName())' ConfigConstants.CONFIG_KEY_MERGE  									);  								IList<RefSpec> fetchRefSpecs = remoteConfig.FetchRefSpecs;  								foreach (RefSpec refSpec in fetchRefSpecs)  								{  									if (refSpec.MatchSource(remoteBranchName))  									{  										RefSpec expandFromSource = refSpec.ExpandFromSource(remoteBranchName);  										name = expandFromSource.GetDestination();  										break;  									}  								}  								if (name == null)  								{  									throw new RevisionSyntaxException(revstr);  								}  							}  							else  							{  								if (time.Matches("^-\\d+$"))  								{  									if (name != null)  									{  										throw new RevisionSyntaxException(revstr);  									}  									else  									{  										string previousCheckout = ResolveReflogCheckout(-System.Convert.ToInt32(time));  										if (ObjectId.IsId(previousCheckout))  										{  											rev = ParseSimple(rw' previousCheckout);  										}  										else  										{  											name = previousCheckout;  										}  									}  								}  								else  								{  									if (name == null)  									{  										name = new string(revChars' done' i);  									}  									if (name.Equals(string.Empty))  									{  										name = Constants.HEAD;  									}  									if (!NGit.Repository.IsValidRefName("x/" + name))  									{  										throw new RevisionSyntaxException(revstr);  									}  									Ref @ref = GetRef(name);  									name = null;  									if (@ref == null)  									{  										return null;  									}  									// @{n} means current branch' not HEAD@{1} unless  									// detached  									if (@ref.IsSymbolic())  									{  										@ref = @ref.GetLeaf();  									}  									rev = ResolveReflog(rw' @ref' time);  								}  							}  							i = m;  						}  						else  						{  							throw new RevisionSyntaxException(revstr);  						}  						break;  					}    					case ':':  					{  						RevTree tree;  						if (rev == null)  						{  							if (name == null)  							{  								name = new string(revChars' done' i);  							}  							if (name.Equals(string.Empty))  							{  								name = Constants.HEAD;  							}  							rev = ParseSimple(rw' name);  							name = null;  						}  						if (rev == null)  						{  							return null;  						}  						tree = rw.ParseTree(rev);  						if (i == revChars.Length - 1)  						{  							return tree.Copy();  						}  						TreeWalk tw = TreeWalk.ForPath(rw.GetObjectReader()' new string(revChars' i + 1'   							revChars.Length - i - 1)' tree);  						return tw != null ? tw.GetObjectId(0) : null;  					}    					default:  					{  						if (rev != null)  						{  							throw new RevisionSyntaxException(revstr);  						}  						break;  					}  				}  			}
Magic Number,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,ResolveSimple,The following statement contains a magic number: if ((dashg + 5) < revstr.Length && 0 <= dashg && IsHex(revstr[dashg + 2]) && IsHex  				(revstr[dashg + 3]) && IsAllHex(revstr' dashg + 4))  			{  				// Possibly output from git describe?  				string s = Sharpen.Runtime.Substring(revstr' dashg + 2);  				if (AbbreviatedObjectId.IsId(s))  				{  					return ResolveAbbreviation(s);  				}  			}
Magic Number,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,ResolveSimple,The following statement contains a magic number: if ((dashg + 5) < revstr.Length && 0 <= dashg && IsHex(revstr[dashg + 2]) && IsHex  				(revstr[dashg + 3]) && IsAllHex(revstr' dashg + 4))  			{  				// Possibly output from git describe?  				string s = Sharpen.Runtime.Substring(revstr' dashg + 2);  				if (AbbreviatedObjectId.IsId(s))  				{  					return ResolveAbbreviation(s);  				}  			}
Magic Number,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,ResolveSimple,The following statement contains a magic number: if ((dashg + 5) < revstr.Length && 0 <= dashg && IsHex(revstr[dashg + 2]) && IsHex  				(revstr[dashg + 3]) && IsAllHex(revstr' dashg + 4))  			{  				// Possibly output from git describe?  				string s = Sharpen.Runtime.Substring(revstr' dashg + 2);  				if (AbbreviatedObjectId.IsId(s))  				{  					return ResolveAbbreviation(s);  				}  			}
Magic Number,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,ResolveSimple,The following statement contains a magic number: if ((dashg + 5) < revstr.Length && 0 <= dashg && IsHex(revstr[dashg + 2]) && IsHex  				(revstr[dashg + 3]) && IsAllHex(revstr' dashg + 4))  			{  				// Possibly output from git describe?  				string s = Sharpen.Runtime.Substring(revstr' dashg + 2);  				if (AbbreviatedObjectId.IsId(s))  				{  					return ResolveAbbreviation(s);  				}  			}
Magic Number,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,ResolveSimple,The following statement contains a magic number: if ((dashg + 5) < revstr.Length && 0 <= dashg && IsHex(revstr[dashg + 2]) && IsHex  				(revstr[dashg + 3]) && IsAllHex(revstr' dashg + 4))  			{  				// Possibly output from git describe?  				string s = Sharpen.Runtime.Substring(revstr' dashg + 2);  				if (AbbreviatedObjectId.IsId(s))  				{  					return ResolveAbbreviation(s);  				}  			}
Magic Number,NGit,RepositoryCache,C:\repos\mono_ngit\NGit\NGit\RepositoryCache.cs,RepositoryCache,The following statement contains a magic number: openLocks = new RepositoryCache.Lock[4];
Magic Number,NGit,RepositoryCache,C:\repos\mono_ngit\NGit\NGit\RepositoryCache.cs,ClearAll,The following statement contains a magic number: for (int stage = 0; stage < 2; stage++)  			{  				for (Iterator<KeyValuePair<RepositoryCache.Key' Reference<Repository>>> i = cacheMap  					.EntrySet().Iterator(); i.HasNext(); )  				{  					KeyValuePair<RepositoryCache.Key' Reference<Repository>> e = i.Next();  					Repository db = e.Value.Get();  					if (db != null)  					{  						db.Close();  					}  					i.Remove();  				}  			}
Magic Number,NGit,FileKey,C:\repos\mono_ngit\NGit\NGit\RepositoryCache.cs,ReadFirstLine,The following statement contains a magic number: try  				{  					byte[] buf = IOUtil.ReadFully(head' 4096);  					int n = buf.Length;  					if (n == 0)  					{  						return null;  					}  					if (buf[n - 1] == '\n')  					{  						n--;  					}  					return RawParseUtils.Decode(buf' 0' n);  				}  				catch (IOException)  				{  					return null;  				}
Magic Number,NGit,TextProgressMonitor,C:\repos\mono_ngit\NGit\NGit\TextProgressMonitor.cs,Format,The following statement contains a magic number: while (s.Length < 25)  			{  				s.Append(' ');  			}
Magic Number,NGit,TextProgressMonitor,C:\repos\mono_ngit\NGit\NGit\TextProgressMonitor.cs,Format,The following statement contains a magic number: while (s.Length < 25)  			{  				s.Append(' ');  			}
Magic Number,NGit,TextProgressMonitor,C:\repos\mono_ngit\NGit\NGit\TextProgressMonitor.cs,Format,The following statement contains a magic number: if (pcnt < 100)  			{  				s.Append(' ');  			}
Magic Number,NGit,TextProgressMonitor,C:\repos\mono_ngit\NGit\NGit\TextProgressMonitor.cs,Format,The following statement contains a magic number: if (pcnt < 10)  			{  				s.Append(' ');  			}
Magic Number,NGit,Tree,C:\repos\mono_ngit\NGit\NGit\Tree.cs,ReadTree,The following statement contains a magic number: while (rawPtr < rawSize)  			{  				int c = raw[rawPtr++];  				if (c < '0' || c > '7')  				{  					throw new CorruptObjectException(GetId()' JGitText.Get().corruptObjectInvalidEntryMode  						);  				}  				int mode = c - '0';  				for (; ; )  				{  					c = raw[rawPtr++];  					if (' ' == c)  					{  						break;  					}  					else  					{  						if (c < '0' || c > '7')  						{  							throw new CorruptObjectException(GetId()' JGitText.Get().corruptObjectInvalidMode  								);  						}  					}  					mode <<= 3;  					mode += c - '0';  				}  				int nameLen = 0;  				while (raw[rawPtr + nameLen] != 0)  				{  					nameLen++;  				}  				byte[] name = new byte[nameLen];  				System.Array.Copy(raw' rawPtr' name' 0' nameLen);  				rawPtr += nameLen + 1;  				ObjectId id = ObjectId.FromRaw(raw' rawPtr);  				rawPtr += Constants.OBJECT_ID_LENGTH;  				TreeEntry ent;  				if (FileMode.REGULAR_FILE.Equals(mode))  				{  					ent = new FileTreeEntry(this' id' name' false);  				}  				else  				{  					if (FileMode.EXECUTABLE_FILE.Equals(mode))  					{  						ent = new FileTreeEntry(this' id' name' true);  					}  					else  					{  						if (FileMode.TREE.Equals(mode))  						{  							ent = new NGit.Tree(this' id' name);  						}  						else  						{  							if (FileMode.SYMLINK.Equals(mode))  							{  								ent = new SymlinkTreeEntry(this' id' name);  							}  							else  							{  								if (FileMode.GITLINK.Equals(mode))  								{  									ent = new GitlinkTreeEntry(this' id' name);  								}  								else  								{  									throw new CorruptObjectException(GetId()' MessageFormat.Format(JGitText.Get().corruptObjectInvalidMode2  										' Sharpen.Extensions.ToOctalString(mode)));  								}  							}  						}  					}  				}  				temp[nextIndex++] = ent;  			}
Magic Number,NGit,TreeFormatter,C:\repos\mono_ngit\NGit\NGit\TreeFormatter.cs,EntrySize,The following statement contains a magic number: return mode.CopyToLength() + nameLen + Constants.OBJECT_ID_LENGTH + 2;
Magic Number,NGit,Task,C:\repos\mono_ngit\NGit\NGit\BatchingProgressMonitor.cs,Update,The following statement contains a magic number: if (totalWork == UNKNOWN)  				{  					// Only display once per second' as the alarm fires.  					if (display)  					{  						pm.OnUpdate(taskName' lastWork);  						output = true;  						RestartTimer();  					}  				}  				else  				{  					// Display once per second or when 1% is done.  					int currPercent = lastWork * 100 / totalWork;  					if (display)  					{  						pm.OnUpdate(taskName' lastWork' totalWork' currPercent);  						output = true;  						RestartTimer();  						lastPercent = currPercent;  					}  					else  					{  						if (currPercent != lastPercent)  						{  							pm.OnUpdate(taskName' lastWork' totalWork' currPercent);  							output = true;  							lastPercent = currPercent;  						}  					}  				}
Magic Number,NGit,Task,C:\repos\mono_ngit\NGit\NGit\BatchingProgressMonitor.cs,End,The following statement contains a magic number: if (output)  				{  					if (totalWork == UNKNOWN)  					{  						pm.OnEndTask(taskName' lastWork);  					}  					else  					{  						int pDone = lastWork * 100 / totalWork;  						pm.OnEndTask(taskName' lastWork' totalWork' pDone);  					}  				}
Magic Number,NGit,ConfigSnapshot,C:\repos\mono_ngit\NGit\NGit\ConfigSnapshot.cs,ConfigSnapshot,The following statement contains a magic number: cache = new ConcurrentHashMap<object' object>(16' 0.75f' 1);
Magic Number,NGit.Api,FetchCommand,C:\repos\mono_ngit\NGit\NGit.Api\FetchCommand.cs,FetchCommand,The following statement contains a magic number: refSpecs = new AList<RefSpec>(3);
Magic Number,NGit.Api,PushCommand,C:\repos\mono_ngit\NGit\NGit.Api\PushCommand.cs,PushCommand,The following statement contains a magic number: refSpecs = new AList<RefSpec>(3);
Magic Number,NGit.Api,PushCommand,C:\repos\mono_ngit\NGit\NGit.Api\PushCommand.cs,Call,The following statement contains a magic number: AList<PushResult> pushResults = new AList<PushResult>(3);
Magic Number,NGit.Api,PullCommand,C:\repos\mono_ngit\NGit\NGit.Api\PullCommand.cs,Call,The following statement contains a magic number: monitor.BeginTask(JGitText.Get().pullTaskName' 2);
Magic Number,NGit.Api,CreateBranchCommand,C:\repos\mono_ngit\NGit\NGit.Api\CreateBranchCommand.cs,Call,The following statement contains a magic number: try  			{  				Ref refToCheck = repo.GetRef(name);  				bool exists = refToCheck != null && refToCheck.GetName().StartsWith(Constants.R_HEADS  					);  				if (!force && exists)  				{  					throw new RefAlreadyExistsException(MessageFormat.Format(JGitText.Get().refAlreadyExists1  						' name));  				}  				ObjectId startAt = GetStartPoint();  				string startPointFullName = null;  				if (startPoint != null)  				{  					Ref baseRef = repo.GetRef(startPoint);  					if (baseRef != null)  					{  						startPointFullName = baseRef.GetName();  					}  				}  				// determine whether we are based on a commit'  				// a branch' or a tag and compose the reflog message  				string refLogMessage;  				string baseBranch = string.Empty;  				if (startPointFullName == null)  				{  					string baseCommit;  					if (startCommit != null)  					{  						baseCommit = startCommit.GetShortMessage();  					}  					else  					{  						RevCommit commit = revWalk.ParseCommit(repo.Resolve(startPoint));  						baseCommit = commit.GetShortMessage();  					}  					if (exists)  					{  						refLogMessage = "branch: Reset start-point to commit " + baseCommit;  					}  					else  					{  						refLogMessage = "branch: Created from commit " + baseCommit;  					}  				}  				else  				{  					if (startPointFullName.StartsWith(Constants.R_HEADS) || startPointFullName.StartsWith  						(Constants.R_REMOTES))  					{  						baseBranch = startPointFullName;  						if (exists)  						{  							refLogMessage = "branch: Reset start-point to branch " + startPointFullName;  						}  						else  						{  							// TODO  							refLogMessage = "branch: Created from branch " + baseBranch;  						}  					}  					else  					{  						startAt = revWalk.Peel(revWalk.ParseAny(startAt));  						if (exists)  						{  							refLogMessage = "branch: Reset start-point to tag " + startPointFullName;  						}  						else  						{  							refLogMessage = "branch: Created from tag " + startPointFullName;  						}  					}  				}  				RefUpdate updateRef = repo.UpdateRef(Constants.R_HEADS + name);  				updateRef.SetNewObjectId(startAt);  				updateRef.SetRefLogMessage(refLogMessage' false);  				RefUpdate.Result updateResult;  				if (exists && force)  				{  					updateResult = updateRef.ForceUpdate();  				}  				else  				{  					updateResult = updateRef.Update();  				}  				SetCallable(false);  				bool ok = false;  				switch (updateResult)  				{  					case RefUpdate.Result.NEW:  					{  						ok = !exists;  						break;  					}    					case RefUpdate.Result.NO_CHANGE:  					case RefUpdate.Result.FAST_FORWARD:  					case RefUpdate.Result.FORCED:  					{  						ok = exists;  						break;  					}    					default:  					{  						break;  						break;  					}  				}  				if (!ok)  				{  					throw new JGitInternalException(MessageFormat.Format(JGitText.Get().createBranchUnexpectedResult  						' updateResult.ToString()));  				}  				Ref result = repo.GetRef(name);  				if (result == null)  				{  					throw new JGitInternalException(JGitText.Get().createBranchFailedUnknownReason);  				}  				if (baseBranch.Length == 0)  				{  					return result;  				}  				// if we are based on another branch' see  				// if we need to configure upstream configuration: first check  				// whether the setting was done explicitly  				bool doConfigure;  				if (upstreamMode == CreateBranchCommand.SetupUpstreamMode.SET_UPSTREAM || upstreamMode  					 == CreateBranchCommand.SetupUpstreamMode.TRACK)  				{  					// explicitly set to configure  					doConfigure = true;  				}  				else  				{  					if (upstreamMode == CreateBranchCommand.SetupUpstreamMode.NOTRACK)  					{  						// explicitly set to not configure  						doConfigure = false;  					}  					else  					{  						// if there was no explicit setting' check the configuration  						string autosetupflag = repo.GetConfig().GetString(ConfigConstants.CONFIG_BRANCH_SECTION  							' null' ConfigConstants.CONFIG_KEY_AUTOSETUPMERGE);  						if ("false".Equals(autosetupflag))  						{  							doConfigure = false;  						}  						else  						{  							if ("always".Equals(autosetupflag))  							{  								doConfigure = true;  							}  							else  							{  								// in this case' the default is to configure  								// only in case the base branch was a remote branch  								doConfigure = baseBranch.StartsWith(Constants.R_REMOTES);  							}  						}  					}  				}  				if (doConfigure)  				{  					StoredConfig config = repo.GetConfig();  					string[] tokens = baseBranch.Split("/"' 4);  					bool isRemote = tokens[1].Equals("remotes");  					if (isRemote)  					{  						// refs/remotes/<remote name>/<branch>  						string remoteName = tokens[2];  						string branchName = tokens[3];  						config.SetString(ConfigConstants.CONFIG_BRANCH_SECTION' name' ConfigConstants.CONFIG_KEY_REMOTE  							' remoteName);  						config.SetString(ConfigConstants.CONFIG_BRANCH_SECTION' name' ConfigConstants.CONFIG_KEY_MERGE  							' Constants.R_HEADS + branchName);  					}  					else  					{  						// set "." as remote  						config.SetString(ConfigConstants.CONFIG_BRANCH_SECTION' name' ConfigConstants.CONFIG_KEY_REMOTE  							' ".");  						config.SetString(ConfigConstants.CONFIG_BRANCH_SECTION' name' ConfigConstants.CONFIG_KEY_MERGE  							' baseBranch);  					}  					config.Save();  				}  				return result;  			}  			catch (IOException ioe)  			{  				throw new JGitInternalException(ioe.Message' ioe);  			}  			finally  			{  				revWalk.Release();  			}
Magic Number,NGit.Api,CreateBranchCommand,C:\repos\mono_ngit\NGit\NGit.Api\CreateBranchCommand.cs,Call,The following statement contains a magic number: try  			{  				Ref refToCheck = repo.GetRef(name);  				bool exists = refToCheck != null && refToCheck.GetName().StartsWith(Constants.R_HEADS  					);  				if (!force && exists)  				{  					throw new RefAlreadyExistsException(MessageFormat.Format(JGitText.Get().refAlreadyExists1  						' name));  				}  				ObjectId startAt = GetStartPoint();  				string startPointFullName = null;  				if (startPoint != null)  				{  					Ref baseRef = repo.GetRef(startPoint);  					if (baseRef != null)  					{  						startPointFullName = baseRef.GetName();  					}  				}  				// determine whether we are based on a commit'  				// a branch' or a tag and compose the reflog message  				string refLogMessage;  				string baseBranch = string.Empty;  				if (startPointFullName == null)  				{  					string baseCommit;  					if (startCommit != null)  					{  						baseCommit = startCommit.GetShortMessage();  					}  					else  					{  						RevCommit commit = revWalk.ParseCommit(repo.Resolve(startPoint));  						baseCommit = commit.GetShortMessage();  					}  					if (exists)  					{  						refLogMessage = "branch: Reset start-point to commit " + baseCommit;  					}  					else  					{  						refLogMessage = "branch: Created from commit " + baseCommit;  					}  				}  				else  				{  					if (startPointFullName.StartsWith(Constants.R_HEADS) || startPointFullName.StartsWith  						(Constants.R_REMOTES))  					{  						baseBranch = startPointFullName;  						if (exists)  						{  							refLogMessage = "branch: Reset start-point to branch " + startPointFullName;  						}  						else  						{  							// TODO  							refLogMessage = "branch: Created from branch " + baseBranch;  						}  					}  					else  					{  						startAt = revWalk.Peel(revWalk.ParseAny(startAt));  						if (exists)  						{  							refLogMessage = "branch: Reset start-point to tag " + startPointFullName;  						}  						else  						{  							refLogMessage = "branch: Created from tag " + startPointFullName;  						}  					}  				}  				RefUpdate updateRef = repo.UpdateRef(Constants.R_HEADS + name);  				updateRef.SetNewObjectId(startAt);  				updateRef.SetRefLogMessage(refLogMessage' false);  				RefUpdate.Result updateResult;  				if (exists && force)  				{  					updateResult = updateRef.ForceUpdate();  				}  				else  				{  					updateResult = updateRef.Update();  				}  				SetCallable(false);  				bool ok = false;  				switch (updateResult)  				{  					case RefUpdate.Result.NEW:  					{  						ok = !exists;  						break;  					}    					case RefUpdate.Result.NO_CHANGE:  					case RefUpdate.Result.FAST_FORWARD:  					case RefUpdate.Result.FORCED:  					{  						ok = exists;  						break;  					}    					default:  					{  						break;  						break;  					}  				}  				if (!ok)  				{  					throw new JGitInternalException(MessageFormat.Format(JGitText.Get().createBranchUnexpectedResult  						' updateResult.ToString()));  				}  				Ref result = repo.GetRef(name);  				if (result == null)  				{  					throw new JGitInternalException(JGitText.Get().createBranchFailedUnknownReason);  				}  				if (baseBranch.Length == 0)  				{  					return result;  				}  				// if we are based on another branch' see  				// if we need to configure upstream configuration: first check  				// whether the setting was done explicitly  				bool doConfigure;  				if (upstreamMode == CreateBranchCommand.SetupUpstreamMode.SET_UPSTREAM || upstreamMode  					 == CreateBranchCommand.SetupUpstreamMode.TRACK)  				{  					// explicitly set to configure  					doConfigure = true;  				}  				else  				{  					if (upstreamMode == CreateBranchCommand.SetupUpstreamMode.NOTRACK)  					{  						// explicitly set to not configure  						doConfigure = false;  					}  					else  					{  						// if there was no explicit setting' check the configuration  						string autosetupflag = repo.GetConfig().GetString(ConfigConstants.CONFIG_BRANCH_SECTION  							' null' ConfigConstants.CONFIG_KEY_AUTOSETUPMERGE);  						if ("false".Equals(autosetupflag))  						{  							doConfigure = false;  						}  						else  						{  							if ("always".Equals(autosetupflag))  							{  								doConfigure = true;  							}  							else  							{  								// in this case' the default is to configure  								// only in case the base branch was a remote branch  								doConfigure = baseBranch.StartsWith(Constants.R_REMOTES);  							}  						}  					}  				}  				if (doConfigure)  				{  					StoredConfig config = repo.GetConfig();  					string[] tokens = baseBranch.Split("/"' 4);  					bool isRemote = tokens[1].Equals("remotes");  					if (isRemote)  					{  						// refs/remotes/<remote name>/<branch>  						string remoteName = tokens[2];  						string branchName = tokens[3];  						config.SetString(ConfigConstants.CONFIG_BRANCH_SECTION' name' ConfigConstants.CONFIG_KEY_REMOTE  							' remoteName);  						config.SetString(ConfigConstants.CONFIG_BRANCH_SECTION' name' ConfigConstants.CONFIG_KEY_MERGE  							' Constants.R_HEADS + branchName);  					}  					else  					{  						// set "." as remote  						config.SetString(ConfigConstants.CONFIG_BRANCH_SECTION' name' ConfigConstants.CONFIG_KEY_REMOTE  							' ".");  						config.SetString(ConfigConstants.CONFIG_BRANCH_SECTION' name' ConfigConstants.CONFIG_KEY_MERGE  							' baseBranch);  					}  					config.Save();  				}  				return result;  			}  			catch (IOException ioe)  			{  				throw new JGitInternalException(ioe.Message' ioe);  			}  			finally  			{  				revWalk.Release();  			}
Magic Number,NGit.Api,CreateBranchCommand,C:\repos\mono_ngit\NGit\NGit.Api\CreateBranchCommand.cs,Call,The following statement contains a magic number: try  			{  				Ref refToCheck = repo.GetRef(name);  				bool exists = refToCheck != null && refToCheck.GetName().StartsWith(Constants.R_HEADS  					);  				if (!force && exists)  				{  					throw new RefAlreadyExistsException(MessageFormat.Format(JGitText.Get().refAlreadyExists1  						' name));  				}  				ObjectId startAt = GetStartPoint();  				string startPointFullName = null;  				if (startPoint != null)  				{  					Ref baseRef = repo.GetRef(startPoint);  					if (baseRef != null)  					{  						startPointFullName = baseRef.GetName();  					}  				}  				// determine whether we are based on a commit'  				// a branch' or a tag and compose the reflog message  				string refLogMessage;  				string baseBranch = string.Empty;  				if (startPointFullName == null)  				{  					string baseCommit;  					if (startCommit != null)  					{  						baseCommit = startCommit.GetShortMessage();  					}  					else  					{  						RevCommit commit = revWalk.ParseCommit(repo.Resolve(startPoint));  						baseCommit = commit.GetShortMessage();  					}  					if (exists)  					{  						refLogMessage = "branch: Reset start-point to commit " + baseCommit;  					}  					else  					{  						refLogMessage = "branch: Created from commit " + baseCommit;  					}  				}  				else  				{  					if (startPointFullName.StartsWith(Constants.R_HEADS) || startPointFullName.StartsWith  						(Constants.R_REMOTES))  					{  						baseBranch = startPointFullName;  						if (exists)  						{  							refLogMessage = "branch: Reset start-point to branch " + startPointFullName;  						}  						else  						{  							// TODO  							refLogMessage = "branch: Created from branch " + baseBranch;  						}  					}  					else  					{  						startAt = revWalk.Peel(revWalk.ParseAny(startAt));  						if (exists)  						{  							refLogMessage = "branch: Reset start-point to tag " + startPointFullName;  						}  						else  						{  							refLogMessage = "branch: Created from tag " + startPointFullName;  						}  					}  				}  				RefUpdate updateRef = repo.UpdateRef(Constants.R_HEADS + name);  				updateRef.SetNewObjectId(startAt);  				updateRef.SetRefLogMessage(refLogMessage' false);  				RefUpdate.Result updateResult;  				if (exists && force)  				{  					updateResult = updateRef.ForceUpdate();  				}  				else  				{  					updateResult = updateRef.Update();  				}  				SetCallable(false);  				bool ok = false;  				switch (updateResult)  				{  					case RefUpdate.Result.NEW:  					{  						ok = !exists;  						break;  					}    					case RefUpdate.Result.NO_CHANGE:  					case RefUpdate.Result.FAST_FORWARD:  					case RefUpdate.Result.FORCED:  					{  						ok = exists;  						break;  					}    					default:  					{  						break;  						break;  					}  				}  				if (!ok)  				{  					throw new JGitInternalException(MessageFormat.Format(JGitText.Get().createBranchUnexpectedResult  						' updateResult.ToString()));  				}  				Ref result = repo.GetRef(name);  				if (result == null)  				{  					throw new JGitInternalException(JGitText.Get().createBranchFailedUnknownReason);  				}  				if (baseBranch.Length == 0)  				{  					return result;  				}  				// if we are based on another branch' see  				// if we need to configure upstream configuration: first check  				// whether the setting was done explicitly  				bool doConfigure;  				if (upstreamMode == CreateBranchCommand.SetupUpstreamMode.SET_UPSTREAM || upstreamMode  					 == CreateBranchCommand.SetupUpstreamMode.TRACK)  				{  					// explicitly set to configure  					doConfigure = true;  				}  				else  				{  					if (upstreamMode == CreateBranchCommand.SetupUpstreamMode.NOTRACK)  					{  						// explicitly set to not configure  						doConfigure = false;  					}  					else  					{  						// if there was no explicit setting' check the configuration  						string autosetupflag = repo.GetConfig().GetString(ConfigConstants.CONFIG_BRANCH_SECTION  							' null' ConfigConstants.CONFIG_KEY_AUTOSETUPMERGE);  						if ("false".Equals(autosetupflag))  						{  							doConfigure = false;  						}  						else  						{  							if ("always".Equals(autosetupflag))  							{  								doConfigure = true;  							}  							else  							{  								// in this case' the default is to configure  								// only in case the base branch was a remote branch  								doConfigure = baseBranch.StartsWith(Constants.R_REMOTES);  							}  						}  					}  				}  				if (doConfigure)  				{  					StoredConfig config = repo.GetConfig();  					string[] tokens = baseBranch.Split("/"' 4);  					bool isRemote = tokens[1].Equals("remotes");  					if (isRemote)  					{  						// refs/remotes/<remote name>/<branch>  						string remoteName = tokens[2];  						string branchName = tokens[3];  						config.SetString(ConfigConstants.CONFIG_BRANCH_SECTION' name' ConfigConstants.CONFIG_KEY_REMOTE  							' remoteName);  						config.SetString(ConfigConstants.CONFIG_BRANCH_SECTION' name' ConfigConstants.CONFIG_KEY_MERGE  							' Constants.R_HEADS + branchName);  					}  					else  					{  						// set "." as remote  						config.SetString(ConfigConstants.CONFIG_BRANCH_SECTION' name' ConfigConstants.CONFIG_KEY_REMOTE  							' ".");  						config.SetString(ConfigConstants.CONFIG_BRANCH_SECTION' name' ConfigConstants.CONFIG_KEY_MERGE  							' baseBranch);  					}  					config.Save();  				}  				return result;  			}  			catch (IOException ioe)  			{  				throw new JGitInternalException(ioe.Message' ioe);  			}  			finally  			{  				revWalk.Release();  			}
Magic Number,NGit.Api,CherryPickCommand,C:\repos\mono_ngit\NGit\NGit.Api\CherryPickCommand.cs,Call,The following statement contains a magic number: try  			{  				// get the head commit  				Ref headRef = repo.GetRef(Constants.HEAD);  				if (headRef == null)  				{  					throw new NoHeadException(JGitText.Get().commitOnRepoWithoutHEADCurrentlyNotSupported  						);  				}  				RevCommit headCommit = revWalk.ParseCommit(headRef.GetObjectId());  				newHead = headCommit;  				// loop through all refs to be cherry-picked  				foreach (Ref src in commits)  				{  					// get the commit to be cherry-picked  					// handle annotated tags  					ObjectId srcObjectId = src.GetPeeledObjectId();  					if (srcObjectId == null)  					{  						srcObjectId = src.GetObjectId();  					}  					RevCommit srcCommit = revWalk.ParseCommit(srcObjectId);  					// get the parent of the commit to cherry-pick  					if (srcCommit.ParentCount != 1)  					{  						throw new MultipleParentsNotAllowedException(MessageFormat.Format(JGitText.Get().  							canOnlyCherryPickCommitsWithOneParent' srcCommit.Name' Sharpen.Extensions.ValueOf  							(srcCommit.ParentCount)));  					}  					RevCommit srcParent = srcCommit.GetParent(0);  					revWalk.ParseHeaders(srcParent);  					string ourName = CalculateOurName(headRef);  					string cherryPickName = srcCommit.Id.Abbreviate(7).Name + " " + srcCommit.GetShortMessage  						();  					ResolveMerger merger = (ResolveMerger)((ThreeWayMerger)MergeStrategy.RESOLVE.NewMerger  						(repo));  					merger.SetWorkingTreeIterator(new FileTreeIterator(repo));  					merger.SetBase(srcParent.Tree);  					merger.SetCommitNames(new string[] { "BASE"' ourName' cherryPickName });  					if (merger.Merge(headCommit' srcCommit))  					{  						if (AnyObjectId.Equals(headCommit.Tree.Id' merger.GetResultTreeId()))  						{  							continue;  						}  						DirCacheCheckout dco = new DirCacheCheckout(repo' headCommit.Tree' repo.LockDirCache  							()' merger.GetResultTreeId());  						dco.SetFailOnConflict(true);  						dco.Checkout();  						newHead = new Git(GetRepository()).Commit().SetMessage(srcCommit.GetFullMessage()  							).SetReflogComment("cherry-pick: " + srcCommit.GetShortMessage()).SetAuthor(srcCommit  							.GetAuthorIdent()).Call();  						cherryPickedRefs.AddItem(src);  					}  					else  					{  						if (merger.Failed())  						{  							return new CherryPickResult(merger.GetFailingPaths());  						}  						// there are merge conflicts  						string message = new MergeMessageFormatter().FormatWithConflicts(srcCommit.GetFullMessage  							()' merger.GetUnmergedPaths());  						repo.WriteCherryPickHead(srcCommit.Id);  						repo.WriteMergeCommitMsg(message);  						return CherryPickResult.CONFLICT;  					}  				}  			}  			catch (IOException e)  			{  				throw new JGitInternalException(MessageFormat.Format(JGitText.Get().exceptionCaughtDuringExecutionOfCherryPickCommand  					' e)' e);  			}  			finally  			{  				revWalk.Release();  			}
Magic Number,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,ToAuthorScript,The following statement contains a magic number: StringBuilder sb = new StringBuilder(100);
Magic Number,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,ToAuthorScript,The following statement contains a magic number: sb.Append(Sharpen.Runtime.Substring(externalString' externalString.LastIndexOf('>'  				) + 2));
Magic Number,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,LoadSteps,The following statement contains a magic number: while (ptr < buf.Length)  			{  				tokenBegin = ptr;  				ptr = RawParseUtils.NextLF(buf' ptr);  				int nextSpace = RawParseUtils.Next(buf' tokenBegin' ' ');  				int tokenCount = 0;  				RebaseCommand.Step current = null;  				while (tokenCount < 3 && nextSpace < ptr)  				{  					switch (tokenCount)  					{  						case 0:  						{  							string actionToken = Sharpen.Runtime.GetStringForBytes(buf' tokenBegin' nextSpace  								 - tokenBegin - 1);  							tokenBegin = nextSpace;  							if (actionToken[0] == '#')  							{  								tokenCount = 3;  								break;  							}  							RebaseCommand.Action action = RebaseCommand.Action.Parse(actionToken);  							if (action != null)  							{  								current = new RebaseCommand.Step(RebaseCommand.Action.Parse(actionToken));  							}  							break;  						}    						case 1:  						{  							if (current == null)  							{  								break;  							}  							nextSpace = RawParseUtils.Next(buf' tokenBegin' ' ');  							string commitToken = Sharpen.Runtime.GetStringForBytes(buf' tokenBegin' nextSpace  								 - tokenBegin - 1);  							tokenBegin = nextSpace;  							current.commit = AbbreviatedObjectId.FromString(commitToken);  							break;  						}    						case 2:  						{  							if (current == null)  							{  								break;  							}  							nextSpace = ptr;  							int length = ptr - tokenBegin;  							current.shortMessage = new byte[length];  							System.Array.Copy(buf' tokenBegin' current.shortMessage' 0' length);  							r.AddItem(current);  							break;  						}  					}  					tokenCount++;  				}  			}
Magic Number,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,LoadSteps,The following statement contains a magic number: while (ptr < buf.Length)  			{  				tokenBegin = ptr;  				ptr = RawParseUtils.NextLF(buf' ptr);  				int nextSpace = RawParseUtils.Next(buf' tokenBegin' ' ');  				int tokenCount = 0;  				RebaseCommand.Step current = null;  				while (tokenCount < 3 && nextSpace < ptr)  				{  					switch (tokenCount)  					{  						case 0:  						{  							string actionToken = Sharpen.Runtime.GetStringForBytes(buf' tokenBegin' nextSpace  								 - tokenBegin - 1);  							tokenBegin = nextSpace;  							if (actionToken[0] == '#')  							{  								tokenCount = 3;  								break;  							}  							RebaseCommand.Action action = RebaseCommand.Action.Parse(actionToken);  							if (action != null)  							{  								current = new RebaseCommand.Step(RebaseCommand.Action.Parse(actionToken));  							}  							break;  						}    						case 1:  						{  							if (current == null)  							{  								break;  							}  							nextSpace = RawParseUtils.Next(buf' tokenBegin' ' ');  							string commitToken = Sharpen.Runtime.GetStringForBytes(buf' tokenBegin' nextSpace  								 - tokenBegin - 1);  							tokenBegin = nextSpace;  							current.commit = AbbreviatedObjectId.FromString(commitToken);  							break;  						}    						case 2:  						{  							if (current == null)  							{  								break;  							}  							nextSpace = ptr;  							int length = ptr - tokenBegin;  							current.shortMessage = new byte[length];  							System.Array.Copy(buf' tokenBegin' current.shortMessage' 0' length);  							r.AddItem(current);  							break;  						}  					}  					tokenCount++;  				}  			}
Magic Number,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,LoadSteps,The following statement contains a magic number: while (ptr < buf.Length)  			{  				tokenBegin = ptr;  				ptr = RawParseUtils.NextLF(buf' ptr);  				int nextSpace = RawParseUtils.Next(buf' tokenBegin' ' ');  				int tokenCount = 0;  				RebaseCommand.Step current = null;  				while (tokenCount < 3 && nextSpace < ptr)  				{  					switch (tokenCount)  					{  						case 0:  						{  							string actionToken = Sharpen.Runtime.GetStringForBytes(buf' tokenBegin' nextSpace  								 - tokenBegin - 1);  							tokenBegin = nextSpace;  							if (actionToken[0] == '#')  							{  								tokenCount = 3;  								break;  							}  							RebaseCommand.Action action = RebaseCommand.Action.Parse(actionToken);  							if (action != null)  							{  								current = new RebaseCommand.Step(RebaseCommand.Action.Parse(actionToken));  							}  							break;  						}    						case 1:  						{  							if (current == null)  							{  								break;  							}  							nextSpace = RawParseUtils.Next(buf' tokenBegin' ' ');  							string commitToken = Sharpen.Runtime.GetStringForBytes(buf' tokenBegin' nextSpace  								 - tokenBegin - 1);  							tokenBegin = nextSpace;  							current.commit = AbbreviatedObjectId.FromString(commitToken);  							break;  						}    						case 2:  						{  							if (current == null)  							{  								break;  							}  							nextSpace = ptr;  							int length = ptr - tokenBegin;  							current.shortMessage = new byte[length];  							System.Array.Copy(buf' tokenBegin' current.shortMessage' 0' length);  							r.AddItem(current);  							break;  						}  					}  					tokenCount++;  				}  			}
Magic Number,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,ParseAuthor,The following statement contains a magic number: for (int p = 0; p < raw.Length; )  			{  				int end = RawParseUtils.NextLF(raw' p);  				if (end == p)  				{  					break;  				}  				int equalsIndex = RawParseUtils.Next(raw' p' '=');  				if (equalsIndex == end)  				{  					break;  				}  				string key = RawParseUtils.Decode(raw' p' equalsIndex - 1);  				string value = RawParseUtils.Decode(raw' equalsIndex + 1' end - 2);  				p = end;  				keyValueMap.Put(key' value);  			}
Magic Number,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,ParseAuthor,The following statement contains a magic number: long when = long.Parse(Sharpen.Runtime.Substring(time' timeStart' time.IndexOf(' '  				))) * 1000;
Magic Number,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,ParseAuthor,The following statement contains a magic number: int hours = System.Convert.ToInt32(Sharpen.Runtime.Substring(tzOffsetString' 1' 3  				));
Magic Number,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,ParseAuthor,The following statement contains a magic number: int minutes = System.Convert.ToInt32(Sharpen.Runtime.Substring(tzOffsetString' 3'   				5));
Magic Number,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,ParseAuthor,The following statement contains a magic number: int minutes = System.Convert.ToInt32(Sharpen.Runtime.Substring(tzOffsetString' 3'   				5));
Magic Number,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,ParseAuthor,The following statement contains a magic number: int tz = (hours * 60 + minutes) * multiplier;
Magic Number,NGit.Api,StashApplyCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashApplyCommand.cs,ScanForConflicts,The following statement contains a magic number: while (treeWalk.Next())  			{  				// State of the stashed index and working directory  				AbstractTreeIterator stashIndexIter = treeWalk.GetTree<AbstractTreeIterator>(1);  				AbstractTreeIterator stashWorkingIter = treeWalk.GetTree<AbstractTreeIterator>(2);  				// State of the current HEAD' index' and working directory  				AbstractTreeIterator headIter = treeWalk.GetTree<AbstractTreeIterator>(3);  				AbstractTreeIterator indexIter = treeWalk.GetTree<AbstractTreeIterator>(4);  				AbstractTreeIterator workingIter = treeWalk.GetTree<AbstractTreeIterator>(5);  				if (IsConflict(stashIndexIter' stashWorkingIter' headIter' indexIter' workingIter  					))  				{  					string path = treeWalk.PathString;  					FilePath file = new FilePath(workingTree' path);  					throw new NGit.Errors.CheckoutConflictException(file.GetAbsolutePath());  				}  			}
Magic Number,NGit.Api,StashApplyCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashApplyCommand.cs,ScanForConflicts,The following statement contains a magic number: while (treeWalk.Next())  			{  				// State of the stashed index and working directory  				AbstractTreeIterator stashIndexIter = treeWalk.GetTree<AbstractTreeIterator>(1);  				AbstractTreeIterator stashWorkingIter = treeWalk.GetTree<AbstractTreeIterator>(2);  				// State of the current HEAD' index' and working directory  				AbstractTreeIterator headIter = treeWalk.GetTree<AbstractTreeIterator>(3);  				AbstractTreeIterator indexIter = treeWalk.GetTree<AbstractTreeIterator>(4);  				AbstractTreeIterator workingIter = treeWalk.GetTree<AbstractTreeIterator>(5);  				if (IsConflict(stashIndexIter' stashWorkingIter' headIter' indexIter' workingIter  					))  				{  					string path = treeWalk.PathString;  					FilePath file = new FilePath(workingTree' path);  					throw new NGit.Errors.CheckoutConflictException(file.GetAbsolutePath());  				}  			}
Magic Number,NGit.Api,StashApplyCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashApplyCommand.cs,ScanForConflicts,The following statement contains a magic number: while (treeWalk.Next())  			{  				// State of the stashed index and working directory  				AbstractTreeIterator stashIndexIter = treeWalk.GetTree<AbstractTreeIterator>(1);  				AbstractTreeIterator stashWorkingIter = treeWalk.GetTree<AbstractTreeIterator>(2);  				// State of the current HEAD' index' and working directory  				AbstractTreeIterator headIter = treeWalk.GetTree<AbstractTreeIterator>(3);  				AbstractTreeIterator indexIter = treeWalk.GetTree<AbstractTreeIterator>(4);  				AbstractTreeIterator workingIter = treeWalk.GetTree<AbstractTreeIterator>(5);  				if (IsConflict(stashIndexIter' stashWorkingIter' headIter' indexIter' workingIter  					))  				{  					string path = treeWalk.PathString;  					FilePath file = new FilePath(workingTree' path);  					throw new NGit.Errors.CheckoutConflictException(file.GetAbsolutePath());  				}  			}
Magic Number,NGit.Api,StashApplyCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashApplyCommand.cs,ScanForConflicts,The following statement contains a magic number: while (treeWalk.Next())  			{  				// State of the stashed index and working directory  				AbstractTreeIterator stashIndexIter = treeWalk.GetTree<AbstractTreeIterator>(1);  				AbstractTreeIterator stashWorkingIter = treeWalk.GetTree<AbstractTreeIterator>(2);  				// State of the current HEAD' index' and working directory  				AbstractTreeIterator headIter = treeWalk.GetTree<AbstractTreeIterator>(3);  				AbstractTreeIterator indexIter = treeWalk.GetTree<AbstractTreeIterator>(4);  				AbstractTreeIterator workingIter = treeWalk.GetTree<AbstractTreeIterator>(5);  				if (IsConflict(stashIndexIter' stashWorkingIter' headIter' indexIter' workingIter  					))  				{  					string path = treeWalk.PathString;  					FilePath file = new FilePath(workingTree' path);  					throw new NGit.Errors.CheckoutConflictException(file.GetAbsolutePath());  				}  			}
Magic Number,NGit.Api,StashApplyCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashApplyCommand.cs,ApplyChanges,The following statement contains a magic number: while (treeWalk.Next())  			{  				string path = treeWalk.PathString;  				FilePath file = new FilePath(workingTree' path);  				// State of the stashed HEAD' index' and working directory  				AbstractTreeIterator stashHeadIter = treeWalk.GetTree<AbstractTreeIterator>(0);  				AbstractTreeIterator stashIndexIter = treeWalk.GetTree<AbstractTreeIterator>(1);  				AbstractTreeIterator stashWorkingIter = treeWalk.GetTree<AbstractTreeIterator>(2);  				if (stashWorkingIter != null && stashIndexIter != null)  				{  					// Checkout index change  					DirCacheEntry entry = cache.GetEntry(path);  					if (entry == null)  					{  						entry = new DirCacheEntry(treeWalk.RawPath);  					}  					entry.FileMode = stashIndexIter.EntryFileMode;  					entry.SetObjectId(stashIndexIter.EntryObjectId);  					DirCacheCheckout.CheckoutEntry(repo' file' entry' treeWalk.ObjectReader);  					DirCacheEntry updatedEntry = entry;  					editor.Add(new _PathEdit_270(updatedEntry' path));  					// Checkout working directory change  					if (!stashWorkingIter.IdEqual(stashIndexIter))  					{  						entry = new DirCacheEntry(treeWalk.RawPath);  						entry.SetObjectId(stashWorkingIter.EntryObjectId);  						DirCacheCheckout.CheckoutEntry(repo' file' entry' treeWalk.ObjectReader);  					}  				}  				else  				{  					if (stashIndexIter == null || (stashHeadIter != null && !stashIndexIter.IdEqual(stashHeadIter  						)))  					{  						editor.Add(new DirCacheEditor.DeletePath(path));  					}  					FileUtils.Delete(file' FileUtils.RETRY | FileUtils.SKIP_MISSING);  				}  			}
Magic Number,NGit.Api,StashApplyCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashApplyCommand.cs,Call,The following statement contains a magic number: try  			{  				RevWalk revWalk = new RevWalk(reader);  				RevCommit stashCommit = revWalk.ParseCommit(stashId);  				if (stashCommit.ParentCount != 2)  				{  					throw new JGitInternalException(MessageFormat.Format(JGitText.Get().stashCommitMissingTwoParents  						' stashId.Name));  				}  				RevTree stashWorkingTree = stashCommit.Tree;  				RevTree stashIndexTree = revWalk.ParseCommit(stashCommit.GetParent(1)).Tree;  				RevTree stashHeadTree = revWalk.ParseCommit(stashCommit.GetParent(0)).Tree;  				CanonicalTreeParser stashWorkingIter = new CanonicalTreeParser();  				stashWorkingIter.Reset(reader' stashWorkingTree);  				CanonicalTreeParser stashIndexIter = new CanonicalTreeParser();  				stashIndexIter.Reset(reader' stashIndexTree);  				CanonicalTreeParser stashHeadIter = new CanonicalTreeParser();  				stashHeadIter.Reset(reader' stashHeadTree);  				CanonicalTreeParser headIter = new CanonicalTreeParser();  				headIter.Reset(reader' headTree);  				DirCache cache = repo.LockDirCache();  				DirCacheEditor editor = cache.Editor();  				try  				{  					DirCacheIterator indexIter = new DirCacheIterator(cache);  					FileTreeIterator workingIter = new FileTreeIterator(repo);  					TreeWalk treeWalk = new TreeWalk(reader);  					treeWalk.Recursive = true;  					treeWalk.Filter = new StashApplyCommand.StashDiffFilter();  					treeWalk.AddTree(stashHeadIter);  					treeWalk.AddTree(stashIndexIter);  					treeWalk.AddTree(stashWorkingIter);  					treeWalk.AddTree(headIter);  					treeWalk.AddTree(indexIter);  					treeWalk.AddTree(workingIter);  					ScanForConflicts(treeWalk);  					// Reset trees and walk  					treeWalk.Reset();  					stashWorkingIter.Reset(reader' stashWorkingTree);  					stashIndexIter.Reset(reader' stashIndexTree);  					stashHeadIter.Reset(reader' stashHeadTree);  					treeWalk.AddTree(stashHeadIter);  					treeWalk.AddTree(stashIndexIter);  					treeWalk.AddTree(stashWorkingIter);  					ApplyChanges(treeWalk' cache' editor);  				}  				finally  				{  					editor.Commit();  					cache.Unlock();  				}  			}  			catch (JGitInternalException e)  			{  				throw;  			}  			catch (IOException e)  			{  				throw new JGitInternalException(JGitText.Get().stashApplyFailed' e);  			}  			finally  			{  				reader.Release();  			}
Magic Number,NGit.Api,StashDiffFilter,C:\repos\mono_ngit\NGit\NGit.Api\StashApplyCommand.cs,Include,The following statement contains a magic number: if (walker.GetRawMode(2) != m || !walker.IdEqual(2' 0))  				{  					return true;  				}
Magic Number,NGit.Api,StashDiffFilter,C:\repos\mono_ngit\NGit\NGit.Api\StashApplyCommand.cs,Include,The following statement contains a magic number: if (walker.GetRawMode(2) != m || !walker.IdEqual(2' 0))  				{  					return true;  				}
Magic Number,NGit.Api,StashCreateCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashCreateCommand.cs,Call,The following statement contains a magic number: try  			{  				RevCommit headCommit = ParseCommit(reader' head.GetObjectId());  				DirCache cache = repo.LockDirCache();  				ObjectInserter inserter = repo.NewObjectInserter();  				ObjectId commitId;  				try  				{  					TreeWalk treeWalk = new TreeWalk(reader);  					treeWalk.Recursive = true;  					treeWalk.AddTree(headCommit.Tree);  					treeWalk.AddTree(new DirCacheIterator(cache));  					treeWalk.AddTree(new FileTreeIterator(repo));  					treeWalk.Filter = AndTreeFilter.Create(new SkipWorkTreeFilter(1)' new IndexDiffFilter  						(1' 2));  					// Return null if no local changes to stash  					if (!treeWalk.Next())  					{  						return null;  					}  					MutableObjectId id = new MutableObjectId();  					IList<DirCacheEditor.PathEdit> wtEdits = new AList<DirCacheEditor.PathEdit>();  					IList<string> wtDeletes = new AList<string>();  					do  					{  						AbstractTreeIterator headIter = treeWalk.GetTree<AbstractTreeIterator>(0);  						DirCacheIterator indexIter = treeWalk.GetTree<DirCacheIterator>(1);  						WorkingTreeIterator wtIter = treeWalk.GetTree<WorkingTreeIterator>(2);  						if (headIter != null && indexIter != null && wtIter != null)  						{  							if (!indexIter.GetDirCacheEntry().IsMerged())  							{  								throw new UnmergedPathsException(new UnmergedPathException(indexIter.GetDirCacheEntry  									()));  							}  							if (wtIter.IdEqual(indexIter) || wtIter.IdEqual(headIter))  							{  								continue;  							}  							treeWalk.GetObjectId(id' 0);  							DirCacheEntry entry = new DirCacheEntry(treeWalk.RawPath);  							entry.SetLength(wtIter.GetEntryLength());  							entry.LastModified = wtIter.GetEntryLastModified();  							entry.FileMode = wtIter.EntryFileMode;  							long contentLength = wtIter.GetEntryContentLength();  							InputStream @in = wtIter.OpenEntryStream();  							try  							{  								entry.SetObjectId(inserter.Insert(Constants.OBJ_BLOB' contentLength' @in));  							}  							finally  							{  								@in.Close();  							}  							wtEdits.AddItem(new _PathEdit_273(entry' entry));  						}  						else  						{  							if (indexIter == null)  							{  								wtDeletes.AddItem(treeWalk.PathString);  							}  							else  							{  								if (wtIter == null && headIter != null)  								{  									wtDeletes.AddItem(treeWalk.PathString);  								}  							}  						}  					}  					while (treeWalk.Next());  					string branch = Repository.ShortenRefName(head.GetTarget().GetName());  					// Commit index changes  					NGit.CommitBuilder builder = CreateBuilder(headCommit);  					builder.TreeId = cache.WriteTree(inserter);  					builder.Message = MessageFormat.Format(indexMessage' branch' headCommit.Abbreviate  						(7).Name' headCommit.GetShortMessage());  					ObjectId indexCommit = inserter.Insert(builder);  					// Commit working tree changes  					if (!wtEdits.IsEmpty() || !wtDeletes.IsEmpty())  					{  						DirCacheEditor editor = cache.Editor();  						foreach (DirCacheEditor.PathEdit edit in wtEdits)  						{  							editor.Add(edit);  						}  						foreach (string path in wtDeletes)  						{  							editor.Add(new DirCacheEditor.DeletePath(path));  						}  						editor.Finish();  					}  					builder.AddParentId(indexCommit);  					builder.Message = MessageFormat.Format(workingDirectoryMessage' branch' headCommit  						.Abbreviate(7).Name' headCommit.GetShortMessage());  					builder.TreeId = cache.WriteTree(inserter);  					commitId = inserter.Insert(builder);  					inserter.Flush();  					UpdateStashRef(commitId' builder.Author' builder.Message);  				}  				finally  				{  					inserter.Release();  					cache.Unlock();  				}  				// Hard reset to HEAD  				new ResetCommand(repo).SetMode(ResetCommand.ResetType.HARD).Call();  				// Return stashed commit  				return ParseCommit(reader' commitId);  			}  			catch (IOException e)  			{  				throw new JGitInternalException(JGitText.Get().stashFailed' e);  			}  			finally  			{  				reader.Release();  			}
Magic Number,NGit.Api,StashCreateCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashCreateCommand.cs,Call,The following statement contains a magic number: try  			{  				RevCommit headCommit = ParseCommit(reader' head.GetObjectId());  				DirCache cache = repo.LockDirCache();  				ObjectInserter inserter = repo.NewObjectInserter();  				ObjectId commitId;  				try  				{  					TreeWalk treeWalk = new TreeWalk(reader);  					treeWalk.Recursive = true;  					treeWalk.AddTree(headCommit.Tree);  					treeWalk.AddTree(new DirCacheIterator(cache));  					treeWalk.AddTree(new FileTreeIterator(repo));  					treeWalk.Filter = AndTreeFilter.Create(new SkipWorkTreeFilter(1)' new IndexDiffFilter  						(1' 2));  					// Return null if no local changes to stash  					if (!treeWalk.Next())  					{  						return null;  					}  					MutableObjectId id = new MutableObjectId();  					IList<DirCacheEditor.PathEdit> wtEdits = new AList<DirCacheEditor.PathEdit>();  					IList<string> wtDeletes = new AList<string>();  					do  					{  						AbstractTreeIterator headIter = treeWalk.GetTree<AbstractTreeIterator>(0);  						DirCacheIterator indexIter = treeWalk.GetTree<DirCacheIterator>(1);  						WorkingTreeIterator wtIter = treeWalk.GetTree<WorkingTreeIterator>(2);  						if (headIter != null && indexIter != null && wtIter != null)  						{  							if (!indexIter.GetDirCacheEntry().IsMerged())  							{  								throw new UnmergedPathsException(new UnmergedPathException(indexIter.GetDirCacheEntry  									()));  							}  							if (wtIter.IdEqual(indexIter) || wtIter.IdEqual(headIter))  							{  								continue;  							}  							treeWalk.GetObjectId(id' 0);  							DirCacheEntry entry = new DirCacheEntry(treeWalk.RawPath);  							entry.SetLength(wtIter.GetEntryLength());  							entry.LastModified = wtIter.GetEntryLastModified();  							entry.FileMode = wtIter.EntryFileMode;  							long contentLength = wtIter.GetEntryContentLength();  							InputStream @in = wtIter.OpenEntryStream();  							try  							{  								entry.SetObjectId(inserter.Insert(Constants.OBJ_BLOB' contentLength' @in));  							}  							finally  							{  								@in.Close();  							}  							wtEdits.AddItem(new _PathEdit_273(entry' entry));  						}  						else  						{  							if (indexIter == null)  							{  								wtDeletes.AddItem(treeWalk.PathString);  							}  							else  							{  								if (wtIter == null && headIter != null)  								{  									wtDeletes.AddItem(treeWalk.PathString);  								}  							}  						}  					}  					while (treeWalk.Next());  					string branch = Repository.ShortenRefName(head.GetTarget().GetName());  					// Commit index changes  					NGit.CommitBuilder builder = CreateBuilder(headCommit);  					builder.TreeId = cache.WriteTree(inserter);  					builder.Message = MessageFormat.Format(indexMessage' branch' headCommit.Abbreviate  						(7).Name' headCommit.GetShortMessage());  					ObjectId indexCommit = inserter.Insert(builder);  					// Commit working tree changes  					if (!wtEdits.IsEmpty() || !wtDeletes.IsEmpty())  					{  						DirCacheEditor editor = cache.Editor();  						foreach (DirCacheEditor.PathEdit edit in wtEdits)  						{  							editor.Add(edit);  						}  						foreach (string path in wtDeletes)  						{  							editor.Add(new DirCacheEditor.DeletePath(path));  						}  						editor.Finish();  					}  					builder.AddParentId(indexCommit);  					builder.Message = MessageFormat.Format(workingDirectoryMessage' branch' headCommit  						.Abbreviate(7).Name' headCommit.GetShortMessage());  					builder.TreeId = cache.WriteTree(inserter);  					commitId = inserter.Insert(builder);  					inserter.Flush();  					UpdateStashRef(commitId' builder.Author' builder.Message);  				}  				finally  				{  					inserter.Release();  					cache.Unlock();  				}  				// Hard reset to HEAD  				new ResetCommand(repo).SetMode(ResetCommand.ResetType.HARD).Call();  				// Return stashed commit  				return ParseCommit(reader' commitId);  			}  			catch (IOException e)  			{  				throw new JGitInternalException(JGitText.Get().stashFailed' e);  			}  			finally  			{  				reader.Release();  			}
Magic Number,NGit.Api,StashCreateCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashCreateCommand.cs,Call,The following statement contains a magic number: try  			{  				RevCommit headCommit = ParseCommit(reader' head.GetObjectId());  				DirCache cache = repo.LockDirCache();  				ObjectInserter inserter = repo.NewObjectInserter();  				ObjectId commitId;  				try  				{  					TreeWalk treeWalk = new TreeWalk(reader);  					treeWalk.Recursive = true;  					treeWalk.AddTree(headCommit.Tree);  					treeWalk.AddTree(new DirCacheIterator(cache));  					treeWalk.AddTree(new FileTreeIterator(repo));  					treeWalk.Filter = AndTreeFilter.Create(new SkipWorkTreeFilter(1)' new IndexDiffFilter  						(1' 2));  					// Return null if no local changes to stash  					if (!treeWalk.Next())  					{  						return null;  					}  					MutableObjectId id = new MutableObjectId();  					IList<DirCacheEditor.PathEdit> wtEdits = new AList<DirCacheEditor.PathEdit>();  					IList<string> wtDeletes = new AList<string>();  					do  					{  						AbstractTreeIterator headIter = treeWalk.GetTree<AbstractTreeIterator>(0);  						DirCacheIterator indexIter = treeWalk.GetTree<DirCacheIterator>(1);  						WorkingTreeIterator wtIter = treeWalk.GetTree<WorkingTreeIterator>(2);  						if (headIter != null && indexIter != null && wtIter != null)  						{  							if (!indexIter.GetDirCacheEntry().IsMerged())  							{  								throw new UnmergedPathsException(new UnmergedPathException(indexIter.GetDirCacheEntry  									()));  							}  							if (wtIter.IdEqual(indexIter) || wtIter.IdEqual(headIter))  							{  								continue;  							}  							treeWalk.GetObjectId(id' 0);  							DirCacheEntry entry = new DirCacheEntry(treeWalk.RawPath);  							entry.SetLength(wtIter.GetEntryLength());  							entry.LastModified = wtIter.GetEntryLastModified();  							entry.FileMode = wtIter.EntryFileMode;  							long contentLength = wtIter.GetEntryContentLength();  							InputStream @in = wtIter.OpenEntryStream();  							try  							{  								entry.SetObjectId(inserter.Insert(Constants.OBJ_BLOB' contentLength' @in));  							}  							finally  							{  								@in.Close();  							}  							wtEdits.AddItem(new _PathEdit_273(entry' entry));  						}  						else  						{  							if (indexIter == null)  							{  								wtDeletes.AddItem(treeWalk.PathString);  							}  							else  							{  								if (wtIter == null && headIter != null)  								{  									wtDeletes.AddItem(treeWalk.PathString);  								}  							}  						}  					}  					while (treeWalk.Next());  					string branch = Repository.ShortenRefName(head.GetTarget().GetName());  					// Commit index changes  					NGit.CommitBuilder builder = CreateBuilder(headCommit);  					builder.TreeId = cache.WriteTree(inserter);  					builder.Message = MessageFormat.Format(indexMessage' branch' headCommit.Abbreviate  						(7).Name' headCommit.GetShortMessage());  					ObjectId indexCommit = inserter.Insert(builder);  					// Commit working tree changes  					if (!wtEdits.IsEmpty() || !wtDeletes.IsEmpty())  					{  						DirCacheEditor editor = cache.Editor();  						foreach (DirCacheEditor.PathEdit edit in wtEdits)  						{  							editor.Add(edit);  						}  						foreach (string path in wtDeletes)  						{  							editor.Add(new DirCacheEditor.DeletePath(path));  						}  						editor.Finish();  					}  					builder.AddParentId(indexCommit);  					builder.Message = MessageFormat.Format(workingDirectoryMessage' branch' headCommit  						.Abbreviate(7).Name' headCommit.GetShortMessage());  					builder.TreeId = cache.WriteTree(inserter);  					commitId = inserter.Insert(builder);  					inserter.Flush();  					UpdateStashRef(commitId' builder.Author' builder.Message);  				}  				finally  				{  					inserter.Release();  					cache.Unlock();  				}  				// Hard reset to HEAD  				new ResetCommand(repo).SetMode(ResetCommand.ResetType.HARD).Call();  				// Return stashed commit  				return ParseCommit(reader' commitId);  			}  			catch (IOException e)  			{  				throw new JGitInternalException(JGitText.Get().stashFailed' e);  			}  			finally  			{  				reader.Release();  			}
Magic Number,NGit.Api,StashCreateCommand,C:\repos\mono_ngit\NGit\NGit.Api\StashCreateCommand.cs,Call,The following statement contains a magic number: try  			{  				RevCommit headCommit = ParseCommit(reader' head.GetObjectId());  				DirCache cache = repo.LockDirCache();  				ObjectInserter inserter = repo.NewObjectInserter();  				ObjectId commitId;  				try  				{  					TreeWalk treeWalk = new TreeWalk(reader);  					treeWalk.Recursive = true;  					treeWalk.AddTree(headCommit.Tree);  					treeWalk.AddTree(new DirCacheIterator(cache));  					treeWalk.AddTree(new FileTreeIterator(repo));  					treeWalk.Filter = AndTreeFilter.Create(new SkipWorkTreeFilter(1)' new IndexDiffFilter  						(1' 2));  					// Return null if no local changes to stash  					if (!treeWalk.Next())  					{  						return null;  					}  					MutableObjectId id = new MutableObjectId();  					IList<DirCacheEditor.PathEdit> wtEdits = new AList<DirCacheEditor.PathEdit>();  					IList<string> wtDeletes = new AList<string>();  					do  					{  						AbstractTreeIterator headIter = treeWalk.GetTree<AbstractTreeIterator>(0);  						DirCacheIterator indexIter = treeWalk.GetTree<DirCacheIterator>(1);  						WorkingTreeIterator wtIter = treeWalk.GetTree<WorkingTreeIterator>(2);  						if (headIter != null && indexIter != null && wtIter != null)  						{  							if (!indexIter.GetDirCacheEntry().IsMerged())  							{  								throw new UnmergedPathsException(new UnmergedPathException(indexIter.GetDirCacheEntry  									()));  							}  							if (wtIter.IdEqual(indexIter) || wtIter.IdEqual(headIter))  							{  								continue;  							}  							treeWalk.GetObjectId(id' 0);  							DirCacheEntry entry = new DirCacheEntry(treeWalk.RawPath);  							entry.SetLength(wtIter.GetEntryLength());  							entry.LastModified = wtIter.GetEntryLastModified();  							entry.FileMode = wtIter.EntryFileMode;  							long contentLength = wtIter.GetEntryContentLength();  							InputStream @in = wtIter.OpenEntryStream();  							try  							{  								entry.SetObjectId(inserter.Insert(Constants.OBJ_BLOB' contentLength' @in));  							}  							finally  							{  								@in.Close();  							}  							wtEdits.AddItem(new _PathEdit_273(entry' entry));  						}  						else  						{  							if (indexIter == null)  							{  								wtDeletes.AddItem(treeWalk.PathString);  							}  							else  							{  								if (wtIter == null && headIter != null)  								{  									wtDeletes.AddItem(treeWalk.PathString);  								}  							}  						}  					}  					while (treeWalk.Next());  					string branch = Repository.ShortenRefName(head.GetTarget().GetName());  					// Commit index changes  					NGit.CommitBuilder builder = CreateBuilder(headCommit);  					builder.TreeId = cache.WriteTree(inserter);  					builder.Message = MessageFormat.Format(indexMessage' branch' headCommit.Abbreviate  						(7).Name' headCommit.GetShortMessage());  					ObjectId indexCommit = inserter.Insert(builder);  					// Commit working tree changes  					if (!wtEdits.IsEmpty() || !wtDeletes.IsEmpty())  					{  						DirCacheEditor editor = cache.Editor();  						foreach (DirCacheEditor.PathEdit edit in wtEdits)  						{  							editor.Add(edit);  						}  						foreach (string path in wtDeletes)  						{  							editor.Add(new DirCacheEditor.DeletePath(path));  						}  						editor.Finish();  					}  					builder.AddParentId(indexCommit);  					builder.Message = MessageFormat.Format(workingDirectoryMessage' branch' headCommit  						.Abbreviate(7).Name' headCommit.GetShortMessage());  					builder.TreeId = cache.WriteTree(inserter);  					commitId = inserter.Insert(builder);  					inserter.Flush();  					UpdateStashRef(commitId' builder.Author' builder.Message);  				}  				finally  				{  					inserter.Release();  					cache.Unlock();  				}  				// Hard reset to HEAD  				new ResetCommand(repo).SetMode(ResetCommand.ResetType.HARD).Call();  				// Return stashed commit  				return ParseCommit(reader' commitId);  			}  			catch (IOException e)  			{  				throw new JGitInternalException(JGitText.Get().stashFailed' e);  			}  			finally  			{  				reader.Release();  			}
Magic Number,NGit.Diff,DiffConfig,C:\repos\mono_ngit\NGit\NGit.Diff\DiffConfig.cs,DiffConfig,The following statement contains a magic number: renameLimit = rc.GetInt("diff"' "renamelimit"' 200);
Magic Number,NGit.Diff,DiffEntry,C:\repos\mono_ngit\NGit\NGit.Diff\DiffEntry.cs,Scan,The following statement contains a magic number: if (walk.TreeCount != 2)  			{  				throw new ArgumentException(JGitText.Get().treeWalkMustHaveExactlyTwoTrees);  			}
Magic Number,NGit.Diff,DiffFormatter,C:\repos\mono_ngit\NGit\NGit.Diff\DiffFormatter.cs,FormatHeader,The following statement contains a magic number: switch (type)  			{  				case DiffEntry.ChangeType.ADD:  				{  					o.Write(Constants.EncodeASCII("new file mode "));  					newMode.CopyTo(o);  					o.Write('\n');  					break;  				}    				case DiffEntry.ChangeType.DELETE:  				{  					o.Write(Constants.EncodeASCII("deleted file mode "));  					oldMode.CopyTo(o);  					o.Write('\n');  					break;  				}    				case DiffEntry.ChangeType.RENAME:  				{  					o.Write(Constants.EncodeASCII("similarity index " + ent.GetScore() + "%"));  					o.Write('\n');  					o.Write(Constants.Encode("rename from " + QuotePath(oldp)));  					o.Write('\n');  					o.Write(Constants.Encode("rename to " + QuotePath(newp)));  					o.Write('\n');  					break;  				}    				case DiffEntry.ChangeType.COPY:  				{  					o.Write(Constants.EncodeASCII("similarity index " + ent.GetScore() + "%"));  					o.Write('\n');  					o.Write(Constants.Encode("copy from " + QuotePath(oldp)));  					o.Write('\n');  					o.Write(Constants.Encode("copy to " + QuotePath(newp)));  					o.Write('\n');  					if (!oldMode.Equals(newMode))  					{  						o.Write(Constants.EncodeASCII("new file mode "));  						newMode.CopyTo(o);  						o.Write('\n');  					}  					break;  				}    				case DiffEntry.ChangeType.MODIFY:  				{  					if (0 < ent.GetScore())  					{  						o.Write(Constants.EncodeASCII("dissimilarity index " + (100 - ent.GetScore()) + "%"  							));  						o.Write('\n');  					}  					break;  				}  			}
Magic Number,NGit.Diff,DiffFormatter,C:\repos\mono_ngit\NGit\NGit.Diff\DiffFormatter.cs,CombineA,The following statement contains a magic number: return e[i].GetBeginA() - e[i - 1].GetEndA() <= 2 * context;
Magic Number,NGit.Diff,DiffFormatter,C:\repos\mono_ngit\NGit\NGit.Diff\DiffFormatter.cs,CombineB,The following statement contains a magic number: return e[i].GetBeginB() - e[i - 1].GetEndB() <= 2 * context;
Magic Number,NGit.Diff,MyersDiff<S>,C:\repos\mono_ngit\NGit\NGit.Diff\MyersDiff.cs,Main,The following statement contains a magic number: if (args.Length != 2)  			{  				System.Console.Error.WriteLine(JGitText.Get().need2Arguments);  				System.Environment.Exit(1);  			}
Magic Number,NGit.Diff,EditPaths,C:\repos\mono_ngit\NGit\NGit.Diff\MyersDiff.cs,GetIndex,The following statement contains a magic number: if (((d + k - this.middleK) % 2) != 0)  					{  						throw new RuntimeException(MessageFormat.Format(JGitText.Get().unexpectedOddResult  							' Sharpen.Extensions.ValueOf(d)' Sharpen.Extensions.ValueOf(k)' Sharpen.Extensions.ValueOf  							(this.middleK)));  					}
Magic Number,NGit.Diff,EditPaths,C:\repos\mono_ngit\NGit\NGit.Diff\MyersDiff.cs,GetIndex,The following statement contains a magic number: return (d + k - this.middleK) / 2;
Magic Number,NGit.Diff,EditPaths,C:\repos\mono_ngit\NGit\NGit.Diff\MyersDiff.cs,NewSnake,The following statement contains a magic number: long ret = ((long)x) << 32;
Magic Number,NGit.Diff,EditPaths,C:\repos\mono_ngit\NGit\NGit.Diff\MyersDiff.cs,Snake2x,The following statement contains a magic number: return (int)((long)(((ulong)snake) >> 32));
Magic Number,NGit.Diff,EditPaths,C:\repos\mono_ngit\NGit\NGit.Diff\MyersDiff.cs,Calculate,The following statement contains a magic number: for (int k = this.endK; k >= this.beginK; k -= 2)  					{  						int left = -1;  						int right = -1;  						long leftSnake = -1L;  						long rightSnake = -1L;  						// TODO: refactor into its own function  						if (k > this.prevBeginK)  						{  							int i = this.GetIndex(d - 1' k - 1);  							left = this.x.Get(i);  							int end = this.Snake(k - 1' left);  							leftSnake = left != end ? this.NewSnake(k - 1' end) : this.snake.Get(i);  							if (this.Meets(d' k - 1' end' leftSnake))  							{  								return true;  							}  							left = this.GetLeft(end);  						}  						if (k < this.prevEndK)  						{  							int i = this.GetIndex(d - 1' k + 1);  							right = this.x.Get(i);  							int end = this.Snake(k + 1' right);  							rightSnake = right != end ? this.NewSnake(k + 1' end) : this.snake.Get(i);  							if (this.Meets(d' k + 1' end' rightSnake))  							{  								return true;  							}  							right = this.GetRight(end);  						}  						int newX;  						long newSnake;  						if (k >= this.prevEndK || (k > this.prevBeginK && this.IsBetter(left' right)))  						{  							newX = left;  							newSnake = leftSnake;  						}  						else  						{  							newX = right;  							newSnake = rightSnake;  						}  						if (this.Meets(d' k' newX' newSnake))  						{  							return true;  						}  						this.AdjustMinMaxK(k' newX);  						int i_1 = this.GetIndex(d' k);  						this.x.Set(i_1' newX);  						this.snake.Set(i_1' newSnake);  					}
Magic Number,NGit.Diff,ForwardEditPaths,C:\repos\mono_ngit\NGit\NGit.Diff\MyersDiff.cs,Meets,The following statement contains a magic number: if (((d - 1 + k - this._enclosing.backward.middleK) % 2) != 0)  					{  						return false;  					}
Magic Number,NGit.Diff,BackwardEditPaths,C:\repos\mono_ngit\NGit\NGit.Diff\MyersDiff.cs,Meets,The following statement contains a magic number: if (((d + k - this._enclosing.forward.middleK) % 2) != 0)  					{  						return false;  					}
Magic Number,NGit.Diff,RawText,C:\repos\mono_ngit\NGit\NGit.Diff\RawText.cs,Size,The following statement contains a magic number: return lines.Size() - 2;
Magic Number,NGit.Diff,RawText,C:\repos\mono_ngit\NGit\NGit.Diff\RawText.cs,GetEnd,The following statement contains a magic number: return lines.Get(i + 2);
Magic Number,NGit.Diff,RawText,C:\repos\mono_ngit\NGit\NGit.Diff\RawText.cs,GetLineDelimiter,The following statement contains a magic number: if (content.Length > 1 && content[e - 2] == '\r')  			{  				return "\r\n";  			}  			else  			{  				return "\n";  			}
Magic Number,NGit.Diff,RenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\RenameDetector.cs,SetRenameScore,The following statement contains a magic number: if (score < 0 || score > 100)  			{  				throw new ArgumentException(JGitText.Get().similarityScoreMustBeWithinBounds);  			}
Magic Number,NGit.Diff,RenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\RenameDetector.cs,CalculateModifyScore,The following statement contains a magic number: try  			{  				SimilarityIndex src = new SimilarityIndex();  				src.Hash(reader.Open(DiffEntry.Side.OLD' d));  				src.Sort();  				SimilarityIndex dst = new SimilarityIndex();  				dst.Hash(reader.Open(DiffEntry.Side.NEW' d));  				dst.Sort();  				return src.Score(dst' 100);  			}  			catch (SimilarityIndex.TableFullException)  			{  				// If either table overflowed while being constructed' don't allow  				// the pair to be broken. Returning 1 higher than breakScore will  				// ensure its not similar' but not quite dissimilar enough to break.  				//  				overRenameLimit = true;  				return breakScore + 1;  			}
Magic Number,NGit.Diff,RenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\RenameDetector.cs,FindExactRenames,The following statement contains a magic number: foreach (IList<DiffEntry> adds in nonUniqueAdds)  			{  				object o_1 = deletedMap.Get(adds[0].newId);  				if (o_1 is DiffEntry)  				{  					// We have many adds to one delete: find the add with the same  					// type and closest name to the delete' then pair them. Mark the  					// rest as copies of the delete.  					DiffEntry d = (DiffEntry)o_1;  					DiffEntry best = BestPathMatch(d' adds);  					if (best != null)  					{  						d.changeType = DiffEntry.ChangeType.RENAME;  						entries.AddItem(ExactRename(d' best));  						foreach (DiffEntry a_1 in adds)  						{  							if (a_1 != best)  							{  								if (SameType(d.oldMode' a_1.newMode))  								{  									entries.AddItem(ExactCopy(d' a_1));  								}  								else  								{  									left.AddItem(a_1);  								}  							}  						}  					}  					else  					{  						Sharpen.Collections.AddAll(left' adds);  					}  				}  				else  				{  					if (o_1 != null)  					{  						// We have many adds to many deletes: score all the adds against  						// all the deletes by path name' take the best matches' pair  						// them as renames' then call the rest copies  						IList<DiffEntry> dels = (IList<DiffEntry>)o_1;  						long[] matrix = new long[dels.Count * adds.Count];  						int mNext = 0;  						for (int delIdx = 0; delIdx < dels.Count; delIdx++)  						{  							string deletedName = dels[delIdx].oldPath;  							for (int addIdx = 0; addIdx < adds.Count; addIdx++)  							{  								string addedName = adds[addIdx].newPath;  								int score = SimilarityRenameDetector.NameScore(addedName' deletedName);  								matrix[mNext] = SimilarityRenameDetector.Encode(score' delIdx' addIdx);  								mNext++;  							}  						}  						Arrays.Sort(matrix);  						for (--mNext; mNext >= 0; mNext--)  						{  							long ent = matrix[mNext];  							int delIdx_1 = SimilarityRenameDetector.SrcFile(ent);  							int addIdx = SimilarityRenameDetector.DstFile(ent);  							DiffEntry d = dels[delIdx_1];  							DiffEntry a_1 = adds[addIdx];  							if (a_1 == null)  							{  								pm.Update(1);  								continue;  							}  							// was already matched earlier  							DiffEntry.ChangeType type;  							if (d.changeType == DiffEntry.ChangeType.DELETE)  							{  								// First use of this source file. Tag it as a rename so we  								// later know it is already been used as a rename' other  								// matches (if any) will claim themselves as copies instead.  								//  								d.changeType = DiffEntry.ChangeType.RENAME;  								type = DiffEntry.ChangeType.RENAME;  							}  							else  							{  								type = DiffEntry.ChangeType.COPY;  							}  							entries.AddItem(DiffEntry.Pair(type' d' a_1' 100));  							adds.Set(addIdx' null);  							// Claim the destination was matched.  							pm.Update(1);  						}  					}  					else  					{  						Sharpen.Collections.AddAll(left' adds);  					}  				}  			}
Magic Number,NGit.Diff,RenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\RenameDetector.cs,PopulateMap,The following statement contains a magic number: foreach (DiffEntry de in diffEntries)  			{  				object old = map.Put(Id(de)' de);  				if (old is DiffEntry)  				{  					AList<DiffEntry> list = new AList<DiffEntry>(2);  					list.AddItem((DiffEntry)old);  					list.AddItem(de);  					map.Put(Id(de)' list);  				}  				else  				{  					if (old != null)  					{  						// Must be a list of DiffEntries  						((IList<DiffEntry>)old).AddItem(de);  						map.Put(Id(de)' old);  					}  				}  				pm.Update(1);  			}
Magic Number,NGit.Diff,_IComparer_72,C:\repos\mono_ngit\NGit\NGit.Diff\RenameDetector.cs,SortOf,The following statement contains a magic number: switch (changeType)  				{  					case DiffEntry.ChangeType.DELETE:  					{  						// Sort deletes before adds so that a major type change for  						// a file path (such as symlink to regular file) will first  						// remove the path' then add it back with the new type.  						//  						return 1;  					}    					case DiffEntry.ChangeType.ADD:  					{  						return 2;  					}    					default:  					{  						return 10;  						break;  					}  				}
Magic Number,NGit.Diff,_IComparer_72,C:\repos\mono_ngit\NGit\NGit.Diff\RenameDetector.cs,SortOf,The following statement contains a magic number: switch (changeType)  				{  					case DiffEntry.ChangeType.DELETE:  					{  						// Sort deletes before adds so that a major type change for  						// a file path (such as symlink to regular file) will first  						// remove the path' then add it back with the new type.  						//  						return 1;  					}    					case DiffEntry.ChangeType.ADD:  					{  						return 2;  					}    					default:  					{  						return 10;  						break;  					}  				}
Magic Number,NGit.Diff,SimilarityIndex,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityIndex.cs,SimilarityIndex,The following statement contains a magic number: idHashBits = 8;
Magic Number,NGit.Diff,SimilarityIndex,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityIndex.cs,Hash,The following statement contains a magic number: while (ptr < end)  			{  				int hash = 5381;  				int start = ptr;  				do  				{  					// Hash one line' or one block' whichever occurs first.  					int c = raw[ptr++] & unchecked((int)(0xff));  					if (c == '\n')  					{  						break;  					}  					hash = (hash << 5) + hash + c;  				}  				while (ptr < end && ptr - start < 64);  				Add(hash' ptr - start);  			}
Magic Number,NGit.Diff,SimilarityIndex,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityIndex.cs,Hash,The following statement contains a magic number: while (ptr < end)  			{  				int hash = 5381;  				int start = ptr;  				do  				{  					// Hash one line' or one block' whichever occurs first.  					int c = raw[ptr++] & unchecked((int)(0xff));  					if (c == '\n')  					{  						break;  					}  					hash = (hash << 5) + hash + c;  				}  				while (ptr < end && ptr - start < 64);  				Add(hash' ptr - start);  			}
Magic Number,NGit.Diff,SimilarityIndex,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityIndex.cs,Hash,The following statement contains a magic number: while (ptr < end)  			{  				int hash = 5381;  				int start = ptr;  				do  				{  					// Hash one line' or one block' whichever occurs first.  					int c = raw[ptr++] & unchecked((int)(0xff));  					if (c == '\n')  					{  						break;  					}  					hash = (hash << 5) + hash + c;  				}  				while (ptr < end && ptr - start < 64);  				Add(hash' ptr - start);  			}
Magic Number,NGit.Diff,SimilarityIndex,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityIndex.cs,Hash,The following statement contains a magic number: byte[] buf = new byte[4096];
Magic Number,NGit.Diff,SimilarityIndex,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityIndex.cs,Hash,The following statement contains a magic number: while (0 < remaining)  			{  				int hash = 5381;  				// Hash one line' or one block' whichever occurs first.  				int n = 0;  				do  				{  					if (ptr == cnt)  					{  						ptr = 0;  						cnt = @in.Read(buf' 0' buf.Length);  						if (cnt <= 0)  						{  							throw new EOFException();  						}  					}  					n++;  					int c = buf[ptr++] & unchecked((int)(0xff));  					if (c == '\n')  					{  						break;  					}  					hash = (hash << 5) + hash + c;  				}  				while (n < 64 && n < remaining);  				Add(hash' n);  				remaining -= n;  			}
Magic Number,NGit.Diff,SimilarityIndex,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityIndex.cs,Hash,The following statement contains a magic number: while (0 < remaining)  			{  				int hash = 5381;  				// Hash one line' or one block' whichever occurs first.  				int n = 0;  				do  				{  					if (ptr == cnt)  					{  						ptr = 0;  						cnt = @in.Read(buf' 0' buf.Length);  						if (cnt <= 0)  						{  							throw new EOFException();  						}  					}  					n++;  					int c = buf[ptr++] & unchecked((int)(0xff));  					if (c == '\n')  					{  						break;  					}  					hash = (hash << 5) + hash + c;  				}  				while (n < 64 && n < remaining);  				Add(hash' n);  				remaining -= n;  			}
Magic Number,NGit.Diff,SimilarityIndex,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityIndex.cs,Hash,The following statement contains a magic number: while (0 < remaining)  			{  				int hash = 5381;  				// Hash one line' or one block' whichever occurs first.  				int n = 0;  				do  				{  					if (ptr == cnt)  					{  						ptr = 0;  						cnt = @in.Read(buf' 0' buf.Length);  						if (cnt <= 0)  						{  							throw new EOFException();  						}  					}  					n++;  					int c = buf[ptr++] & unchecked((int)(0xff));  					if (c == '\n')  					{  						break;  					}  					hash = (hash << 5) + hash + c;  				}  				while (n < 64 && n < remaining);  				Add(hash' n);  				remaining -= n;  			}
Magic Number,NGit.Diff,SimilarityIndex,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityIndex.cs,Slot,The following statement contains a magic number: return (int)(((uint)key) >> (31 - idHashBits));
Magic Number,NGit.Diff,SimilarityIndex,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityIndex.cs,GrowAt,The following statement contains a magic number: return (1 << idHashBits) * (idHashBits - 3) / idHashBits;
Magic Number,NGit.Diff,SimilarityIndex,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityIndex.cs,Grow,The following statement contains a magic number: if (idHashBits == 30)  			{  				throw new SimilarityIndex.TableFullException();  			}
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,Compute,The following statement contains a magic number: pm.BeginTask(JGitText.Get().renamesFindingByContent' 2 * srcs.Count * dsts.Count);
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,BuildMatrix,The following statement contains a magic number: for (int srcIdx = 0; srcIdx < srcs.Count; srcIdx++)  			{  				DiffEntry srcEnt = srcs[srcIdx];  				if (!IsFile(srcEnt.oldMode))  				{  					pm.Update(dsts.Count);  					continue;  				}  				SimilarityIndex s = null;  				for (int dstIdx = 0; dstIdx < dsts.Count; dstIdx++)  				{  					DiffEntry dstEnt = dsts[dstIdx];  					if (!IsFile(dstEnt.newMode))  					{  						pm.Update(1);  						continue;  					}  					if (!RenameDetector.SameType(srcEnt.oldMode' dstEnt.newMode))  					{  						pm.Update(1);  						continue;  					}  					if (dstTooLarge != null && dstTooLarge.Get(dstIdx))  					{  						pm.Update(1);  						continue;  					}  					long srcSize = srcSizes[srcIdx];  					if (srcSize == 0)  					{  						srcSize = Size(DiffEntry.Side.OLD' srcEnt) + 1;  						srcSizes[srcIdx] = srcSize;  					}  					long dstSize = dstSizes[dstIdx];  					if (dstSize == 0)  					{  						dstSize = Size(DiffEntry.Side.NEW' dstEnt) + 1;  						dstSizes[dstIdx] = dstSize;  					}  					long max = Math.Max(srcSize' dstSize);  					long min = Math.Min(srcSize' dstSize);  					if (min * 100 / max < renameScore)  					{  						// Cannot possibly match' as the file sizes are so different  						pm.Update(1);  						continue;  					}  					if (s == null)  					{  						try  						{  							s = Hash(DiffEntry.Side.OLD' srcEnt);  						}  						catch (SimilarityIndex.TableFullException)  						{  							tableOverflow = true;  							goto SRC_continue;  						}  					}  					SimilarityIndex d;  					try  					{  						d = Hash(DiffEntry.Side.NEW' dstEnt);  					}  					catch (SimilarityIndex.TableFullException)  					{  						if (dstTooLarge == null)  						{  							dstTooLarge = new BitSet(dsts.Count);  						}  						dstTooLarge.Set(dstIdx);  						tableOverflow = true;  						pm.Update(1);  						continue;  					}  					int contentScore = s.Score(d' 10000);  					// nameScore returns a value between 0 and 100' but we want it  					// to be in the same range as the content score. This allows it  					// to be dropped into the pretty formula for the final score.  					int nameScore = NameScore(srcEnt.oldPath' dstEnt.newPath) * 100;  					int score = (contentScore * 99 + nameScore * 1) / 10000;  					if (score < renameScore)  					{  						pm.Update(1);  						continue;  					}  					matrix[mNext++] = Encode(score' srcIdx' dstIdx);  					pm.Update(1);  				}  SRC_continue: ;  			}
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,BuildMatrix,The following statement contains a magic number: for (int srcIdx = 0; srcIdx < srcs.Count; srcIdx++)  			{  				DiffEntry srcEnt = srcs[srcIdx];  				if (!IsFile(srcEnt.oldMode))  				{  					pm.Update(dsts.Count);  					continue;  				}  				SimilarityIndex s = null;  				for (int dstIdx = 0; dstIdx < dsts.Count; dstIdx++)  				{  					DiffEntry dstEnt = dsts[dstIdx];  					if (!IsFile(dstEnt.newMode))  					{  						pm.Update(1);  						continue;  					}  					if (!RenameDetector.SameType(srcEnt.oldMode' dstEnt.newMode))  					{  						pm.Update(1);  						continue;  					}  					if (dstTooLarge != null && dstTooLarge.Get(dstIdx))  					{  						pm.Update(1);  						continue;  					}  					long srcSize = srcSizes[srcIdx];  					if (srcSize == 0)  					{  						srcSize = Size(DiffEntry.Side.OLD' srcEnt) + 1;  						srcSizes[srcIdx] = srcSize;  					}  					long dstSize = dstSizes[dstIdx];  					if (dstSize == 0)  					{  						dstSize = Size(DiffEntry.Side.NEW' dstEnt) + 1;  						dstSizes[dstIdx] = dstSize;  					}  					long max = Math.Max(srcSize' dstSize);  					long min = Math.Min(srcSize' dstSize);  					if (min * 100 / max < renameScore)  					{  						// Cannot possibly match' as the file sizes are so different  						pm.Update(1);  						continue;  					}  					if (s == null)  					{  						try  						{  							s = Hash(DiffEntry.Side.OLD' srcEnt);  						}  						catch (SimilarityIndex.TableFullException)  						{  							tableOverflow = true;  							goto SRC_continue;  						}  					}  					SimilarityIndex d;  					try  					{  						d = Hash(DiffEntry.Side.NEW' dstEnt);  					}  					catch (SimilarityIndex.TableFullException)  					{  						if (dstTooLarge == null)  						{  							dstTooLarge = new BitSet(dsts.Count);  						}  						dstTooLarge.Set(dstIdx);  						tableOverflow = true;  						pm.Update(1);  						continue;  					}  					int contentScore = s.Score(d' 10000);  					// nameScore returns a value between 0 and 100' but we want it  					// to be in the same range as the content score. This allows it  					// to be dropped into the pretty formula for the final score.  					int nameScore = NameScore(srcEnt.oldPath' dstEnt.newPath) * 100;  					int score = (contentScore * 99 + nameScore * 1) / 10000;  					if (score < renameScore)  					{  						pm.Update(1);  						continue;  					}  					matrix[mNext++] = Encode(score' srcIdx' dstIdx);  					pm.Update(1);  				}  SRC_continue: ;  			}
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,BuildMatrix,The following statement contains a magic number: for (int srcIdx = 0; srcIdx < srcs.Count; srcIdx++)  			{  				DiffEntry srcEnt = srcs[srcIdx];  				if (!IsFile(srcEnt.oldMode))  				{  					pm.Update(dsts.Count);  					continue;  				}  				SimilarityIndex s = null;  				for (int dstIdx = 0; dstIdx < dsts.Count; dstIdx++)  				{  					DiffEntry dstEnt = dsts[dstIdx];  					if (!IsFile(dstEnt.newMode))  					{  						pm.Update(1);  						continue;  					}  					if (!RenameDetector.SameType(srcEnt.oldMode' dstEnt.newMode))  					{  						pm.Update(1);  						continue;  					}  					if (dstTooLarge != null && dstTooLarge.Get(dstIdx))  					{  						pm.Update(1);  						continue;  					}  					long srcSize = srcSizes[srcIdx];  					if (srcSize == 0)  					{  						srcSize = Size(DiffEntry.Side.OLD' srcEnt) + 1;  						srcSizes[srcIdx] = srcSize;  					}  					long dstSize = dstSizes[dstIdx];  					if (dstSize == 0)  					{  						dstSize = Size(DiffEntry.Side.NEW' dstEnt) + 1;  						dstSizes[dstIdx] = dstSize;  					}  					long max = Math.Max(srcSize' dstSize);  					long min = Math.Min(srcSize' dstSize);  					if (min * 100 / max < renameScore)  					{  						// Cannot possibly match' as the file sizes are so different  						pm.Update(1);  						continue;  					}  					if (s == null)  					{  						try  						{  							s = Hash(DiffEntry.Side.OLD' srcEnt);  						}  						catch (SimilarityIndex.TableFullException)  						{  							tableOverflow = true;  							goto SRC_continue;  						}  					}  					SimilarityIndex d;  					try  					{  						d = Hash(DiffEntry.Side.NEW' dstEnt);  					}  					catch (SimilarityIndex.TableFullException)  					{  						if (dstTooLarge == null)  						{  							dstTooLarge = new BitSet(dsts.Count);  						}  						dstTooLarge.Set(dstIdx);  						tableOverflow = true;  						pm.Update(1);  						continue;  					}  					int contentScore = s.Score(d' 10000);  					// nameScore returns a value between 0 and 100' but we want it  					// to be in the same range as the content score. This allows it  					// to be dropped into the pretty formula for the final score.  					int nameScore = NameScore(srcEnt.oldPath' dstEnt.newPath) * 100;  					int score = (contentScore * 99 + nameScore * 1) / 10000;  					if (score < renameScore)  					{  						pm.Update(1);  						continue;  					}  					matrix[mNext++] = Encode(score' srcIdx' dstIdx);  					pm.Update(1);  				}  SRC_continue: ;  			}
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,BuildMatrix,The following statement contains a magic number: for (int srcIdx = 0; srcIdx < srcs.Count; srcIdx++)  			{  				DiffEntry srcEnt = srcs[srcIdx];  				if (!IsFile(srcEnt.oldMode))  				{  					pm.Update(dsts.Count);  					continue;  				}  				SimilarityIndex s = null;  				for (int dstIdx = 0; dstIdx < dsts.Count; dstIdx++)  				{  					DiffEntry dstEnt = dsts[dstIdx];  					if (!IsFile(dstEnt.newMode))  					{  						pm.Update(1);  						continue;  					}  					if (!RenameDetector.SameType(srcEnt.oldMode' dstEnt.newMode))  					{  						pm.Update(1);  						continue;  					}  					if (dstTooLarge != null && dstTooLarge.Get(dstIdx))  					{  						pm.Update(1);  						continue;  					}  					long srcSize = srcSizes[srcIdx];  					if (srcSize == 0)  					{  						srcSize = Size(DiffEntry.Side.OLD' srcEnt) + 1;  						srcSizes[srcIdx] = srcSize;  					}  					long dstSize = dstSizes[dstIdx];  					if (dstSize == 0)  					{  						dstSize = Size(DiffEntry.Side.NEW' dstEnt) + 1;  						dstSizes[dstIdx] = dstSize;  					}  					long max = Math.Max(srcSize' dstSize);  					long min = Math.Min(srcSize' dstSize);  					if (min * 100 / max < renameScore)  					{  						// Cannot possibly match' as the file sizes are so different  						pm.Update(1);  						continue;  					}  					if (s == null)  					{  						try  						{  							s = Hash(DiffEntry.Side.OLD' srcEnt);  						}  						catch (SimilarityIndex.TableFullException)  						{  							tableOverflow = true;  							goto SRC_continue;  						}  					}  					SimilarityIndex d;  					try  					{  						d = Hash(DiffEntry.Side.NEW' dstEnt);  					}  					catch (SimilarityIndex.TableFullException)  					{  						if (dstTooLarge == null)  						{  							dstTooLarge = new BitSet(dsts.Count);  						}  						dstTooLarge.Set(dstIdx);  						tableOverflow = true;  						pm.Update(1);  						continue;  					}  					int contentScore = s.Score(d' 10000);  					// nameScore returns a value between 0 and 100' but we want it  					// to be in the same range as the content score. This allows it  					// to be dropped into the pretty formula for the final score.  					int nameScore = NameScore(srcEnt.oldPath' dstEnt.newPath) * 100;  					int score = (contentScore * 99 + nameScore * 1) / 10000;  					if (score < renameScore)  					{  						pm.Update(1);  						continue;  					}  					matrix[mNext++] = Encode(score' srcIdx' dstIdx);  					pm.Update(1);  				}  SRC_continue: ;  			}
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,BuildMatrix,The following statement contains a magic number: for (int srcIdx = 0; srcIdx < srcs.Count; srcIdx++)  			{  				DiffEntry srcEnt = srcs[srcIdx];  				if (!IsFile(srcEnt.oldMode))  				{  					pm.Update(dsts.Count);  					continue;  				}  				SimilarityIndex s = null;  				for (int dstIdx = 0; dstIdx < dsts.Count; dstIdx++)  				{  					DiffEntry dstEnt = dsts[dstIdx];  					if (!IsFile(dstEnt.newMode))  					{  						pm.Update(1);  						continue;  					}  					if (!RenameDetector.SameType(srcEnt.oldMode' dstEnt.newMode))  					{  						pm.Update(1);  						continue;  					}  					if (dstTooLarge != null && dstTooLarge.Get(dstIdx))  					{  						pm.Update(1);  						continue;  					}  					long srcSize = srcSizes[srcIdx];  					if (srcSize == 0)  					{  						srcSize = Size(DiffEntry.Side.OLD' srcEnt) + 1;  						srcSizes[srcIdx] = srcSize;  					}  					long dstSize = dstSizes[dstIdx];  					if (dstSize == 0)  					{  						dstSize = Size(DiffEntry.Side.NEW' dstEnt) + 1;  						dstSizes[dstIdx] = dstSize;  					}  					long max = Math.Max(srcSize' dstSize);  					long min = Math.Min(srcSize' dstSize);  					if (min * 100 / max < renameScore)  					{  						// Cannot possibly match' as the file sizes are so different  						pm.Update(1);  						continue;  					}  					if (s == null)  					{  						try  						{  							s = Hash(DiffEntry.Side.OLD' srcEnt);  						}  						catch (SimilarityIndex.TableFullException)  						{  							tableOverflow = true;  							goto SRC_continue;  						}  					}  					SimilarityIndex d;  					try  					{  						d = Hash(DiffEntry.Side.NEW' dstEnt);  					}  					catch (SimilarityIndex.TableFullException)  					{  						if (dstTooLarge == null)  						{  							dstTooLarge = new BitSet(dsts.Count);  						}  						dstTooLarge.Set(dstIdx);  						tableOverflow = true;  						pm.Update(1);  						continue;  					}  					int contentScore = s.Score(d' 10000);  					// nameScore returns a value between 0 and 100' but we want it  					// to be in the same range as the content score. This allows it  					// to be dropped into the pretty formula for the final score.  					int nameScore = NameScore(srcEnt.oldPath' dstEnt.newPath) * 100;  					int score = (contentScore * 99 + nameScore * 1) / 10000;  					if (score < renameScore)  					{  						pm.Update(1);  						continue;  					}  					matrix[mNext++] = Encode(score' srcIdx' dstIdx);  					pm.Update(1);  				}  SRC_continue: ;  			}
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,NameScore,The following statement contains a magic number: if (dirMax == 0)  			{  				dirScoreLtr = 100;  				dirScoreRtl = 100;  			}  			else  			{  				int dirSim = 0;  				for (; dirSim < dirMin; dirSim++)  				{  					if (a[dirSim] != b[dirSim])  					{  						break;  					}  				}  				dirScoreLtr = (dirSim * 100) / dirMax;  				if (dirScoreLtr == 100)  				{  					dirScoreRtl = 100;  				}  				else  				{  					for (dirSim = 0; dirSim < dirMin; dirSim++)  					{  						if (a[aDirLen - 1 - dirSim] != b[bDirLen - 1 - dirSim])  						{  							break;  						}  					}  					dirScoreRtl = (dirSim * 100) / dirMax;  				}  			}
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,NameScore,The following statement contains a magic number: if (dirMax == 0)  			{  				dirScoreLtr = 100;  				dirScoreRtl = 100;  			}  			else  			{  				int dirSim = 0;  				for (; dirSim < dirMin; dirSim++)  				{  					if (a[dirSim] != b[dirSim])  					{  						break;  					}  				}  				dirScoreLtr = (dirSim * 100) / dirMax;  				if (dirScoreLtr == 100)  				{  					dirScoreRtl = 100;  				}  				else  				{  					for (dirSim = 0; dirSim < dirMin; dirSim++)  					{  						if (a[aDirLen - 1 - dirSim] != b[bDirLen - 1 - dirSim])  						{  							break;  						}  					}  					dirScoreRtl = (dirSim * 100) / dirMax;  				}  			}
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,NameScore,The following statement contains a magic number: if (dirMax == 0)  			{  				dirScoreLtr = 100;  				dirScoreRtl = 100;  			}  			else  			{  				int dirSim = 0;  				for (; dirSim < dirMin; dirSim++)  				{  					if (a[dirSim] != b[dirSim])  					{  						break;  					}  				}  				dirScoreLtr = (dirSim * 100) / dirMax;  				if (dirScoreLtr == 100)  				{  					dirScoreRtl = 100;  				}  				else  				{  					for (dirSim = 0; dirSim < dirMin; dirSim++)  					{  						if (a[aDirLen - 1 - dirSim] != b[bDirLen - 1 - dirSim])  						{  							break;  						}  					}  					dirScoreRtl = (dirSim * 100) / dirMax;  				}  			}
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,NameScore,The following statement contains a magic number: if (dirMax == 0)  			{  				dirScoreLtr = 100;  				dirScoreRtl = 100;  			}  			else  			{  				int dirSim = 0;  				for (; dirSim < dirMin; dirSim++)  				{  					if (a[dirSim] != b[dirSim])  					{  						break;  					}  				}  				dirScoreLtr = (dirSim * 100) / dirMax;  				if (dirScoreLtr == 100)  				{  					dirScoreRtl = 100;  				}  				else  				{  					for (dirSim = 0; dirSim < dirMin; dirSim++)  					{  						if (a[aDirLen - 1 - dirSim] != b[bDirLen - 1 - dirSim])  						{  							break;  						}  					}  					dirScoreRtl = (dirSim * 100) / dirMax;  				}  			}
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,NameScore,The following statement contains a magic number: if (dirMax == 0)  			{  				dirScoreLtr = 100;  				dirScoreRtl = 100;  			}  			else  			{  				int dirSim = 0;  				for (; dirSim < dirMin; dirSim++)  				{  					if (a[dirSim] != b[dirSim])  					{  						break;  					}  				}  				dirScoreLtr = (dirSim * 100) / dirMax;  				if (dirScoreLtr == 100)  				{  					dirScoreRtl = 100;  				}  				else  				{  					for (dirSim = 0; dirSim < dirMin; dirSim++)  					{  						if (a[aDirLen - 1 - dirSim] != b[bDirLen - 1 - dirSim])  						{  							break;  						}  					}  					dirScoreRtl = (dirSim * 100) / dirMax;  				}  			}
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,NameScore,The following statement contains a magic number: if (dirMax == 0)  			{  				dirScoreLtr = 100;  				dirScoreRtl = 100;  			}  			else  			{  				int dirSim = 0;  				for (; dirSim < dirMin; dirSim++)  				{  					if (a[dirSim] != b[dirSim])  					{  						break;  					}  				}  				dirScoreLtr = (dirSim * 100) / dirMax;  				if (dirScoreLtr == 100)  				{  					dirScoreRtl = 100;  				}  				else  				{  					for (dirSim = 0; dirSim < dirMin; dirSim++)  					{  						if (a[aDirLen - 1 - dirSim] != b[bDirLen - 1 - dirSim])  						{  							break;  						}  					}  					dirScoreRtl = (dirSim * 100) / dirMax;  				}  			}
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,NameScore,The following statement contains a magic number: int fileScore = (fileSim * 100) / fileMax;
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,NameScore,The following statement contains a magic number: return (((dirScoreLtr + dirScoreRtl) * 25) + (fileScore * 50)) / 100;
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,NameScore,The following statement contains a magic number: return (((dirScoreLtr + dirScoreRtl) * 25) + (fileScore * 50)) / 100;
Magic Number,NGit.Diff,SimilarityRenameDetector,C:\repos\mono_ngit\NGit\NGit.Diff\SimilarityRenameDetector.cs,NameScore,The following statement contains a magic number: return (((dirScoreLtr + dirScoreRtl) * 25) + (fileScore * 50)) / 100;
Magic Number,NGit.Diff,HistogramDiffIndex<S>,C:\repos\mono_ngit\NGit\NGit.Diff\HistogramDiffIndex.cs,HistogramDiffIndex,The following statement contains a magic number: keyShift = 32 - tableBits;
Magic Number,NGit.Diff,HistogramDiffIndex<S>,C:\repos\mono_ngit\NGit\NGit.Diff\HistogramDiffIndex.cs,HistogramDiffIndex,The following statement contains a magic number: recs = new long[Math.Max(4' (int)(((uint)sz) >> 3))];
Magic Number,NGit.Diff,HistogramDiffIndex<S>,C:\repos\mono_ngit\NGit\NGit.Diff\HistogramDiffIndex.cs,HistogramDiffIndex,The following statement contains a magic number: recs = new long[Math.Max(4' (int)(((uint)sz) >> 3))];
Magic Number,NGit.Diff,HistogramDiffIndex<S>,C:\repos\mono_ngit\NGit\NGit.Diff\HistogramDiffIndex.cs,TableBits,The following statement contains a magic number: int bits = 31 - Sharpen.Extensions.NumberOfLeadingZeros(sz);
Magic Number,NGit.Diff,RawTextComparator,C:\repos\mono_ngit\NGit\NGit.Diff\RawTextComparator.cs,Hash,The following statement contains a magic number: int end = seq.lines.Get(lno + 2);
Magic Number,NGit.Diff,RawTextComparator,C:\repos\mono_ngit\NGit\NGit.Diff\RawTextComparator.cs,FindForwardLine,The following statement contains a magic number: int end = lines.Size() - 2;
Magic Number,NGit.Diff,RawTextComparator,C:\repos\mono_ngit\NGit\NGit.Diff\RawTextComparator.cs,FindForwardLine,The following statement contains a magic number: while (idx < end && lines.Get(idx + 2) < ptr)  			{  				idx++;  			}
Magic Number,NGit.Diff,_RawTextComparator_56,C:\repos\mono_ngit\NGit\NGit.Diff\RawTextComparator.cs,HashRegion,The following statement contains a magic number: int hash = 5381;
Magic Number,NGit.Diff,_RawTextComparator_56,C:\repos\mono_ngit\NGit\NGit.Diff\RawTextComparator.cs,HashRegion,The following statement contains a magic number: for (; ptr < end; ptr++)  				{  					hash = ((hash << 5) + hash) + (raw[ptr] & unchecked((int)(0xff)));  				}
Magic Number,NGit.Diff,_RawTextComparator_87,C:\repos\mono_ngit\NGit\NGit.Diff\RawTextComparator.cs,HashRegion,The following statement contains a magic number: int hash = 5381;
Magic Number,NGit.Diff,_RawTextComparator_87,C:\repos\mono_ngit\NGit\NGit.Diff\RawTextComparator.cs,HashRegion,The following statement contains a magic number: for (; ptr < end; ptr++)  				{  					byte c = raw[ptr];  					if (!RawCharUtil.IsWhitespace(c))  					{  						hash = ((hash << 5) + hash) + (c & unchecked((int)(0xff)));  					}  				}
Magic Number,NGit.Diff,_RawTextComparator_138,C:\repos\mono_ngit\NGit\NGit.Diff\RawTextComparator.cs,HashRegion,The following statement contains a magic number: int hash = 5381;
Magic Number,NGit.Diff,_RawTextComparator_138,C:\repos\mono_ngit\NGit\NGit.Diff\RawTextComparator.cs,HashRegion,The following statement contains a magic number: for (; ptr < end; ptr++)  				{  					hash = ((hash << 5) + hash) + (raw[ptr] & unchecked((int)(0xff)));  				}
Magic Number,NGit.Diff,_RawTextComparator_173,C:\repos\mono_ngit\NGit\NGit.Diff\RawTextComparator.cs,HashRegion,The following statement contains a magic number: int hash = 5381;
Magic Number,NGit.Diff,_RawTextComparator_173,C:\repos\mono_ngit\NGit\NGit.Diff\RawTextComparator.cs,HashRegion,The following statement contains a magic number: for (; ptr < end; ptr++)  				{  					hash = ((hash << 5) + hash) + (raw[ptr] & unchecked((int)(0xff)));  				}
Magic Number,NGit.Diff,_RawTextComparator_208,C:\repos\mono_ngit\NGit\NGit.Diff\RawTextComparator.cs,HashRegion,The following statement contains a magic number: int hash = 5381;
Magic Number,NGit.Diff,_RawTextComparator_208,C:\repos\mono_ngit\NGit\NGit.Diff\RawTextComparator.cs,HashRegion,The following statement contains a magic number: while (ptr < end)  				{  					byte c = raw[ptr];  					hash = ((hash << 5) + hash) + (c & unchecked((int)(0xff)));  					if (RawCharUtil.IsWhitespace(c))  					{  						ptr = RawCharUtil.TrimLeadingWhitespace(raw' ptr' end);  					}  					else  					{  						ptr++;  					}  				}
Magic Number,NGit.Dircache,BaseDirCacheEditor,C:\repos\mono_ngit\NGit\NGit.Dircache\BaseDirCacheEditor.cs,FastAdd,The following statement contains a magic number: if (entries.Length == entryCnt)  			{  				DirCacheEntry[] n = new DirCacheEntry[(entryCnt + 16) * 3 / 2];  				System.Array.Copy(entries' 0' n' 0' entryCnt);  				entries = n;  			}
Magic Number,NGit.Dircache,BaseDirCacheEditor,C:\repos\mono_ngit\NGit\NGit.Dircache\BaseDirCacheEditor.cs,FastAdd,The following statement contains a magic number: if (entries.Length == entryCnt)  			{  				DirCacheEntry[] n = new DirCacheEntry[(entryCnt + 16) * 3 / 2];  				System.Array.Copy(entries' 0' n' 0' entryCnt);  				entries = n;  			}
Magic Number,NGit.Dircache,BaseDirCacheEditor,C:\repos\mono_ngit\NGit\NGit.Dircache\BaseDirCacheEditor.cs,FastAdd,The following statement contains a magic number: if (entries.Length == entryCnt)  			{  				DirCacheEntry[] n = new DirCacheEntry[(entryCnt + 16) * 3 / 2];  				System.Array.Copy(entries' 0' n' 0' entryCnt);  				entries = n;  			}
Magic Number,NGit.Dircache,BaseDirCacheEditor,C:\repos\mono_ngit\NGit\NGit.Dircache\BaseDirCacheEditor.cs,FastKeep,The following statement contains a magic number: if (entryCnt + cnt > entries.Length)  			{  				int m1 = (entryCnt + 16) * 3 / 2;  				int m2 = entryCnt + cnt;  				DirCacheEntry[] n = new DirCacheEntry[Math.Max(m1' m2)];  				System.Array.Copy(entries' 0' n' 0' entryCnt);  				entries = n;  			}
Magic Number,NGit.Dircache,BaseDirCacheEditor,C:\repos\mono_ngit\NGit\NGit.Dircache\BaseDirCacheEditor.cs,FastKeep,The following statement contains a magic number: if (entryCnt + cnt > entries.Length)  			{  				int m1 = (entryCnt + 16) * 3 / 2;  				int m2 = entryCnt + cnt;  				DirCacheEntry[] n = new DirCacheEntry[Math.Max(m1' m2)];  				System.Array.Copy(entries' 0' n' 0' entryCnt);  				entries = n;  			}
Magic Number,NGit.Dircache,BaseDirCacheEditor,C:\repos\mono_ngit\NGit\NGit.Dircache\BaseDirCacheEditor.cs,FastKeep,The following statement contains a magic number: if (entryCnt + cnt > entries.Length)  			{  				int m1 = (entryCnt + 16) * 3 / 2;  				int m2 = entryCnt + cnt;  				DirCacheEntry[] n = new DirCacheEntry[Math.Max(m1' m2)];  				System.Array.Copy(entries' 0' n' 0' entryCnt);  				entries = n;  			}
Magic Number,NGit.Dircache,BaseDirCacheEditor,C:\repos\mono_ngit\NGit\NGit.Dircache\BaseDirCacheEditor.cs,Replace,The following statement contains a magic number: if (entryCnt < entries.Length / 2)  			{  				DirCacheEntry[] n = new DirCacheEntry[entryCnt];  				System.Array.Copy(entries' 0' n' 0' entryCnt);  				entries = n;  			}
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,Builder,The following statement contains a magic number: return new DirCacheBuilder(this' entryCnt + 16);
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,Editor,The following statement contains a magic number: return new DirCacheEditor(this' entryCnt + 16);
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: byte[] hdr = new byte[20];
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: IOUtil.ReadFully(@in' hdr' 0' 12);
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: md.Update(hdr' 0' 12);
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: int ver = NB.DecodeInt32(hdr' 4);
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: if (ver == 3)  			{  				extended = true;  			}  			else  			{  				if (ver != 2)  				{  					throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().unknownDIRCVersion  						' Sharpen.Extensions.ValueOf(ver)));  				}  			}
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: if (ver == 3)  			{  				extended = true;  			}  			else  			{  				if (ver != 2)  				{  					throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().unknownDIRCVersion  						' Sharpen.Extensions.ValueOf(ver)));  				}  			}
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: entryCnt = NB.DecodeInt32(hdr' 8);
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: int smudge_s = (int)(snapshot.LastModified() / 1000);
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: int smudge_ns = ((int)(snapshot.LastModified() % 1000)) * 1000000;
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: int smudge_ns = ((int)(snapshot.LastModified() % 1000)) * 1000000;
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: for (; ; )  			{  				@in.Mark(21);  				IOUtil.ReadFully(@in' hdr' 0' 20);  				if (@in.Read() < 0)  				{  					// No extensions present; the file ended where we expected.  					//  					break;  				}  				@in.Reset();  				md.Update(hdr' 0' 8);  				IOUtil.SkipFully(@in' 8);  				long sz = NB.DecodeUInt32(hdr' 4);  				switch (NB.DecodeInt32(hdr' 0))  				{  					case EXT_TREE:  					{  						if (int.MaxValue < sz)  						{  							throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().DIRCExtensionIsTooLargeAt  								' FormatExtensionName(hdr)' Sharpen.Extensions.ValueOf(sz)));  						}  						byte[] raw = new byte[(int)sz];  						IOUtil.ReadFully(@in' raw' 0' raw.Length);  						md.Update(raw' 0' raw.Length);  						tree = new DirCacheTree(raw' new MutableInteger()' null);  						break;  					}    					default:  					{  						if (hdr[0] >= 'A' && ((sbyte)hdr[0]) <= 'Z')  						{  							// The extension is optional and is here only as  							// a performance optimization. Since we do not  							// understand it' we can safely skip past it' after  							// we include its data in our checksum.  							//  							SkipOptionalExtension(@in' md' hdr' sz);  						}  						else  						{  							// The extension is not an optimization and is  							// _required_ to understand this index format.  							// Since we did not trap it above we must abort.  							//  							throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().DIRCExtensionNotSupportedByThisVersion  								' FormatExtensionName(hdr)));  						}  						break;  					}  				}  			}
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: for (; ; )  			{  				@in.Mark(21);  				IOUtil.ReadFully(@in' hdr' 0' 20);  				if (@in.Read() < 0)  				{  					// No extensions present; the file ended where we expected.  					//  					break;  				}  				@in.Reset();  				md.Update(hdr' 0' 8);  				IOUtil.SkipFully(@in' 8);  				long sz = NB.DecodeUInt32(hdr' 4);  				switch (NB.DecodeInt32(hdr' 0))  				{  					case EXT_TREE:  					{  						if (int.MaxValue < sz)  						{  							throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().DIRCExtensionIsTooLargeAt  								' FormatExtensionName(hdr)' Sharpen.Extensions.ValueOf(sz)));  						}  						byte[] raw = new byte[(int)sz];  						IOUtil.ReadFully(@in' raw' 0' raw.Length);  						md.Update(raw' 0' raw.Length);  						tree = new DirCacheTree(raw' new MutableInteger()' null);  						break;  					}    					default:  					{  						if (hdr[0] >= 'A' && ((sbyte)hdr[0]) <= 'Z')  						{  							// The extension is optional and is here only as  							// a performance optimization. Since we do not  							// understand it' we can safely skip past it' after  							// we include its data in our checksum.  							//  							SkipOptionalExtension(@in' md' hdr' sz);  						}  						else  						{  							// The extension is not an optimization and is  							// _required_ to understand this index format.  							// Since we did not trap it above we must abort.  							//  							throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().DIRCExtensionNotSupportedByThisVersion  								' FormatExtensionName(hdr)));  						}  						break;  					}  				}  			}
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: for (; ; )  			{  				@in.Mark(21);  				IOUtil.ReadFully(@in' hdr' 0' 20);  				if (@in.Read() < 0)  				{  					// No extensions present; the file ended where we expected.  					//  					break;  				}  				@in.Reset();  				md.Update(hdr' 0' 8);  				IOUtil.SkipFully(@in' 8);  				long sz = NB.DecodeUInt32(hdr' 4);  				switch (NB.DecodeInt32(hdr' 0))  				{  					case EXT_TREE:  					{  						if (int.MaxValue < sz)  						{  							throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().DIRCExtensionIsTooLargeAt  								' FormatExtensionName(hdr)' Sharpen.Extensions.ValueOf(sz)));  						}  						byte[] raw = new byte[(int)sz];  						IOUtil.ReadFully(@in' raw' 0' raw.Length);  						md.Update(raw' 0' raw.Length);  						tree = new DirCacheTree(raw' new MutableInteger()' null);  						break;  					}    					default:  					{  						if (hdr[0] >= 'A' && ((sbyte)hdr[0]) <= 'Z')  						{  							// The extension is optional and is here only as  							// a performance optimization. Since we do not  							// understand it' we can safely skip past it' after  							// we include its data in our checksum.  							//  							SkipOptionalExtension(@in' md' hdr' sz);  						}  						else  						{  							// The extension is not an optimization and is  							// _required_ to understand this index format.  							// Since we did not trap it above we must abort.  							//  							throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().DIRCExtensionNotSupportedByThisVersion  								' FormatExtensionName(hdr)));  						}  						break;  					}  				}  			}
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: for (; ; )  			{  				@in.Mark(21);  				IOUtil.ReadFully(@in' hdr' 0' 20);  				if (@in.Read() < 0)  				{  					// No extensions present; the file ended where we expected.  					//  					break;  				}  				@in.Reset();  				md.Update(hdr' 0' 8);  				IOUtil.SkipFully(@in' 8);  				long sz = NB.DecodeUInt32(hdr' 4);  				switch (NB.DecodeInt32(hdr' 0))  				{  					case EXT_TREE:  					{  						if (int.MaxValue < sz)  						{  							throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().DIRCExtensionIsTooLargeAt  								' FormatExtensionName(hdr)' Sharpen.Extensions.ValueOf(sz)));  						}  						byte[] raw = new byte[(int)sz];  						IOUtil.ReadFully(@in' raw' 0' raw.Length);  						md.Update(raw' 0' raw.Length);  						tree = new DirCacheTree(raw' new MutableInteger()' null);  						break;  					}    					default:  					{  						if (hdr[0] >= 'A' && ((sbyte)hdr[0]) <= 'Z')  						{  							// The extension is optional and is here only as  							// a performance optimization. Since we do not  							// understand it' we can safely skip past it' after  							// we include its data in our checksum.  							//  							SkipOptionalExtension(@in' md' hdr' sz);  						}  						else  						{  							// The extension is not an optimization and is  							// _required_ to understand this index format.  							// Since we did not trap it above we must abort.  							//  							throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().DIRCExtensionNotSupportedByThisVersion  								' FormatExtensionName(hdr)));  						}  						break;  					}  				}  			}
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,ReadFrom,The following statement contains a magic number: for (; ; )  			{  				@in.Mark(21);  				IOUtil.ReadFully(@in' hdr' 0' 20);  				if (@in.Read() < 0)  				{  					// No extensions present; the file ended where we expected.  					//  					break;  				}  				@in.Reset();  				md.Update(hdr' 0' 8);  				IOUtil.SkipFully(@in' 8);  				long sz = NB.DecodeUInt32(hdr' 4);  				switch (NB.DecodeInt32(hdr' 0))  				{  					case EXT_TREE:  					{  						if (int.MaxValue < sz)  						{  							throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().DIRCExtensionIsTooLargeAt  								' FormatExtensionName(hdr)' Sharpen.Extensions.ValueOf(sz)));  						}  						byte[] raw = new byte[(int)sz];  						IOUtil.ReadFully(@in' raw' 0' raw.Length);  						md.Update(raw' 0' raw.Length);  						tree = new DirCacheTree(raw' new MutableInteger()' null);  						break;  					}    					default:  					{  						if (hdr[0] >= 'A' && ((sbyte)hdr[0]) <= 'Z')  						{  							// The extension is optional and is here only as  							// a performance optimization. Since we do not  							// understand it' we can safely skip past it' after  							// we include its data in our checksum.  							//  							SkipOptionalExtension(@in' md' hdr' sz);  						}  						else  						{  							// The extension is not an optimization and is  							// _required_ to understand this index format.  							// Since we did not trap it above we must abort.  							//  							throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().DIRCExtensionNotSupportedByThisVersion  								' FormatExtensionName(hdr)));  						}  						break;  					}  				}  			}
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,SkipOptionalExtension,The following statement contains a magic number: byte[] b = new byte[4096];
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,FormatExtensionName,The following statement contains a magic number: return "'" + Sharpen.Runtime.GetStringForBytes(hdr' 0' 4' "ISO-8859-1") + "'";
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,WriteTo,The following statement contains a magic number: byte[] tmp = new byte[128];
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,WriteTo,The following statement contains a magic number: NB.EncodeInt32(tmp' 4' extended ? 3 : 2);
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,WriteTo,The following statement contains a magic number: NB.EncodeInt32(tmp' 4' extended ? 3 : 2);
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,WriteTo,The following statement contains a magic number: NB.EncodeInt32(tmp' 4' extended ? 3 : 2);
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,WriteTo,The following statement contains a magic number: NB.EncodeInt32(tmp' 8' entryCnt);
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,WriteTo,The following statement contains a magic number: dos.Write(tmp' 0' 12);
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,WriteTo,The following statement contains a magic number: if (myLock != null)  			{  				// For new files we need to smudge the index entry  				// if they have been modified "now". Ideally we'd  				// want the timestamp when we're done writing the index'  				// so we use the current timestamp as a approximation.  				myLock.CreateCommitSnapshot();  				snapshot = myLock.GetCommitSnapshot();  				smudge_s = (int)(snapshot.LastModified() / 1000);  				smudge_ns = ((int)(snapshot.LastModified() % 1000)) * 1000000;  			}  			else  			{  				// Used in unit tests only  				smudge_ns = 0;  				smudge_s = 0;  			}
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,WriteTo,The following statement contains a magic number: if (myLock != null)  			{  				// For new files we need to smudge the index entry  				// if they have been modified "now". Ideally we'd  				// want the timestamp when we're done writing the index'  				// so we use the current timestamp as a approximation.  				myLock.CreateCommitSnapshot();  				snapshot = myLock.GetCommitSnapshot();  				smudge_s = (int)(snapshot.LastModified() / 1000);  				smudge_ns = ((int)(snapshot.LastModified() % 1000)) * 1000000;  			}  			else  			{  				// Used in unit tests only  				smudge_ns = 0;  				smudge_s = 0;  			}
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,WriteTo,The following statement contains a magic number: if (myLock != null)  			{  				// For new files we need to smudge the index entry  				// if they have been modified "now". Ideally we'd  				// want the timestamp when we're done writing the index'  				// so we use the current timestamp as a approximation.  				myLock.CreateCommitSnapshot();  				snapshot = myLock.GetCommitSnapshot();  				smudge_s = (int)(snapshot.LastModified() / 1000);  				smudge_ns = ((int)(snapshot.LastModified() % 1000)) * 1000000;  			}  			else  			{  				// Used in unit tests only  				smudge_ns = 0;  				smudge_s = 0;  			}
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,WriteTo,The following statement contains a magic number: if (writeTree)  			{  				TemporaryBuffer bb = new TemporaryBuffer.LocalFile();  				tree.Write(tmp' bb);  				bb.Close();  				NB.EncodeInt32(tmp' 0' EXT_TREE);  				NB.EncodeInt32(tmp' 4' (int)bb.Length());  				dos.Write(tmp' 0' 8);  				bb.WriteTo(dos' null);  			}
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,WriteTo,The following statement contains a magic number: if (writeTree)  			{  				TemporaryBuffer bb = new TemporaryBuffer.LocalFile();  				tree.Write(tmp' bb);  				bb.Close();  				NB.EncodeInt32(tmp' 0' EXT_TREE);  				NB.EncodeInt32(tmp' 4' (int)bb.Length());  				dos.Write(tmp' 0' 8);  				bb.WriteTo(dos' null);  			}
Magic Number,NGit.Dircache,DirCache,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCache.cs,UpdateSmudgedEntries,The following statement contains a magic number: IList<string> paths = new AList<string>(128);
Magic Number,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,PreScanTwoTrees,The following statement contains a magic number: while (walk.Next())  			{  				ProcessEntry(walk.GetTree<CanonicalTreeParser>(0)' walk.GetTree<CanonicalTreeParser  					>(1)' walk.GetTree<DirCacheBuildIterator>(2)' walk.GetTree<WorkingTreeIterator>(  					3));  				if (walk.IsSubtree)  				{  					walk.EnterSubtree();  				}  			}
Magic Number,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,PreScanTwoTrees,The following statement contains a magic number: while (walk.Next())  			{  				ProcessEntry(walk.GetTree<CanonicalTreeParser>(0)' walk.GetTree<CanonicalTreeParser  					>(1)' walk.GetTree<DirCacheBuildIterator>(2)' walk.GetTree<WorkingTreeIterator>(  					3));  				if (walk.IsSubtree)  				{  					walk.EnterSubtree();  				}  			}
Magic Number,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,PrescanOneTree,The following statement contains a magic number: while (walk.Next())  			{  				ProcessEntry(walk.GetTree<CanonicalTreeParser>(0)' walk.GetTree<DirCacheBuildIterator  					>(1)' walk.GetTree<WorkingTreeIterator>(2));  				if (walk.IsSubtree)  				{  					walk.EnterSubtree();  				}  			}
Magic Number,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,IsValidPathSegment,The following statement contains a magic number: if (ptr - start == 1)  			{  				if (raw[start] == '.')  				{  					return false;  				}  			}  			else  			{  				if (ptr - start == 2)  				{  					if (raw[start] == '.')  					{  						if (raw[start + 1] == '.')  						{  							return false;  						}  					}  				}  				else  				{  					if (ptr - start == 4)  					{  						// .git (possibly case insensitive) is disallowed  						if (raw[start] == '.')  						{  							if (raw[start + 1] == 'g' || (ignCase && raw[start + 1] == 'G'))  							{  								if (raw[start + 2] == 'i' || (ignCase && raw[start + 2] == 'I'))  								{  									if (raw[start + 3] == 't' || (ignCase && raw[start + 3] == 'T'))  									{  										return false;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,IsValidPathSegment,The following statement contains a magic number: if (ptr - start == 1)  			{  				if (raw[start] == '.')  				{  					return false;  				}  			}  			else  			{  				if (ptr - start == 2)  				{  					if (raw[start] == '.')  					{  						if (raw[start + 1] == '.')  						{  							return false;  						}  					}  				}  				else  				{  					if (ptr - start == 4)  					{  						// .git (possibly case insensitive) is disallowed  						if (raw[start] == '.')  						{  							if (raw[start + 1] == 'g' || (ignCase && raw[start + 1] == 'G'))  							{  								if (raw[start + 2] == 'i' || (ignCase && raw[start + 2] == 'I'))  								{  									if (raw[start + 3] == 't' || (ignCase && raw[start + 3] == 'T'))  									{  										return false;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,IsValidPathSegment,The following statement contains a magic number: if (ptr - start == 1)  			{  				if (raw[start] == '.')  				{  					return false;  				}  			}  			else  			{  				if (ptr - start == 2)  				{  					if (raw[start] == '.')  					{  						if (raw[start + 1] == '.')  						{  							return false;  						}  					}  				}  				else  				{  					if (ptr - start == 4)  					{  						// .git (possibly case insensitive) is disallowed  						if (raw[start] == '.')  						{  							if (raw[start + 1] == 'g' || (ignCase && raw[start + 1] == 'G'))  							{  								if (raw[start + 2] == 'i' || (ignCase && raw[start + 2] == 'I'))  								{  									if (raw[start + 3] == 't' || (ignCase && raw[start + 3] == 'T'))  									{  										return false;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,IsValidPathSegment,The following statement contains a magic number: if (ptr - start == 1)  			{  				if (raw[start] == '.')  				{  					return false;  				}  			}  			else  			{  				if (ptr - start == 2)  				{  					if (raw[start] == '.')  					{  						if (raw[start + 1] == '.')  						{  							return false;  						}  					}  				}  				else  				{  					if (ptr - start == 4)  					{  						// .git (possibly case insensitive) is disallowed  						if (raw[start] == '.')  						{  							if (raw[start + 1] == 'g' || (ignCase && raw[start + 1] == 'G'))  							{  								if (raw[start + 2] == 'i' || (ignCase && raw[start + 2] == 'I'))  								{  									if (raw[start + 3] == 't' || (ignCase && raw[start + 3] == 'T'))  									{  										return false;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,IsValidPathSegment,The following statement contains a magic number: if (ptr - start == 1)  			{  				if (raw[start] == '.')  				{  					return false;  				}  			}  			else  			{  				if (ptr - start == 2)  				{  					if (raw[start] == '.')  					{  						if (raw[start + 1] == '.')  						{  							return false;  						}  					}  				}  				else  				{  					if (ptr - start == 4)  					{  						// .git (possibly case insensitive) is disallowed  						if (raw[start] == '.')  						{  							if (raw[start + 1] == 'g' || (ignCase && raw[start + 1] == 'G'))  							{  								if (raw[start + 2] == 'i' || (ignCase && raw[start + 2] == 'I'))  								{  									if (raw[start + 3] == 't' || (ignCase && raw[start + 3] == 'T'))  									{  										return false;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,IsValidPathSegment,The following statement contains a magic number: if (ptr - start == 1)  			{  				if (raw[start] == '.')  				{  					return false;  				}  			}  			else  			{  				if (ptr - start == 2)  				{  					if (raw[start] == '.')  					{  						if (raw[start + 1] == '.')  						{  							return false;  						}  					}  				}  				else  				{  					if (ptr - start == 4)  					{  						// .git (possibly case insensitive) is disallowed  						if (raw[start] == '.')  						{  							if (raw[start + 1] == 'g' || (ignCase && raw[start + 1] == 'G'))  							{  								if (raw[start + 2] == 'i' || (ignCase && raw[start + 2] == 'I'))  								{  									if (raw[start + 3] == 't' || (ignCase && raw[start + 3] == 'T'))  									{  										return false;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,IsValidPathSegment,The following statement contains a magic number: if (isWindows)  			{  				// Space or period at end of file name is ignored by Windows.  				// Treat this as a bad path for now. We may want to handle  				// this as case insensitivity in the future.  				if (raw[ptr - 1] == '.' || raw[ptr - 1] == ' ')  				{  					return false;  				}  				int i;  				// Bad names' eliminate suffix first  				for (i = start; i < ptr; ++i)  				{  					if (raw[i] == '.')  					{  						break;  					}  				}  				int len = i - start;  				if (len == 3 || len == 4)  				{  					for (int j = 0; j < forbidden.Length; ++j)  					{  						if (forbidden[j].Length == len)  						{  							if (((sbyte)ToUpper(raw[start])) < forbidden[j][0])  							{  								break;  							}  							int k;  							for (k = 0; k < len; ++k)  							{  								if (ToUpper(raw[start + k]) != forbidden[j][k])  								{  									break;  								}  							}  							if (k == len)  							{  								return false;  							}  						}  					}  				}  			}
Magic Number,NGit.Dircache,DirCacheCheckout,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheCheckout.cs,IsValidPathSegment,The following statement contains a magic number: if (isWindows)  			{  				// Space or period at end of file name is ignored by Windows.  				// Treat this as a bad path for now. We may want to handle  				// this as case insensitivity in the future.  				if (raw[ptr - 1] == '.' || raw[ptr - 1] == ' ')  				{  					return false;  				}  				int i;  				// Bad names' eliminate suffix first  				for (i = start; i < ptr; ++i)  				{  					if (raw[i] == '.')  					{  						break;  					}  				}  				int len = i - start;  				if (len == 3 || len == 4)  				{  					for (int j = 0; j < forbidden.Length; ++j)  					{  						if (forbidden[j].Length == len)  						{  							if (((sbyte)ToUpper(raw[start])) < forbidden[j][0])  							{  								break;  							}  							int k;  							for (k = 0; k < len; ++k)  							{  								if (ToUpper(raw[start + k]) != forbidden[j][k])  								{  									break;  								}  							}  							if (k == len)  							{  								return false;  							}  						}  					}  				}  			}
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DirCacheEntry,The following statement contains a magic number: int expLen = (actLen + 8) & ~7;
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DirCacheEntry,The following statement contains a magic number: int expLen = (actLen + 8) & ~7;
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DirCacheEntry,The following statement contains a magic number: if (stage < 0 || 3 < stage)  			{  				throw new ArgumentException(MessageFormat.Format(JGitText.Get().invalidStageForPath  					' stage' ToString(newPath)));  			}
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DirCacheEntry,The following statement contains a magic number: int flags = ((stage & unchecked((int)(0x3))) << 12);
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,Write,The following statement contains a magic number: int expLen = (actLen + 8) & ~7;
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,Write,The following statement contains a magic number: int expLen = (actLen + 8) & ~7;
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,MightBeRacilyClean,The following statement contains a magic number: if (smudge_s == mtime)  			{  				return smudge_ns <= NB.DecodeInt32(info' @base + 4);  			}
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,SmudgeRacilyClean,The following statement contains a magic number: Arrays.Fill(info' @base' @base + 4' unchecked((byte)0));
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,CopyMetaData,The following statement contains a magic number: int SHIFTED_STAGE_MASK = unchecked((int)(0x3)) << 12;
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DecodeTS,The following statement contains a magic number: int ms = NB.DecodeInt32(info' @base + 4) / 1000000;
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,DecodeTS,The following statement contains a magic number: int ms = NB.DecodeInt32(info' @base + 4) / 1000000;
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,EncodeTS,The following statement contains a magic number: NB.EncodeInt32(info' @base' (int)(when / 1000));
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,EncodeTS,The following statement contains a magic number: NB.EncodeInt32(info' @base + 4' ((int)(when % 1000)) * 1000000);
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,EncodeTS,The following statement contains a magic number: NB.EncodeInt32(info' @base + 4' ((int)(when % 1000)) * 1000000);
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,EncodeTS,The following statement contains a magic number: NB.EncodeInt32(info' @base + 4' ((int)(when % 1000)) * 1000000);
Magic Number,NGit.Dircache,DirCacheEntry,C:\repos\mono_ngit\NGit\NGit.Dircache\DirCacheEntry.cs,GetExtendedFlags,The following statement contains a magic number: if (IsExtended)  			{  				return NB.DecodeUInt16(info' infoOffset + P_FLAGS2) << 16;  			}  			else  			{  				return 0;  			}
Magic Number,NGit.Fnmatch,FileNameMatcher,C:\repos\mono_ngit\NGit\NGit.Fnmatch\FileNameMatcher.cs,CreateHeadsStartValues,The following statement contains a magic number: IList<Head> nextHeadsSuggestion = new AList<Head>(2);
Magic Number,NGit.Fnmatch,FileNameMatcher,C:\repos\mono_ngit\NGit\NGit.Fnmatch\FileNameMatcher.cs,CreateHeadsStartValues,The following statement contains a magic number: for (int i = allHeads.Count - 1; i >= 0; i--)  			{  				AbstractHead head = allHeads[i];  				// explanation:  				// a and * of the pattern "a*b"  				// need *b as newHeads  				// that's why * extends the list for it self and it's left neighbor.  				if (head.IsStar())  				{  					nextHeadsSuggestion.AddItem(head);  					head.SetNewHeads(nextHeadsSuggestion);  				}  				else  				{  					head.SetNewHeads(nextHeadsSuggestion);  					nextHeadsSuggestion = new AList<Head>(2);  					nextHeadsSuggestion.AddItem(head);  				}  			}
Magic Number,NGit.Fnmatch,FileNameMatcher,C:\repos\mono_ngit\NGit\NGit.Fnmatch\FileNameMatcher.cs,FindGroupEnd,The following statement contains a magic number: int firstValidEndBracketIndex = indexOfStartBracket + 2;
Magic Number,NGit.Fnmatch,FileNameMatcher,C:\repos\mono_ngit\NGit\NGit.Fnmatch\FileNameMatcher.cs,FindGroupEnd,The following statement contains a magic number: while (groupEnd == -1)  			{  				int possibleGroupEnd = pattern.IndexOf(']'' firstValidEndBracketIndex);  				if (possibleGroupEnd == -1)  				{  					throw new NoClosingBracketException(indexOfStartBracket' "["' "]"' pattern);  				}  				bool foundCharClass = charClassStartMatcher.Find(firstValidCharClassIndex);  				if (foundCharClass && charClassStartMatcher.Start() < possibleGroupEnd)  				{  					string classStart = charClassStartMatcher.Group(0);  					string classEnd = classStart[1] + "]";  					int classStartIndex = charClassStartMatcher.Start();  					int classEndIndex = pattern.IndexOf(classEnd' classStartIndex + 2);  					if (classEndIndex == -1)  					{  						throw new NoClosingBracketException(classStartIndex' classStart' classEnd' pattern  							);  					}  					firstValidCharClassIndex = classEndIndex + 2;  					firstValidEndBracketIndex = firstValidCharClassIndex;  				}  				else  				{  					groupEnd = possibleGroupEnd;  				}  			}
Magic Number,NGit.Fnmatch,FileNameMatcher,C:\repos\mono_ngit\NGit\NGit.Fnmatch\FileNameMatcher.cs,FindGroupEnd,The following statement contains a magic number: while (groupEnd == -1)  			{  				int possibleGroupEnd = pattern.IndexOf(']'' firstValidEndBracketIndex);  				if (possibleGroupEnd == -1)  				{  					throw new NoClosingBracketException(indexOfStartBracket' "["' "]"' pattern);  				}  				bool foundCharClass = charClassStartMatcher.Find(firstValidCharClassIndex);  				if (foundCharClass && charClassStartMatcher.Start() < possibleGroupEnd)  				{  					string classStart = charClassStartMatcher.Group(0);  					string classEnd = classStart[1] + "]";  					int classStartIndex = charClassStartMatcher.Start();  					int classEndIndex = pattern.IndexOf(classEnd' classStartIndex + 2);  					if (classEndIndex == -1)  					{  						throw new NoClosingBracketException(classStartIndex' classStart' classEnd' pattern  							);  					}  					firstValidCharClassIndex = classEndIndex + 2;  					firstValidEndBracketIndex = firstValidCharClassIndex;  				}  				else  				{  					groupEnd = possibleGroupEnd;  				}  			}
Magic Number,NGit.Fnmatch,GroupHead,C:\repos\mono_ngit\NGit\NGit.Fnmatch\GroupHead.cs,GroupHead,The following statement contains a magic number: while (matcher.Find())  			{  				string characterClass = matcher.Group(0);  				if (characterClass.Length == 3 && characterClass[1] == '-')  				{  					char start = characterClass[0];  					char end = characterClass[2];  					characterClasses.AddItem(new GroupHead.CharacterRange(start' end));  				}  				else  				{  					if (characterClass.Equals("[:alnum:]"))  					{  						characterClasses.AddItem(GroupHead.LetterPattern.INSTANCE);  						characterClasses.AddItem(GroupHead.DigitPattern.INSTANCE);  					}  					else  					{  						if (characterClass.Equals("[:alpha:]"))  						{  							characterClasses.AddItem(GroupHead.LetterPattern.INSTANCE);  						}  						else  						{  							if (characterClass.Equals("[:blank:]"))  							{  								characterClasses.AddItem(new GroupHead.OneCharacterPattern(' '));  								characterClasses.AddItem(new GroupHead.OneCharacterPattern('\t'));  							}  							else  							{  								if (characterClass.Equals("[:cntrl:]"))  								{  									characterClasses.AddItem(new GroupHead.CharacterRange('\u0000'' '\u001F'));  									characterClasses.AddItem(new GroupHead.OneCharacterPattern('\u007F'));  								}  								else  								{  									if (characterClass.Equals("[:digit:]"))  									{  										characterClasses.AddItem(GroupHead.DigitPattern.INSTANCE);  									}  									else  									{  										if (characterClass.Equals("[:graph:]"))  										{  											characterClasses.AddItem(new GroupHead.CharacterRange('\u0021'' '\u007E'));  											characterClasses.AddItem(GroupHead.LetterPattern.INSTANCE);  											characterClasses.AddItem(GroupHead.DigitPattern.INSTANCE);  										}  										else  										{  											if (characterClass.Equals("[:lower:]"))  											{  												characterClasses.AddItem(GroupHead.LowerPattern.INSTANCE);  											}  											else  											{  												if (characterClass.Equals("[:print:]"))  												{  													characterClasses.AddItem(new GroupHead.CharacterRange('\u0020'' '\u007E'));  													characterClasses.AddItem(GroupHead.LetterPattern.INSTANCE);  													characterClasses.AddItem(GroupHead.DigitPattern.INSTANCE);  												}  												else  												{  													if (characterClass.Equals("[:punct:]"))  													{  														characterClasses.AddItem(GroupHead.PunctPattern.INSTANCE);  													}  													else  													{  														if (characterClass.Equals("[:space:]"))  														{  															characterClasses.AddItem(GroupHead.WhitespacePattern.INSTANCE);  														}  														else  														{  															if (characterClass.Equals("[:upper:]"))  															{  																characterClasses.AddItem(GroupHead.UpperPattern.INSTANCE);  															}  															else  															{  																if (characterClass.Equals("[:xdigit:]"))  																{  																	characterClasses.AddItem(new GroupHead.CharacterRange('0'' '9'));  																	characterClasses.AddItem(new GroupHead.CharacterRange('a'' 'f'));  																	characterClasses.AddItem(new GroupHead.CharacterRange('A'' 'F'));  																}  																else  																{  																	if (characterClass.Equals("[:word:]"))  																	{  																		characterClasses.AddItem(new GroupHead.OneCharacterPattern('_'));  																		characterClasses.AddItem(GroupHead.LetterPattern.INSTANCE);  																		characterClasses.AddItem(GroupHead.DigitPattern.INSTANCE);  																	}  																	else  																	{  																		string message = string.Format(MessageFormat.Format(JGitText.Get().characterClassIsNotSupported  																			' characterClass));  																		throw new InvalidPatternException(message' wholePattern);  																	}  																}  															}  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				pattern = matcher.ReplaceFirst(string.Empty);  				matcher.Reset(pattern);  			}
Magic Number,NGit.Fnmatch,GroupHead,C:\repos\mono_ngit\NGit\NGit.Fnmatch\GroupHead.cs,GroupHead,The following statement contains a magic number: while (matcher.Find())  			{  				string characterClass = matcher.Group(0);  				if (characterClass.Length == 3 && characterClass[1] == '-')  				{  					char start = characterClass[0];  					char end = characterClass[2];  					characterClasses.AddItem(new GroupHead.CharacterRange(start' end));  				}  				else  				{  					if (characterClass.Equals("[:alnum:]"))  					{  						characterClasses.AddItem(GroupHead.LetterPattern.INSTANCE);  						characterClasses.AddItem(GroupHead.DigitPattern.INSTANCE);  					}  					else  					{  						if (characterClass.Equals("[:alpha:]"))  						{  							characterClasses.AddItem(GroupHead.LetterPattern.INSTANCE);  						}  						else  						{  							if (characterClass.Equals("[:blank:]"))  							{  								characterClasses.AddItem(new GroupHead.OneCharacterPattern(' '));  								characterClasses.AddItem(new GroupHead.OneCharacterPattern('\t'));  							}  							else  							{  								if (characterClass.Equals("[:cntrl:]"))  								{  									characterClasses.AddItem(new GroupHead.CharacterRange('\u0000'' '\u001F'));  									characterClasses.AddItem(new GroupHead.OneCharacterPattern('\u007F'));  								}  								else  								{  									if (characterClass.Equals("[:digit:]"))  									{  										characterClasses.AddItem(GroupHead.DigitPattern.INSTANCE);  									}  									else  									{  										if (characterClass.Equals("[:graph:]"))  										{  											characterClasses.AddItem(new GroupHead.CharacterRange('\u0021'' '\u007E'));  											characterClasses.AddItem(GroupHead.LetterPattern.INSTANCE);  											characterClasses.AddItem(GroupHead.DigitPattern.INSTANCE);  										}  										else  										{  											if (characterClass.Equals("[:lower:]"))  											{  												characterClasses.AddItem(GroupHead.LowerPattern.INSTANCE);  											}  											else  											{  												if (characterClass.Equals("[:print:]"))  												{  													characterClasses.AddItem(new GroupHead.CharacterRange('\u0020'' '\u007E'));  													characterClasses.AddItem(GroupHead.LetterPattern.INSTANCE);  													characterClasses.AddItem(GroupHead.DigitPattern.INSTANCE);  												}  												else  												{  													if (characterClass.Equals("[:punct:]"))  													{  														characterClasses.AddItem(GroupHead.PunctPattern.INSTANCE);  													}  													else  													{  														if (characterClass.Equals("[:space:]"))  														{  															characterClasses.AddItem(GroupHead.WhitespacePattern.INSTANCE);  														}  														else  														{  															if (characterClass.Equals("[:upper:]"))  															{  																characterClasses.AddItem(GroupHead.UpperPattern.INSTANCE);  															}  															else  															{  																if (characterClass.Equals("[:xdigit:]"))  																{  																	characterClasses.AddItem(new GroupHead.CharacterRange('0'' '9'));  																	characterClasses.AddItem(new GroupHead.CharacterRange('a'' 'f'));  																	characterClasses.AddItem(new GroupHead.CharacterRange('A'' 'F'));  																}  																else  																{  																	if (characterClass.Equals("[:word:]"))  																	{  																		characterClasses.AddItem(new GroupHead.OneCharacterPattern('_'));  																		characterClasses.AddItem(GroupHead.LetterPattern.INSTANCE);  																		characterClasses.AddItem(GroupHead.DigitPattern.INSTANCE);  																	}  																	else  																	{  																		string message = string.Format(MessageFormat.Format(JGitText.Get().characterClassIsNotSupported  																			' characterClass));  																		throw new InvalidPatternException(message' wholePattern);  																	}  																}  															}  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				pattern = matcher.ReplaceFirst(string.Empty);  				matcher.Reset(pattern);  			}
Magic Number,NGit.Merge,MergeAlgorithm,C:\repos\mono_ngit\NGit\NGit.Merge\MergeAlgorithm.cs,Merge,The following statement contains a magic number: IList<S> sequences = new AList<S>(3);
Magic Number,NGit.Merge,MergeAlgorithm,C:\repos\mono_ngit\NGit\NGit.Merge\MergeAlgorithm.cs,Merge,The following statement contains a magic number: if (ours.Size() == 0)  			{  				if (theirs.Size() != 0)  				{  					EditList theirsEdits = diffAlg.Diff(cmp' @base' theirs);  					if (!theirsEdits.IsEmpty())  					{  						// we deleted' they modified -> Let their complete content  						// conflict with empty text  						result.Add(1' 0' 0' MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE);  						result.Add(2' 0' theirs.Size()' MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);  					}  					else  					{  						// we deleted' they didn't modify -> Let our deletion win  						result.Add(1' 0' 0' MergeChunk.ConflictState.NO_CONFLICT);  					}  				}  				else  				{  					// we and they deleted -> return a single chunk of nothing  					result.Add(1' 0' 0' MergeChunk.ConflictState.NO_CONFLICT);  				}  				return result;  			}  			else  			{  				if (theirs.Size() == 0)  				{  					EditList oursEdits = diffAlg.Diff(cmp' @base' ours);  					if (!oursEdits.IsEmpty())  					{  						// we modified' they deleted -> Let our complete content  						// conflict with empty text  						result.Add(1' 0' ours.Size()' MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE);  						result.Add(2' 0' 0' MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);  					}  					else  					{  						// they deleted' we didn't modify -> Let their deletion win  						result.Add(2' 0' 0' MergeChunk.ConflictState.NO_CONFLICT);  					}  					return result;  				}  			}
Magic Number,NGit.Merge,MergeAlgorithm,C:\repos\mono_ngit\NGit\NGit.Merge\MergeAlgorithm.cs,Merge,The following statement contains a magic number: if (ours.Size() == 0)  			{  				if (theirs.Size() != 0)  				{  					EditList theirsEdits = diffAlg.Diff(cmp' @base' theirs);  					if (!theirsEdits.IsEmpty())  					{  						// we deleted' they modified -> Let their complete content  						// conflict with empty text  						result.Add(1' 0' 0' MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE);  						result.Add(2' 0' theirs.Size()' MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);  					}  					else  					{  						// we deleted' they didn't modify -> Let our deletion win  						result.Add(1' 0' 0' MergeChunk.ConflictState.NO_CONFLICT);  					}  				}  				else  				{  					// we and they deleted -> return a single chunk of nothing  					result.Add(1' 0' 0' MergeChunk.ConflictState.NO_CONFLICT);  				}  				return result;  			}  			else  			{  				if (theirs.Size() == 0)  				{  					EditList oursEdits = diffAlg.Diff(cmp' @base' ours);  					if (!oursEdits.IsEmpty())  					{  						// we modified' they deleted -> Let our complete content  						// conflict with empty text  						result.Add(1' 0' ours.Size()' MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE);  						result.Add(2' 0' 0' MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);  					}  					else  					{  						// they deleted' we didn't modify -> Let their deletion win  						result.Add(2' 0' 0' MergeChunk.ConflictState.NO_CONFLICT);  					}  					return result;  				}  			}
Magic Number,NGit.Merge,MergeAlgorithm,C:\repos\mono_ngit\NGit\NGit.Merge\MergeAlgorithm.cs,Merge,The following statement contains a magic number: if (ours.Size() == 0)  			{  				if (theirs.Size() != 0)  				{  					EditList theirsEdits = diffAlg.Diff(cmp' @base' theirs);  					if (!theirsEdits.IsEmpty())  					{  						// we deleted' they modified -> Let their complete content  						// conflict with empty text  						result.Add(1' 0' 0' MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE);  						result.Add(2' 0' theirs.Size()' MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);  					}  					else  					{  						// we deleted' they didn't modify -> Let our deletion win  						result.Add(1' 0' 0' MergeChunk.ConflictState.NO_CONFLICT);  					}  				}  				else  				{  					// we and they deleted -> return a single chunk of nothing  					result.Add(1' 0' 0' MergeChunk.ConflictState.NO_CONFLICT);  				}  				return result;  			}  			else  			{  				if (theirs.Size() == 0)  				{  					EditList oursEdits = diffAlg.Diff(cmp' @base' ours);  					if (!oursEdits.IsEmpty())  					{  						// we modified' they deleted -> Let our complete content  						// conflict with empty text  						result.Add(1' 0' ours.Size()' MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE);  						result.Add(2' 0' 0' MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);  					}  					else  					{  						// they deleted' we didn't modify -> Let their deletion win  						result.Add(2' 0' 0' MergeChunk.ConflictState.NO_CONFLICT);  					}  					return result;  				}  			}
Magic Number,NGit.Merge,MergeAlgorithm,C:\repos\mono_ngit\NGit\NGit.Merge\MergeAlgorithm.cs,Merge,The following statement contains a magic number: while (theirsEdit != END_EDIT || oursEdit != END_EDIT)  			{  				if (oursEdit.GetEndA() < theirsEdit.GetBeginA())  				{  					// something was changed in ours not overlapping with any change  					// from theirs. First add the common part in front of the edit  					// then the edit.  					if (current != oursEdit.GetBeginA())  					{  						result.Add(0' current' oursEdit.GetBeginA()' MergeChunk.ConflictState.NO_CONFLICT  							);  					}  					result.Add(1' oursEdit.GetBeginB()' oursEdit.GetEndB()' MergeChunk.ConflictState.  						NO_CONFLICT);  					current = oursEdit.GetEndA();  					oursEdit = NextEdit(baseToOurs);  				}  				else  				{  					if (theirsEdit.GetEndA() < oursEdit.GetBeginA())  					{  						// something was changed in theirs not overlapping with any  						// from ours. First add the common part in front of the edit  						// then the edit.  						if (current != theirsEdit.GetBeginA())  						{  							result.Add(0' current' theirsEdit.GetBeginA()' MergeChunk.ConflictState.NO_CONFLICT  								);  						}  						result.Add(2' theirsEdit.GetBeginB()' theirsEdit.GetEndB()' MergeChunk.ConflictState  							.NO_CONFLICT);  						current = theirsEdit.GetEndA();  						theirsEdit = NextEdit(baseToTheirs);  					}  					else  					{  						// here we found a real overlapping modification  						// if there is a common part in front of the conflict add it  						if (oursEdit.GetBeginA() != current && theirsEdit.GetBeginA() != current)  						{  							result.Add(0' current' Math.Min(oursEdit.GetBeginA()' theirsEdit.GetBeginA())' MergeChunk.ConflictState  								.NO_CONFLICT);  						}  						// set some initial values for the ranges in A and B which we  						// want to handle  						int oursBeginB = oursEdit.GetBeginB();  						int theirsBeginB = theirsEdit.GetBeginB();  						// harmonize the start of the ranges in A and B  						if (oursEdit.GetBeginA() < theirsEdit.GetBeginA())  						{  							theirsBeginB -= theirsEdit.GetBeginA() - oursEdit.GetBeginA();  						}  						else  						{  							oursBeginB -= oursEdit.GetBeginA() - theirsEdit.GetBeginA();  						}  						// combine edits:  						// Maybe an Edit on one side corresponds to multiple Edits on  						// the other side. Then we have to combine the Edits of the  						// other side - so in the end we can merge together two single  						// edits.  						//  						// It is important to notice that this combining will extend the  						// ranges of our conflict always downwards (towards the end of  						// the content). The starts of the conflicting ranges in ours  						// and theirs are not touched here.  						//  						// This combining is an iterative process: after we have  						// combined some edits we have to do the check again. The  						// combined edits could now correspond to multiple edits on the  						// other side.  						//  						// Example: when this combining algorithm works on the following  						// edits  						// oursEdits=((0-5'0-5)'(6-8'6-8)'(10-11'10-11)) and  						// theirsEdits=((0-1'0-1)'(2-3'2-3)'(5-7'5-7))  						// it will merge them into  						// oursEdits=((0-8'0-8)'(10-11'10-11)) and  						// theirsEdits=((0-7'0-7))  						//  						// Since the only interesting thing to us is how in ours and  						// theirs the end of the conflicting range is changing we let  						// oursEdit and theirsEdit point to the last conflicting edit  						Edit nextOursEdit = NextEdit(baseToOurs);  						Edit nextTheirsEdit = NextEdit(baseToTheirs);  						for (; ; )  						{  							if (oursEdit.GetEndA() >= nextTheirsEdit.GetBeginA())  							{  								theirsEdit = nextTheirsEdit;  								nextTheirsEdit = NextEdit(baseToTheirs);  							}  							else  							{  								if (theirsEdit.GetEndA() >= nextOursEdit.GetBeginA())  								{  									oursEdit = nextOursEdit;  									nextOursEdit = NextEdit(baseToOurs);  								}  								else  								{  									break;  								}  							}  						}  						// harmonize the end of the ranges in A and B  						int oursEndB = oursEdit.GetEndB();  						int theirsEndB = theirsEdit.GetEndB();  						if (oursEdit.GetEndA() < theirsEdit.GetEndA())  						{  							oursEndB += theirsEdit.GetEndA() - oursEdit.GetEndA();  						}  						else  						{  							theirsEndB += oursEdit.GetEndA() - theirsEdit.GetEndA();  						}  						// A conflicting region is found. Strip off common lines in  						// in the beginning and the end of the conflicting region  						// Determine the minimum length of the conflicting areas in OURS  						// and THEIRS. Also determine how much bigger the conflicting  						// area in THEIRS is compared to OURS. All that is needed to  						// limit the search for common areas at the beginning or end  						// (the common areas cannot be bigger then the smaller  						// conflicting area. The delta is needed to know whether the  						// complete conflicting area is common in OURS and THEIRS.  						int minBSize = oursEndB - oursBeginB;  						int BSizeDelta = minBSize - (theirsEndB - theirsBeginB);  						if (BSizeDelta > 0)  						{  							minBSize -= BSizeDelta;  						}  						int commonPrefix = 0;  						while (commonPrefix < minBSize && cmp.Equals(ours' oursBeginB + commonPrefix' theirs  							' theirsBeginB + commonPrefix))  						{  							commonPrefix++;  						}  						minBSize -= commonPrefix;  						int commonSuffix = 0;  						while (commonSuffix < minBSize && cmp.Equals(ours' oursEndB - commonSuffix - 1' theirs  							' theirsEndB - commonSuffix - 1))  						{  							commonSuffix++;  						}  						minBSize -= commonSuffix;  						// Add the common lines at start of conflict  						if (commonPrefix > 0)  						{  							result.Add(1' oursBeginB' oursBeginB + commonPrefix' MergeChunk.ConflictState.NO_CONFLICT  								);  						}  						// Add the conflict (Only if there is a conflict left to report)  						if (minBSize > 0 || BSizeDelta != 0)  						{  							result.Add(1' oursBeginB + commonPrefix' oursEndB - commonSuffix' MergeChunk.ConflictState  								.FIRST_CONFLICTING_RANGE);  							result.Add(2' theirsBeginB + commonPrefix' theirsEndB - commonSuffix' MergeChunk.ConflictState  								.NEXT_CONFLICTING_RANGE);  						}  						// Add the common lines at end of conflict  						if (commonSuffix > 0)  						{  							result.Add(1' oursEndB - commonSuffix' oursEndB' MergeChunk.ConflictState.NO_CONFLICT  								);  						}  						current = Math.Max(oursEdit.GetEndA()' theirsEdit.GetEndA());  						oursEdit = nextOursEdit;  						theirsEdit = nextTheirsEdit;  					}  				}  			}
Magic Number,NGit.Merge,MergeAlgorithm,C:\repos\mono_ngit\NGit\NGit.Merge\MergeAlgorithm.cs,Merge,The following statement contains a magic number: while (theirsEdit != END_EDIT || oursEdit != END_EDIT)  			{  				if (oursEdit.GetEndA() < theirsEdit.GetBeginA())  				{  					// something was changed in ours not overlapping with any change  					// from theirs. First add the common part in front of the edit  					// then the edit.  					if (current != oursEdit.GetBeginA())  					{  						result.Add(0' current' oursEdit.GetBeginA()' MergeChunk.ConflictState.NO_CONFLICT  							);  					}  					result.Add(1' oursEdit.GetBeginB()' oursEdit.GetEndB()' MergeChunk.ConflictState.  						NO_CONFLICT);  					current = oursEdit.GetEndA();  					oursEdit = NextEdit(baseToOurs);  				}  				else  				{  					if (theirsEdit.GetEndA() < oursEdit.GetBeginA())  					{  						// something was changed in theirs not overlapping with any  						// from ours. First add the common part in front of the edit  						// then the edit.  						if (current != theirsEdit.GetBeginA())  						{  							result.Add(0' current' theirsEdit.GetBeginA()' MergeChunk.ConflictState.NO_CONFLICT  								);  						}  						result.Add(2' theirsEdit.GetBeginB()' theirsEdit.GetEndB()' MergeChunk.ConflictState  							.NO_CONFLICT);  						current = theirsEdit.GetEndA();  						theirsEdit = NextEdit(baseToTheirs);  					}  					else  					{  						// here we found a real overlapping modification  						// if there is a common part in front of the conflict add it  						if (oursEdit.GetBeginA() != current && theirsEdit.GetBeginA() != current)  						{  							result.Add(0' current' Math.Min(oursEdit.GetBeginA()' theirsEdit.GetBeginA())' MergeChunk.ConflictState  								.NO_CONFLICT);  						}  						// set some initial values for the ranges in A and B which we  						// want to handle  						int oursBeginB = oursEdit.GetBeginB();  						int theirsBeginB = theirsEdit.GetBeginB();  						// harmonize the start of the ranges in A and B  						if (oursEdit.GetBeginA() < theirsEdit.GetBeginA())  						{  							theirsBeginB -= theirsEdit.GetBeginA() - oursEdit.GetBeginA();  						}  						else  						{  							oursBeginB -= oursEdit.GetBeginA() - theirsEdit.GetBeginA();  						}  						// combine edits:  						// Maybe an Edit on one side corresponds to multiple Edits on  						// the other side. Then we have to combine the Edits of the  						// other side - so in the end we can merge together two single  						// edits.  						//  						// It is important to notice that this combining will extend the  						// ranges of our conflict always downwards (towards the end of  						// the content). The starts of the conflicting ranges in ours  						// and theirs are not touched here.  						//  						// This combining is an iterative process: after we have  						// combined some edits we have to do the check again. The  						// combined edits could now correspond to multiple edits on the  						// other side.  						//  						// Example: when this combining algorithm works on the following  						// edits  						// oursEdits=((0-5'0-5)'(6-8'6-8)'(10-11'10-11)) and  						// theirsEdits=((0-1'0-1)'(2-3'2-3)'(5-7'5-7))  						// it will merge them into  						// oursEdits=((0-8'0-8)'(10-11'10-11)) and  						// theirsEdits=((0-7'0-7))  						//  						// Since the only interesting thing to us is how in ours and  						// theirs the end of the conflicting range is changing we let  						// oursEdit and theirsEdit point to the last conflicting edit  						Edit nextOursEdit = NextEdit(baseToOurs);  						Edit nextTheirsEdit = NextEdit(baseToTheirs);  						for (; ; )  						{  							if (oursEdit.GetEndA() >= nextTheirsEdit.GetBeginA())  							{  								theirsEdit = nextTheirsEdit;  								nextTheirsEdit = NextEdit(baseToTheirs);  							}  							else  							{  								if (theirsEdit.GetEndA() >= nextOursEdit.GetBeginA())  								{  									oursEdit = nextOursEdit;  									nextOursEdit = NextEdit(baseToOurs);  								}  								else  								{  									break;  								}  							}  						}  						// harmonize the end of the ranges in A and B  						int oursEndB = oursEdit.GetEndB();  						int theirsEndB = theirsEdit.GetEndB();  						if (oursEdit.GetEndA() < theirsEdit.GetEndA())  						{  							oursEndB += theirsEdit.GetEndA() - oursEdit.GetEndA();  						}  						else  						{  							theirsEndB += oursEdit.GetEndA() - theirsEdit.GetEndA();  						}  						// A conflicting region is found. Strip off common lines in  						// in the beginning and the end of the conflicting region  						// Determine the minimum length of the conflicting areas in OURS  						// and THEIRS. Also determine how much bigger the conflicting  						// area in THEIRS is compared to OURS. All that is needed to  						// limit the search for common areas at the beginning or end  						// (the common areas cannot be bigger then the smaller  						// conflicting area. The delta is needed to know whether the  						// complete conflicting area is common in OURS and THEIRS.  						int minBSize = oursEndB - oursBeginB;  						int BSizeDelta = minBSize - (theirsEndB - theirsBeginB);  						if (BSizeDelta > 0)  						{  							minBSize -= BSizeDelta;  						}  						int commonPrefix = 0;  						while (commonPrefix < minBSize && cmp.Equals(ours' oursBeginB + commonPrefix' theirs  							' theirsBeginB + commonPrefix))  						{  							commonPrefix++;  						}  						minBSize -= commonPrefix;  						int commonSuffix = 0;  						while (commonSuffix < minBSize && cmp.Equals(ours' oursEndB - commonSuffix - 1' theirs  							' theirsEndB - commonSuffix - 1))  						{  							commonSuffix++;  						}  						minBSize -= commonSuffix;  						// Add the common lines at start of conflict  						if (commonPrefix > 0)  						{  							result.Add(1' oursBeginB' oursBeginB + commonPrefix' MergeChunk.ConflictState.NO_CONFLICT  								);  						}  						// Add the conflict (Only if there is a conflict left to report)  						if (minBSize > 0 || BSizeDelta != 0)  						{  							result.Add(1' oursBeginB + commonPrefix' oursEndB - commonSuffix' MergeChunk.ConflictState  								.FIRST_CONFLICTING_RANGE);  							result.Add(2' theirsBeginB + commonPrefix' theirsEndB - commonSuffix' MergeChunk.ConflictState  								.NEXT_CONFLICTING_RANGE);  						}  						// Add the common lines at end of conflict  						if (commonSuffix > 0)  						{  							result.Add(1' oursEndB - commonSuffix' oursEndB' MergeChunk.ConflictState.NO_CONFLICT  								);  						}  						current = Math.Max(oursEdit.GetEndA()' theirsEdit.GetEndA());  						oursEdit = nextOursEdit;  						theirsEdit = nextTheirsEdit;  					}  				}  			}
Magic Number,NGit.Merge,MergeFormatter,C:\repos\mono_ngit\NGit\NGit.Merge\MergeFormatter.cs,FormatMerge,The following statement contains a magic number: bool threeWayMerge = (res.GetSequences().Count == 3);
Magic Number,NGit.Merge,MergeFormatter,C:\repos\mono_ngit\NGit\NGit.Merge\MergeFormatter.cs,FormatMerge,The following statement contains a magic number: IList<string> names = new AList<string>(3);
Magic Number,NGit.Merge,ResolveMerger,C:\repos\mono_ngit\NGit\NGit.Merge\ResolveMerger.cs,UpdateIndex,The following statement contains a magic number: if (result.ContainsConflicts())  			{  				// a conflict occurred' the file will contain conflict markers  				// the index will be populated with the three stages and only the  				// workdir (if used) contains the halfways merged content  				Add(tw.RawPath' @base' DirCacheEntry.STAGE_1' 0' 0);  				Add(tw.RawPath' ours' DirCacheEntry.STAGE_2' 0' 0);  				Add(tw.RawPath' theirs' DirCacheEntry.STAGE_3' 0' 0);  				mergeResults.Put(tw.PathString' result.Upcast ());  			}  			else  			{  				// no conflict occurred' the file will contain fully merged content.  				// the index will be populated with the new merged version  				DirCacheEntry dce = new DirCacheEntry(tw.PathString);  				int newMode = MergeFileModes(tw.GetRawMode(0)' tw.GetRawMode(1)' tw.GetRawMode(2)  					);  				// set the mode for the new content. Fall back to REGULAR_FILE if  				// you can't merge modes of OURS and THEIRS  				dce.FileMode = (newMode == FileMode.MISSING.GetBits()) ? FileMode.REGULAR_FILE :   					FileMode.FromBits(newMode);  				dce.LastModified = of.LastModified();  				dce.SetLength((int)of.Length());  				InputStream @is = new FileInputStream(of);  				try  				{  					dce.SetObjectId(GetObjectInserter().Insert(Constants.OBJ_BLOB' of.Length()' @is));  				}  				finally  				{  					@is.Close();  					if (inCore)  					{  						FileUtils.Delete(of);  					}  				}  				builder.Add(dce);  			}
Magic Number,NGit.Merge,ThreeWayMerger,C:\repos\mono_ngit\NGit\NGit.Merge\ThreeWayMerger.cs,Merge,The following statement contains a magic number: if (tips.Length != 2)  			{  				return false;  			}
Magic Number,NGit.Patch,FileHeader,C:\repos\mono_ngit\NGit\NGit.Patch\FileHeader.cs,ParseGitFileName,The following statement contains a magic number: while (ptr < eol)  			{  				int sp = RawParseUtils.NextLF(buf' ptr' ' ');  				if (sp >= eol)  				{  					// We can't split the header' it isn't valid.  					// This may be OK if this is a rename patch.  					//  					return eol;  				}  				int bStart = RawParseUtils.NextLF(buf' sp' '/');  				if (bStart >= eol)  				{  					return eol;  				}  				// If buffer[aStart..sp - 1] = buffer[bStart..eol - 1]  				// we have a valid split.  				//  				if (Eq(aStart' sp - 1' bStart' eol - 1))  				{  					if (buf[bol] == '"')  					{  						// We're a double quoted name. The region better end  						// in a double quote too' and we need to decode the  						// characters before reading the name.  						//  						if (buf[sp - 2] != '"')  						{  							return eol;  						}  						oldPath = QuotedString.GIT_PATH.Dequote(buf' bol' sp - 1);  						oldPath = P1(oldPath);  					}  					else  					{  						oldPath = RawParseUtils.Decode(Constants.CHARSET' buf' aStart' sp - 1);  					}  					newPath = oldPath;  					return eol;  				}  				// This split wasn't correct. Move past the space and try  				// another split as the space must be part of the file name.  				//  				ptr = sp;  			}
Magic Number,NGit.Patch,FileHeader,C:\repos\mono_ngit\NGit\NGit.Patch\FileHeader.cs,ParseFileMode,The following statement contains a magic number: while (ptr < end - 1)  			{  				tmp <<= 3;  				tmp += buf[ptr++] - '0';  			}
Magic Number,NGit.Patch,FileHeader,C:\repos\mono_ngit\NGit\NGit.Patch\FileHeader.cs,IsHunkHdr,The following statement contains a magic number: if (ptr - start < 2)  			{  				return 0;  			}
Magic Number,NGit.Patch,FileHeader,C:\repos\mono_ngit\NGit\NGit.Patch\FileHeader.cs,IsHunkHdr,The following statement contains a magic number: return (ptr - 3) - start;
Magic Number,NGit.Patch,Patch,C:\repos\mono_ngit\NGit\NGit.Patch\Patch.cs,ParseFile,The following statement contains a magic number: while (c < end)  			{  				if (FileHeader.IsHunkHdr(buf' c' end) >= 1)  				{  					// If we find a disconnected hunk header we might  					// have missed a file header previously. The hunk  					// isn't valid without knowing where it comes from.  					//  					Error(buf' c' JGitText.Get().hunkDisconnectedFromFile);  					c = RawParseUtils.NextLF(buf' c);  					continue;  				}  				// Valid git style patch?  				//  				if (RawParseUtils.Match(buf' c' DIFF_GIT) >= 0)  				{  					return ParseDiffGit(buf' c' end);  				}  				if (RawParseUtils.Match(buf' c' DIFF_CC) >= 0)  				{  					return ParseDiffCombined(DIFF_CC' buf' c' end);  				}  				if (RawParseUtils.Match(buf' c' DIFF_COMBINED) >= 0)  				{  					return ParseDiffCombined(DIFF_COMBINED' buf' c' end);  				}  				// Junk between files? Leading junk? Traditional  				// (non-git generated) patch?  				//  				int n = RawParseUtils.NextLF(buf' c);  				if (n >= end)  				{  					// Patches cannot be only one line long. This must be  					// trailing junk that we should ignore.  					//  					return end;  				}  				if (n - c < 6)  				{  					// A valid header must be at least 6 bytes on the  					// first line' e.g. "--- a/b\n".  					//  					c = n;  					continue;  				}  				if (RawParseUtils.Match(buf' c' FileHeader.OLD_NAME) >= 0 && RawParseUtils.Match(  					buf' n' FileHeader.NEW_NAME) >= 0)  				{  					// Probably a traditional patch. Ensure we have at least  					// a "@@ -0'0" smelling line next. We only check the "@@ -".  					//  					int f = RawParseUtils.NextLF(buf' n);  					if (f >= end)  					{  						return end;  					}  					if (FileHeader.IsHunkHdr(buf' f' end) == 1)  					{  						return ParseTraditionalPatch(buf' c' end);  					}  				}  				c = n;  			}
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++)  			{  				PlotCommit<TLane> p;  				TLane pLane;  				TColor pColor;  				int cx;  				p = (PlotCommit<TLane>)commit.GetParent(i);  				pLane = p.GetLane();  				if (pLane == null)  				{  					continue;  				}  				pColor = LaneColor(pLane);  				cx = LaneC(pLane);  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH)  				{  					if (myLaneX < cx)  					{  						int ix = cx - LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  					else  					{  						int ix = cx + LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				}  				else  				{  					DrawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++)  			{  				PlotCommit<TLane> p;  				TLane pLane;  				TColor pColor;  				int cx;  				p = (PlotCommit<TLane>)commit.GetParent(i);  				pLane = p.GetLane();  				if (pLane == null)  				{  					continue;  				}  				pColor = LaneColor(pLane);  				cx = LaneC(pLane);  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH)  				{  					if (myLaneX < cx)  					{  						int ix = cx - LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  					else  					{  						int ix = cx + LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				}  				else  				{  					DrawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++)  			{  				PlotCommit<TLane> p;  				TLane pLane;  				TColor pColor;  				int cx;  				p = (PlotCommit<TLane>)commit.GetParent(i);  				pLane = p.GetLane();  				if (pLane == null)  				{  					continue;  				}  				pColor = LaneColor(pLane);  				cx = LaneC(pLane);  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH)  				{  					if (myLaneX < cx)  					{  						int ix = cx - LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  					else  					{  						int ix = cx + LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				}  				else  				{  					DrawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++)  			{  				PlotCommit<TLane> p;  				TLane pLane;  				TColor pColor;  				int cx;  				p = (PlotCommit<TLane>)commit.GetParent(i);  				pLane = p.GetLane();  				if (pLane == null)  				{  					continue;  				}  				pColor = LaneColor(pLane);  				cx = LaneC(pLane);  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH)  				{  					if (myLaneX < cx)  					{  						int ix = cx - LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  					else  					{  						int ix = cx + LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				}  				else  				{  					DrawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++)  			{  				PlotCommit<TLane> p;  				TLane pLane;  				TColor pColor;  				int cx;  				p = (PlotCommit<TLane>)commit.GetParent(i);  				pLane = p.GetLane();  				if (pLane == null)  				{  					continue;  				}  				pColor = LaneColor(pLane);  				cx = LaneC(pLane);  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH)  				{  					if (myLaneX < cx)  					{  						int ix = cx - LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  					else  					{  						int ix = cx + LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				}  				else  				{  					DrawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++)  			{  				PlotCommit<TLane> p;  				TLane pLane;  				TColor pColor;  				int cx;  				p = (PlotCommit<TLane>)commit.GetParent(i);  				pLane = p.GetLane();  				if (pLane == null)  				{  					continue;  				}  				pColor = LaneColor(pLane);  				cx = LaneC(pLane);  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH)  				{  					if (myLaneX < cx)  					{  						int ix = cx - LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  					else  					{  						int ix = cx + LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				}  				else  				{  					DrawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++)  			{  				PlotCommit<TLane> p;  				TLane pLane;  				TColor pColor;  				int cx;  				p = (PlotCommit<TLane>)commit.GetParent(i);  				pLane = p.GetLane();  				if (pLane == null)  				{  					continue;  				}  				pColor = LaneColor(pLane);  				cx = LaneC(pLane);  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH)  				{  					if (myLaneX < cx)  					{  						int ix = cx - LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  					else  					{  						int ix = cx + LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				}  				else  				{  					DrawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++)  			{  				PlotCommit<TLane> p;  				TLane pLane;  				TColor pColor;  				int cx;  				p = (PlotCommit<TLane>)commit.GetParent(i);  				pLane = p.GetLane();  				if (pLane == null)  				{  					continue;  				}  				pColor = LaneColor(pLane);  				cx = LaneC(pLane);  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH)  				{  					if (myLaneX < cx)  					{  						int ix = cx - LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  					else  					{  						int ix = cx + LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				}  				else  				{  					DrawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++)  			{  				PlotCommit<TLane> p;  				TLane pLane;  				TColor pColor;  				int cx;  				p = (PlotCommit<TLane>)commit.GetParent(i);  				pLane = p.GetLane();  				if (pLane == null)  				{  					continue;  				}  				pColor = LaneColor(pLane);  				cx = LaneC(pLane);  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH)  				{  					if (myLaneX < cx)  					{  						int ix = cx - LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  					else  					{  						int ix = cx + LANE_WIDTH / 2;  						DrawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						DrawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				}  				else  				{  					DrawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: int dotX = myLaneX - dotSize / 2 - 1;
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: int dotY = (h - dotSize) / 2;
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: int textx = Math.Max(maxCenter + LANE_WIDTH / 2' dotX + dotSize) + 8;
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: int textx = Math.Max(maxCenter + LANE_WIDTH / 2' dotX + dotSize) + 8;
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: for (int i_1 = 0; i_1 < n; ++i_1)  			{  				textx += DrawLabel(textx + dotSize' h / 2' commit.refs[i_1]);  			}
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: DrawText(msg' textx + dotSize + n * 2' h / 2);
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,PaintCommit,The following statement contains a magic number: DrawText(msg' textx + dotSize + n * 2' h / 2);
Magic Number,NGit.Revplot,AbstractPlotRenderer<TLane;TColor>,C:\repos\mono_ngit\NGit\NGit.Revplot\AbstractPlotRenderer.cs,LaneC,The following statement contains a magic number: return LaneX(myLane) + LANE_WIDTH / 2;
Magic Number,NGit.Revplot,PlotCommitList<L>,C:\repos\mono_ngit\NGit\NGit.Revplot\PlotCommitList.cs,Enter,The following statement contains a magic number: if (nChildren == 1 && currCommit.children[0].ParentCount < 2)  			{  				// Only one child' child has only us as their parent.  				// Stay in the same lane as the child.  				//  				PlotCommit c = currCommit.children[0];  				if (c.lane == null)  				{  					// Hmmph. This child must be the first along this lane.  					//  					c.lane = NextFreeLane();  					activeLanes.AddItem(c.lane);  				}  				for (int r = index - 1; r >= 0; r--)  				{  					PlotCommit rObj = this[r];  					if (rObj == c)  					{  						break;  					}  					rObj.AddPassingLane(c.lane);  				}  				currCommit.lane = c.lane;  				HandleBlockedLanes(index' currCommit' nChildren);  			}  			else  			{  				// More than one child' or our child is a merge.  				// Use a different lane.  				//  				// Process all our children. Especially important when there is more  				// than one child (e.g. a commit is processed where other branches  				// fork out). For each child the following is done  				// 1. If no lane was assigned to the child a new lane is created and  				// assigned  				// 2. The lane of the child is closed. If this frees a position'  				// this position will be added freePositions list.  				// If we have multiple children which where previously not on a lane  				// each such child will get his own new lane but all those new lanes  				// will be on the same position. We have to take care that not  				// multiple newly created (in step 1) lanes occupy that position on  				// which the  				// parent's lane will be on. Therefore we delay closing the lane  				// with the parents position until all children are processed.  				// The lane on that position the current commit will be on  				PlotLane reservedLane = null;  				for (int i = 0; i < nChildren; i++)  				{  					PlotCommit c = currCommit.children[i];  					// don't forget to position all of your children if they are  					// not already positioned.  					if (c.lane == null)  					{  						c.lane = NextFreeLane();  						activeLanes.AddItem(c.lane);  						if (reservedLane != null)  						{  							CloseLane(c.lane);  						}  						else  						{  							reservedLane = c.lane;  						}  					}  					else  					{  						if (reservedLane == null && activeLanes.Contains(c.lane))  						{  							reservedLane = c.lane;  						}  						else  						{  							CloseLane(c.lane);  						}  					}  				}  				// finally all children are processed. We can close the lane on that  				// position our current commit will be on.  				if (reservedLane != null)  				{  					CloseLane(reservedLane);  				}  				currCommit.lane = NextFreeLane();  				activeLanes.AddItem(currCommit.lane);  				HandleBlockedLanes(index' currCommit' nChildren);  			}
Magic Number,NGit.Revplot,PlotRefComparator,C:\repos\mono_ngit\NGit\NGit.Revplot\PlotWalk.cs,Kind,The following statement contains a magic number: if (r.GetName().StartsWith(Constants.R_REMOTES))  				{  					return 2;  				}
Magic Number,NGit.Revplot,PlotRefComparator,C:\repos\mono_ngit\NGit\NGit.Revplot\PlotWalk.cs,Kind,The following statement contains a magic number: return 3;
Magic Number,NGit.Revwalk,Block,C:\repos\mono_ngit\NGit\NGit.Revwalk\BlockObjQueue.cs,ResetToMiddle,The following statement contains a magic number: headIndex = tailIndex = BLOCK_SIZE / 2;
Magic Number,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ObjectWalk,The following statement contains a magic number: pathBuf = new byte[256];
Magic Number,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ParseMode,The following statement contains a magic number: for (; ; )  			{  				byte c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  			}
Magic Number,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ParseMode,The following statement contains a magic number: for (; ; )  			{  				byte c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  			}
Magic Number,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ParseMode,The following statement contains a magic number: for (; ; )  			{  				byte c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  			}
Magic Number,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ParseMode,The following statement contains a magic number: for (; ; )  			{  				byte c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  			}
Magic Number,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ParseMode,The following statement contains a magic number: for (; ; )  			{  				byte c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  			}
Magic Number,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ParseMode,The following statement contains a magic number: for (; ; )  			{  				byte c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  			}
Magic Number,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ParseMode,The following statement contains a magic number: for (; ; )  			{  				byte c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  				c = buf[++startPtr];  				if (' ' == c)  				{  					break;  				}  				mode <<= 3;  				mode += c - '0';  			}
Magic Number,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,GetPathHashCode,The following statement contains a magic number: if (16 <= (nameEnd - tv.namePtr))  			{  				buf = tv.buf;  				ptr = nameEnd - 16;  			}  			else  			{  				nameEnd = pathLen;  				if (nameEnd == 0)  				{  					nameEnd = UpdatePathBuf(currVisit);  					pathLen = nameEnd;  				}  				buf = pathBuf;  				ptr = Math.Max(0' nameEnd - 16);  			}
Magic Number,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,GetPathHashCode,The following statement contains a magic number: if (16 <= (nameEnd - tv.namePtr))  			{  				buf = tv.buf;  				ptr = nameEnd - 16;  			}  			else  			{  				nameEnd = pathLen;  				if (nameEnd == 0)  				{  					nameEnd = UpdatePathBuf(currVisit);  					pathLen = nameEnd;  				}  				buf = pathBuf;  				ptr = Math.Max(0' nameEnd - 16);  			}
Magic Number,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,GetPathHashCode,The following statement contains a magic number: if (16 <= (nameEnd - tv.namePtr))  			{  				buf = tv.buf;  				ptr = nameEnd - 16;  			}  			else  			{  				nameEnd = pathLen;  				if (nameEnd == 0)  				{  					nameEnd = UpdatePathBuf(currVisit);  					pathLen = nameEnd;  				}  				buf = pathBuf;  				ptr = Math.Max(0' nameEnd - 16);  			}
Magic Number,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,GetPathHashCode,The following statement contains a magic number: for (; ptr < nameEnd; ptr++)  			{  				byte c = buf[ptr];  				if (c != ' ')  				{  					hash = ((int)(((uint)hash) >> 2)) + (c << 24);  				}  			}
Magic Number,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,GetPathHashCode,The following statement contains a magic number: for (; ptr < nameEnd; ptr++)  			{  				byte c = buf[ptr];  				if (c != ' ')  				{  					hash = ((int)(((uint)hash) >> 2)) + (c << 24);  				}  			}
Magic Number,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,MarkTreeUninteresting,The following statement contains a magic number: for (int ptr = 0; ptr < raw.Length; )  			{  				byte c = raw[ptr];  				int mode = c - '0';  				for (; ; )  				{  					c = raw[++ptr];  					if (' ' == c)  					{  						break;  					}  					mode <<= 3;  					mode += c - '0';  				}  				while (raw[++ptr] != 0)  				{  				}  				// Skip entry name.  				ptr++;  				switch ((int)(((uint)mode) >> TYPE_SHIFT))  				{  					case TYPE_FILE:  					case TYPE_SYMLINK:  					{  						// Skip NUL after entry name.  						idBuffer.FromRaw(raw' ptr);  						LookupBlob(idBuffer).flags |= UNINTERESTING;  						break;  					}    					case TYPE_TREE:  					{  						idBuffer.FromRaw(raw' ptr);  						MarkTreeUninteresting(LookupTree(idBuffer));  						break;  					}    					case TYPE_GITLINK:  					{  						break;  					}    					default:  					{  						idBuffer.FromRaw(raw' ptr);  						throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().corruptObjectInvalidMode3  							' string.Format("%o"' Sharpen.Extensions.ValueOf(mode))' idBuffer.Name' string.Empty  							' tree));  					}  				}  				ptr += ID_SZ;  			}
Magic Number,NGit.Revwalk,RevCommit,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommit.cs,ParseCanonical,The following statement contains a magic number: idBuffer.FromString(raw' 5);
Magic Number,NGit.Revwalk,RevCommit,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommit.cs,ParseCanonical,The following statement contains a magic number: int ptr = 46;
Magic Number,NGit.Revwalk,RevCommit,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommit.cs,ParseCanonical,The following statement contains a magic number: if (parents == null)  			{  				NGit.Revwalk.RevCommit[] pList = new NGit.Revwalk.RevCommit[1];  				int nParents = 0;  				for (; ; )  				{  					if (raw[ptr] != 'p')  					{  						break;  					}  					idBuffer.FromString(raw' ptr + 7);  					NGit.Revwalk.RevCommit p = walk.LookupCommit(idBuffer);  					if (nParents == 0)  					{  						pList[nParents++] = p;  					}  					else  					{  						if (nParents == 1)  						{  							pList = new NGit.Revwalk.RevCommit[] { pList[0]' p };  							nParents = 2;  						}  						else  						{  							if (pList.Length <= nParents)  							{  								NGit.Revwalk.RevCommit[] old = pList;  								pList = new NGit.Revwalk.RevCommit[pList.Length + 32];  								System.Array.Copy(old' 0' pList' 0' nParents);  							}  							pList[nParents++] = p;  						}  					}  					ptr += 48;  				}  				if (nParents != pList.Length)  				{  					NGit.Revwalk.RevCommit[] old = pList;  					pList = new NGit.Revwalk.RevCommit[nParents];  					System.Array.Copy(old' 0' pList' 0' nParents);  				}  				parents = pList;  			}
Magic Number,NGit.Revwalk,RevCommit,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommit.cs,ParseCanonical,The following statement contains a magic number: if (parents == null)  			{  				NGit.Revwalk.RevCommit[] pList = new NGit.Revwalk.RevCommit[1];  				int nParents = 0;  				for (; ; )  				{  					if (raw[ptr] != 'p')  					{  						break;  					}  					idBuffer.FromString(raw' ptr + 7);  					NGit.Revwalk.RevCommit p = walk.LookupCommit(idBuffer);  					if (nParents == 0)  					{  						pList[nParents++] = p;  					}  					else  					{  						if (nParents == 1)  						{  							pList = new NGit.Revwalk.RevCommit[] { pList[0]' p };  							nParents = 2;  						}  						else  						{  							if (pList.Length <= nParents)  							{  								NGit.Revwalk.RevCommit[] old = pList;  								pList = new NGit.Revwalk.RevCommit[pList.Length + 32];  								System.Array.Copy(old' 0' pList' 0' nParents);  							}  							pList[nParents++] = p;  						}  					}  					ptr += 48;  				}  				if (nParents != pList.Length)  				{  					NGit.Revwalk.RevCommit[] old = pList;  					pList = new NGit.Revwalk.RevCommit[nParents];  					System.Array.Copy(old' 0' pList' 0' nParents);  				}  				parents = pList;  			}
Magic Number,NGit.Revwalk,RevCommit,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommit.cs,ParseCanonical,The following statement contains a magic number: if (parents == null)  			{  				NGit.Revwalk.RevCommit[] pList = new NGit.Revwalk.RevCommit[1];  				int nParents = 0;  				for (; ; )  				{  					if (raw[ptr] != 'p')  					{  						break;  					}  					idBuffer.FromString(raw' ptr + 7);  					NGit.Revwalk.RevCommit p = walk.LookupCommit(idBuffer);  					if (nParents == 0)  					{  						pList[nParents++] = p;  					}  					else  					{  						if (nParents == 1)  						{  							pList = new NGit.Revwalk.RevCommit[] { pList[0]' p };  							nParents = 2;  						}  						else  						{  							if (pList.Length <= nParents)  							{  								NGit.Revwalk.RevCommit[] old = pList;  								pList = new NGit.Revwalk.RevCommit[pList.Length + 32];  								System.Array.Copy(old' 0' pList' 0' nParents);  							}  							pList[nParents++] = p;  						}  					}  					ptr += 48;  				}  				if (nParents != pList.Length)  				{  					NGit.Revwalk.RevCommit[] old = pList;  					pList = new NGit.Revwalk.RevCommit[nParents];  					System.Array.Copy(old' 0' pList' 0' nParents);  				}  				parents = pList;  			}
Magic Number,NGit.Revwalk,RevCommit,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommit.cs,ParseCanonical,The following statement contains a magic number: if (parents == null)  			{  				NGit.Revwalk.RevCommit[] pList = new NGit.Revwalk.RevCommit[1];  				int nParents = 0;  				for (; ; )  				{  					if (raw[ptr] != 'p')  					{  						break;  					}  					idBuffer.FromString(raw' ptr + 7);  					NGit.Revwalk.RevCommit p = walk.LookupCommit(idBuffer);  					if (nParents == 0)  					{  						pList[nParents++] = p;  					}  					else  					{  						if (nParents == 1)  						{  							pList = new NGit.Revwalk.RevCommit[] { pList[0]' p };  							nParents = 2;  						}  						else  						{  							if (pList.Length <= nParents)  							{  								NGit.Revwalk.RevCommit[] old = pList;  								pList = new NGit.Revwalk.RevCommit[pList.Length + 32];  								System.Array.Copy(old' 0' pList' 0' nParents);  							}  							pList[nParents++] = p;  						}  					}  					ptr += 48;  				}  				if (nParents != pList.Length)  				{  					NGit.Revwalk.RevCommit[] old = pList;  					pList = new NGit.Revwalk.RevCommit[nParents];  					System.Array.Copy(old' 0' pList' 0' nParents);  				}  				parents = pList;  			}
Magic Number,NGit.Revwalk,RevCommit,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommit.cs,GetFooterLines,The following statement contains a magic number: AList<FooterLine> r = new AList<FooterLine>(4);
Magic Number,NGit.Revwalk,RevCommit,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevCommit.cs,GetFooterLines,The following statement contains a magic number: for (; ; )  			{  				ptr = RawParseUtils.PrevLF(raw' ptr);  				if (ptr <= msgB)  				{  					break;  				}  				// Don't parse commit headers as footer lines.  				int keyStart = ptr + 2;  				if (raw[keyStart] == '\n')  				{  					break;  				}  				// Stop at first paragraph break' no footers above it.  				int keyEnd = RawParseUtils.EndOfFooterLineKey(raw' keyStart);  				if (keyEnd < 0)  				{  					continue;  				}  				// Not a well formed footer line' skip it.  				// Skip over the ': *' at the end of the key before the value.  				//  				int valStart = keyEnd + 1;  				while (valStart < raw.Length && raw[valStart] == ' ')  				{  					valStart++;  				}  				// Value ends at the LF' and does not include it.  				//  				int valEnd = RawParseUtils.NextLF(raw' valStart);  				if (raw[valEnd - 1] == '\n')  				{  					valEnd--;  				}  				r.AddItem(new FooterLine(raw' enc' keyStart' keyEnd' valStart' valEnd));  			}
Magic Number,NGit.Revwalk,RevObjectList<E>,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevObjectList.cs,Get,The following statement contains a magic number: if (index >> s.shift >= 1024)  			{  				return null;  			}
Magic Number,NGit.Revwalk,RevTag,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevTag.cs,ParseCanonical,The following statement contains a magic number: pos.value = 53;
Magic Number,NGit.Revwalk,RevTag,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevTag.cs,ParseCanonical,The following statement contains a magic number: walk.idBuffer.FromString(rawTag' 7);
Magic Number,NGit.Revwalk,RevTag,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevTag.cs,ParseCanonical,The following statement contains a magic number: int p = pos.value += 4;
Magic Number,NGit.Revwalk,RevWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevWalk.cs,GetCachedBytes,The following statement contains a magic number: try  			{  				return ldr.GetCachedBytes(5 * MB);  			}  			catch (LargeObjectException tooBig)  			{  				tooBig.SetObjectId(obj);  				throw;  			}
Magic Number,NGit.Revwalk,RevWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevWalk.cs,AllocFlag,The following statement contains a magic number: if (freeFlags == 0)  			{  				throw new ArgumentException(MessageFormat.Format(JGitText.Get().flagsAlreadyCreated  					' Sharpen.Extensions.ValueOf(32 - RESERVED_FLAGS)));  			}
Magic Number,NGit.Revwalk,RevWalkUtils,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevWalkUtils.cs,FindBranchesReachableFrom,The following statement contains a magic number: int SKEW = 24 * 3600;
Magic Number,NGit.Revwalk,RevWalkUtils,C:\repos\mono_ngit\NGit\NGit.Revwalk\RevWalkUtils.cs,FindBranchesReachableFrom,The following statement contains a magic number: int SKEW = 24 * 3600;
Magic Number,NGit.Revwalk.Filter,AndRevFilter,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\AndRevFilter.cs,Create,The following statement contains a magic number: if (list.Length == 2)  			{  				return Create(list[0]' list[1]);  			}
Magic Number,NGit.Revwalk.Filter,AndRevFilter,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\AndRevFilter.cs,Create,The following statement contains a magic number: if (list.Length < 2)  			{  				throw new ArgumentException(JGitText.Get().atLeastTwoFiltersNeeded);  			}
Magic Number,NGit.Revwalk.Filter,AndRevFilter,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\AndRevFilter.cs,Create,The following statement contains a magic number: if (list.Count < 2)  			{  				throw new ArgumentException(JGitText.Get().atLeastTwoFiltersNeeded);  			}
Magic Number,NGit.Revwalk.Filter,AndRevFilter,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\AndRevFilter.cs,Create,The following statement contains a magic number: if (subfilters.Length == 2)  			{  				return Create(subfilters[0]' subfilters[1]);  			}
Magic Number,NGit.Revwalk.Filter,CommitTimeRevFilter,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\CommitTimeRevFilter.cs,CommitTimeRevFilter,The following statement contains a magic number: when = (int)(ts / 1000);
Magic Number,NGit.Revwalk.Filter,CommitTimeRevFilterBetween,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\CommitTimeRevFilter.cs,CommitTimeRevFilterBetween,The following statement contains a magic number: this.until = (int)(until / 1000);
Magic Number,NGit.Revwalk.Filter,OrRevFilter,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\OrRevFilter.cs,Create,The following statement contains a magic number: if (list.Length == 2)  			{  				return Create(list[0]' list[1]);  			}
Magic Number,NGit.Revwalk.Filter,OrRevFilter,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\OrRevFilter.cs,Create,The following statement contains a magic number: if (list.Length < 2)  			{  				throw new ArgumentException(JGitText.Get().atLeastTwoFiltersNeeded);  			}
Magic Number,NGit.Revwalk.Filter,OrRevFilter,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\OrRevFilter.cs,Create,The following statement contains a magic number: if (list.Count < 2)  			{  				throw new ArgumentException(JGitText.Get().atLeastTwoFiltersNeeded);  			}
Magic Number,NGit.Revwalk.Filter,OrRevFilter,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\OrRevFilter.cs,Create,The following statement contains a magic number: if (subfilters.Length == 2)  			{  				return Create(subfilters[0]' subfilters[1]);  			}
Magic Number,NGit.Revwalk.Filter,NoMergesFilter,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\RevFilter.cs,Include,The following statement contains a magic number: return c.ParentCount < 2;
Magic Number,NGit.Storage.File,ByteBufferWindow,C:\repos\mono_ngit\NGit\NGit.Storage.File\ByteBufferWindow.cs,SetInput,The following statement contains a magic number: byte[] tmp = new byte[Math.Min(s.Remaining()' 512)];
Magic Number,NGit.Storage.File,CachedObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\CachedObjectDirectory.cs,CachedObjectDirectory,The following statement contains a magic number: foreach (string d in fanout)  			{  				if (d.Length != 2)  				{  					continue;  				}  				string[] entries = new FilePath(objects' d).List();  				if (entries == null)  				{  					continue;  				}  				foreach (string e in entries)  				{  					if (e.Length != Constants.OBJECT_ID_STRING_LENGTH - 2)  					{  						continue;  					}  					try  					{  						ObjectId id = ObjectId.FromString(d + e);  						unpackedObjects.Add(new CachedObjectDirectory.UnpackedObjectId(id));  					}  					catch (ArgumentException)  					{  					}  				}  			}
Magic Number,NGit.Storage.File,CachedObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\CachedObjectDirectory.cs,CachedObjectDirectory,The following statement contains a magic number: foreach (string d in fanout)  			{  				if (d.Length != 2)  				{  					continue;  				}  				string[] entries = new FilePath(objects' d).List();  				if (entries == null)  				{  					continue;  				}  				foreach (string e in entries)  				{  					if (e.Length != Constants.OBJECT_ID_STRING_LENGTH - 2)  					{  						continue;  					}  					try  					{  						ObjectId id = ObjectId.FromString(d + e);  						unpackedObjects.Add(new CachedObjectDirectory.UnpackedObjectId(id));  					}  					catch (ArgumentException)  					{  					}  				}  			}
Magic Number,NGit.Storage.File,FileBasedConfig,C:\repos\mono_ngit\NGit\NGit.Storage.File\FileBasedConfig.cs,Load,The following statement contains a magic number: try  			{  				byte[] @in = IOUtil.ReadFully(GetFile());  				ObjectId newHash = Hash(@in);  				if (hash.Equals(newHash))  				{  					if (oldSnapshot.Equals(newSnapshot))  					{  						oldSnapshot.SetClean(newSnapshot);  					}  					else  					{  						snapshot = newSnapshot;  					}  				}  				else  				{  					string decoded;  					if (@in.Length >= 3 && @in[0] == unchecked((byte)unchecked((int)(0xEF))) && @in[1  						] == unchecked((byte)unchecked((int)(0xBB))) && @in[2] == unchecked((byte)unchecked(  						(int)(0xBF))))  					{  						decoded = RawParseUtils.Decode(RawParseUtils.UTF8_CHARSET' @in' 3' @in.Length);  						utf8Bom = true;  					}  					else  					{  						decoded = RawParseUtils.Decode(@in);  					}  					FromText(decoded);  					snapshot = newSnapshot;  					hash = newHash;  				}  			}  			catch (FileNotFoundException)  			{  				Clear();  				snapshot = newSnapshot;  			}  			catch (IOException e)  			{  				IOException e2 = new IOException(MessageFormat.Format(JGitText.Get().cannotReadFile  					' GetFile()));  				Sharpen.Extensions.InitCause(e2' e);  				throw e2;  			}  			catch (ConfigInvalidException e)  			{  				throw new ConfigInvalidException(MessageFormat.Format(JGitText.Get().cannotReadFile  					' GetFile())' e);  			}
Magic Number,NGit.Storage.File,FileBasedConfig,C:\repos\mono_ngit\NGit\NGit.Storage.File\FileBasedConfig.cs,Load,The following statement contains a magic number: try  			{  				byte[] @in = IOUtil.ReadFully(GetFile());  				ObjectId newHash = Hash(@in);  				if (hash.Equals(newHash))  				{  					if (oldSnapshot.Equals(newSnapshot))  					{  						oldSnapshot.SetClean(newSnapshot);  					}  					else  					{  						snapshot = newSnapshot;  					}  				}  				else  				{  					string decoded;  					if (@in.Length >= 3 && @in[0] == unchecked((byte)unchecked((int)(0xEF))) && @in[1  						] == unchecked((byte)unchecked((int)(0xBB))) && @in[2] == unchecked((byte)unchecked(  						(int)(0xBF))))  					{  						decoded = RawParseUtils.Decode(RawParseUtils.UTF8_CHARSET' @in' 3' @in.Length);  						utf8Bom = true;  					}  					else  					{  						decoded = RawParseUtils.Decode(@in);  					}  					FromText(decoded);  					snapshot = newSnapshot;  					hash = newHash;  				}  			}  			catch (FileNotFoundException)  			{  				Clear();  				snapshot = newSnapshot;  			}  			catch (IOException e)  			{  				IOException e2 = new IOException(MessageFormat.Format(JGitText.Get().cannotReadFile  					' GetFile()));  				Sharpen.Extensions.InitCause(e2' e);  				throw e2;  			}  			catch (ConfigInvalidException e)  			{  				throw new ConfigInvalidException(MessageFormat.Format(JGitText.Get().cannotReadFile  					' GetFile())' e);  			}
Magic Number,NGit.Storage.File,FileBasedConfig,C:\repos\mono_ngit\NGit\NGit.Storage.File\FileBasedConfig.cs,Load,The following statement contains a magic number: try  			{  				byte[] @in = IOUtil.ReadFully(GetFile());  				ObjectId newHash = Hash(@in);  				if (hash.Equals(newHash))  				{  					if (oldSnapshot.Equals(newSnapshot))  					{  						oldSnapshot.SetClean(newSnapshot);  					}  					else  					{  						snapshot = newSnapshot;  					}  				}  				else  				{  					string decoded;  					if (@in.Length >= 3 && @in[0] == unchecked((byte)unchecked((int)(0xEF))) && @in[1  						] == unchecked((byte)unchecked((int)(0xBB))) && @in[2] == unchecked((byte)unchecked(  						(int)(0xBF))))  					{  						decoded = RawParseUtils.Decode(RawParseUtils.UTF8_CHARSET' @in' 3' @in.Length);  						utf8Bom = true;  					}  					else  					{  						decoded = RawParseUtils.Decode(@in);  					}  					FromText(decoded);  					snapshot = newSnapshot;  					hash = newHash;  				}  			}  			catch (FileNotFoundException)  			{  				Clear();  				snapshot = newSnapshot;  			}  			catch (IOException e)  			{  				IOException e2 = new IOException(MessageFormat.Format(JGitText.Get().cannotReadFile  					' GetFile()));  				Sharpen.Extensions.InitCause(e2' e);  				throw e2;  			}  			catch (ConfigInvalidException e)  			{  				throw new ConfigInvalidException(MessageFormat.Format(JGitText.Get().cannotReadFile  					' GetFile())' e);  			}
Magic Number,NGit.Storage.File,FileObjectDatabase,C:\repos\mono_ngit\NGit\NGit.Storage.File\FileObjectDatabase.cs,FileFor,The following statement contains a magic number: string d = Sharpen.Runtime.Substring(objectName' 0' 2);
Magic Number,NGit.Storage.File,FileObjectDatabase,C:\repos\mono_ngit\NGit\NGit.Storage.File\FileObjectDatabase.cs,FileFor,The following statement contains a magic number: string f = Sharpen.Runtime.Substring(objectName' 2);
Magic Number,NGit.Storage.File,LargePackedDeltaObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\LargePackedDeltaObject.cs,OpenStream,The following statement contains a magic number: @in = new BufferedInputStream(@in' 8192);
Magic Number,NGit.Storage.File,LargePackedWholeObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\LargePackedWholeObject.cs,OpenStream,The following statement contains a magic number: @in = new BufferedInputStream(new InflaterInputStream(@in' wc.Inflater()' 8192)'   				8192);
Magic Number,NGit.Storage.File,LargePackedWholeObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\LargePackedWholeObject.cs,OpenStream,The following statement contains a magic number: @in = new BufferedInputStream(new InflaterInputStream(@in' wc.Inflater()' 8192)'   				8192);
Magic Number,NGit.Storage.File,LockFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\LockFile.cs,CopyCurrentContent,The following statement contains a magic number: try  			{  				FileInputStream fis = new FileInputStream(@ref);  				try  				{  					if (fsync)  					{  						FileChannel @in = fis.GetChannel();  						long pos = 0;  						long cnt = @in.Size();  						while (0 < cnt)  						{  							long r = os.GetChannel().TransferFrom(@in' pos' cnt);  							pos += r;  							cnt -= r;  						}  					}  					else  					{  						byte[] buf = new byte[2048];  						int r;  						while ((r = fis.Read(buf)) >= 0)  						{  							os.Write(buf' 0' r);  						}  					}  				}  				finally  				{  					fis.Close();  				}  			}  			catch (FileNotFoundException)  			{  			}  			catch (IOException ioe)  			{  				// Don't worry about a file that doesn't exist yet' it  				// conceptually has no current content to copy.  				//  				Unlock();  				throw;  			}  			catch (RuntimeException ioe)  			{  				Unlock();  				throw;  			}  			catch (Error ioe)  			{  				Unlock();  				throw;  			}
Magic Number,NGit.Storage.File,LockFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\LockFile.cs,WaitForStatChange,The following statement contains a magic number: while (o.Equals(n))  			{  				Sharpen.Thread.Sleep(25);  				lck.SetLastModified(Runtime.CurrentTimeMillis());  				n = FileSnapshot.Save(lck);  			}
Magic Number,NGit.Storage.File,LockFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\LockFile.cs,DeleteRef,The following statement contains a magic number: for (int attempts = 0; attempts < 10; attempts++)  			{  				if (@ref.Delete())  				{  					return true;  				}  				try  				{  					Sharpen.Thread.Sleep(100);  				}  				catch (Exception)  				{  					return false;  				}  			}
Magic Number,NGit.Storage.File,LockFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\LockFile.cs,DeleteRef,The following statement contains a magic number: for (int attempts = 0; attempts < 10; attempts++)  			{  				if (@ref.Delete())  				{  					return true;  				}  				try  				{  					Sharpen.Thread.Sleep(100);  				}  				catch (Exception)  				{  					return false;  				}  			}
Magic Number,NGit.Storage.File,LockFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\LockFile.cs,RenameLock,The following statement contains a magic number: for (int attempts = 0; attempts < 10; attempts++)  			{  				if (lck.RenameTo(@ref))  				{  					return true;  				}  				try  				{  					Sharpen.Thread.Sleep(100);  				}  				catch (Exception)  				{  					return false;  				}  			}
Magic Number,NGit.Storage.File,LockFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\LockFile.cs,RenameLock,The following statement contains a magic number: for (int attempts = 0; attempts < 10; attempts++)  			{  				if (lck.RenameTo(@ref))  				{  					return true;  				}  				try  				{  					Sharpen.Thread.Sleep(100);  				}  				catch (Exception)  				{  					return false;  				}  			}
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,ScanCachedPacks,The following statement contains a magic number: AList<LocalCachedPack> list = new AList<LocalCachedPack>(4);
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,ScanCachedPacks,The following statement contains a magic number: while (ptr < buf.Length)  			{  				if (buf[ptr] == '#' || buf[ptr] == '\n')  				{  					ptr = RawParseUtils.NextLF(buf' ptr);  					continue;  				}  				if (buf[ptr] == '+')  				{  					tips.AddItem(ObjectId.FromString(buf' ptr + 2));  					ptr = RawParseUtils.NextLF(buf' ptr + 2);  					continue;  				}  				IList<string> names = new AList<string>(4);  				while (ptr < buf.Length && buf[ptr] == 'P')  				{  					int end = RawParseUtils.NextLF(buf' ptr);  					if (buf[end - 1] == '\n')  					{  						end--;  					}  					names.AddItem(RawParseUtils.Decode(buf' ptr + 2' end));  					ptr = RawParseUtils.NextLF(buf' end);  				}  				if (!tips.IsEmpty() && !names.IsEmpty())  				{  					list.AddItem(new LocalCachedPack(this' tips' names));  					tips = new HashSet<ObjectId>();  				}  			}
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,ScanCachedPacks,The following statement contains a magic number: while (ptr < buf.Length)  			{  				if (buf[ptr] == '#' || buf[ptr] == '\n')  				{  					ptr = RawParseUtils.NextLF(buf' ptr);  					continue;  				}  				if (buf[ptr] == '+')  				{  					tips.AddItem(ObjectId.FromString(buf' ptr + 2));  					ptr = RawParseUtils.NextLF(buf' ptr + 2);  					continue;  				}  				IList<string> names = new AList<string>(4);  				while (ptr < buf.Length && buf[ptr] == 'P')  				{  					int end = RawParseUtils.NextLF(buf' ptr);  					if (buf[end - 1] == '\n')  					{  						end--;  					}  					names.AddItem(RawParseUtils.Decode(buf' ptr + 2' end));  					ptr = RawParseUtils.NextLF(buf' end);  				}  				if (!tips.IsEmpty() && !names.IsEmpty())  				{  					list.AddItem(new LocalCachedPack(this' tips' names));  					tips = new HashSet<ObjectId>();  				}  			}
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,ScanCachedPacks,The following statement contains a magic number: while (ptr < buf.Length)  			{  				if (buf[ptr] == '#' || buf[ptr] == '\n')  				{  					ptr = RawParseUtils.NextLF(buf' ptr);  					continue;  				}  				if (buf[ptr] == '+')  				{  					tips.AddItem(ObjectId.FromString(buf' ptr + 2));  					ptr = RawParseUtils.NextLF(buf' ptr + 2);  					continue;  				}  				IList<string> names = new AList<string>(4);  				while (ptr < buf.Length && buf[ptr] == 'P')  				{  					int end = RawParseUtils.NextLF(buf' ptr);  					if (buf[end - 1] == '\n')  					{  						end--;  					}  					names.AddItem(RawParseUtils.Decode(buf' ptr + 2' end));  					ptr = RawParseUtils.NextLF(buf' end);  				}  				if (!tips.IsEmpty() && !names.IsEmpty())  				{  					list.AddItem(new LocalCachedPack(this' tips' names));  					tips = new HashSet<ObjectId>();  				}  			}
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,ScanCachedPacks,The following statement contains a magic number: while (ptr < buf.Length)  			{  				if (buf[ptr] == '#' || buf[ptr] == '\n')  				{  					ptr = RawParseUtils.NextLF(buf' ptr);  					continue;  				}  				if (buf[ptr] == '+')  				{  					tips.AddItem(ObjectId.FromString(buf' ptr + 2));  					ptr = RawParseUtils.NextLF(buf' ptr + 2);  					continue;  				}  				IList<string> names = new AList<string>(4);  				while (ptr < buf.Length && buf[ptr] == 'P')  				{  					int end = RawParseUtils.NextLF(buf' ptr);  					if (buf[end - 1] == '\n')  					{  						end--;  					}  					names.AddItem(RawParseUtils.Decode(buf' ptr + 2' end));  					ptr = RawParseUtils.NextLF(buf' end);  				}  				if (!tips.IsEmpty() && !names.IsEmpty())  				{  					list.AddItem(new LocalCachedPack(this' tips' names));  					tips = new HashSet<ObjectId>();  				}  			}
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,OpenPack,The following statement contains a magic number: if (p.Length != 50 || !p.StartsWith("pack-") || !p.EndsWith(".pack"))  			{  				throw new IOException(MessageFormat.Format(JGitText.Get().notAValidPack' pack));  			}
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,OpenPack,The following statement contains a magic number: if (i.Length != 49 || !i.StartsWith("pack-") || !i.EndsWith(".idx"))  			{  				throw new IOException(MessageFormat.Format(JGitText.Get().notAValidPack' idx));  			}
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,OpenPack,The following statement contains a magic number: if (!Sharpen.Runtime.Substring(p' 0' 45).Equals(Sharpen.Runtime.Substring(i' 0' 45  				)))  			{  				throw new IOException(MessageFormat.Format(JGitText.Get().packDoesNotMatchIndex'   					pack));  			}
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,OpenPack,The following statement contains a magic number: if (!Sharpen.Runtime.Substring(p' 0' 45).Equals(Sharpen.Runtime.Substring(i' 0' 45  				)))  			{  				throw new IOException(MessageFormat.Format(JGitText.Get().packDoesNotMatchIndex'   					pack));  			}
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,Resolve,The following statement contains a magic number: string fanOut = Sharpen.Runtime.Substring(id.Name' 0' 2);
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,Resolve,The following statement contains a magic number: if (entries != null)  			{  				foreach (string e in entries)  				{  					if (e.Length != Constants.OBJECT_ID_STRING_LENGTH - 2)  					{  						continue;  					}  					try  					{  						ObjectId entId = ObjectId.FromString(fanOut + e);  						if (id.PrefixCompare(entId) == 0)  						{  							matches.AddItem(entId);  						}  					}  					catch (ArgumentException)  					{  						continue;  					}  					if (matches.Count > RESOLVE_ABBREV_LIMIT)  					{  						return;  					}  				}  			}
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,ScanPacksImpl,The following statement contains a magic number: IList<PackFile> list = new AList<PackFile>(names.Count >> 2);
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,ScanPacksImpl,The following statement contains a magic number: foreach (string indexName in names)  			{  				// Must match "pack-[0-9a-f]{40}.idx" to be an index.  				//  				if (indexName.Length != 49 || !indexName.EndsWith(".idx"))  				{  					continue;  				}  				string @base = Sharpen.Runtime.Substring(indexName' 0' indexName.Length - 4);  				string packName = @base + ".pack";  				if (!names.Contains(packName))  				{  					// Sometimes C Git's HTTP fetch transport leaves a  					// .idx file behind and does not download the .pack.  					// We have to skip over such useless indexes.  					//  					continue;  				}  				PackFile oldPack = Sharpen.Collections.Remove(forReuse' packName);  				if (oldPack != null)  				{  					list.AddItem(oldPack);  					continue;  				}  				FilePath packFile = new FilePath(packDirectory' packName);  				FilePath idxFile = new FilePath(packDirectory' indexName);  				list.AddItem(new PackFile(idxFile' packFile));  				foundNew = true;  			}
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,ScanPacksImpl,The following statement contains a magic number: foreach (string indexName in names)  			{  				// Must match "pack-[0-9a-f]{40}.idx" to be an index.  				//  				if (indexName.Length != 49 || !indexName.EndsWith(".idx"))  				{  					continue;  				}  				string @base = Sharpen.Runtime.Substring(indexName' 0' indexName.Length - 4);  				string packName = @base + ".pack";  				if (!names.Contains(packName))  				{  					// Sometimes C Git's HTTP fetch transport leaves a  					// .idx file behind and does not download the .pack.  					// We have to skip over such useless indexes.  					//  					continue;  				}  				PackFile oldPack = Sharpen.Collections.Remove(forReuse' packName);  				if (oldPack != null)  				{  					list.AddItem(oldPack);  					continue;  				}  				FilePath packFile = new FilePath(packDirectory' packName);  				FilePath idxFile = new FilePath(packDirectory' indexName);  				list.AddItem(new PackFile(idxFile' packFile));  				foundNew = true;  			}
Magic Number,NGit.Storage.File,ObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectory.cs,LoadAlternates,The following statement contains a magic number: IList<FileObjectDatabase.AlternateHandle> l = new AList<FileObjectDatabase.AlternateHandle  				>(4);
Magic Number,NGit.Storage.File,ObjectDirectoryInserter,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryInserter.cs,Compress,The following statement contains a magic number: return new DeflaterOutputStream(@out' deflate' 8192);
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,PackFile,The following statement contains a magic number: this.packLastModified = (int)(packFile.LastModified() >> 10);
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,PackFile,The following statement contains a magic number: hash = Runtime.IdentityHashCode(this) * 31;
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,CopyAsIs2,The following statement contains a magic number: ReadFully(src.offset' buf' 0' 20' curs);
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,CopyAsIs2,The following statement contains a magic number: int typeCode = (c >> 4) & 7;
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,CopyAsIs2,The following statement contains a magic number: int typeCode = (c >> 4) & 7;
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,CopyAsIs2,The following statement contains a magic number: long inflatedLength = c & 15;
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,CopyAsIs2,The following statement contains a magic number: int shift = 4;
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,CopyAsIs2,The following statement contains a magic number: while ((c & unchecked((int)(0x80))) != 0)  			{  				c = buf[headerCnt++] & unchecked((int)(0xff));  				inflatedLength += ((long)(c & unchecked((int)(0x7f)))) << shift;  				shift += 7;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,CopyAsIs2,The following statement contains a magic number: if (typeCode == Constants.OBJ_OFS_DELTA)  			{  				do  				{  					c = buf[headerCnt++] & unchecked((int)(0xff));  				}  				while ((c & 128) != 0);  				if (validate)  				{  					crc1.Update(buf' 0' headerCnt);  					crc2.Update(buf' 0' headerCnt);  				}  			}  			else  			{  				if (typeCode == Constants.OBJ_REF_DELTA)  				{  					if (validate)  					{  						crc1.Update(buf' 0' headerCnt);  						crc2.Update(buf' 0' headerCnt);  					}  					ReadFully(src.offset + headerCnt' buf' 0' 20' curs);  					if (validate)  					{  						crc1.Update(buf' 0' 20);  						crc2.Update(buf' 0' 20);  					}  					headerCnt += 20;  				}  				else  				{  					if (validate)  					{  						crc1.Update(buf' 0' headerCnt);  						crc2.Update(buf' 0' headerCnt);  					}  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,CopyAsIs2,The following statement contains a magic number: if (typeCode == Constants.OBJ_OFS_DELTA)  			{  				do  				{  					c = buf[headerCnt++] & unchecked((int)(0xff));  				}  				while ((c & 128) != 0);  				if (validate)  				{  					crc1.Update(buf' 0' headerCnt);  					crc2.Update(buf' 0' headerCnt);  				}  			}  			else  			{  				if (typeCode == Constants.OBJ_REF_DELTA)  				{  					if (validate)  					{  						crc1.Update(buf' 0' headerCnt);  						crc2.Update(buf' 0' headerCnt);  					}  					ReadFully(src.offset + headerCnt' buf' 0' 20' curs);  					if (validate)  					{  						crc1.Update(buf' 0' 20);  						crc2.Update(buf' 0' 20);  					}  					headerCnt += 20;  				}  				else  				{  					if (validate)  					{  						crc1.Update(buf' 0' headerCnt);  						crc2.Update(buf' 0' headerCnt);  					}  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,CopyAsIs2,The following statement contains a magic number: if (typeCode == Constants.OBJ_OFS_DELTA)  			{  				do  				{  					c = buf[headerCnt++] & unchecked((int)(0xff));  				}  				while ((c & 128) != 0);  				if (validate)  				{  					crc1.Update(buf' 0' headerCnt);  					crc2.Update(buf' 0' headerCnt);  				}  			}  			else  			{  				if (typeCode == Constants.OBJ_REF_DELTA)  				{  					if (validate)  					{  						crc1.Update(buf' 0' headerCnt);  						crc2.Update(buf' 0' headerCnt);  					}  					ReadFully(src.offset + headerCnt' buf' 0' 20' curs);  					if (validate)  					{  						crc1.Update(buf' 0' 20);  						crc2.Update(buf' 0' 20);  					}  					headerCnt += 20;  				}  				else  				{  					if (validate)  					{  						crc1.Update(buf' 0' headerCnt);  						crc2.Update(buf' 0' headerCnt);  					}  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,CopyAsIs2,The following statement contains a magic number: if (typeCode == Constants.OBJ_OFS_DELTA)  			{  				do  				{  					c = buf[headerCnt++] & unchecked((int)(0xff));  				}  				while ((c & 128) != 0);  				if (validate)  				{  					crc1.Update(buf' 0' headerCnt);  					crc2.Update(buf' 0' headerCnt);  				}  			}  			else  			{  				if (typeCode == Constants.OBJ_REF_DELTA)  				{  					if (validate)  					{  						crc1.Update(buf' 0' headerCnt);  						crc2.Update(buf' 0' headerCnt);  					}  					ReadFully(src.offset + headerCnt' buf' 0' 20' curs);  					if (validate)  					{  						crc1.Update(buf' 0' 20);  						crc2.Update(buf' 0' 20);  					}  					headerCnt += 20;  				}  				else  				{  					if (validate)  					{  						crc1.Update(buf' 0' headerCnt);  						crc2.Update(buf' 0' headerCnt);  					}  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,CopyAsIs2,The following statement contains a magic number: if (typeCode == Constants.OBJ_OFS_DELTA)  			{  				do  				{  					c = buf[headerCnt++] & unchecked((int)(0xff));  				}  				while ((c & 128) != 0);  				if (validate)  				{  					crc1.Update(buf' 0' headerCnt);  					crc2.Update(buf' 0' headerCnt);  				}  			}  			else  			{  				if (typeCode == Constants.OBJ_REF_DELTA)  				{  					if (validate)  					{  						crc1.Update(buf' 0' headerCnt);  						crc2.Update(buf' 0' headerCnt);  					}  					ReadFully(src.offset + headerCnt' buf' 0' 20' curs);  					if (validate)  					{  						crc1.Update(buf' 0' 20);  						crc2.Update(buf' 0' 20);  					}  					headerCnt += 20;  				}  				else  				{  					if (validate)  					{  						crc1.Update(buf' 0' headerCnt);  						crc2.Update(buf' 0' headerCnt);  					}  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,CopyAsIs2,The following statement contains a magic number: try  			{  				quickCopy = curs.QuickCopy(this' dataOffset' dataLength);  				if (validate && Idx().HasCRC32Support())  				{  					// Index has the CRC32 code cached' validate the object.  					//  					expectedCRC = Idx().FindCRC32(src);  					if (quickCopy != null)  					{  						quickCopy.Crc32(crc1' dataOffset' (int)dataLength);  					}  					else  					{  						long pos = dataOffset;  						long cnt = dataLength;  						while (cnt > 0)  						{  							int n = (int)Math.Min(cnt' buf.Length);  							ReadFully(pos' buf' 0' n' curs);  							crc1.Update(buf' 0' n);  							pos += n;  							cnt -= n;  						}  					}  					if (crc1.GetValue() != expectedCRC)  					{  						SetCorrupt(src.offset);  						throw new CorruptObjectException(MessageFormat.Format(JGitText.Get().objectAtHasBadZlibStream  							' Sharpen.Extensions.ValueOf(src.offset)' GetPackFile()));  					}  				}  				else  				{  					if (validate)  					{  						// We don't have a CRC32 code in the index' so compute it  						// now while inflating the raw data to get zlib to tell us  						// whether or not the data is safe.  						//  						Inflater inf = curs.Inflater();  						byte[] tmp = new byte[1024];  						if (quickCopy != null)  						{  							quickCopy.Check(inf' tmp' dataOffset' (int)dataLength);  						}  						else  						{  							long pos = dataOffset;  							long cnt = dataLength;  							while (cnt > 0)  							{  								int n = (int)Math.Min(cnt' buf.Length);  								ReadFully(pos' buf' 0' n' curs);  								crc1.Update(buf' 0' n);  								inf.SetInput(buf' 0' n);  								while (inf.Inflate(tmp' 0' tmp.Length) > 0)  								{  									continue;  								}  								pos += n;  								cnt -= n;  							}  						}  						if (!inf.IsFinished || inf.TotalIn != dataLength)  						{  							SetCorrupt(src.offset);  							throw new EOFException(MessageFormat.Format(JGitText.Get().shortCompressedStreamAt  								' Sharpen.Extensions.ValueOf(src.offset)));  						}  						expectedCRC = crc1.GetValue();  					}  					else  					{  						expectedCRC = -1;  					}  				}  			}  			catch (SharpZipBaseException dataFormat)  			{  				SetCorrupt(src.offset);  				CorruptObjectException corruptObject = new CorruptObjectException(MessageFormat.Format  					(JGitText.Get().objectAtHasBadZlibStream' Sharpen.Extensions.ValueOf(src.offset)  					' GetPackFile()));  				Sharpen.Extensions.InitCause(corruptObject' dataFormat);  				StoredObjectRepresentationNotAvailableException gone;  				gone = new StoredObjectRepresentationNotAvailableException(src);  				Sharpen.Extensions.InitCause(gone' corruptObject);  				throw gone;  			}  			catch (IOException ioError)  			{  				StoredObjectRepresentationNotAvailableException gone;  				gone = new StoredObjectRepresentationNotAvailableException(src);  				Sharpen.Extensions.InitCause(gone' ioError);  				throw gone;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,OnOpenPack,The following statement contains a magic number: byte[] buf = new byte[20];
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,OnOpenPack,The following statement contains a magic number: fd.ReadFully(buf' 0' 12);
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,OnOpenPack,The following statement contains a magic number: if (RawParseUtils.Match(buf' 0' Constants.PACK_SIGNATURE) != 4)  			{  				throw new IOException(JGitText.Get().notAPACKFile);  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,OnOpenPack,The following statement contains a magic number: long vers = NB.DecodeUInt32(buf' 4);
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,OnOpenPack,The following statement contains a magic number: long packCnt = NB.DecodeUInt32(buf' 8);
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,OnOpenPack,The following statement contains a magic number: if (vers != 2 && vers != 3)  			{  				throw new IOException(MessageFormat.Format(JGitText.Get().unsupportedPackVersion'   					Sharpen.Extensions.ValueOf(vers)));  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,OnOpenPack,The following statement contains a magic number: if (vers != 2 && vers != 3)  			{  				throw new IOException(MessageFormat.Format(JGitText.Get().unsupportedPackVersion'   					Sharpen.Extensions.ValueOf(vers)));  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,OnOpenPack,The following statement contains a magic number: fd.Seek(length - 20);
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,OnOpenPack,The following statement contains a magic number: fd.ReadFully(buf' 0' 20);
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Load,The following statement contains a magic number: try  			{  				byte[] ib = curs.tempId;  				PackFile.Delta delta = null;  				byte[] data = null;  				int type = Constants.OBJ_BAD;  				bool cached = false;  				for (; ; )  				{  					ReadFully(pos' ib' 0' 20' curs);  					int c = ib[0] & unchecked((int)(0xff));  					int typeCode = (c >> 4) & 7;  					long sz = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = ib[p++] & unchecked((int)(0xff));  						sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							if (sz < curs.GetStreamFileThreshold())  							{  								data = Decompress(pos + p' (int)sz' curs);  							}  							if (delta != null)  							{  								type = typeCode;  								goto SEARCH_break;  							}  							if (data != null)  							{  								return new ObjectLoader.SmallObject(typeCode' data);  							}  							else  							{  								return new LargePackedWholeObject(typeCode' sz' pos' p' this' curs.db);  							}  							goto case Constants.OBJ_OFS_DELTA;  						}    						case Constants.OBJ_OFS_DELTA:  						{  							c = ib[p++] & unchecked((int)(0xff));  							long @base = c & 127;  							while ((c & 128) != 0)  							{  								@base += 1;  								c = ib[p++] & unchecked((int)(0xff));  								@base <<= 7;  								@base += (c & 127);  							}  							@base = pos - @base;  							delta = new PackFile.Delta(delta' pos' (int)sz' p' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						case Constants.OBJ_REF_DELTA:  						{  							ReadFully(pos + p' ib' 0' 20' curs);  							long @base = FindDeltaBase(ObjectId.FromRaw(ib));  							delta = new PackFile.Delta(delta' pos' (int)sz' p + 20' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						default:  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  								(typeCode)));  						}  					}  SEARCH_continue: ;  				}  SEARCH_break: ;  				// At this point there is at least one delta to apply to data.  				// (Whole objects with no deltas to apply return early above.)  				if (data == null)  				{  					return delta.Large(this' curs);  				}  				do  				{  					// Cache only the base immediately before desired object.  					if (cached)  					{  						cached = false;  					}  					else  					{  						if (delta.next == null)  						{  							curs.GetDeltaBaseCache().Store(this' delta.basePos' data' type);  						}  					}  					pos = delta.deltaPos;  					byte[] cmds = Decompress(pos + delta.hdrLen' delta.deltaSize' curs);  					if (cmds == null)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					long sz = BinaryDelta.GetResultSize(cmds);  					if (int.MaxValue <= sz)  					{  						return delta.Large(this' curs);  					}  					byte[] result;  					try  					{  						result = new byte[(int)sz];  					}  					catch (OutOfMemoryException)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					BinaryDelta.Apply(data' cmds' result);  					data = result;  					delta = delta.next;  				}  				while (delta != null);  				return new ObjectLoader.SmallObject(type' data);  			}  			catch (SharpZipBaseException dfe)  			{  				CorruptObjectException coe = new CorruptObjectException(MessageFormat.Format(JGitText  					.Get().objectAtHasBadZlibStream' Sharpen.Extensions.ValueOf(pos)' GetPackFile())  					);  				Sharpen.Extensions.InitCause(coe' dfe);  				throw coe;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Load,The following statement contains a magic number: try  			{  				byte[] ib = curs.tempId;  				PackFile.Delta delta = null;  				byte[] data = null;  				int type = Constants.OBJ_BAD;  				bool cached = false;  				for (; ; )  				{  					ReadFully(pos' ib' 0' 20' curs);  					int c = ib[0] & unchecked((int)(0xff));  					int typeCode = (c >> 4) & 7;  					long sz = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = ib[p++] & unchecked((int)(0xff));  						sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							if (sz < curs.GetStreamFileThreshold())  							{  								data = Decompress(pos + p' (int)sz' curs);  							}  							if (delta != null)  							{  								type = typeCode;  								goto SEARCH_break;  							}  							if (data != null)  							{  								return new ObjectLoader.SmallObject(typeCode' data);  							}  							else  							{  								return new LargePackedWholeObject(typeCode' sz' pos' p' this' curs.db);  							}  							goto case Constants.OBJ_OFS_DELTA;  						}    						case Constants.OBJ_OFS_DELTA:  						{  							c = ib[p++] & unchecked((int)(0xff));  							long @base = c & 127;  							while ((c & 128) != 0)  							{  								@base += 1;  								c = ib[p++] & unchecked((int)(0xff));  								@base <<= 7;  								@base += (c & 127);  							}  							@base = pos - @base;  							delta = new PackFile.Delta(delta' pos' (int)sz' p' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						case Constants.OBJ_REF_DELTA:  						{  							ReadFully(pos + p' ib' 0' 20' curs);  							long @base = FindDeltaBase(ObjectId.FromRaw(ib));  							delta = new PackFile.Delta(delta' pos' (int)sz' p + 20' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						default:  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  								(typeCode)));  						}  					}  SEARCH_continue: ;  				}  SEARCH_break: ;  				// At this point there is at least one delta to apply to data.  				// (Whole objects with no deltas to apply return early above.)  				if (data == null)  				{  					return delta.Large(this' curs);  				}  				do  				{  					// Cache only the base immediately before desired object.  					if (cached)  					{  						cached = false;  					}  					else  					{  						if (delta.next == null)  						{  							curs.GetDeltaBaseCache().Store(this' delta.basePos' data' type);  						}  					}  					pos = delta.deltaPos;  					byte[] cmds = Decompress(pos + delta.hdrLen' delta.deltaSize' curs);  					if (cmds == null)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					long sz = BinaryDelta.GetResultSize(cmds);  					if (int.MaxValue <= sz)  					{  						return delta.Large(this' curs);  					}  					byte[] result;  					try  					{  						result = new byte[(int)sz];  					}  					catch (OutOfMemoryException)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					BinaryDelta.Apply(data' cmds' result);  					data = result;  					delta = delta.next;  				}  				while (delta != null);  				return new ObjectLoader.SmallObject(type' data);  			}  			catch (SharpZipBaseException dfe)  			{  				CorruptObjectException coe = new CorruptObjectException(MessageFormat.Format(JGitText  					.Get().objectAtHasBadZlibStream' Sharpen.Extensions.ValueOf(pos)' GetPackFile())  					);  				Sharpen.Extensions.InitCause(coe' dfe);  				throw coe;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Load,The following statement contains a magic number: try  			{  				byte[] ib = curs.tempId;  				PackFile.Delta delta = null;  				byte[] data = null;  				int type = Constants.OBJ_BAD;  				bool cached = false;  				for (; ; )  				{  					ReadFully(pos' ib' 0' 20' curs);  					int c = ib[0] & unchecked((int)(0xff));  					int typeCode = (c >> 4) & 7;  					long sz = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = ib[p++] & unchecked((int)(0xff));  						sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							if (sz < curs.GetStreamFileThreshold())  							{  								data = Decompress(pos + p' (int)sz' curs);  							}  							if (delta != null)  							{  								type = typeCode;  								goto SEARCH_break;  							}  							if (data != null)  							{  								return new ObjectLoader.SmallObject(typeCode' data);  							}  							else  							{  								return new LargePackedWholeObject(typeCode' sz' pos' p' this' curs.db);  							}  							goto case Constants.OBJ_OFS_DELTA;  						}    						case Constants.OBJ_OFS_DELTA:  						{  							c = ib[p++] & unchecked((int)(0xff));  							long @base = c & 127;  							while ((c & 128) != 0)  							{  								@base += 1;  								c = ib[p++] & unchecked((int)(0xff));  								@base <<= 7;  								@base += (c & 127);  							}  							@base = pos - @base;  							delta = new PackFile.Delta(delta' pos' (int)sz' p' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						case Constants.OBJ_REF_DELTA:  						{  							ReadFully(pos + p' ib' 0' 20' curs);  							long @base = FindDeltaBase(ObjectId.FromRaw(ib));  							delta = new PackFile.Delta(delta' pos' (int)sz' p + 20' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						default:  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  								(typeCode)));  						}  					}  SEARCH_continue: ;  				}  SEARCH_break: ;  				// At this point there is at least one delta to apply to data.  				// (Whole objects with no deltas to apply return early above.)  				if (data == null)  				{  					return delta.Large(this' curs);  				}  				do  				{  					// Cache only the base immediately before desired object.  					if (cached)  					{  						cached = false;  					}  					else  					{  						if (delta.next == null)  						{  							curs.GetDeltaBaseCache().Store(this' delta.basePos' data' type);  						}  					}  					pos = delta.deltaPos;  					byte[] cmds = Decompress(pos + delta.hdrLen' delta.deltaSize' curs);  					if (cmds == null)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					long sz = BinaryDelta.GetResultSize(cmds);  					if (int.MaxValue <= sz)  					{  						return delta.Large(this' curs);  					}  					byte[] result;  					try  					{  						result = new byte[(int)sz];  					}  					catch (OutOfMemoryException)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					BinaryDelta.Apply(data' cmds' result);  					data = result;  					delta = delta.next;  				}  				while (delta != null);  				return new ObjectLoader.SmallObject(type' data);  			}  			catch (SharpZipBaseException dfe)  			{  				CorruptObjectException coe = new CorruptObjectException(MessageFormat.Format(JGitText  					.Get().objectAtHasBadZlibStream' Sharpen.Extensions.ValueOf(pos)' GetPackFile())  					);  				Sharpen.Extensions.InitCause(coe' dfe);  				throw coe;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Load,The following statement contains a magic number: try  			{  				byte[] ib = curs.tempId;  				PackFile.Delta delta = null;  				byte[] data = null;  				int type = Constants.OBJ_BAD;  				bool cached = false;  				for (; ; )  				{  					ReadFully(pos' ib' 0' 20' curs);  					int c = ib[0] & unchecked((int)(0xff));  					int typeCode = (c >> 4) & 7;  					long sz = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = ib[p++] & unchecked((int)(0xff));  						sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							if (sz < curs.GetStreamFileThreshold())  							{  								data = Decompress(pos + p' (int)sz' curs);  							}  							if (delta != null)  							{  								type = typeCode;  								goto SEARCH_break;  							}  							if (data != null)  							{  								return new ObjectLoader.SmallObject(typeCode' data);  							}  							else  							{  								return new LargePackedWholeObject(typeCode' sz' pos' p' this' curs.db);  							}  							goto case Constants.OBJ_OFS_DELTA;  						}    						case Constants.OBJ_OFS_DELTA:  						{  							c = ib[p++] & unchecked((int)(0xff));  							long @base = c & 127;  							while ((c & 128) != 0)  							{  								@base += 1;  								c = ib[p++] & unchecked((int)(0xff));  								@base <<= 7;  								@base += (c & 127);  							}  							@base = pos - @base;  							delta = new PackFile.Delta(delta' pos' (int)sz' p' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						case Constants.OBJ_REF_DELTA:  						{  							ReadFully(pos + p' ib' 0' 20' curs);  							long @base = FindDeltaBase(ObjectId.FromRaw(ib));  							delta = new PackFile.Delta(delta' pos' (int)sz' p + 20' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						default:  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  								(typeCode)));  						}  					}  SEARCH_continue: ;  				}  SEARCH_break: ;  				// At this point there is at least one delta to apply to data.  				// (Whole objects with no deltas to apply return early above.)  				if (data == null)  				{  					return delta.Large(this' curs);  				}  				do  				{  					// Cache only the base immediately before desired object.  					if (cached)  					{  						cached = false;  					}  					else  					{  						if (delta.next == null)  						{  							curs.GetDeltaBaseCache().Store(this' delta.basePos' data' type);  						}  					}  					pos = delta.deltaPos;  					byte[] cmds = Decompress(pos + delta.hdrLen' delta.deltaSize' curs);  					if (cmds == null)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					long sz = BinaryDelta.GetResultSize(cmds);  					if (int.MaxValue <= sz)  					{  						return delta.Large(this' curs);  					}  					byte[] result;  					try  					{  						result = new byte[(int)sz];  					}  					catch (OutOfMemoryException)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					BinaryDelta.Apply(data' cmds' result);  					data = result;  					delta = delta.next;  				}  				while (delta != null);  				return new ObjectLoader.SmallObject(type' data);  			}  			catch (SharpZipBaseException dfe)  			{  				CorruptObjectException coe = new CorruptObjectException(MessageFormat.Format(JGitText  					.Get().objectAtHasBadZlibStream' Sharpen.Extensions.ValueOf(pos)' GetPackFile())  					);  				Sharpen.Extensions.InitCause(coe' dfe);  				throw coe;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Load,The following statement contains a magic number: try  			{  				byte[] ib = curs.tempId;  				PackFile.Delta delta = null;  				byte[] data = null;  				int type = Constants.OBJ_BAD;  				bool cached = false;  				for (; ; )  				{  					ReadFully(pos' ib' 0' 20' curs);  					int c = ib[0] & unchecked((int)(0xff));  					int typeCode = (c >> 4) & 7;  					long sz = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = ib[p++] & unchecked((int)(0xff));  						sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							if (sz < curs.GetStreamFileThreshold())  							{  								data = Decompress(pos + p' (int)sz' curs);  							}  							if (delta != null)  							{  								type = typeCode;  								goto SEARCH_break;  							}  							if (data != null)  							{  								return new ObjectLoader.SmallObject(typeCode' data);  							}  							else  							{  								return new LargePackedWholeObject(typeCode' sz' pos' p' this' curs.db);  							}  							goto case Constants.OBJ_OFS_DELTA;  						}    						case Constants.OBJ_OFS_DELTA:  						{  							c = ib[p++] & unchecked((int)(0xff));  							long @base = c & 127;  							while ((c & 128) != 0)  							{  								@base += 1;  								c = ib[p++] & unchecked((int)(0xff));  								@base <<= 7;  								@base += (c & 127);  							}  							@base = pos - @base;  							delta = new PackFile.Delta(delta' pos' (int)sz' p' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						case Constants.OBJ_REF_DELTA:  						{  							ReadFully(pos + p' ib' 0' 20' curs);  							long @base = FindDeltaBase(ObjectId.FromRaw(ib));  							delta = new PackFile.Delta(delta' pos' (int)sz' p + 20' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						default:  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  								(typeCode)));  						}  					}  SEARCH_continue: ;  				}  SEARCH_break: ;  				// At this point there is at least one delta to apply to data.  				// (Whole objects with no deltas to apply return early above.)  				if (data == null)  				{  					return delta.Large(this' curs);  				}  				do  				{  					// Cache only the base immediately before desired object.  					if (cached)  					{  						cached = false;  					}  					else  					{  						if (delta.next == null)  						{  							curs.GetDeltaBaseCache().Store(this' delta.basePos' data' type);  						}  					}  					pos = delta.deltaPos;  					byte[] cmds = Decompress(pos + delta.hdrLen' delta.deltaSize' curs);  					if (cmds == null)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					long sz = BinaryDelta.GetResultSize(cmds);  					if (int.MaxValue <= sz)  					{  						return delta.Large(this' curs);  					}  					byte[] result;  					try  					{  						result = new byte[(int)sz];  					}  					catch (OutOfMemoryException)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					BinaryDelta.Apply(data' cmds' result);  					data = result;  					delta = delta.next;  				}  				while (delta != null);  				return new ObjectLoader.SmallObject(type' data);  			}  			catch (SharpZipBaseException dfe)  			{  				CorruptObjectException coe = new CorruptObjectException(MessageFormat.Format(JGitText  					.Get().objectAtHasBadZlibStream' Sharpen.Extensions.ValueOf(pos)' GetPackFile())  					);  				Sharpen.Extensions.InitCause(coe' dfe);  				throw coe;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Load,The following statement contains a magic number: try  			{  				byte[] ib = curs.tempId;  				PackFile.Delta delta = null;  				byte[] data = null;  				int type = Constants.OBJ_BAD;  				bool cached = false;  				for (; ; )  				{  					ReadFully(pos' ib' 0' 20' curs);  					int c = ib[0] & unchecked((int)(0xff));  					int typeCode = (c >> 4) & 7;  					long sz = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = ib[p++] & unchecked((int)(0xff));  						sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							if (sz < curs.GetStreamFileThreshold())  							{  								data = Decompress(pos + p' (int)sz' curs);  							}  							if (delta != null)  							{  								type = typeCode;  								goto SEARCH_break;  							}  							if (data != null)  							{  								return new ObjectLoader.SmallObject(typeCode' data);  							}  							else  							{  								return new LargePackedWholeObject(typeCode' sz' pos' p' this' curs.db);  							}  							goto case Constants.OBJ_OFS_DELTA;  						}    						case Constants.OBJ_OFS_DELTA:  						{  							c = ib[p++] & unchecked((int)(0xff));  							long @base = c & 127;  							while ((c & 128) != 0)  							{  								@base += 1;  								c = ib[p++] & unchecked((int)(0xff));  								@base <<= 7;  								@base += (c & 127);  							}  							@base = pos - @base;  							delta = new PackFile.Delta(delta' pos' (int)sz' p' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						case Constants.OBJ_REF_DELTA:  						{  							ReadFully(pos + p' ib' 0' 20' curs);  							long @base = FindDeltaBase(ObjectId.FromRaw(ib));  							delta = new PackFile.Delta(delta' pos' (int)sz' p + 20' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						default:  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  								(typeCode)));  						}  					}  SEARCH_continue: ;  				}  SEARCH_break: ;  				// At this point there is at least one delta to apply to data.  				// (Whole objects with no deltas to apply return early above.)  				if (data == null)  				{  					return delta.Large(this' curs);  				}  				do  				{  					// Cache only the base immediately before desired object.  					if (cached)  					{  						cached = false;  					}  					else  					{  						if (delta.next == null)  						{  							curs.GetDeltaBaseCache().Store(this' delta.basePos' data' type);  						}  					}  					pos = delta.deltaPos;  					byte[] cmds = Decompress(pos + delta.hdrLen' delta.deltaSize' curs);  					if (cmds == null)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					long sz = BinaryDelta.GetResultSize(cmds);  					if (int.MaxValue <= sz)  					{  						return delta.Large(this' curs);  					}  					byte[] result;  					try  					{  						result = new byte[(int)sz];  					}  					catch (OutOfMemoryException)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					BinaryDelta.Apply(data' cmds' result);  					data = result;  					delta = delta.next;  				}  				while (delta != null);  				return new ObjectLoader.SmallObject(type' data);  			}  			catch (SharpZipBaseException dfe)  			{  				CorruptObjectException coe = new CorruptObjectException(MessageFormat.Format(JGitText  					.Get().objectAtHasBadZlibStream' Sharpen.Extensions.ValueOf(pos)' GetPackFile())  					);  				Sharpen.Extensions.InitCause(coe' dfe);  				throw coe;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Load,The following statement contains a magic number: try  			{  				byte[] ib = curs.tempId;  				PackFile.Delta delta = null;  				byte[] data = null;  				int type = Constants.OBJ_BAD;  				bool cached = false;  				for (; ; )  				{  					ReadFully(pos' ib' 0' 20' curs);  					int c = ib[0] & unchecked((int)(0xff));  					int typeCode = (c >> 4) & 7;  					long sz = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = ib[p++] & unchecked((int)(0xff));  						sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							if (sz < curs.GetStreamFileThreshold())  							{  								data = Decompress(pos + p' (int)sz' curs);  							}  							if (delta != null)  							{  								type = typeCode;  								goto SEARCH_break;  							}  							if (data != null)  							{  								return new ObjectLoader.SmallObject(typeCode' data);  							}  							else  							{  								return new LargePackedWholeObject(typeCode' sz' pos' p' this' curs.db);  							}  							goto case Constants.OBJ_OFS_DELTA;  						}    						case Constants.OBJ_OFS_DELTA:  						{  							c = ib[p++] & unchecked((int)(0xff));  							long @base = c & 127;  							while ((c & 128) != 0)  							{  								@base += 1;  								c = ib[p++] & unchecked((int)(0xff));  								@base <<= 7;  								@base += (c & 127);  							}  							@base = pos - @base;  							delta = new PackFile.Delta(delta' pos' (int)sz' p' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						case Constants.OBJ_REF_DELTA:  						{  							ReadFully(pos + p' ib' 0' 20' curs);  							long @base = FindDeltaBase(ObjectId.FromRaw(ib));  							delta = new PackFile.Delta(delta' pos' (int)sz' p + 20' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						default:  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  								(typeCode)));  						}  					}  SEARCH_continue: ;  				}  SEARCH_break: ;  				// At this point there is at least one delta to apply to data.  				// (Whole objects with no deltas to apply return early above.)  				if (data == null)  				{  					return delta.Large(this' curs);  				}  				do  				{  					// Cache only the base immediately before desired object.  					if (cached)  					{  						cached = false;  					}  					else  					{  						if (delta.next == null)  						{  							curs.GetDeltaBaseCache().Store(this' delta.basePos' data' type);  						}  					}  					pos = delta.deltaPos;  					byte[] cmds = Decompress(pos + delta.hdrLen' delta.deltaSize' curs);  					if (cmds == null)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					long sz = BinaryDelta.GetResultSize(cmds);  					if (int.MaxValue <= sz)  					{  						return delta.Large(this' curs);  					}  					byte[] result;  					try  					{  						result = new byte[(int)sz];  					}  					catch (OutOfMemoryException)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					BinaryDelta.Apply(data' cmds' result);  					data = result;  					delta = delta.next;  				}  				while (delta != null);  				return new ObjectLoader.SmallObject(type' data);  			}  			catch (SharpZipBaseException dfe)  			{  				CorruptObjectException coe = new CorruptObjectException(MessageFormat.Format(JGitText  					.Get().objectAtHasBadZlibStream' Sharpen.Extensions.ValueOf(pos)' GetPackFile())  					);  				Sharpen.Extensions.InitCause(coe' dfe);  				throw coe;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Load,The following statement contains a magic number: try  			{  				byte[] ib = curs.tempId;  				PackFile.Delta delta = null;  				byte[] data = null;  				int type = Constants.OBJ_BAD;  				bool cached = false;  				for (; ; )  				{  					ReadFully(pos' ib' 0' 20' curs);  					int c = ib[0] & unchecked((int)(0xff));  					int typeCode = (c >> 4) & 7;  					long sz = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = ib[p++] & unchecked((int)(0xff));  						sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							if (sz < curs.GetStreamFileThreshold())  							{  								data = Decompress(pos + p' (int)sz' curs);  							}  							if (delta != null)  							{  								type = typeCode;  								goto SEARCH_break;  							}  							if (data != null)  							{  								return new ObjectLoader.SmallObject(typeCode' data);  							}  							else  							{  								return new LargePackedWholeObject(typeCode' sz' pos' p' this' curs.db);  							}  							goto case Constants.OBJ_OFS_DELTA;  						}    						case Constants.OBJ_OFS_DELTA:  						{  							c = ib[p++] & unchecked((int)(0xff));  							long @base = c & 127;  							while ((c & 128) != 0)  							{  								@base += 1;  								c = ib[p++] & unchecked((int)(0xff));  								@base <<= 7;  								@base += (c & 127);  							}  							@base = pos - @base;  							delta = new PackFile.Delta(delta' pos' (int)sz' p' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						case Constants.OBJ_REF_DELTA:  						{  							ReadFully(pos + p' ib' 0' 20' curs);  							long @base = FindDeltaBase(ObjectId.FromRaw(ib));  							delta = new PackFile.Delta(delta' pos' (int)sz' p + 20' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						default:  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  								(typeCode)));  						}  					}  SEARCH_continue: ;  				}  SEARCH_break: ;  				// At this point there is at least one delta to apply to data.  				// (Whole objects with no deltas to apply return early above.)  				if (data == null)  				{  					return delta.Large(this' curs);  				}  				do  				{  					// Cache only the base immediately before desired object.  					if (cached)  					{  						cached = false;  					}  					else  					{  						if (delta.next == null)  						{  							curs.GetDeltaBaseCache().Store(this' delta.basePos' data' type);  						}  					}  					pos = delta.deltaPos;  					byte[] cmds = Decompress(pos + delta.hdrLen' delta.deltaSize' curs);  					if (cmds == null)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					long sz = BinaryDelta.GetResultSize(cmds);  					if (int.MaxValue <= sz)  					{  						return delta.Large(this' curs);  					}  					byte[] result;  					try  					{  						result = new byte[(int)sz];  					}  					catch (OutOfMemoryException)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					BinaryDelta.Apply(data' cmds' result);  					data = result;  					delta = delta.next;  				}  				while (delta != null);  				return new ObjectLoader.SmallObject(type' data);  			}  			catch (SharpZipBaseException dfe)  			{  				CorruptObjectException coe = new CorruptObjectException(MessageFormat.Format(JGitText  					.Get().objectAtHasBadZlibStream' Sharpen.Extensions.ValueOf(pos)' GetPackFile())  					);  				Sharpen.Extensions.InitCause(coe' dfe);  				throw coe;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Load,The following statement contains a magic number: try  			{  				byte[] ib = curs.tempId;  				PackFile.Delta delta = null;  				byte[] data = null;  				int type = Constants.OBJ_BAD;  				bool cached = false;  				for (; ; )  				{  					ReadFully(pos' ib' 0' 20' curs);  					int c = ib[0] & unchecked((int)(0xff));  					int typeCode = (c >> 4) & 7;  					long sz = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = ib[p++] & unchecked((int)(0xff));  						sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							if (sz < curs.GetStreamFileThreshold())  							{  								data = Decompress(pos + p' (int)sz' curs);  							}  							if (delta != null)  							{  								type = typeCode;  								goto SEARCH_break;  							}  							if (data != null)  							{  								return new ObjectLoader.SmallObject(typeCode' data);  							}  							else  							{  								return new LargePackedWholeObject(typeCode' sz' pos' p' this' curs.db);  							}  							goto case Constants.OBJ_OFS_DELTA;  						}    						case Constants.OBJ_OFS_DELTA:  						{  							c = ib[p++] & unchecked((int)(0xff));  							long @base = c & 127;  							while ((c & 128) != 0)  							{  								@base += 1;  								c = ib[p++] & unchecked((int)(0xff));  								@base <<= 7;  								@base += (c & 127);  							}  							@base = pos - @base;  							delta = new PackFile.Delta(delta' pos' (int)sz' p' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						case Constants.OBJ_REF_DELTA:  						{  							ReadFully(pos + p' ib' 0' 20' curs);  							long @base = FindDeltaBase(ObjectId.FromRaw(ib));  							delta = new PackFile.Delta(delta' pos' (int)sz' p + 20' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						default:  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  								(typeCode)));  						}  					}  SEARCH_continue: ;  				}  SEARCH_break: ;  				// At this point there is at least one delta to apply to data.  				// (Whole objects with no deltas to apply return early above.)  				if (data == null)  				{  					return delta.Large(this' curs);  				}  				do  				{  					// Cache only the base immediately before desired object.  					if (cached)  					{  						cached = false;  					}  					else  					{  						if (delta.next == null)  						{  							curs.GetDeltaBaseCache().Store(this' delta.basePos' data' type);  						}  					}  					pos = delta.deltaPos;  					byte[] cmds = Decompress(pos + delta.hdrLen' delta.deltaSize' curs);  					if (cmds == null)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					long sz = BinaryDelta.GetResultSize(cmds);  					if (int.MaxValue <= sz)  					{  						return delta.Large(this' curs);  					}  					byte[] result;  					try  					{  						result = new byte[(int)sz];  					}  					catch (OutOfMemoryException)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					BinaryDelta.Apply(data' cmds' result);  					data = result;  					delta = delta.next;  				}  				while (delta != null);  				return new ObjectLoader.SmallObject(type' data);  			}  			catch (SharpZipBaseException dfe)  			{  				CorruptObjectException coe = new CorruptObjectException(MessageFormat.Format(JGitText  					.Get().objectAtHasBadZlibStream' Sharpen.Extensions.ValueOf(pos)' GetPackFile())  					);  				Sharpen.Extensions.InitCause(coe' dfe);  				throw coe;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Load,The following statement contains a magic number: try  			{  				byte[] ib = curs.tempId;  				PackFile.Delta delta = null;  				byte[] data = null;  				int type = Constants.OBJ_BAD;  				bool cached = false;  				for (; ; )  				{  					ReadFully(pos' ib' 0' 20' curs);  					int c = ib[0] & unchecked((int)(0xff));  					int typeCode = (c >> 4) & 7;  					long sz = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = ib[p++] & unchecked((int)(0xff));  						sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							if (sz < curs.GetStreamFileThreshold())  							{  								data = Decompress(pos + p' (int)sz' curs);  							}  							if (delta != null)  							{  								type = typeCode;  								goto SEARCH_break;  							}  							if (data != null)  							{  								return new ObjectLoader.SmallObject(typeCode' data);  							}  							else  							{  								return new LargePackedWholeObject(typeCode' sz' pos' p' this' curs.db);  							}  							goto case Constants.OBJ_OFS_DELTA;  						}    						case Constants.OBJ_OFS_DELTA:  						{  							c = ib[p++] & unchecked((int)(0xff));  							long @base = c & 127;  							while ((c & 128) != 0)  							{  								@base += 1;  								c = ib[p++] & unchecked((int)(0xff));  								@base <<= 7;  								@base += (c & 127);  							}  							@base = pos - @base;  							delta = new PackFile.Delta(delta' pos' (int)sz' p' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						case Constants.OBJ_REF_DELTA:  						{  							ReadFully(pos + p' ib' 0' 20' curs);  							long @base = FindDeltaBase(ObjectId.FromRaw(ib));  							delta = new PackFile.Delta(delta' pos' (int)sz' p + 20' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						default:  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  								(typeCode)));  						}  					}  SEARCH_continue: ;  				}  SEARCH_break: ;  				// At this point there is at least one delta to apply to data.  				// (Whole objects with no deltas to apply return early above.)  				if (data == null)  				{  					return delta.Large(this' curs);  				}  				do  				{  					// Cache only the base immediately before desired object.  					if (cached)  					{  						cached = false;  					}  					else  					{  						if (delta.next == null)  						{  							curs.GetDeltaBaseCache().Store(this' delta.basePos' data' type);  						}  					}  					pos = delta.deltaPos;  					byte[] cmds = Decompress(pos + delta.hdrLen' delta.deltaSize' curs);  					if (cmds == null)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					long sz = BinaryDelta.GetResultSize(cmds);  					if (int.MaxValue <= sz)  					{  						return delta.Large(this' curs);  					}  					byte[] result;  					try  					{  						result = new byte[(int)sz];  					}  					catch (OutOfMemoryException)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					BinaryDelta.Apply(data' cmds' result);  					data = result;  					delta = delta.next;  				}  				while (delta != null);  				return new ObjectLoader.SmallObject(type' data);  			}  			catch (SharpZipBaseException dfe)  			{  				CorruptObjectException coe = new CorruptObjectException(MessageFormat.Format(JGitText  					.Get().objectAtHasBadZlibStream' Sharpen.Extensions.ValueOf(pos)' GetPackFile())  					);  				Sharpen.Extensions.InitCause(coe' dfe);  				throw coe;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Load,The following statement contains a magic number: try  			{  				byte[] ib = curs.tempId;  				PackFile.Delta delta = null;  				byte[] data = null;  				int type = Constants.OBJ_BAD;  				bool cached = false;  				for (; ; )  				{  					ReadFully(pos' ib' 0' 20' curs);  					int c = ib[0] & unchecked((int)(0xff));  					int typeCode = (c >> 4) & 7;  					long sz = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = ib[p++] & unchecked((int)(0xff));  						sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							if (sz < curs.GetStreamFileThreshold())  							{  								data = Decompress(pos + p' (int)sz' curs);  							}  							if (delta != null)  							{  								type = typeCode;  								goto SEARCH_break;  							}  							if (data != null)  							{  								return new ObjectLoader.SmallObject(typeCode' data);  							}  							else  							{  								return new LargePackedWholeObject(typeCode' sz' pos' p' this' curs.db);  							}  							goto case Constants.OBJ_OFS_DELTA;  						}    						case Constants.OBJ_OFS_DELTA:  						{  							c = ib[p++] & unchecked((int)(0xff));  							long @base = c & 127;  							while ((c & 128) != 0)  							{  								@base += 1;  								c = ib[p++] & unchecked((int)(0xff));  								@base <<= 7;  								@base += (c & 127);  							}  							@base = pos - @base;  							delta = new PackFile.Delta(delta' pos' (int)sz' p' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						case Constants.OBJ_REF_DELTA:  						{  							ReadFully(pos + p' ib' 0' 20' curs);  							long @base = FindDeltaBase(ObjectId.FromRaw(ib));  							delta = new PackFile.Delta(delta' pos' (int)sz' p + 20' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						default:  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  								(typeCode)));  						}  					}  SEARCH_continue: ;  				}  SEARCH_break: ;  				// At this point there is at least one delta to apply to data.  				// (Whole objects with no deltas to apply return early above.)  				if (data == null)  				{  					return delta.Large(this' curs);  				}  				do  				{  					// Cache only the base immediately before desired object.  					if (cached)  					{  						cached = false;  					}  					else  					{  						if (delta.next == null)  						{  							curs.GetDeltaBaseCache().Store(this' delta.basePos' data' type);  						}  					}  					pos = delta.deltaPos;  					byte[] cmds = Decompress(pos + delta.hdrLen' delta.deltaSize' curs);  					if (cmds == null)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					long sz = BinaryDelta.GetResultSize(cmds);  					if (int.MaxValue <= sz)  					{  						return delta.Large(this' curs);  					}  					byte[] result;  					try  					{  						result = new byte[(int)sz];  					}  					catch (OutOfMemoryException)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					BinaryDelta.Apply(data' cmds' result);  					data = result;  					delta = delta.next;  				}  				while (delta != null);  				return new ObjectLoader.SmallObject(type' data);  			}  			catch (SharpZipBaseException dfe)  			{  				CorruptObjectException coe = new CorruptObjectException(MessageFormat.Format(JGitText  					.Get().objectAtHasBadZlibStream' Sharpen.Extensions.ValueOf(pos)' GetPackFile())  					);  				Sharpen.Extensions.InitCause(coe' dfe);  				throw coe;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Load,The following statement contains a magic number: try  			{  				byte[] ib = curs.tempId;  				PackFile.Delta delta = null;  				byte[] data = null;  				int type = Constants.OBJ_BAD;  				bool cached = false;  				for (; ; )  				{  					ReadFully(pos' ib' 0' 20' curs);  					int c = ib[0] & unchecked((int)(0xff));  					int typeCode = (c >> 4) & 7;  					long sz = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = ib[p++] & unchecked((int)(0xff));  						sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							if (sz < curs.GetStreamFileThreshold())  							{  								data = Decompress(pos + p' (int)sz' curs);  							}  							if (delta != null)  							{  								type = typeCode;  								goto SEARCH_break;  							}  							if (data != null)  							{  								return new ObjectLoader.SmallObject(typeCode' data);  							}  							else  							{  								return new LargePackedWholeObject(typeCode' sz' pos' p' this' curs.db);  							}  							goto case Constants.OBJ_OFS_DELTA;  						}    						case Constants.OBJ_OFS_DELTA:  						{  							c = ib[p++] & unchecked((int)(0xff));  							long @base = c & 127;  							while ((c & 128) != 0)  							{  								@base += 1;  								c = ib[p++] & unchecked((int)(0xff));  								@base <<= 7;  								@base += (c & 127);  							}  							@base = pos - @base;  							delta = new PackFile.Delta(delta' pos' (int)sz' p' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						case Constants.OBJ_REF_DELTA:  						{  							ReadFully(pos + p' ib' 0' 20' curs);  							long @base = FindDeltaBase(ObjectId.FromRaw(ib));  							delta = new PackFile.Delta(delta' pos' (int)sz' p + 20' @base);  							if (sz != delta.deltaSize)  							{  								goto SEARCH_break;  							}  							DeltaBaseCache.Entry e = curs.GetDeltaBaseCache().Get(this' @base);  							if (e != null)  							{  								type = e.type;  								data = e.data;  								cached = true;  								goto SEARCH_break;  							}  							pos = @base;  							goto SEARCH_continue;  						}    						default:  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  								(typeCode)));  						}  					}  SEARCH_continue: ;  				}  SEARCH_break: ;  				// At this point there is at least one delta to apply to data.  				// (Whole objects with no deltas to apply return early above.)  				if (data == null)  				{  					return delta.Large(this' curs);  				}  				do  				{  					// Cache only the base immediately before desired object.  					if (cached)  					{  						cached = false;  					}  					else  					{  						if (delta.next == null)  						{  							curs.GetDeltaBaseCache().Store(this' delta.basePos' data' type);  						}  					}  					pos = delta.deltaPos;  					byte[] cmds = Decompress(pos + delta.hdrLen' delta.deltaSize' curs);  					if (cmds == null)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					long sz = BinaryDelta.GetResultSize(cmds);  					if (int.MaxValue <= sz)  					{  						return delta.Large(this' curs);  					}  					byte[] result;  					try  					{  						result = new byte[(int)sz];  					}  					catch (OutOfMemoryException)  					{  						data = null;  						// Discard base in case of OutOfMemoryError  						return delta.Large(this' curs);  					}  					BinaryDelta.Apply(data' cmds' result);  					data = result;  					delta = delta.next;  				}  				while (delta != null);  				return new ObjectLoader.SmallObject(type' data);  			}  			catch (SharpZipBaseException dfe)  			{  				CorruptObjectException coe = new CorruptObjectException(MessageFormat.Format(JGitText  					.Get().objectAtHasBadZlibStream' Sharpen.Extensions.ValueOf(pos)' GetPackFile())  					);  				Sharpen.Extensions.InitCause(coe' dfe);  				throw coe;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetDeltaHeader,The following statement contains a magic number: byte[] hdr = new byte[18];
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectType,The following statement contains a magic number: for (; ; )  			{  				ReadFully(pos' ib' 0' 20' curs);  				int c = ib[0] & unchecked((int)(0xff));  				int type = (c >> 4) & 7;  				switch (type)  				{  					case Constants.OBJ_COMMIT:  					case Constants.OBJ_TREE:  					case Constants.OBJ_BLOB:  					case Constants.OBJ_TAG:  					{  						return type;  					}    					case Constants.OBJ_OFS_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						c = ib[p++] & unchecked((int)(0xff));  						long ofs = c & 127;  						while ((c & 128) != 0)  						{  							ofs += 1;  							c = ib[p++] & unchecked((int)(0xff));  							ofs <<= 7;  							ofs += (c & 127);  						}  						pos = pos - ofs;  						continue;  						goto case Constants.OBJ_REF_DELTA;  					}    					case Constants.OBJ_REF_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						ReadFully(pos + p' ib' 0' 20' curs);  						pos = FindDeltaBase(ObjectId.FromRaw(ib));  						continue;  						goto default;  					}    					default:  					{  						throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  							(type)));  					}  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectType,The following statement contains a magic number: for (; ; )  			{  				ReadFully(pos' ib' 0' 20' curs);  				int c = ib[0] & unchecked((int)(0xff));  				int type = (c >> 4) & 7;  				switch (type)  				{  					case Constants.OBJ_COMMIT:  					case Constants.OBJ_TREE:  					case Constants.OBJ_BLOB:  					case Constants.OBJ_TAG:  					{  						return type;  					}    					case Constants.OBJ_OFS_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						c = ib[p++] & unchecked((int)(0xff));  						long ofs = c & 127;  						while ((c & 128) != 0)  						{  							ofs += 1;  							c = ib[p++] & unchecked((int)(0xff));  							ofs <<= 7;  							ofs += (c & 127);  						}  						pos = pos - ofs;  						continue;  						goto case Constants.OBJ_REF_DELTA;  					}    					case Constants.OBJ_REF_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						ReadFully(pos + p' ib' 0' 20' curs);  						pos = FindDeltaBase(ObjectId.FromRaw(ib));  						continue;  						goto default;  					}    					default:  					{  						throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  							(type)));  					}  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectType,The following statement contains a magic number: for (; ; )  			{  				ReadFully(pos' ib' 0' 20' curs);  				int c = ib[0] & unchecked((int)(0xff));  				int type = (c >> 4) & 7;  				switch (type)  				{  					case Constants.OBJ_COMMIT:  					case Constants.OBJ_TREE:  					case Constants.OBJ_BLOB:  					case Constants.OBJ_TAG:  					{  						return type;  					}    					case Constants.OBJ_OFS_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						c = ib[p++] & unchecked((int)(0xff));  						long ofs = c & 127;  						while ((c & 128) != 0)  						{  							ofs += 1;  							c = ib[p++] & unchecked((int)(0xff));  							ofs <<= 7;  							ofs += (c & 127);  						}  						pos = pos - ofs;  						continue;  						goto case Constants.OBJ_REF_DELTA;  					}    					case Constants.OBJ_REF_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						ReadFully(pos + p' ib' 0' 20' curs);  						pos = FindDeltaBase(ObjectId.FromRaw(ib));  						continue;  						goto default;  					}    					default:  					{  						throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  							(type)));  					}  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectType,The following statement contains a magic number: for (; ; )  			{  				ReadFully(pos' ib' 0' 20' curs);  				int c = ib[0] & unchecked((int)(0xff));  				int type = (c >> 4) & 7;  				switch (type)  				{  					case Constants.OBJ_COMMIT:  					case Constants.OBJ_TREE:  					case Constants.OBJ_BLOB:  					case Constants.OBJ_TAG:  					{  						return type;  					}    					case Constants.OBJ_OFS_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						c = ib[p++] & unchecked((int)(0xff));  						long ofs = c & 127;  						while ((c & 128) != 0)  						{  							ofs += 1;  							c = ib[p++] & unchecked((int)(0xff));  							ofs <<= 7;  							ofs += (c & 127);  						}  						pos = pos - ofs;  						continue;  						goto case Constants.OBJ_REF_DELTA;  					}    					case Constants.OBJ_REF_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						ReadFully(pos + p' ib' 0' 20' curs);  						pos = FindDeltaBase(ObjectId.FromRaw(ib));  						continue;  						goto default;  					}    					default:  					{  						throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  							(type)));  					}  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectType,The following statement contains a magic number: for (; ; )  			{  				ReadFully(pos' ib' 0' 20' curs);  				int c = ib[0] & unchecked((int)(0xff));  				int type = (c >> 4) & 7;  				switch (type)  				{  					case Constants.OBJ_COMMIT:  					case Constants.OBJ_TREE:  					case Constants.OBJ_BLOB:  					case Constants.OBJ_TAG:  					{  						return type;  					}    					case Constants.OBJ_OFS_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						c = ib[p++] & unchecked((int)(0xff));  						long ofs = c & 127;  						while ((c & 128) != 0)  						{  							ofs += 1;  							c = ib[p++] & unchecked((int)(0xff));  							ofs <<= 7;  							ofs += (c & 127);  						}  						pos = pos - ofs;  						continue;  						goto case Constants.OBJ_REF_DELTA;  					}    					case Constants.OBJ_REF_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						ReadFully(pos + p' ib' 0' 20' curs);  						pos = FindDeltaBase(ObjectId.FromRaw(ib));  						continue;  						goto default;  					}    					default:  					{  						throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  							(type)));  					}  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectType,The following statement contains a magic number: for (; ; )  			{  				ReadFully(pos' ib' 0' 20' curs);  				int c = ib[0] & unchecked((int)(0xff));  				int type = (c >> 4) & 7;  				switch (type)  				{  					case Constants.OBJ_COMMIT:  					case Constants.OBJ_TREE:  					case Constants.OBJ_BLOB:  					case Constants.OBJ_TAG:  					{  						return type;  					}    					case Constants.OBJ_OFS_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						c = ib[p++] & unchecked((int)(0xff));  						long ofs = c & 127;  						while ((c & 128) != 0)  						{  							ofs += 1;  							c = ib[p++] & unchecked((int)(0xff));  							ofs <<= 7;  							ofs += (c & 127);  						}  						pos = pos - ofs;  						continue;  						goto case Constants.OBJ_REF_DELTA;  					}    					case Constants.OBJ_REF_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						ReadFully(pos + p' ib' 0' 20' curs);  						pos = FindDeltaBase(ObjectId.FromRaw(ib));  						continue;  						goto default;  					}    					default:  					{  						throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  							(type)));  					}  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectType,The following statement contains a magic number: for (; ; )  			{  				ReadFully(pos' ib' 0' 20' curs);  				int c = ib[0] & unchecked((int)(0xff));  				int type = (c >> 4) & 7;  				switch (type)  				{  					case Constants.OBJ_COMMIT:  					case Constants.OBJ_TREE:  					case Constants.OBJ_BLOB:  					case Constants.OBJ_TAG:  					{  						return type;  					}    					case Constants.OBJ_OFS_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						c = ib[p++] & unchecked((int)(0xff));  						long ofs = c & 127;  						while ((c & 128) != 0)  						{  							ofs += 1;  							c = ib[p++] & unchecked((int)(0xff));  							ofs <<= 7;  							ofs += (c & 127);  						}  						pos = pos - ofs;  						continue;  						goto case Constants.OBJ_REF_DELTA;  					}    					case Constants.OBJ_REF_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						ReadFully(pos + p' ib' 0' 20' curs);  						pos = FindDeltaBase(ObjectId.FromRaw(ib));  						continue;  						goto default;  					}    					default:  					{  						throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  							(type)));  					}  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectType,The following statement contains a magic number: for (; ; )  			{  				ReadFully(pos' ib' 0' 20' curs);  				int c = ib[0] & unchecked((int)(0xff));  				int type = (c >> 4) & 7;  				switch (type)  				{  					case Constants.OBJ_COMMIT:  					case Constants.OBJ_TREE:  					case Constants.OBJ_BLOB:  					case Constants.OBJ_TAG:  					{  						return type;  					}    					case Constants.OBJ_OFS_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						c = ib[p++] & unchecked((int)(0xff));  						long ofs = c & 127;  						while ((c & 128) != 0)  						{  							ofs += 1;  							c = ib[p++] & unchecked((int)(0xff));  							ofs <<= 7;  							ofs += (c & 127);  						}  						pos = pos - ofs;  						continue;  						goto case Constants.OBJ_REF_DELTA;  					}    					case Constants.OBJ_REF_DELTA:  					{  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = ib[p++] & unchecked((int)(0xff));  						}  						ReadFully(pos + p' ib' 0' 20' curs);  						pos = FindDeltaBase(ObjectId.FromRaw(ib));  						continue;  						goto default;  					}    					default:  					{  						throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  							(type)));  					}  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectSize,The following statement contains a magic number: ReadFully(pos' ib' 0' 20' curs);
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectSize,The following statement contains a magic number: int type = (c >> 4) & 7;
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectSize,The following statement contains a magic number: int type = (c >> 4) & 7;
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectSize,The following statement contains a magic number: long sz = c & 15;
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectSize,The following statement contains a magic number: int shift = 4;
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectSize,The following statement contains a magic number: while ((c & unchecked((int)(0x80))) != 0)  			{  				c = ib[p++] & unchecked((int)(0xff));  				sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  				shift += 7;  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectSize,The following statement contains a magic number: switch (type)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					return sz;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ib[p++] & unchecked((int)(0xff));  					while ((c & 128) != 0)  					{  						c = ib[p++] & unchecked((int)(0xff));  					}  					deltaAt = pos + p;  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					deltaAt = pos + p + 20;  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(type)));  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,GetObjectSize,The following statement contains a magic number: switch (type)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					return sz;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ib[p++] & unchecked((int)(0xff));  					while ((c & 128) != 0)  					{  						c = ib[p++] & unchecked((int)(0xff));  					}  					deltaAt = pos + p;  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					deltaAt = pos + p + 20;  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(type)));  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Representation,The following statement contains a magic number: ReadFully(pos' ib' 0' 20' curs);
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Representation,The following statement contains a magic number: int typeCode = (c >> 4) & 7;
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Representation,The following statement contains a magic number: int typeCode = (c >> 4) & 7;
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Representation,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					return LocalObjectRepresentation.NewWhole(this' pos' len - p);  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ib[p++] & unchecked((int)(0xff));  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ib[p++] & unchecked((int)(0xff));  						ofs <<= 7;  						ofs += (c & 127);  					}  					ofs = pos - ofs;  					return LocalObjectRepresentation.NewDelta(this' pos' len - p' ofs);  				}    				case Constants.OBJ_REF_DELTA:  				{  					len -= p;  					len -= Constants.OBJECT_ID_LENGTH;  					ReadFully(pos + p' ib' 0' 20' curs);  					ObjectId id = ObjectId.FromRaw(ib);  					return LocalObjectRepresentation.NewDelta(this' pos' len' id);  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(typeCode)));  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Representation,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					return LocalObjectRepresentation.NewWhole(this' pos' len - p);  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ib[p++] & unchecked((int)(0xff));  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ib[p++] & unchecked((int)(0xff));  						ofs <<= 7;  						ofs += (c & 127);  					}  					ofs = pos - ofs;  					return LocalObjectRepresentation.NewDelta(this' pos' len - p' ofs);  				}    				case Constants.OBJ_REF_DELTA:  				{  					len -= p;  					len -= Constants.OBJECT_ID_LENGTH;  					ReadFully(pos + p' ib' 0' 20' curs);  					ObjectId id = ObjectId.FromRaw(ib);  					return LocalObjectRepresentation.NewDelta(this' pos' len' id);  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(typeCode)));  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Representation,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					return LocalObjectRepresentation.NewWhole(this' pos' len - p);  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ib[p++] & unchecked((int)(0xff));  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ib[p++] & unchecked((int)(0xff));  						ofs <<= 7;  						ofs += (c & 127);  					}  					ofs = pos - ofs;  					return LocalObjectRepresentation.NewDelta(this' pos' len - p' ofs);  				}    				case Constants.OBJ_REF_DELTA:  				{  					len -= p;  					len -= Constants.OBJECT_ID_LENGTH;  					ReadFully(pos + p' ib' 0' 20' curs);  					ObjectId id = ObjectId.FromRaw(ib);  					return LocalObjectRepresentation.NewDelta(this' pos' len' id);  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(typeCode)));  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Representation,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					return LocalObjectRepresentation.NewWhole(this' pos' len - p);  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ib[p++] & unchecked((int)(0xff));  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ib[p++] & unchecked((int)(0xff));  						ofs <<= 7;  						ofs += (c & 127);  					}  					ofs = pos - ofs;  					return LocalObjectRepresentation.NewDelta(this' pos' len - p' ofs);  				}    				case Constants.OBJ_REF_DELTA:  				{  					len -= p;  					len -= Constants.OBJECT_ID_LENGTH;  					ReadFully(pos + p' ib' 0' 20' curs);  					ObjectId id = ObjectId.FromRaw(ib);  					return LocalObjectRepresentation.NewDelta(this' pos' len' id);  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(typeCode)));  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,Representation,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					return LocalObjectRepresentation.NewWhole(this' pos' len - p);  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ib[p++] & unchecked((int)(0xff));  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ib[p++] & unchecked((int)(0xff));  						ofs <<= 7;  						ofs += (c & 127);  					}  					ofs = pos - ofs;  					return LocalObjectRepresentation.NewDelta(this' pos' len - p' ofs);  				}    				case Constants.OBJ_REF_DELTA:  				{  					len -= p;  					len -= Constants.OBJECT_ID_LENGTH;  					ReadFully(pos + p' ib' 0' 20' curs);  					ObjectId id = ObjectId.FromRaw(ib);  					return LocalObjectRepresentation.NewDelta(this' pos' len' id);  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(typeCode)));  				}  			}
Magic Number,NGit.Storage.File,PackFile,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackFile.cs,FindEndOffset,The following statement contains a magic number: long maxOffset = length - 20;
Magic Number,NGit.Storage.File,PackIndex,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndex.cs,Read,The following statement contains a magic number: byte[] hdr = new byte[8];
Magic Number,NGit.Storage.File,PackIndex,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndex.cs,Read,The following statement contains a magic number: if (IsTOC(hdr))  			{  				int v = NB.DecodeInt32(hdr' 4);  				switch (v)  				{  					case 2:  					{  						return new PackIndexV2(fd);  					}    					default:  					{  						throw new IOException(MessageFormat.Format(JGitText.Get().unsupportedPackIndexVersion  							' Sharpen.Extensions.ValueOf(v)));  					}  				}  			}
Magic Number,NGit.Storage.File,PackIndex,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndex.cs,Read,The following statement contains a magic number: if (IsTOC(hdr))  			{  				int v = NB.DecodeInt32(hdr' 4);  				switch (v)  				{  					case 2:  					{  						return new PackIndexV2(fd);  					}    					default:  					{  						throw new IOException(MessageFormat.Format(JGitText.Get().unsupportedPackIndexVersion  							' Sharpen.Extensions.ValueOf(v)));  					}  				}  			}
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: idxHeader = new long[256];
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: for (int k = 0; k < idxHeader.Length; k++)  			{  				idxHeader[k] = NB.DecodeUInt32(fanoutTable' k * 4);  			}
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: for (int k_1 = 0; k_1 < idxHeader.Length; k_1++)  			{  				int n;  				if (k_1 == 0)  				{  					n = (int)(idxHeader[k_1]);  				}  				else  				{  					n = (int)(idxHeader[k_1] - idxHeader[k_1 - 1]);  				}  				if (n > 0)  				{  					idxdata[k_1] = new byte[n * (Constants.OBJECT_ID_LENGTH + 4)];  					IOUtil.ReadFully(fd' idxdata[k_1]' 0' idxdata[k_1].Length);  				}  			}
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: objectCnt = idxHeader[255];
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: packChecksum = new byte[20];
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,FindOffset,The following statement contains a magic number: int high = data.Length / (4 + Constants.OBJECT_ID_LENGTH);
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (int)(((uint)(low + high)) >> 1);  				int pos = IdOffset(mid);  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else  				{  					if (cmp == 0)  					{  						int b0 = data[pos - 4] & unchecked((int)(0xff));  						int b1 = data[pos - 3] & unchecked((int)(0xff));  						int b2 = data[pos - 2] & unchecked((int)(0xff));  						int b3 = data[pos - 1] & unchecked((int)(0xff));  						return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  					}  					else  					{  						low = mid + 1;  					}  				}  			}  			while (low < high);
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (int)(((uint)(low + high)) >> 1);  				int pos = IdOffset(mid);  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else  				{  					if (cmp == 0)  					{  						int b0 = data[pos - 4] & unchecked((int)(0xff));  						int b1 = data[pos - 3] & unchecked((int)(0xff));  						int b2 = data[pos - 2] & unchecked((int)(0xff));  						int b3 = data[pos - 1] & unchecked((int)(0xff));  						return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  					}  					else  					{  						low = mid + 1;  					}  				}  			}  			while (low < high);
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (int)(((uint)(low + high)) >> 1);  				int pos = IdOffset(mid);  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else  				{  					if (cmp == 0)  					{  						int b0 = data[pos - 4] & unchecked((int)(0xff));  						int b1 = data[pos - 3] & unchecked((int)(0xff));  						int b2 = data[pos - 2] & unchecked((int)(0xff));  						int b3 = data[pos - 1] & unchecked((int)(0xff));  						return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  					}  					else  					{  						low = mid + 1;  					}  				}  			}  			while (low < high);
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (int)(((uint)(low + high)) >> 1);  				int pos = IdOffset(mid);  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else  				{  					if (cmp == 0)  					{  						int b0 = data[pos - 4] & unchecked((int)(0xff));  						int b1 = data[pos - 3] & unchecked((int)(0xff));  						int b2 = data[pos - 2] & unchecked((int)(0xff));  						int b3 = data[pos - 1] & unchecked((int)(0xff));  						return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  					}  					else  					{  						low = mid + 1;  					}  				}  			}  			while (low < high);
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (int)(((uint)(low + high)) >> 1);  				int pos = IdOffset(mid);  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else  				{  					if (cmp == 0)  					{  						int b0 = data[pos - 4] & unchecked((int)(0xff));  						int b1 = data[pos - 3] & unchecked((int)(0xff));  						int b2 = data[pos - 2] & unchecked((int)(0xff));  						int b3 = data[pos - 1] & unchecked((int)(0xff));  						return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  					}  					else  					{  						low = mid + 1;  					}  				}  			}  			while (low < high);
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (int)(((uint)(low + high)) >> 1);  				int pos = IdOffset(mid);  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else  				{  					if (cmp == 0)  					{  						int b0 = data[pos - 4] & unchecked((int)(0xff));  						int b1 = data[pos - 3] & unchecked((int)(0xff));  						int b2 = data[pos - 2] & unchecked((int)(0xff));  						int b3 = data[pos - 1] & unchecked((int)(0xff));  						return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  					}  					else  					{  						low = mid + 1;  					}  				}  			}  			while (low < high);
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,Resolve,The following statement contains a magic number: int max = data.Length / (4 + Constants.OBJECT_ID_LENGTH);
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,IdOffset,The following statement contains a magic number: return ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;
Magic Number,NGit.Storage.File,PackIndexV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,IdOffset,The following statement contains a magic number: return ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;
Magic Number,NGit.Storage.File,IndexV1Iterator,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV1.cs,Next,The following statement contains a magic number: for (; this.levelOne < this._enclosing.idxdata.Length; this.levelOne++)  				{  					if (this._enclosing.idxdata[this.levelOne] == null)  					{  						continue;  					}  					if (this.levelTwo < this._enclosing.idxdata[this.levelOne].Length)  					{  						this.entry.offset = NB.DecodeUInt32(this._enclosing.idxdata[this.levelOne]' this.  							levelTwo);  						this.levelTwo += Constants.OBJECT_ID_LENGTH + 4;  						this.returnedNumber++;  						return this.entry;  					}  					this.levelTwo = 0;  				}
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: byte[] fanoutRaw = new byte[4 * FANOUT];
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k = 0; k < FANOUT; k++)  			{  				fanoutTable[k] = NB.DecodeUInt32(fanoutRaw' k * 4);  			}
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k_1 = 0; k_1 < FANOUT; k_1++)  			{  				long bucketCnt;  				if (k_1 == 0)  				{  					bucketCnt = fanoutTable[k_1];  				}  				else  				{  					bucketCnt = fanoutTable[k_1] - fanoutTable[k_1 - 1];  				}  				if (bucketCnt == 0)  				{  					names[k_1] = NO_INTS;  					offset32[k_1] = NO_BYTES;  					crc32[k_1] = NO_BYTES;  					continue;  				}  				long nameLen = bucketCnt * Constants.OBJECT_ID_LENGTH;  				if (nameLen > int.MaxValue)  				{  					throw new IOException(JGitText.Get().indexFileIsTooLargeForJgit);  				}  				int intNameLen = (int)nameLen;  				byte[] raw = new byte[intNameLen];  				int[] bin = new int[(int)(((uint)intNameLen) >> 2)];  				IOUtil.ReadFully(fd' raw' 0' raw.Length);  				for (int i = 0; i < bin.Length; i++)  				{  					bin[i] = NB.DecodeInt32(raw' i << 2);  				}  				names[k_1] = bin;  				offset32[k_1] = new byte[(int)(bucketCnt * 4)];  				crc32[k_1] = new byte[(int)(bucketCnt * 4)];  			}
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k_1 = 0; k_1 < FANOUT; k_1++)  			{  				long bucketCnt;  				if (k_1 == 0)  				{  					bucketCnt = fanoutTable[k_1];  				}  				else  				{  					bucketCnt = fanoutTable[k_1] - fanoutTable[k_1 - 1];  				}  				if (bucketCnt == 0)  				{  					names[k_1] = NO_INTS;  					offset32[k_1] = NO_BYTES;  					crc32[k_1] = NO_BYTES;  					continue;  				}  				long nameLen = bucketCnt * Constants.OBJECT_ID_LENGTH;  				if (nameLen > int.MaxValue)  				{  					throw new IOException(JGitText.Get().indexFileIsTooLargeForJgit);  				}  				int intNameLen = (int)nameLen;  				byte[] raw = new byte[intNameLen];  				int[] bin = new int[(int)(((uint)intNameLen) >> 2)];  				IOUtil.ReadFully(fd' raw' 0' raw.Length);  				for (int i = 0; i < bin.Length; i++)  				{  					bin[i] = NB.DecodeInt32(raw' i << 2);  				}  				names[k_1] = bin;  				offset32[k_1] = new byte[(int)(bucketCnt * 4)];  				crc32[k_1] = new byte[(int)(bucketCnt * 4)];  			}
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k_1 = 0; k_1 < FANOUT; k_1++)  			{  				long bucketCnt;  				if (k_1 == 0)  				{  					bucketCnt = fanoutTable[k_1];  				}  				else  				{  					bucketCnt = fanoutTable[k_1] - fanoutTable[k_1 - 1];  				}  				if (bucketCnt == 0)  				{  					names[k_1] = NO_INTS;  					offset32[k_1] = NO_BYTES;  					crc32[k_1] = NO_BYTES;  					continue;  				}  				long nameLen = bucketCnt * Constants.OBJECT_ID_LENGTH;  				if (nameLen > int.MaxValue)  				{  					throw new IOException(JGitText.Get().indexFileIsTooLargeForJgit);  				}  				int intNameLen = (int)nameLen;  				byte[] raw = new byte[intNameLen];  				int[] bin = new int[(int)(((uint)intNameLen) >> 2)];  				IOUtil.ReadFully(fd' raw' 0' raw.Length);  				for (int i = 0; i < bin.Length; i++)  				{  					bin[i] = NB.DecodeInt32(raw' i << 2);  				}  				names[k_1] = bin;  				offset32[k_1] = new byte[(int)(bucketCnt * 4)];  				crc32[k_1] = new byte[(int)(bucketCnt * 4)];  			}
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k_1 = 0; k_1 < FANOUT; k_1++)  			{  				long bucketCnt;  				if (k_1 == 0)  				{  					bucketCnt = fanoutTable[k_1];  				}  				else  				{  					bucketCnt = fanoutTable[k_1] - fanoutTable[k_1 - 1];  				}  				if (bucketCnt == 0)  				{  					names[k_1] = NO_INTS;  					offset32[k_1] = NO_BYTES;  					crc32[k_1] = NO_BYTES;  					continue;  				}  				long nameLen = bucketCnt * Constants.OBJECT_ID_LENGTH;  				if (nameLen > int.MaxValue)  				{  					throw new IOException(JGitText.Get().indexFileIsTooLargeForJgit);  				}  				int intNameLen = (int)nameLen;  				byte[] raw = new byte[intNameLen];  				int[] bin = new int[(int)(((uint)intNameLen) >> 2)];  				IOUtil.ReadFully(fd' raw' 0' raw.Length);  				for (int i = 0; i < bin.Length; i++)  				{  					bin[i] = NB.DecodeInt32(raw' i << 2);  				}  				names[k_1] = bin;  				offset32[k_1] = new byte[(int)(bucketCnt * 4)];  				crc32[k_1] = new byte[(int)(bucketCnt * 4)];  			}
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k_3 = 0; k_3 < FANOUT; k_3++)  			{  				byte[] ofs = offset32[k_3];  				IOUtil.ReadFully(fd' ofs' 0' ofs.Length);  				for (int p = 0; p < ofs.Length; p += 4)  				{  					if (((sbyte)ofs[p]) < 0)  					{  						o64cnt++;  					}  				}  			}
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: if (o64cnt > 0)  			{  				offset64 = new byte[o64cnt * 8];  				IOUtil.ReadFully(fd' offset64' 0' offset64.Length);  			}  			else  			{  				offset64 = NO_BYTES;  			}
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: packChecksum = new byte[20];
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,GetOffset64Count,The following statement contains a magic number: return offset64.Length / 8;
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,GetObjectId,The following statement contains a magic number: int p4 = p << 2;
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,FindOffset,The following statement contains a magic number: long p = NB.DecodeUInt32(offset32[levelOne]' levelTwo << 2);
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,FindOffset,The following statement contains a magic number: if ((p & IS_O64) != 0)  			{  				return NB.DecodeUInt64(offset64' (8 * (int)(p & ~IS_O64)));  			}
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,FindCRC32,The following statement contains a magic number: return NB.DecodeUInt32(crc32[levelOne]' levelTwo << 2);
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,Resolve,The following statement contains a magic number: int max = (int)(((uint)offset32[id.FirstByte].Length) >> 2);
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,IdOffset,The following statement contains a magic number: return (p << 2) + p;
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,BinarySearchLevelTwo,The following statement contains a magic number: int high = (int)(((uint)offset32[levelOne].Length) >> 2);
Magic Number,NGit.Storage.File,PackIndexV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,BinarySearchLevelTwo,The following statement contains a magic number: do  			{  				int mid = (int)(((uint)(low + high)) >> 1);  				int mid4 = mid << 2;  				int cmp;  				cmp = objId.CompareTo(data' mid4 + mid);  				// mid * 5  				if (cmp < 0)  				{  					high = mid;  				}  				else  				{  					if (cmp == 0)  					{  						return mid;  					}  					else  					{  						low = mid + 1;  					}  				}  			}  			while (low < high);
Magic Number,NGit.Storage.File,EntriesIteratorV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,Next,The following statement contains a magic number: for (; this.levelOne < this._enclosing.names.Length; this.levelOne++)  				{  					if (this.levelTwo < this._enclosing.names[this.levelOne].Length)  					{  						int idx = this.levelTwo / (Constants.OBJECT_ID_LENGTH / 4) * 4;  						long offset = NB.DecodeUInt32(this._enclosing.offset32[this.levelOne]' idx);  						if ((offset & PackIndexV2.IS_O64) != 0)  						{  							idx = (8 * (int)(offset & ~PackIndexV2.IS_O64));  							offset = NB.DecodeUInt64(this._enclosing.offset64' idx);  						}  						this.entry.offset = offset;  						this.levelTwo += Constants.OBJECT_ID_LENGTH / 4;  						this.returnedNumber++;  						return this.entry;  					}  					this.levelTwo = 0;  				}
Magic Number,NGit.Storage.File,EntriesIteratorV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,Next,The following statement contains a magic number: for (; this.levelOne < this._enclosing.names.Length; this.levelOne++)  				{  					if (this.levelTwo < this._enclosing.names[this.levelOne].Length)  					{  						int idx = this.levelTwo / (Constants.OBJECT_ID_LENGTH / 4) * 4;  						long offset = NB.DecodeUInt32(this._enclosing.offset32[this.levelOne]' idx);  						if ((offset & PackIndexV2.IS_O64) != 0)  						{  							idx = (8 * (int)(offset & ~PackIndexV2.IS_O64));  							offset = NB.DecodeUInt64(this._enclosing.offset64' idx);  						}  						this.entry.offset = offset;  						this.levelTwo += Constants.OBJECT_ID_LENGTH / 4;  						this.returnedNumber++;  						return this.entry;  					}  					this.levelTwo = 0;  				}
Magic Number,NGit.Storage.File,EntriesIteratorV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,Next,The following statement contains a magic number: for (; this.levelOne < this._enclosing.names.Length; this.levelOne++)  				{  					if (this.levelTwo < this._enclosing.names[this.levelOne].Length)  					{  						int idx = this.levelTwo / (Constants.OBJECT_ID_LENGTH / 4) * 4;  						long offset = NB.DecodeUInt32(this._enclosing.offset32[this.levelOne]' idx);  						if ((offset & PackIndexV2.IS_O64) != 0)  						{  							idx = (8 * (int)(offset & ~PackIndexV2.IS_O64));  							offset = NB.DecodeUInt64(this._enclosing.offset64' idx);  						}  						this.entry.offset = offset;  						this.levelTwo += Constants.OBJECT_ID_LENGTH / 4;  						this.returnedNumber++;  						return this.entry;  					}  					this.levelTwo = 0;  				}
Magic Number,NGit.Storage.File,EntriesIteratorV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,Next,The following statement contains a magic number: for (; this.levelOne < this._enclosing.names.Length; this.levelOne++)  				{  					if (this.levelTwo < this._enclosing.names[this.levelOne].Length)  					{  						int idx = this.levelTwo / (Constants.OBJECT_ID_LENGTH / 4) * 4;  						long offset = NB.DecodeUInt32(this._enclosing.offset32[this.levelOne]' idx);  						if ((offset & PackIndexV2.IS_O64) != 0)  						{  							idx = (8 * (int)(offset & ~PackIndexV2.IS_O64));  							offset = NB.DecodeUInt64(this._enclosing.offset64' idx);  						}  						this.entry.offset = offset;  						this.levelTwo += Constants.OBJECT_ID_LENGTH / 4;  						this.returnedNumber++;  						return this.entry;  					}  					this.levelTwo = 0;  				}
Magic Number,NGit.Storage.File,_MutableEntry_291,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexV2.cs,EnsureId,The following statement contains a magic number: this.idBuffer.FromRaw(this._enclosing._enclosing.names[this._enclosing.levelOne]'   						this._enclosing.levelTwo - Constants.OBJECT_ID_LENGTH / 4);
Magic Number,NGit.Storage.File,PackIndexWriter,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriter.cs,CreateOldestPossible,The following statement contains a magic number: foreach (PackedObjectInfo oe in objs)  			{  				switch (version)  				{  					case 1:  					{  						if (PackIndexWriterV1.CanStore(oe))  						{  							continue;  						}  						version = 2;  						goto case 2;  					}    					case 2:  					{  						goto LOOP_break;  					}  				}  			}
Magic Number,NGit.Storage.File,PackIndexWriter,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriter.cs,CreateOldestPossible,The following statement contains a magic number: foreach (PackedObjectInfo oe in objs)  			{  				switch (version)  				{  					case 1:  					{  						if (PackIndexWriterV1.CanStore(oe))  						{  							continue;  						}  						version = 2;  						goto case 2;  					}    					case 2:  					{  						goto LOOP_break;  					}  				}  			}
Magic Number,NGit.Storage.File,PackIndexWriter,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriter.cs,CreateOldestPossible,The following statement contains a magic number: foreach (PackedObjectInfo oe in objs)  			{  				switch (version)  				{  					case 1:  					{  						if (PackIndexWriterV1.CanStore(oe))  						{  							continue;  						}  						version = 2;  						goto case 2;  					}    					case 2:  					{  						goto LOOP_break;  					}  				}  			}
Magic Number,NGit.Storage.File,PackIndexWriter,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriter.cs,CreateVersion,The following statement contains a magic number: switch (version)  			{  				case 1:  				{  					return new PackIndexWriterV1(dst);  				}    				case 2:  				{  					return new PackIndexWriterV2(dst);  				}    				default:  				{  					throw new ArgumentException(MessageFormat.Format(JGitText.Get().unsupportedPackIndexVersion  						' Sharpen.Extensions.ValueOf(version)));  				}  			}
Magic Number,NGit.Storage.File,PackIndexWriter,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriter.cs,PackIndexWriter,The following statement contains a magic number: tmp = new byte[4 + Constants.OBJECT_ID_LENGTH];
Magic Number,NGit.Storage.File,PackIndexWriter,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriter.cs,WriteTOC,The following statement contains a magic number: @out.Write(tmp' 0' 4);
Magic Number,NGit.Storage.File,PackIndexWriter,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriter.cs,WriteFanOutTable,The following statement contains a magic number: int[] fanout = new int[256];
Magic Number,NGit.Storage.File,PackIndexWriter,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriter.cs,WriteFanOutTable,The following statement contains a magic number: for (int i = 1; i < 256; i++)  			{  				fanout[i] += fanout[i - 1];  			}
Magic Number,NGit.Storage.File,PackIndexWriter,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriter.cs,WriteFanOutTable,The following statement contains a magic number: foreach (int n in fanout)  			{  				NB.EncodeInt32(tmp' 0' n);  				@out.Write(tmp' 0' 4);  			}
Magic Number,NGit.Storage.File,PackIndexWriterV1,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriterV1.cs,WriteImpl,The following statement contains a magic number: foreach (PackedObjectInfo oe in entries)  			{  				if (!CanStore(oe))  				{  					throw new IOException(JGitText.Get().packTooLargeForIndexVersion1);  				}  				NB.EncodeInt32(tmp' 0' (int)oe.GetOffset());  				oe.CopyRawTo(tmp' 4);  				@out.Write(tmp);  			}
Magic Number,NGit.Storage.File,PackIndexWriterV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriterV2.cs,WriteImpl,The following statement contains a magic number: WriteTOC(2);
Magic Number,NGit.Storage.File,PackIndexWriterV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriterV2.cs,WriteCRCs,The following statement contains a magic number: foreach (PackedObjectInfo oe in entries)  			{  				NB.EncodeInt32(tmp' 0' oe.GetCRC());  				@out.Write(tmp' 0' 4);  			}
Magic Number,NGit.Storage.File,PackIndexWriterV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriterV2.cs,WriteOffset32,The following statement contains a magic number: foreach (PackedObjectInfo oe in entries)  			{  				long o = oe.GetOffset();  				if (o <= MAX_OFFSET_32)  				{  					NB.EncodeInt32(tmp' 0' (int)o);  				}  				else  				{  					NB.EncodeInt32(tmp' 0' IS_OFFSET_64 | o64++);  				}  				@out.Write(tmp' 0' 4);  			}
Magic Number,NGit.Storage.File,PackIndexWriterV2,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriterV2.cs,WriteOffset64,The following statement contains a magic number: foreach (PackedObjectInfo oe in entries)  			{  				long o = oe.GetOffset();  				if (MAX_OFFSET_32 < o)  				{  					NB.EncodeInt64(tmp' 0' o);  					@out.Write(tmp' 0' 8);  				}  			}
Magic Number,NGit.Storage.File,PackLock,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackLock.cs,PackLock,The following statement contains a magic number: keepFile = new FilePath(p' Sharpen.Runtime.Substring(n' 0' n.Length - 5) + ".keep"  				);
Magic Number,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,Delete,The following statement contains a magic number: int levels = LevelsIn(name) - 2;
Magic Number,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,Pack,The following statement contains a magic number: try  			{  				RefDirectory.PackedRefList packed = GetPackedRefs();  				RefList<Ref> cur = ReadPackedRefs();  				// Iterate over all refs to be packed  				foreach (string refName in refs)  				{  					Ref @ref = ReadRef(refName' cur);  					if (@ref.IsSymbolic())  					{  						continue;  					}  					// can't pack symbolic refs  					// Add/Update it to packed-refs  					int idx = cur.Find(refName);  					if (idx >= 0)  					{  						cur = cur.Set(idx' PeeledPackedRef(@ref));  					}  					else  					{  						cur = cur.Add(idx' PeeledPackedRef(@ref));  					}  				}  				// The new content for packed-refs is collected. Persist it.  				CommitPackedRefs(lck' cur' packed);  				// Now delete the loose refs which are now packed  				foreach (string refName_1 in refs)  				{  					// Lock the loose ref  					FilePath refFile = FileFor(refName_1);  					if (!refFile.Exists())  					{  						continue;  					}  					LockFile rLck = new LockFile(refFile' parent.FileSystem);  					if (!rLck.Lock())  					{  						continue;  					}  					try  					{  						RefDirectory.LooseRef currentLooseRef = ScanRef(null' refName_1);  						if (currentLooseRef == null || currentLooseRef.IsSymbolic())  						{  							continue;  						}  						Ref packedRef = cur.Get(refName_1);  						ObjectId clr_oid = currentLooseRef.GetObjectId();  						if (clr_oid != null && clr_oid.Equals(packedRef.GetObjectId()))  						{  							RefList<RefDirectory.LooseRef> curLoose;  							RefList<RefDirectory.LooseRef> newLoose;  							do  							{  								curLoose = looseRefs.Get();  								int idx = curLoose.Find(refName_1);  								if (idx < 0)  								{  									break;  								}  								newLoose = curLoose.Remove(idx);  							}  							while (!looseRefs.CompareAndSet(curLoose' newLoose));  							int levels = LevelsIn(refName_1) - 2;  							Delete(FileFor(refName_1)' levels);  						}  					}  					finally  					{  						rLck.Unlock();  					}  				}  			}  			finally  			{  				// Don't fire refsChanged. The refs have not change' only their  				// storage.  				lck.Unlock();  			}
Magic Number,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,ScanRef,The following statement contains a magic number: int limit = 4096;
Magic Number,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,ScanRef,The following statement contains a magic number: if (IsSymRef(buf' n))  			{  				if (n == limit)  				{  					return null;  				}  				// possibly truncated ref  				// trim trailing whitespace  				while (0 < n && char.IsWhiteSpace((char)buf[n - 1]))  				{  					n--;  				}  				if (n < 6)  				{  					string content = RawParseUtils.Decode(buf' 0' n);  					throw new IOException(MessageFormat.Format(JGitText.Get().notARef' name' content)  						);  				}  				string target = RawParseUtils.Decode(buf' 5' n);  				if (@ref != null && @ref.IsSymbolic() && @ref.GetTarget().GetName().Equals(target  					))  				{  					currentSnapshot.SetClean(otherSnapshot);  					return @ref;  				}  				return NewSymbolicRef(otherSnapshot' name' target);  			}
Magic Number,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,ScanRef,The following statement contains a magic number: if (IsSymRef(buf' n))  			{  				if (n == limit)  				{  					return null;  				}  				// possibly truncated ref  				// trim trailing whitespace  				while (0 < n && char.IsWhiteSpace((char)buf[n - 1]))  				{  					n--;  				}  				if (n < 6)  				{  					string content = RawParseUtils.Decode(buf' 0' n);  					throw new IOException(MessageFormat.Format(JGitText.Get().notARef' name' content)  						);  				}  				string target = RawParseUtils.Decode(buf' 5' n);  				if (@ref != null && @ref.IsSymbolic() && @ref.GetTarget().GetName().Equals(target  					))  				{  					currentSnapshot.SetClean(otherSnapshot);  					return @ref;  				}  				return NewSymbolicRef(otherSnapshot' name' target);  			}
Magic Number,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,IsSymRef,The following statement contains a magic number: if (n < 6)  			{  				return false;  			}
Magic Number,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,IsSymRef,The following statement contains a magic number: return buf[0] == 'r' && buf[1] == 'e' && buf[2] == 'f' && buf[3] == ':' && buf[4]  				 == ' ';
Magic Number,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,IsSymRef,The following statement contains a magic number: return buf[0] == 'r' && buf[1] == 'e' && buf[2] == 'f' && buf[3] == ':' && buf[4]  				 == ' ';
Magic Number,NGit.Storage.File,RefDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectory.cs,IsSymRef,The following statement contains a magic number: return buf[0] == 'r' && buf[1] == 'e' && buf[2] == 'f' && buf[3] == ':' && buf[4]  				 == ' ';
Magic Number,NGit.Storage.File,RefDirectoryRename,C:\repos\mono_ngit\NGit\NGit.Storage.File\RefDirectoryRename.cs,RenameLog,The following statement contains a magic number: try  			{  				int levels = RefDirectory.LevelsIn(src.GetName()) - 2;  				RefDirectory.Delete(srcLog' levels);  				return true;  			}  			catch (IOException)  			{  				Rename(dstLog' srcLog);  				return false;  			}
Magic Number,NGit.Storage.File,ReflogReader,C:\repos\mono_ngit\NGit\NGit.Storage.File\ReflogReader.cs,GetReverseEntry,The following statement contains a magic number: while (rs >= 0)  			{  				rs = RawParseUtils.PrevLF(log' rs);  				if (number == current)  				{  					return new ReflogEntry(log' rs < 0 ? 0 : rs + 2);  				}  				current++;  			}
Magic Number,NGit.Storage.File,ReflogReader,C:\repos\mono_ngit\NGit\NGit.Storage.File\ReflogReader.cs,GetReverseEntries,The following statement contains a magic number: while (rs >= 0 && max-- > 0)  			{  				rs = RawParseUtils.PrevLF(log' rs);  				ReflogEntry entry = new ReflogEntry(log' rs < 0 ? 0 : rs + 2);  				ret.AddItem(entry);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Open,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					int type = Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectGarbageAfterSize  							);  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						byte[] data = new byte[(int)size];  						int n = avail - p.value;  						if (n > 0)  						{  							System.Array.Copy(hdr' p.value' data' 0' n);  						}  						IOUtil.ReadFully(zIn' data' n' data.Length - n);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					int type = (c >> 4) & 7;  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (type)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							// Acceptable types for a loose object.  							break;  						}    						default:  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						Inflater inf = wc.Inflater();  						InputStream zIn = Inflate(@in' inf);  						byte[] data = new byte[(int)size];  						IOUtil.ReadFully(zIn' data' 0' data.Length);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Open,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					int type = Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectGarbageAfterSize  							);  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						byte[] data = new byte[(int)size];  						int n = avail - p.value;  						if (n > 0)  						{  							System.Array.Copy(hdr' p.value' data' 0' n);  						}  						IOUtil.ReadFully(zIn' data' n' data.Length - n);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					int type = (c >> 4) & 7;  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (type)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							// Acceptable types for a loose object.  							break;  						}    						default:  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						Inflater inf = wc.Inflater();  						InputStream zIn = Inflate(@in' inf);  						byte[] data = new byte[(int)size];  						IOUtil.ReadFully(zIn' data' 0' data.Length);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Open,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					int type = Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectGarbageAfterSize  							);  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						byte[] data = new byte[(int)size];  						int n = avail - p.value;  						if (n > 0)  						{  							System.Array.Copy(hdr' p.value' data' 0' n);  						}  						IOUtil.ReadFully(zIn' data' n' data.Length - n);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					int type = (c >> 4) & 7;  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (type)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							// Acceptable types for a loose object.  							break;  						}    						default:  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						Inflater inf = wc.Inflater();  						InputStream zIn = Inflate(@in' inf);  						byte[] data = new byte[(int)size];  						IOUtil.ReadFully(zIn' data' 0' data.Length);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Open,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					int type = Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectGarbageAfterSize  							);  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						byte[] data = new byte[(int)size];  						int n = avail - p.value;  						if (n > 0)  						{  							System.Array.Copy(hdr' p.value' data' 0' n);  						}  						IOUtil.ReadFully(zIn' data' n' data.Length - n);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					int type = (c >> 4) & 7;  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (type)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							// Acceptable types for a loose object.  							break;  						}    						default:  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						Inflater inf = wc.Inflater();  						InputStream zIn = Inflate(@in' inf);  						byte[] data = new byte[(int)size];  						IOUtil.ReadFully(zIn' data' 0' data.Length);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Open,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					int type = Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectGarbageAfterSize  							);  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						byte[] data = new byte[(int)size];  						int n = avail - p.value;  						if (n > 0)  						{  							System.Array.Copy(hdr' p.value' data' 0' n);  						}  						IOUtil.ReadFully(zIn' data' n' data.Length - n);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					int type = (c >> 4) & 7;  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (type)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							// Acceptable types for a loose object.  							break;  						}    						default:  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						Inflater inf = wc.Inflater();  						InputStream zIn = Inflate(@in' inf);  						byte[] data = new byte[(int)size];  						IOUtil.ReadFully(zIn' data' 0' data.Length);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Open,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					int type = Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectGarbageAfterSize  							);  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						byte[] data = new byte[(int)size];  						int n = avail - p.value;  						if (n > 0)  						{  							System.Array.Copy(hdr' p.value' data' 0' n);  						}  						IOUtil.ReadFully(zIn' data' n' data.Length - n);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					int type = (c >> 4) & 7;  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (type)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							// Acceptable types for a loose object.  							break;  						}    						default:  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						Inflater inf = wc.Inflater();  						InputStream zIn = Inflate(@in' inf);  						byte[] data = new byte[(int)size];  						IOUtil.ReadFully(zIn' data' 0' data.Length);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Open,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					int type = Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectGarbageAfterSize  							);  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						byte[] data = new byte[(int)size];  						int n = avail - p.value;  						if (n > 0)  						{  							System.Array.Copy(hdr' p.value' data' 0' n);  						}  						IOUtil.ReadFully(zIn' data' n' data.Length - n);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					int type = (c >> 4) & 7;  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (type)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							// Acceptable types for a loose object.  							break;  						}    						default:  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						Inflater inf = wc.Inflater();  						InputStream zIn = Inflate(@in' inf);  						byte[] data = new byte[(int)size];  						IOUtil.ReadFully(zIn' data' 0' data.Length);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Open,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					int type = Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectGarbageAfterSize  							);  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						byte[] data = new byte[(int)size];  						int n = avail - p.value;  						if (n > 0)  						{  							System.Array.Copy(hdr' p.value' data' 0' n);  						}  						IOUtil.ReadFully(zIn' data' n' data.Length - n);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					int type = (c >> 4) & 7;  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (type)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							// Acceptable types for a loose object.  							break;  						}    						default:  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						Inflater inf = wc.Inflater();  						InputStream zIn = Inflate(@in' inf);  						byte[] data = new byte[(int)size];  						IOUtil.ReadFully(zIn' data' 0' data.Length);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Open,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					int type = Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectGarbageAfterSize  							);  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						byte[] data = new byte[(int)size];  						int n = avail - p.value;  						if (n > 0)  						{  							System.Array.Copy(hdr' p.value' data' 0' n);  						}  						IOUtil.ReadFully(zIn' data' n' data.Length - n);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					int type = (c >> 4) & 7;  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (type)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							// Acceptable types for a loose object.  							break;  						}    						default:  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						Inflater inf = wc.Inflater();  						InputStream zIn = Inflate(@in' inf);  						byte[] data = new byte[(int)size];  						IOUtil.ReadFully(zIn' data' 0' data.Length);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Open,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					int type = Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectGarbageAfterSize  							);  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						byte[] data = new byte[(int)size];  						int n = avail - p.value;  						if (n > 0)  						{  							System.Array.Copy(hdr' p.value' data' 0' n);  						}  						IOUtil.ReadFully(zIn' data' n' data.Length - n);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					int type = (c >> 4) & 7;  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (type)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							// Acceptable types for a loose object.  							break;  						}    						default:  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						Inflater inf = wc.Inflater();  						InputStream zIn = Inflate(@in' inf);  						byte[] data = new byte[(int)size];  						IOUtil.ReadFully(zIn' data' 0' data.Length);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Open,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					int type = Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectGarbageAfterSize  							);  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						byte[] data = new byte[(int)size];  						int n = avail - p.value;  						if (n > 0)  						{  							System.Array.Copy(hdr' p.value' data' 0' n);  						}  						IOUtil.ReadFully(zIn' data' n' data.Length - n);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					int type = (c >> 4) & 7;  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (type)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							// Acceptable types for a loose object.  							break;  						}    						default:  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						Inflater inf = wc.Inflater();  						InputStream zIn = Inflate(@in' inf);  						byte[] data = new byte[(int)size];  						IOUtil.ReadFully(zIn' data' 0' data.Length);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Open,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					int type = Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectGarbageAfterSize  							);  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						byte[] data = new byte[(int)size];  						int n = avail - p.value;  						if (n > 0)  						{  							System.Array.Copy(hdr' p.value' data' 0' n);  						}  						IOUtil.ReadFully(zIn' data' n' data.Length - n);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					int type = (c >> 4) & 7;  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					switch (type)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  						{  							// Acceptable types for a loose object.  							break;  						}    						default:  						{  							throw new CorruptObjectException(id' JGitText.Get().corruptObjectInvalidType);  						}  					}  					if (path == null && int.MaxValue < size)  					{  						LargeObjectException.ExceedsByteArrayLimit e;  						e = new LargeObjectException.ExceedsByteArrayLimit();  						e.SetObjectId(id);  						throw e;  					}  					if (size < wc.GetStreamFileThreshold() || path == null)  					{  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						Inflater inf = wc.Inflater();  						InputStream zIn = Inflate(@in' inf);  						byte[] data = new byte[(int)size];  						IOUtil.ReadFully(zIn' data' 0' data.Length);  						CheckValidEndOfStream(@in' inf' id' hdr);  						return new ObjectLoader.SmallObject(type' data);  					}  					return new UnpackedObject.LargeObject(type' size' path' id' wc.db);  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,GetSize,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					return size;  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					return size;  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,GetSize,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					return size;  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					return size;  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,GetSize,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					return size;  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					return size;  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,GetSize,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					return size;  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					return size;  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,GetSize,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					return size;  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					return size;  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,GetSize,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					return size;  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					return size;  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,GetSize,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					return size;  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					return size;  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,GetSize,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					return size;  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					return size;  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,GetSize,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					return size;  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					return size;  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,GetSize,The following statement contains a magic number: try  			{  				@in = Buffer(@in);  				@in.Mark(20);  				byte[] hdr = new byte[64];  				IOUtil.ReadFully(@in' hdr' 0' 2);  				if (IsStandardFormat(hdr))  				{  					@in.Reset();  					Inflater inf = wc.Inflater();  					InputStream zIn = Inflate(@in' inf);  					int avail = ReadSome(zIn' hdr' 0' 64);  					if (avail < 5)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNoHeader);  					}  					MutableInteger p = new MutableInteger();  					Constants.DecodeTypeString(id' hdr' unchecked((byte)' ')' p);  					long size = RawParseUtils.ParseLongBase10(hdr' p.value' p);  					if (size < 0)  					{  						throw new CorruptObjectException(id' JGitText.Get().corruptObjectNegativeSize);  					}  					return size;  				}  				else  				{  					ReadSome(@in' hdr' 2' 18);  					int c = hdr[0] & unchecked((int)(0xff));  					long size = c & 15;  					int shift = 4;  					int p = 1;  					while ((c & unchecked((int)(0x80))) != 0)  					{  						c = hdr[p++] & unchecked((int)(0xff));  						size += ((long)(c & unchecked((int)(0x7f)))) << shift;  						shift += 7;  					}  					return size;  				}  			}  			catch (SharpZipBaseException)  			{  				throw new CorruptObjectException(id' JGitText.Get().corruptObjectBadStream);  			}
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,IsStandardFormat,The following statement contains a magic number: return (fb & unchecked((int)(0x8f))) == unchecked((int)(0x08)) && (((fb << 8) | hdr  				[1] & unchecked((int)(0xff))) % 31) == 0;
Magic Number,NGit.Storage.File,UnpackedObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,IsStandardFormat,The following statement contains a magic number: return (fb & unchecked((int)(0x8f))) == unchecked((int)(0x08)) && (((fb << 8) | hdr  				[1] & unchecked((int)(0xff))) % 31) == 0;
Magic Number,NGit.Storage.File,_InflaterInputStream_307,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,Close,The following statement contains a magic number: try  				{  					if (this.remaining <= 0)  					{  						UnpackedObject.CheckValidEndOfStream(this.@in' this.inf' id' new byte[64]);  					}  				}  				finally  				{  					InflaterCache.Release(this.inf);  					base.Close();  				}
Magic Number,NGit.Storage.File,LargeObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,OpenStream,The following statement contains a magic number: try  				{  					byte[] hdr = new byte[64];  					@in.Mark(20);  					IOUtil.ReadFully(@in' hdr' 0' 2);  					if (IsStandardFormat(hdr))  					{  						@in.Reset();  						@in = Buffer(Inflate(@in' size' id));  						while (0 < @in.Read())  						{  							continue;  						}  					}  					else  					{  						ReadSome(@in' hdr' 2' 18);  						int c = hdr[0] & unchecked((int)(0xff));  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = hdr[p++] & unchecked((int)(0xff));  						}  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						@in = Buffer(Inflate(@in' size' id));  					}  					ok = true;  					return new ObjectStream.Filter(type' size' @in);  				}  				finally  				{  					if (!ok)  					{  						@in.Close();  					}  				}
Magic Number,NGit.Storage.File,LargeObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,OpenStream,The following statement contains a magic number: try  				{  					byte[] hdr = new byte[64];  					@in.Mark(20);  					IOUtil.ReadFully(@in' hdr' 0' 2);  					if (IsStandardFormat(hdr))  					{  						@in.Reset();  						@in = Buffer(Inflate(@in' size' id));  						while (0 < @in.Read())  						{  							continue;  						}  					}  					else  					{  						ReadSome(@in' hdr' 2' 18);  						int c = hdr[0] & unchecked((int)(0xff));  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = hdr[p++] & unchecked((int)(0xff));  						}  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						@in = Buffer(Inflate(@in' size' id));  					}  					ok = true;  					return new ObjectStream.Filter(type' size' @in);  				}  				finally  				{  					if (!ok)  					{  						@in.Close();  					}  				}
Magic Number,NGit.Storage.File,LargeObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,OpenStream,The following statement contains a magic number: try  				{  					byte[] hdr = new byte[64];  					@in.Mark(20);  					IOUtil.ReadFully(@in' hdr' 0' 2);  					if (IsStandardFormat(hdr))  					{  						@in.Reset();  						@in = Buffer(Inflate(@in' size' id));  						while (0 < @in.Read())  						{  							continue;  						}  					}  					else  					{  						ReadSome(@in' hdr' 2' 18);  						int c = hdr[0] & unchecked((int)(0xff));  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = hdr[p++] & unchecked((int)(0xff));  						}  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						@in = Buffer(Inflate(@in' size' id));  					}  					ok = true;  					return new ObjectStream.Filter(type' size' @in);  				}  				finally  				{  					if (!ok)  					{  						@in.Close();  					}  				}
Magic Number,NGit.Storage.File,LargeObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,OpenStream,The following statement contains a magic number: try  				{  					byte[] hdr = new byte[64];  					@in.Mark(20);  					IOUtil.ReadFully(@in' hdr' 0' 2);  					if (IsStandardFormat(hdr))  					{  						@in.Reset();  						@in = Buffer(Inflate(@in' size' id));  						while (0 < @in.Read())  						{  							continue;  						}  					}  					else  					{  						ReadSome(@in' hdr' 2' 18);  						int c = hdr[0] & unchecked((int)(0xff));  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = hdr[p++] & unchecked((int)(0xff));  						}  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						@in = Buffer(Inflate(@in' size' id));  					}  					ok = true;  					return new ObjectStream.Filter(type' size' @in);  				}  				finally  				{  					if (!ok)  					{  						@in.Close();  					}  				}
Magic Number,NGit.Storage.File,LargeObject,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObject.cs,OpenStream,The following statement contains a magic number: try  				{  					byte[] hdr = new byte[64];  					@in.Mark(20);  					IOUtil.ReadFully(@in' hdr' 0' 2);  					if (IsStandardFormat(hdr))  					{  						@in.Reset();  						@in = Buffer(Inflate(@in' size' id));  						while (0 < @in.Read())  						{  							continue;  						}  					}  					else  					{  						ReadSome(@in' hdr' 2' 18);  						int c = hdr[0] & unchecked((int)(0xff));  						int p = 1;  						while ((c & unchecked((int)(0x80))) != 0)  						{  							c = hdr[p++] & unchecked((int)(0xff));  						}  						@in.Reset();  						IOUtil.SkipFully(@in' p);  						@in = Buffer(Inflate(@in' size' id));  					}  					ok = true;  					return new ObjectStream.Filter(type' size' @in);  				}  				finally  				{  					if (!ok)  					{  						@in.Close();  					}  				}
Magic Number,NGit.Storage.File,Table,C:\repos\mono_ngit\NGit\NGit.Storage.File\UnpackedObjectCache.cs,Table,The following statement contains a magic number: this.shift = 32 - bits;
Magic Number,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,Bits,The following statement contains a magic number: if (newSize < 4096)  			{  				throw new ArgumentException(JGitText.Get().invalidWindowSize);  			}
Magic Number,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,WindowCache,The following statement contains a magic number: int eb = (int)(tableSize * .1);
Magic Number,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,WindowCache,The following statement contains a magic number: if (64 < eb)  			{  				eb = 64;  			}  			else  			{  				if (eb < 4)  				{  					eb = 4;  				}  			}
Magic Number,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,WindowCache,The following statement contains a magic number: if (64 < eb)  			{  				eb = 64;  			}  			else  			{  				if (eb < 4)  				{  					eb = 4;  				}  			}
Magic Number,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,WindowCache,The following statement contains a magic number: if (64 < eb)  			{  				eb = 64;  			}  			else  			{  				if (eb < 4)  				{  					eb = 4;  				}  			}
Magic Number,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,WindowCache,The following statement contains a magic number: if (64 < eb)  			{  				eb = 64;  			}  			else  			{  				if (eb < 4)  				{  					eb = 4;  				}  			}
Magic Number,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,TableSize,The following statement contains a magic number: return (int)Math.Min(5 * (limit / wsz) / 2' 2000000000);
Magic Number,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,TableSize,The following statement contains a magic number: return (int)Math.Min(5 * (limit / wsz) / 2' 2000000000);
Magic Number,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,TableSize,The following statement contains a magic number: return (int)Math.Min(5 * (limit / wsz) / 2' 2000000000);
Magic Number,NGit.Storage.File,WindowCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCache.cs,LockCount,The following statement contains a magic number: return Math.Max(cfg.GetPackedGitOpenFiles()' 32);
Magic Number,NGit.Storage.File,WindowCacheConfig,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCacheConfig.cs,WindowCacheConfig,The following statement contains a magic number: packedGitOpenFiles = 128;
Magic Number,NGit.Storage.File,WindowCacheConfig,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCacheConfig.cs,WindowCacheConfig,The following statement contains a magic number: packedGitLimit = 10 * MB;
Magic Number,NGit.Storage.File,WindowCacheConfig,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCacheConfig.cs,WindowCacheConfig,The following statement contains a magic number: packedGitWindowSize = 8 * KB;
Magic Number,NGit.Storage.File,WindowCacheConfig,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCacheConfig.cs,WindowCacheConfig,The following statement contains a magic number: deltaBaseCacheLimit = 10 * MB;
Magic Number,NGit.Storage.File,WindowCacheConfig,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCacheConfig.cs,FromConfig,The following statement contains a magic number: sft = Math.Min(sft' maxMem / 4);
Magic Number,NGit.Storage.File,WindowCursor,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCursor.cs,CopyPackAsIs,The following statement contains a magic number: if (validate)  			{  				md = Constants.NewMessageDigest();  				byte[] buf = @out.GetCopyBuffer();  				Pin(pack' 0);  				if (window.Copy(0' buf' 0' 12) != 12)  				{  					pack.SetInvalid();  					throw new IOException(JGitText.Get().packfileIsTruncated);  				}  				md.Update(buf' 0' 12);  			}
Magic Number,NGit.Storage.File,WindowCursor,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCursor.cs,CopyPackAsIs,The following statement contains a magic number: if (validate)  			{  				md = Constants.NewMessageDigest();  				byte[] buf = @out.GetCopyBuffer();  				Pin(pack' 0);  				if (window.Copy(0' buf' 0' 12) != 12)  				{  					pack.SetInvalid();  					throw new IOException(JGitText.Get().packfileIsTruncated);  				}  				md.Update(buf' 0' 12);  			}
Magic Number,NGit.Storage.File,WindowCursor,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCursor.cs,CopyPackAsIs,The following statement contains a magic number: if (validate)  			{  				md = Constants.NewMessageDigest();  				byte[] buf = @out.GetCopyBuffer();  				Pin(pack' 0);  				if (window.Copy(0' buf' 0' 12) != 12)  				{  					pack.SetInvalid();  					throw new IOException(JGitText.Get().packfileIsTruncated);  				}  				md.Update(buf' 0' 12);  			}
Magic Number,NGit.Storage.File,WindowCursor,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCursor.cs,CopyPackAsIs,The following statement contains a magic number: long position = 12;
Magic Number,NGit.Storage.File,WindowCursor,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCursor.cs,CopyPackAsIs,The following statement contains a magic number: long remaining = length - (12 + 20);
Magic Number,NGit.Storage.File,WindowCursor,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCursor.cs,CopyPackAsIs,The following statement contains a magic number: long remaining = length - (12 + 20);
Magic Number,NGit.Storage.File,WindowCursor,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCursor.cs,CopyPackAsIs,The following statement contains a magic number: if (md != null)  			{  				byte[] buf = new byte[20];  				byte[] actHash = md.Digest();  				Pin(pack' position);  				if (window.Copy(position' buf' 0' 20) != 20)  				{  					pack.SetInvalid();  					throw new IOException(JGitText.Get().packfileIsTruncated);  				}  				if (!Arrays.Equals(actHash' buf))  				{  					pack.SetInvalid();  					throw new IOException(MessageFormat.Format(JGitText.Get().packfileCorruptionDetected  						' pack.GetPackFile().GetPath()));  				}  			}
Magic Number,NGit.Storage.File,WindowCursor,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCursor.cs,CopyPackAsIs,The following statement contains a magic number: if (md != null)  			{  				byte[] buf = new byte[20];  				byte[] actHash = md.Digest();  				Pin(pack' position);  				if (window.Copy(position' buf' 0' 20) != 20)  				{  					pack.SetInvalid();  					throw new IOException(JGitText.Get().packfileIsTruncated);  				}  				if (!Arrays.Equals(actHash' buf))  				{  					pack.SetInvalid();  					throw new IOException(MessageFormat.Format(JGitText.Get().packfileCorruptionDetected  						' pack.GetPackFile().GetPath()));  				}  			}
Magic Number,NGit.Storage.File,WindowCursor,C:\repos\mono_ngit\NGit\NGit.Storage.File\WindowCursor.cs,CopyPackAsIs,The following statement contains a magic number: if (md != null)  			{  				byte[] buf = new byte[20];  				byte[] actHash = md.Digest();  				Pin(pack' position);  				if (window.Copy(position' buf' 0' 20) != 20)  				{  					pack.SetInvalid();  					throw new IOException(JGitText.Get().packfileIsTruncated);  				}  				if (!Arrays.Equals(actHash' buf))  				{  					pack.SetInvalid();  					throw new IOException(MessageFormat.Format(JGitText.Get().packfileCorruptionDetected  						' pack.GetPackFile().GetPath()));  				}  			}
Magic Number,NGit.Storage.File,DeltaBaseCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\DeltaBaseCache.cs,Hash,The following statement contains a magic number: return (int)(((uint)(((int)position) << 22)) >> 22);
Magic Number,NGit.Storage.File,DeltaBaseCache,C:\repos\mono_ngit\NGit\NGit.Storage.File\DeltaBaseCache.cs,Hash,The following statement contains a magic number: return (int)(((uint)(((int)position) << 22)) >> 22);
Magic Number,NGit.Storage.File,FileSnapshot,C:\repos\mono_ngit\NGit\NGit.Storage.File\FileSnapshot.cs,NotRacyClean,The following statement contains a magic number: return read - lastModified > 2500;
Magic Number,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,OnAppendBase,The following statement contains a magic number: buf[len++] = unchecked((byte)((typeCode << 4) | sz & 15));
Magic Number,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,OnAppendBase,The following statement contains a magic number: buf[len++] = unchecked((byte)((typeCode << 4) | sz & 15));
Magic Number,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,OnAppendBase,The following statement contains a magic number: sz = (int)(((uint)sz) >> 4);
Magic Number,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,OnAppendBase,The following statement contains a magic number: while (sz > 0)  			{  				buf[len - 1] |= unchecked((int)(0x80));  				buf[len++] = unchecked((byte)(sz & unchecked((int)(0x7f))));  				sz = (int)(((uint)sz) >> 7);  			}
Magic Number,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,OnEndThinPack,The following statement contains a magic number: @out.ReadFully(buf' 0' 12);
Magic Number,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,OnEndThinPack,The following statement contains a magic number: origDigest.Update(buf' 0' 12);
Magic Number,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,OnEndThinPack,The following statement contains a magic number: origRemaining -= 12;
Magic Number,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,OnEndThinPack,The following statement contains a magic number: NB.EncodeInt32(buf' 8' GetObjectCount());
Magic Number,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,OnEndThinPack,The following statement contains a magic number: @out.Write(buf' 0' 12);
Magic Number,NGit.Storage.File,ObjectDirectoryPackParser,C:\repos\mono_ngit\NGit\NGit.Storage.File\ObjectDirectoryPackParser.cs,OnEndThinPack,The following statement contains a magic number: packDigest.Update(buf' 0' 12);
Magic Number,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,Gc,The following statement contains a magic number: pm.Start(6);
Magic Number,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,PrunePacked,The following statement contains a magic number: if (fanout != null && fanout.Length > 0)  			{  				pm.BeginTask(JGitText.Get().pruneLoosePackedObjects' fanout.Length);  				try  				{  					foreach (string d in fanout)  					{  						pm.Update(1);  						if (d.Length != 2)  						{  							continue;  						}  						string[] entries = new FilePath(objects' d).List();  						if (entries == null)  						{  							continue;  						}  						foreach (string e in entries)  						{  							if (e.Length != Constants.OBJECT_ID_STRING_LENGTH - 2)  							{  								continue;  							}  							ObjectId id;  							try  							{  								id = ObjectId.FromString(d + e);  							}  							catch (ArgumentException)  							{  								// ignoring the file that does not represent loose  								// object  								continue;  							}  							bool found = false;  							foreach (PackFile p in packs)  							{  								if (p.HasObject(id))  								{  									found = true;  									break;  								}  							}  							if (found)  							{  								FileUtils.Delete(objdb.FileFor(id)' FileUtils.RETRY | FileUtils.SKIP_MISSING | FileUtils  									.IGNORE_ERRORS);  							}  						}  					}  				}  				finally  				{  					pm.EndTask();  				}  			}
Magic Number,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,PrunePacked,The following statement contains a magic number: if (fanout != null && fanout.Length > 0)  			{  				pm.BeginTask(JGitText.Get().pruneLoosePackedObjects' fanout.Length);  				try  				{  					foreach (string d in fanout)  					{  						pm.Update(1);  						if (d.Length != 2)  						{  							continue;  						}  						string[] entries = new FilePath(objects' d).List();  						if (entries == null)  						{  							continue;  						}  						foreach (string e in entries)  						{  							if (e.Length != Constants.OBJECT_ID_STRING_LENGTH - 2)  							{  								continue;  							}  							ObjectId id;  							try  							{  								id = ObjectId.FromString(d + e);  							}  							catch (ArgumentException)  							{  								// ignoring the file that does not represent loose  								// object  								continue;  							}  							bool found = false;  							foreach (PackFile p in packs)  							{  								if (p.HasObject(id))  								{  									found = true;  									break;  								}  							}  							if (found)  							{  								FileUtils.Delete(objdb.FileFor(id)' FileUtils.RETRY | FileUtils.SKIP_MISSING | FileUtils  									.IGNORE_ERRORS);  							}  						}  					}  				}  				finally  				{  					pm.EndTask();  				}  			}
Magic Number,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,Prune,The following statement contains a magic number: if (fanout != null && fanout.Length > 0)  			{  				pm.BeginTask(JGitText.Get().pruneLooseUnreferencedObjects' fanout.Length);  				try  				{  					foreach (string d in fanout)  					{  						pm.Update(1);  						if (d.Length != 2)  						{  							continue;  						}  						FilePath[] entries = new FilePath(objects' d).ListFiles();  						if (entries == null)  						{  							continue;  						}  						foreach (FilePath f in entries)  						{  							string fName = f.GetName();  							if (fName.Length != Constants.OBJECT_ID_STRING_LENGTH - 2)  							{  								continue;  							}  							if (f.LastModified() >= expireDate)  							{  								continue;  							}  							try  							{  								ObjectId id = ObjectId.FromString(d + fName);  								if (objectsToKeep.Contains(id))  								{  									continue;  								}  								if (indexObjects == null)  								{  									indexObjects = ListNonHEADIndexObjects();  								}  								if (indexObjects.Contains(id))  								{  									continue;  								}  								deletionCandidates.Put(id' f);  							}  							catch (ArgumentException)  							{  								// ignoring the file that does not represent loose  								// object  								continue;  							}  						}  					}  				}  				finally  				{  					pm.EndTask();  				}  			}
Magic Number,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,Prune,The following statement contains a magic number: if (fanout != null && fanout.Length > 0)  			{  				pm.BeginTask(JGitText.Get().pruneLooseUnreferencedObjects' fanout.Length);  				try  				{  					foreach (string d in fanout)  					{  						pm.Update(1);  						if (d.Length != 2)  						{  							continue;  						}  						FilePath[] entries = new FilePath(objects' d).ListFiles();  						if (entries == null)  						{  							continue;  						}  						foreach (FilePath f in entries)  						{  							string fName = f.GetName();  							if (fName.Length != Constants.OBJECT_ID_STRING_LENGTH - 2)  							{  								continue;  							}  							if (f.LastModified() >= expireDate)  							{  								continue;  							}  							try  							{  								ObjectId id = ObjectId.FromString(d + fName);  								if (objectsToKeep.Contains(id))  								{  									continue;  								}  								if (indexObjects == null)  								{  									indexObjects = ListNonHEADIndexObjects();  								}  								if (indexObjects.Contains(id))  								{  									continue;  								}  								deletionCandidates.Put(id' f);  							}  							catch (ArgumentException)  							{  								// ignoring the file that does not represent loose  								// object  								continue;  							}  						}  					}  				}  				finally  				{  					pm.EndTask();  				}  			}
Magic Number,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,Repack,The following statement contains a magic number: IList<PackFile> ret = new AList<PackFile>(2);
Magic Number,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,GetStatistics,The following statement contains a magic number: if (fanout != null && fanout.Length > 0)  			{  				foreach (string d in fanout)  				{  					if (d.Length != 2)  					{  						continue;  					}  					FilePath[] entries = new FilePath(objDir' d).ListFiles();  					if (entries == null)  					{  						continue;  					}  					foreach (FilePath f_1 in entries)  					{  						if (f_1.GetName().Length != Constants.OBJECT_ID_STRING_LENGTH - 2)  						{  							continue;  						}  						ret.numberOfLooseObjects++;  						ret.sizeOfLooseObjects += f_1.Length();  					}  				}  			}
Magic Number,NGit.Storage.File,GC,C:\repos\mono_ngit\NGit\NGit.Storage.File\GC.cs,GetStatistics,The following statement contains a magic number: if (fanout != null && fanout.Length > 0)  			{  				foreach (string d in fanout)  				{  					if (d.Length != 2)  					{  						continue;  					}  					FilePath[] entries = new FilePath(objDir' d).ListFiles();  					if (entries == null)  					{  						continue;  					}  					foreach (FilePath f_1 in entries)  					{  						if (f_1.GetName().Length != Constants.OBJECT_ID_STRING_LENGTH - 2)  						{  							continue;  						}  						ret.numberOfLooseObjects++;  						ret.sizeOfLooseObjects += f_1.Length();  					}  				}  			}
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,GetBaseSize,The following statement contains a magic number: do  			{  				c = delta[p++] & unchecked((int)(0xff));  				baseLen |= ((long)(c & unchecked((int)(0x7f)))) << shift;  				shift += 7;  			}  			while ((c & unchecked((int)(0x80))) != 0);
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,GetResultSize,The following statement contains a magic number: do  			{  				c = delta[p++] & unchecked((int)(0xff));  				resLen |= ((long)(c & unchecked((int)(0x7f)))) << shift;  				shift += 7;  			}  			while ((c & unchecked((int)(0x80))) != 0);
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Apply,The following statement contains a magic number: do  			{  				c = delta[deltaPtr++] & unchecked((int)(0xff));  				baseLen |= ((int)(c & unchecked((int)(0x7f)))) << shift;  				shift += 7;  			}  			while ((c & unchecked((int)(0x80))) != 0);
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Apply,The following statement contains a magic number: do  			{  				c = delta[deltaPtr++] & unchecked((int)(0xff));  				resLen |= ((int)(c & unchecked((int)(0x7f)))) << shift;  				shift += 7;  			}  			while ((c & unchecked((int)(0x80))) != 0);
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & unchecked((int)(0xff));  				if ((cmd & unchecked((int)(0x80))) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a length.  					//  					int copyOffset = 0;  					if ((cmd & unchecked((int)(0x01))) != 0)  					{  						copyOffset = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x02))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x04))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if ((cmd & unchecked((int)(0x08))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 24;  					}  					int copySize = 0;  					if ((cmd & unchecked((int)(0x10))) != 0)  					{  						copySize = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x20))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x40))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if (copySize == 0)  					{  						copySize = unchecked((int)(0x10000));  					}  					System.Array.Copy(@base' copyOffset' result' resultPtr' copySize);  					resultPtr += copySize;  				}  				else  				{  					if (cmd != 0)  					{  						// Anything else the data is literal within the delta  						// itself.  						//  						System.Array.Copy(delta' deltaPtr' result' resultPtr' cmd);  						deltaPtr += cmd;  						resultPtr += cmd;  					}  					else  					{  						// cmd == 0 has been reserved for future encoding but  						// for now its not acceptable.  						//  						throw new ArgumentException(JGitText.Get().unsupportedCommand0);  					}  				}  			}
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & unchecked((int)(0xff));  				if ((cmd & unchecked((int)(0x80))) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a length.  					//  					int copyOffset = 0;  					if ((cmd & unchecked((int)(0x01))) != 0)  					{  						copyOffset = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x02))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x04))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if ((cmd & unchecked((int)(0x08))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 24;  					}  					int copySize = 0;  					if ((cmd & unchecked((int)(0x10))) != 0)  					{  						copySize = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x20))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x40))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if (copySize == 0)  					{  						copySize = unchecked((int)(0x10000));  					}  					System.Array.Copy(@base' copyOffset' result' resultPtr' copySize);  					resultPtr += copySize;  				}  				else  				{  					if (cmd != 0)  					{  						// Anything else the data is literal within the delta  						// itself.  						//  						System.Array.Copy(delta' deltaPtr' result' resultPtr' cmd);  						deltaPtr += cmd;  						resultPtr += cmd;  					}  					else  					{  						// cmd == 0 has been reserved for future encoding but  						// for now its not acceptable.  						//  						throw new ArgumentException(JGitText.Get().unsupportedCommand0);  					}  				}  			}
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & unchecked((int)(0xff));  				if ((cmd & unchecked((int)(0x80))) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a length.  					//  					int copyOffset = 0;  					if ((cmd & unchecked((int)(0x01))) != 0)  					{  						copyOffset = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x02))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x04))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if ((cmd & unchecked((int)(0x08))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 24;  					}  					int copySize = 0;  					if ((cmd & unchecked((int)(0x10))) != 0)  					{  						copySize = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x20))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x40))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if (copySize == 0)  					{  						copySize = unchecked((int)(0x10000));  					}  					System.Array.Copy(@base' copyOffset' result' resultPtr' copySize);  					resultPtr += copySize;  				}  				else  				{  					if (cmd != 0)  					{  						// Anything else the data is literal within the delta  						// itself.  						//  						System.Array.Copy(delta' deltaPtr' result' resultPtr' cmd);  						deltaPtr += cmd;  						resultPtr += cmd;  					}  					else  					{  						// cmd == 0 has been reserved for future encoding but  						// for now its not acceptable.  						//  						throw new ArgumentException(JGitText.Get().unsupportedCommand0);  					}  				}  			}
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & unchecked((int)(0xff));  				if ((cmd & unchecked((int)(0x80))) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a length.  					//  					int copyOffset = 0;  					if ((cmd & unchecked((int)(0x01))) != 0)  					{  						copyOffset = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x02))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x04))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if ((cmd & unchecked((int)(0x08))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 24;  					}  					int copySize = 0;  					if ((cmd & unchecked((int)(0x10))) != 0)  					{  						copySize = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x20))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x40))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if (copySize == 0)  					{  						copySize = unchecked((int)(0x10000));  					}  					System.Array.Copy(@base' copyOffset' result' resultPtr' copySize);  					resultPtr += copySize;  				}  				else  				{  					if (cmd != 0)  					{  						// Anything else the data is literal within the delta  						// itself.  						//  						System.Array.Copy(delta' deltaPtr' result' resultPtr' cmd);  						deltaPtr += cmd;  						resultPtr += cmd;  					}  					else  					{  						// cmd == 0 has been reserved for future encoding but  						// for now its not acceptable.  						//  						throw new ArgumentException(JGitText.Get().unsupportedCommand0);  					}  				}  			}
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & unchecked((int)(0xff));  				if ((cmd & unchecked((int)(0x80))) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a length.  					//  					int copyOffset = 0;  					if ((cmd & unchecked((int)(0x01))) != 0)  					{  						copyOffset = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x02))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x04))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if ((cmd & unchecked((int)(0x08))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 24;  					}  					int copySize = 0;  					if ((cmd & unchecked((int)(0x10))) != 0)  					{  						copySize = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x20))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x40))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if (copySize == 0)  					{  						copySize = unchecked((int)(0x10000));  					}  					System.Array.Copy(@base' copyOffset' result' resultPtr' copySize);  					resultPtr += copySize;  				}  				else  				{  					if (cmd != 0)  					{  						// Anything else the data is literal within the delta  						// itself.  						//  						System.Array.Copy(delta' deltaPtr' result' resultPtr' cmd);  						deltaPtr += cmd;  						resultPtr += cmd;  					}  					else  					{  						// cmd == 0 has been reserved for future encoding but  						// for now its not acceptable.  						//  						throw new ArgumentException(JGitText.Get().unsupportedCommand0);  					}  				}  			}
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Format,The following statement contains a magic number: do  			{  				c = delta[deltaPtr++] & unchecked((int)(0xff));  				baseLen |= ((long)(c & unchecked((int)(0x7f)))) << shift;  				shift += 7;  			}  			while ((c & unchecked((int)(0x80))) != 0);
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Format,The following statement contains a magic number: do  			{  				c = delta[deltaPtr++] & unchecked((int)(0xff));  				resLen |= ((long)(c & unchecked((int)(0x7f)))) << shift;  				shift += 7;  			}  			while ((c & unchecked((int)(0x80))) != 0);
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Format,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & unchecked((int)(0xff));  				if ((cmd & unchecked((int)(0x80))) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a length.  					//  					int copyOffset = 0;  					if ((cmd & unchecked((int)(0x01))) != 0)  					{  						copyOffset = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x02))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x04))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if ((cmd & unchecked((int)(0x08))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 24;  					}  					int copySize = 0;  					if ((cmd & unchecked((int)(0x10))) != 0)  					{  						copySize = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x20))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x40))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if (copySize == 0)  					{  						copySize = unchecked((int)(0x10000));  					}  					r.Append("  COPY  (" + copyOffset + "' " + copySize + ")\n");  				}  				else  				{  					if (cmd != 0)  					{  						// Anything else the data is literal within the delta  						// itself.  						//  						r.Append("  INSERT(");  						r.Append(QuotedString.GIT_PATH.Quote(RawParseUtils.Decode(delta' deltaPtr' deltaPtr  							 + cmd)));  						r.Append(")\n");  						deltaPtr += cmd;  					}  					else  					{  						// cmd == 0 has been reserved for future encoding but  						// for now its not acceptable.  						//  						throw new ArgumentException(JGitText.Get().unsupportedCommand0);  					}  				}  			}
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Format,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & unchecked((int)(0xff));  				if ((cmd & unchecked((int)(0x80))) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a length.  					//  					int copyOffset = 0;  					if ((cmd & unchecked((int)(0x01))) != 0)  					{  						copyOffset = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x02))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x04))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if ((cmd & unchecked((int)(0x08))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 24;  					}  					int copySize = 0;  					if ((cmd & unchecked((int)(0x10))) != 0)  					{  						copySize = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x20))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x40))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if (copySize == 0)  					{  						copySize = unchecked((int)(0x10000));  					}  					r.Append("  COPY  (" + copyOffset + "' " + copySize + ")\n");  				}  				else  				{  					if (cmd != 0)  					{  						// Anything else the data is literal within the delta  						// itself.  						//  						r.Append("  INSERT(");  						r.Append(QuotedString.GIT_PATH.Quote(RawParseUtils.Decode(delta' deltaPtr' deltaPtr  							 + cmd)));  						r.Append(")\n");  						deltaPtr += cmd;  					}  					else  					{  						// cmd == 0 has been reserved for future encoding but  						// for now its not acceptable.  						//  						throw new ArgumentException(JGitText.Get().unsupportedCommand0);  					}  				}  			}
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Format,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & unchecked((int)(0xff));  				if ((cmd & unchecked((int)(0x80))) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a length.  					//  					int copyOffset = 0;  					if ((cmd & unchecked((int)(0x01))) != 0)  					{  						copyOffset = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x02))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x04))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if ((cmd & unchecked((int)(0x08))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 24;  					}  					int copySize = 0;  					if ((cmd & unchecked((int)(0x10))) != 0)  					{  						copySize = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x20))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x40))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if (copySize == 0)  					{  						copySize = unchecked((int)(0x10000));  					}  					r.Append("  COPY  (" + copyOffset + "' " + copySize + ")\n");  				}  				else  				{  					if (cmd != 0)  					{  						// Anything else the data is literal within the delta  						// itself.  						//  						r.Append("  INSERT(");  						r.Append(QuotedString.GIT_PATH.Quote(RawParseUtils.Decode(delta' deltaPtr' deltaPtr  							 + cmd)));  						r.Append(")\n");  						deltaPtr += cmd;  					}  					else  					{  						// cmd == 0 has been reserved for future encoding but  						// for now its not acceptable.  						//  						throw new ArgumentException(JGitText.Get().unsupportedCommand0);  					}  				}  			}
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Format,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & unchecked((int)(0xff));  				if ((cmd & unchecked((int)(0x80))) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a length.  					//  					int copyOffset = 0;  					if ((cmd & unchecked((int)(0x01))) != 0)  					{  						copyOffset = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x02))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x04))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if ((cmd & unchecked((int)(0x08))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 24;  					}  					int copySize = 0;  					if ((cmd & unchecked((int)(0x10))) != 0)  					{  						copySize = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x20))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x40))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if (copySize == 0)  					{  						copySize = unchecked((int)(0x10000));  					}  					r.Append("  COPY  (" + copyOffset + "' " + copySize + ")\n");  				}  				else  				{  					if (cmd != 0)  					{  						// Anything else the data is literal within the delta  						// itself.  						//  						r.Append("  INSERT(");  						r.Append(QuotedString.GIT_PATH.Quote(RawParseUtils.Decode(delta' deltaPtr' deltaPtr  							 + cmd)));  						r.Append(")\n");  						deltaPtr += cmd;  					}  					else  					{  						// cmd == 0 has been reserved for future encoding but  						// for now its not acceptable.  						//  						throw new ArgumentException(JGitText.Get().unsupportedCommand0);  					}  				}  			}
Magic Number,NGit.Storage.Pack,BinaryDelta,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\BinaryDelta.cs,Format,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & unchecked((int)(0xff));  				if ((cmd & unchecked((int)(0x80))) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a length.  					//  					int copyOffset = 0;  					if ((cmd & unchecked((int)(0x01))) != 0)  					{  						copyOffset = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x02))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x04))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if ((cmd & unchecked((int)(0x08))) != 0)  					{  						copyOffset |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 24;  					}  					int copySize = 0;  					if ((cmd & unchecked((int)(0x10))) != 0)  					{  						copySize = delta[deltaPtr++] & unchecked((int)(0xff));  					}  					if ((cmd & unchecked((int)(0x20))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 8;  					}  					if ((cmd & unchecked((int)(0x40))) != 0)  					{  						copySize |= (delta[deltaPtr++] & unchecked((int)(0xff))) << 16;  					}  					if (copySize == 0)  					{  						copySize = unchecked((int)(0x10000));  					}  					r.Append("  COPY  (" + copyOffset + "' " + copySize + ")\n");  				}  				else  				{  					if (cmd != 0)  					{  						// Anything else the data is literal within the delta  						// itself.  						//  						r.Append("  INSERT(");  						r.Append(QuotedString.GIT_PATH.Quote(RawParseUtils.Decode(delta' deltaPtr' deltaPtr  							 + cmd)));  						r.Append(")\n");  						deltaPtr += cmd;  					}  					else  					{  						// cmd == 0 has been reserved for future encoding but  						// for now its not acceptable.  						//  						throw new ArgumentException(JGitText.Get().unsupportedCommand0);  					}  				}  			}
Magic Number,NGit.Storage.Pack,DeltaCache,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaCache.cs,CanCache,The following statement contains a magic number: if (length >> 10 < (src.GetWeight() >> 20) + (res.GetWeight() >> 21))  			{  				used += length;  				return true;  			}
Magic Number,NGit.Storage.Pack,DeltaCache,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaCache.cs,CanCache,The following statement contains a magic number: if (length >> 10 < (src.GetWeight() >> 20) + (res.GetWeight() >> 21))  			{  				used += length;  				return true;  			}
Magic Number,NGit.Storage.Pack,DeltaCache,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaCache.cs,CanCache,The following statement contains a magic number: if (length >> 10 < (src.GetWeight() >> 20) + (res.GetWeight() >> 21))  			{  				used += length;  				return true;  			}
Magic Number,NGit.Storage.Pack,DeltaEncoder,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaEncoder.cs,WriteVarint,The following statement contains a magic number: while (sz >= unchecked((int)(0x80)))  			{  				buf[p++] = unchecked((byte)(unchecked((int)(0x80)) | (((int)sz) & unchecked((int)  					(0x7f)))));  				sz = (long)(((ulong)sz) >> 7);  			}
Magic Number,NGit.Storage.Pack,DeltaEncoder,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaEncoder.cs,EncodeCopy,The following statement contains a magic number: if ((offset & (unchecked((int)(0xff)) << 8)) != 0)  			{  				cmd |= unchecked((int)(0x02));  				buf[p++] = unchecked((byte)(((long)(((ulong)offset) >> 8)) & unchecked((int)(0xff  					))));  			}
Magic Number,NGit.Storage.Pack,DeltaEncoder,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaEncoder.cs,EncodeCopy,The following statement contains a magic number: if ((offset & (unchecked((int)(0xff)) << 8)) != 0)  			{  				cmd |= unchecked((int)(0x02));  				buf[p++] = unchecked((byte)(((long)(((ulong)offset) >> 8)) & unchecked((int)(0xff  					))));  			}
Magic Number,NGit.Storage.Pack,DeltaEncoder,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaEncoder.cs,EncodeCopy,The following statement contains a magic number: if ((offset & (unchecked((int)(0xff)) << 16)) != 0)  			{  				cmd |= unchecked((int)(0x04));  				buf[p++] = unchecked((byte)(((long)(((ulong)offset) >> 16)) & unchecked((int)(0xff  					))));  			}
Magic Number,NGit.Storage.Pack,DeltaEncoder,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaEncoder.cs,EncodeCopy,The following statement contains a magic number: if ((offset & (unchecked((int)(0xff)) << 16)) != 0)  			{  				cmd |= unchecked((int)(0x04));  				buf[p++] = unchecked((byte)(((long)(((ulong)offset) >> 16)) & unchecked((int)(0xff  					))));  			}
Magic Number,NGit.Storage.Pack,DeltaEncoder,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaEncoder.cs,EncodeCopy,The following statement contains a magic number: if ((offset & (unchecked((int)(0xff)) << 24)) != 0)  			{  				cmd |= unchecked((int)(0x08));  				buf[p++] = unchecked((byte)(((long)(((ulong)offset) >> 24)) & unchecked((int)(0xff  					))));  			}
Magic Number,NGit.Storage.Pack,DeltaEncoder,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaEncoder.cs,EncodeCopy,The following statement contains a magic number: if ((offset & (unchecked((int)(0xff)) << 24)) != 0)  			{  				cmd |= unchecked((int)(0x08));  				buf[p++] = unchecked((byte)(((long)(((ulong)offset) >> 24)) & unchecked((int)(0xff  					))));  			}
Magic Number,NGit.Storage.Pack,DeltaEncoder,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaEncoder.cs,EncodeCopy,The following statement contains a magic number: if (cnt != MAX_V2_COPY)  			{  				if ((cnt & unchecked((int)(0xff))) != 0)  				{  					cmd |= unchecked((int)(0x10));  					buf[p++] = unchecked((byte)(cnt & unchecked((int)(0xff))));  				}  				if ((cnt & (unchecked((int)(0xff)) << 8)) != 0)  				{  					cmd |= unchecked((int)(0x20));  					buf[p++] = unchecked((byte)(((int)(((uint)cnt) >> 8)) & unchecked((int)(0xff))));  				}  				if ((cnt & (unchecked((int)(0xff)) << 16)) != 0)  				{  					cmd |= unchecked((int)(0x40));  					buf[p++] = unchecked((byte)(((int)(((uint)cnt) >> 16)) & unchecked((int)(0xff))));  				}  			}
Magic Number,NGit.Storage.Pack,DeltaEncoder,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaEncoder.cs,EncodeCopy,The following statement contains a magic number: if (cnt != MAX_V2_COPY)  			{  				if ((cnt & unchecked((int)(0xff))) != 0)  				{  					cmd |= unchecked((int)(0x10));  					buf[p++] = unchecked((byte)(cnt & unchecked((int)(0xff))));  				}  				if ((cnt & (unchecked((int)(0xff)) << 8)) != 0)  				{  					cmd |= unchecked((int)(0x20));  					buf[p++] = unchecked((byte)(((int)(((uint)cnt) >> 8)) & unchecked((int)(0xff))));  				}  				if ((cnt & (unchecked((int)(0xff)) << 16)) != 0)  				{  					cmd |= unchecked((int)(0x40));  					buf[p++] = unchecked((byte)(((int)(((uint)cnt) >> 16)) & unchecked((int)(0xff))));  				}  			}
Magic Number,NGit.Storage.Pack,DeltaEncoder,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaEncoder.cs,EncodeCopy,The following statement contains a magic number: if (cnt != MAX_V2_COPY)  			{  				if ((cnt & unchecked((int)(0xff))) != 0)  				{  					cmd |= unchecked((int)(0x10));  					buf[p++] = unchecked((byte)(cnt & unchecked((int)(0xff))));  				}  				if ((cnt & (unchecked((int)(0xff)) << 8)) != 0)  				{  					cmd |= unchecked((int)(0x20));  					buf[p++] = unchecked((byte)(((int)(((uint)cnt) >> 8)) & unchecked((int)(0xff))));  				}  				if ((cnt & (unchecked((int)(0xff)) << 16)) != 0)  				{  					cmd |= unchecked((int)(0x40));  					buf[p++] = unchecked((byte)(((int)(((uint)cnt) >> 16)) & unchecked((int)(0xff))));  				}  			}
Magic Number,NGit.Storage.Pack,DeltaEncoder,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaEncoder.cs,EncodeCopy,The following statement contains a magic number: if (cnt != MAX_V2_COPY)  			{  				if ((cnt & unchecked((int)(0xff))) != 0)  				{  					cmd |= unchecked((int)(0x10));  					buf[p++] = unchecked((byte)(cnt & unchecked((int)(0xff))));  				}  				if ((cnt & (unchecked((int)(0xff)) << 8)) != 0)  				{  					cmd |= unchecked((int)(0x20));  					buf[p++] = unchecked((byte)(((int)(((uint)cnt) >> 8)) & unchecked((int)(0xff))));  				}  				if ((cnt & (unchecked((int)(0xff)) << 16)) != 0)  				{  					cmd |= unchecked((int)(0x40));  					buf[p++] = unchecked((byte)(((int)(((uint)cnt) >> 16)) & unchecked((int)(0xff))));  				}  			}
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,EstimateIndexSize,The following statement contains a magic number: return sourceLength + (sourceLength * 3 / 4);
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,EstimateIndexSize,The following statement contains a magic number: return sourceLength + (sourceLength * 3 / 4);
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,GetIndexSize,The following statement contains a magic number: long sz = 8;
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,GetIndexSize,The following statement contains a magic number: sz += 4 * 4;
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,GetIndexSize,The following statement contains a magic number: sz += 4 * 4;
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,SizeOf,The following statement contains a magic number: return SizeOfArray(4' b.Length);
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,SizeOf,The following statement contains a magic number: return SizeOfArray(8' b.Length);
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,SizeOfArray,The following statement contains a magic number: return 12 + (len * entSize);
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,Encode,The following statement contains a magic number: while (blkEnd < end)  			{  				int tableIdx = hash & tableMask;  				int entryIdx = table[tableIdx];  				if (entryIdx == 0)  				{  					// No matching blocks' slide forward one byte.  					//  					hash = Step(hash' res[blkPtr++]' res[blkEnd++]);  					continue;  				}  				// For every possible location of the current block' try to  				// extend the match out to the longest common substring.  				//  				int bestLen = -1;  				int bestPtr = -1;  				int bestNeg = 0;  				do  				{  					long ent = entries[entryIdx++];  					if (KeyOf(ent) == hash)  					{  						int neg = 0;  						if (resPtr < blkPtr)  						{  							// If we need to do an insertion' check to see if  							// moving the starting point of the copy backwards  							// will allow us to shorten the insert. Our hash  							// may not have allowed us to identify this area.  							// Since it is quite fast to perform a negative  							// scan' try to stretch backwards too.  							//  							neg = blkPtr - resPtr;  							neg = Negmatch(res' blkPtr' src' ValOf(ent)' neg);  						}  						int len = neg + Fwdmatch(res' blkPtr' src' ValOf(ent));  						if (bestLen < len)  						{  							bestLen = len;  							bestPtr = ValOf(ent);  							bestNeg = neg;  						}  					}  					else  					{  						if ((KeyOf(ent) & tableMask) != tableIdx)  						{  							break;  						}  					}  				}  				while (bestLen < 4096 && entryIdx < entries.Length);  				if (bestLen < BLKSZ)  				{  					// All of the locations were false positives' or the copy  					// is shorter than a block. In the latter case this won't  					// give us a very great copy instruction' so delay and try  					// at the next byte.  					//  					hash = Step(hash' res[blkPtr++]' res[blkEnd++]);  					continue;  				}  				blkPtr -= bestNeg;  				if (resPtr < blkPtr)  				{  					// There are bytes between the last instruction we made  					// and the current block pointer. None of these matched  					// during the earlier iteration so insert them directly  					// into the instruction stream.  					//  					int cnt = blkPtr - resPtr;  					if (!enc.Insert(res' resPtr' cnt))  					{  						return false;  					}  				}  				if (!enc.Copy(bestPtr - bestNeg' bestLen))  				{  					return false;  				}  				blkPtr += bestLen;  				resPtr = blkPtr;  				blkEnd = blkPtr + BLKSZ;  				// If we don't have a full block available to us' abort now.  				//  				if (end <= blkEnd)  				{  					break;  				}  				// Start a new hash of the block after the copy region.  				//  				hash = HashBlock(res' blkPtr);  			}
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,ToString,The following statement contains a magic number: while (1024 <= sz && u < units.Length - 1)  			{  				int rem = (int)(sz % 1024);  				sz /= 1024;  				if (rem != 0)  				{  					sz++;  				}  				u++;  			}
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,ToString,The following statement contains a magic number: while (1024 <= sz && u < units.Length - 1)  			{  				int rem = (int)(sz % 1024);  				sz /= 1024;  				if (rem != 0)  				{  					sz++;  				}  				u++;  			}
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,ToString,The following statement contains a magic number: while (1024 <= sz && u < units.Length - 1)  			{  				int rem = (int)(sz % 1024);  				sz /= 1024;  				if (rem != 0)  				{  					sz++;  				}  				u++;  			}
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((raw[ptr] & unchecked((int)(0xff))) << 24) | ((raw[ptr + 1] & unchecked((  				int)(0xff))) << 16) | ((raw[ptr + 2] & unchecked((int)(0xff))) << 8) | (raw[ptr   				+ 3] & unchecked((int)(0xff)));
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((raw[ptr] & unchecked((int)(0xff))) << 24) | ((raw[ptr + 1] & unchecked((  				int)(0xff))) << 16) | ((raw[ptr + 2] & unchecked((int)(0xff))) << 8) | (raw[ptr   				+ 3] & unchecked((int)(0xff)));
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((raw[ptr] & unchecked((int)(0xff))) << 24) | ((raw[ptr + 1] & unchecked((  				int)(0xff))) << 16) | ((raw[ptr + 2] & unchecked((int)(0xff))) << 8) | (raw[ptr   				+ 3] & unchecked((int)(0xff)));
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((raw[ptr] & unchecked((int)(0xff))) << 24) | ((raw[ptr + 1] & unchecked((  				int)(0xff))) << 16) | ((raw[ptr + 2] & unchecked((int)(0xff))) << 8) | (raw[ptr   				+ 3] & unchecked((int)(0xff)));
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((raw[ptr] & unchecked((int)(0xff))) << 24) | ((raw[ptr + 1] & unchecked((  				int)(0xff))) << 16) | ((raw[ptr + 2] & unchecked((int)(0xff))) << 8) | (raw[ptr   				+ 3] & unchecked((int)(0xff)));
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash ^= T[(int)(((uint)hash) >> 31)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 4] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 4] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 4] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 5] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 5] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 5] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 6] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 6] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 6] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 7] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 7] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 7] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 8] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 8] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 8] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 9] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 9] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 9] & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash  				) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 10] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 10] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 10] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 11] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 11] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 11] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 12] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 12] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 12] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 13] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 13] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 13] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 14] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 14] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 14] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 15] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 15] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,HashBlock,The following statement contains a magic number: hash = ((hash << 8) | (raw[ptr + 15] & unchecked((int)(0xff)))) ^ T[(int)(((uint)  				hash) >> 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,Step,The following statement contains a magic number: return ((hash << 8) | (toAdd & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash) >>  				 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,Step,The following statement contains a magic number: return ((hash << 8) | (toAdd & unchecked((int)(0xff)))) ^ T[(int)(((uint)hash) >>  				 23)];
Magic Number,NGit.Storage.Pack,DeltaIndex,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndex.cs,KeyOf,The following statement contains a magic number: return (int)((long)(((ulong)ent) >> 32));
Magic Number,NGit.Storage.Pack,DeltaIndexScanner,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndexScanner.cs,Scan,The following statement contains a magic number: do  			{  				int key = DeltaIndex.HashBlock(raw' ptr);  				int tIdx = key & tableMask;  				int head = table[tIdx];  				if (head != 0 && lastHash == key)  				{  					// Two consecutive blocks have the same content hash'  					// prefer the earlier block because we want to use the  					// longest sequence we can during encoding.  					//  					entries[head] = (((long)key) << 32) | ptr;  				}  				else  				{  					int eIdx = ++entryCnt;  					entries[eIdx] = (((long)key) << 32) | ptr;  					next[eIdx] = head;  					table[tIdx] = eIdx;  				}  				lastHash = key;  				ptr -= DeltaIndex.BLKSZ;  			}  			while (0 <= ptr);
Magic Number,NGit.Storage.Pack,DeltaIndexScanner,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndexScanner.cs,Scan,The following statement contains a magic number: do  			{  				int key = DeltaIndex.HashBlock(raw' ptr);  				int tIdx = key & tableMask;  				int head = table[tIdx];  				if (head != 0 && lastHash == key)  				{  					// Two consecutive blocks have the same content hash'  					// prefer the earlier block because we want to use the  					// longest sequence we can during encoding.  					//  					entries[head] = (((long)key) << 32) | ptr;  				}  				else  				{  					int eIdx = ++entryCnt;  					entries[eIdx] = (((long)key) << 32) | ptr;  					next[eIdx] = head;  					table[tIdx] = eIdx;  				}  				lastHash = key;  				ptr -= DeltaIndex.BLKSZ;  			}  			while (0 <= ptr);
Magic Number,NGit.Storage.Pack,DeltaIndexScanner,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaIndexScanner.cs,TableSize,The following statement contains a magic number: int shift = 32 - Sharpen.Extensions.NumberOfLeadingZeros(worstCaseBlockCnt);
Magic Number,NGit.Storage.Pack,DeltaStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaStream.cs,DeltaStream,The following statement contains a magic number: do  			{  				c = cmdbuf[cmdptr++] & unchecked((int)(0xff));  				baseSize |= ((long)(c & unchecked((int)(0x7f)))) << shift;  				shift += 7;  			}  			while ((c & unchecked((int)(0x80))) != 0);
Magic Number,NGit.Storage.Pack,DeltaStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaStream.cs,DeltaStream,The following statement contains a magic number: do  			{  				c = cmdbuf[cmdptr++] & unchecked((int)(0xff));  				resultSize |= ((long)(c & unchecked((int)(0x7f)))) << shift;  				shift += 7;  			}  			while ((c & unchecked((int)(0x80))) != 0);
Magic Number,NGit.Storage.Pack,DeltaStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaStream.cs,Next,The following statement contains a magic number: if (!Fill(8))  			{  				return CMD_EOF;  			}
Magic Number,NGit.Storage.Pack,DeltaStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaStream.cs,Next,The following statement contains a magic number: if ((cmd & unchecked((int)(0x80))) != 0)  			{  				// Determine the segment of the base which should  				// be copied into the output. The segment is given  				// as an offset and a length.  				//  				copyOffset = 0;  				if ((cmd & unchecked((int)(0x01))) != 0)  				{  					copyOffset = cmdbuf[cmdptr++] & unchecked((int)(0xff));  				}  				if ((cmd & unchecked((int)(0x02))) != 0)  				{  					copyOffset |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 8;  				}  				if ((cmd & unchecked((int)(0x04))) != 0)  				{  					copyOffset |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 16;  				}  				if ((cmd & unchecked((int)(0x08))) != 0)  				{  					copyOffset |= ((long)(cmdbuf[cmdptr++] & unchecked((int)(0xff)))) << 24;  				}  				copySize = 0;  				if ((cmd & unchecked((int)(0x10))) != 0)  				{  					copySize = cmdbuf[cmdptr++] & unchecked((int)(0xff));  				}  				if ((cmd & unchecked((int)(0x20))) != 0)  				{  					copySize |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 8;  				}  				if ((cmd & unchecked((int)(0x40))) != 0)  				{  					copySize |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 16;  				}  				if (copySize == 0)  				{  					copySize = unchecked((int)(0x10000));  				}  				return CMD_COPY;  			}  			else  			{  				if (cmd != 0)  				{  					// Anything else the data is literal within the delta  					// itself. Page the entire thing into the cmdbuf' if  					// its not already there.  					//  					Fill(cmd);  					copySize = cmd;  					return CMD_INSERT;  				}  				else  				{  					// cmd == 0 has been reserved for future encoding but  					// for now its not acceptable.  					//  					throw new CorruptObjectException(JGitText.Get().unsupportedCommand0);  				}  			}
Magic Number,NGit.Storage.Pack,DeltaStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaStream.cs,Next,The following statement contains a magic number: if ((cmd & unchecked((int)(0x80))) != 0)  			{  				// Determine the segment of the base which should  				// be copied into the output. The segment is given  				// as an offset and a length.  				//  				copyOffset = 0;  				if ((cmd & unchecked((int)(0x01))) != 0)  				{  					copyOffset = cmdbuf[cmdptr++] & unchecked((int)(0xff));  				}  				if ((cmd & unchecked((int)(0x02))) != 0)  				{  					copyOffset |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 8;  				}  				if ((cmd & unchecked((int)(0x04))) != 0)  				{  					copyOffset |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 16;  				}  				if ((cmd & unchecked((int)(0x08))) != 0)  				{  					copyOffset |= ((long)(cmdbuf[cmdptr++] & unchecked((int)(0xff)))) << 24;  				}  				copySize = 0;  				if ((cmd & unchecked((int)(0x10))) != 0)  				{  					copySize = cmdbuf[cmdptr++] & unchecked((int)(0xff));  				}  				if ((cmd & unchecked((int)(0x20))) != 0)  				{  					copySize |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 8;  				}  				if ((cmd & unchecked((int)(0x40))) != 0)  				{  					copySize |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 16;  				}  				if (copySize == 0)  				{  					copySize = unchecked((int)(0x10000));  				}  				return CMD_COPY;  			}  			else  			{  				if (cmd != 0)  				{  					// Anything else the data is literal within the delta  					// itself. Page the entire thing into the cmdbuf' if  					// its not already there.  					//  					Fill(cmd);  					copySize = cmd;  					return CMD_INSERT;  				}  				else  				{  					// cmd == 0 has been reserved for future encoding but  					// for now its not acceptable.  					//  					throw new CorruptObjectException(JGitText.Get().unsupportedCommand0);  				}  			}
Magic Number,NGit.Storage.Pack,DeltaStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaStream.cs,Next,The following statement contains a magic number: if ((cmd & unchecked((int)(0x80))) != 0)  			{  				// Determine the segment of the base which should  				// be copied into the output. The segment is given  				// as an offset and a length.  				//  				copyOffset = 0;  				if ((cmd & unchecked((int)(0x01))) != 0)  				{  					copyOffset = cmdbuf[cmdptr++] & unchecked((int)(0xff));  				}  				if ((cmd & unchecked((int)(0x02))) != 0)  				{  					copyOffset |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 8;  				}  				if ((cmd & unchecked((int)(0x04))) != 0)  				{  					copyOffset |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 16;  				}  				if ((cmd & unchecked((int)(0x08))) != 0)  				{  					copyOffset |= ((long)(cmdbuf[cmdptr++] & unchecked((int)(0xff)))) << 24;  				}  				copySize = 0;  				if ((cmd & unchecked((int)(0x10))) != 0)  				{  					copySize = cmdbuf[cmdptr++] & unchecked((int)(0xff));  				}  				if ((cmd & unchecked((int)(0x20))) != 0)  				{  					copySize |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 8;  				}  				if ((cmd & unchecked((int)(0x40))) != 0)  				{  					copySize |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 16;  				}  				if (copySize == 0)  				{  					copySize = unchecked((int)(0x10000));  				}  				return CMD_COPY;  			}  			else  			{  				if (cmd != 0)  				{  					// Anything else the data is literal within the delta  					// itself. Page the entire thing into the cmdbuf' if  					// its not already there.  					//  					Fill(cmd);  					copySize = cmd;  					return CMD_INSERT;  				}  				else  				{  					// cmd == 0 has been reserved for future encoding but  					// for now its not acceptable.  					//  					throw new CorruptObjectException(JGitText.Get().unsupportedCommand0);  				}  			}
Magic Number,NGit.Storage.Pack,DeltaStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaStream.cs,Next,The following statement contains a magic number: if ((cmd & unchecked((int)(0x80))) != 0)  			{  				// Determine the segment of the base which should  				// be copied into the output. The segment is given  				// as an offset and a length.  				//  				copyOffset = 0;  				if ((cmd & unchecked((int)(0x01))) != 0)  				{  					copyOffset = cmdbuf[cmdptr++] & unchecked((int)(0xff));  				}  				if ((cmd & unchecked((int)(0x02))) != 0)  				{  					copyOffset |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 8;  				}  				if ((cmd & unchecked((int)(0x04))) != 0)  				{  					copyOffset |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 16;  				}  				if ((cmd & unchecked((int)(0x08))) != 0)  				{  					copyOffset |= ((long)(cmdbuf[cmdptr++] & unchecked((int)(0xff)))) << 24;  				}  				copySize = 0;  				if ((cmd & unchecked((int)(0x10))) != 0)  				{  					copySize = cmdbuf[cmdptr++] & unchecked((int)(0xff));  				}  				if ((cmd & unchecked((int)(0x20))) != 0)  				{  					copySize |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 8;  				}  				if ((cmd & unchecked((int)(0x40))) != 0)  				{  					copySize |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 16;  				}  				if (copySize == 0)  				{  					copySize = unchecked((int)(0x10000));  				}  				return CMD_COPY;  			}  			else  			{  				if (cmd != 0)  				{  					// Anything else the data is literal within the delta  					// itself. Page the entire thing into the cmdbuf' if  					// its not already there.  					//  					Fill(cmd);  					copySize = cmd;  					return CMD_INSERT;  				}  				else  				{  					// cmd == 0 has been reserved for future encoding but  					// for now its not acceptable.  					//  					throw new CorruptObjectException(JGitText.Get().unsupportedCommand0);  				}  			}
Magic Number,NGit.Storage.Pack,DeltaStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaStream.cs,Next,The following statement contains a magic number: if ((cmd & unchecked((int)(0x80))) != 0)  			{  				// Determine the segment of the base which should  				// be copied into the output. The segment is given  				// as an offset and a length.  				//  				copyOffset = 0;  				if ((cmd & unchecked((int)(0x01))) != 0)  				{  					copyOffset = cmdbuf[cmdptr++] & unchecked((int)(0xff));  				}  				if ((cmd & unchecked((int)(0x02))) != 0)  				{  					copyOffset |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 8;  				}  				if ((cmd & unchecked((int)(0x04))) != 0)  				{  					copyOffset |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 16;  				}  				if ((cmd & unchecked((int)(0x08))) != 0)  				{  					copyOffset |= ((long)(cmdbuf[cmdptr++] & unchecked((int)(0xff)))) << 24;  				}  				copySize = 0;  				if ((cmd & unchecked((int)(0x10))) != 0)  				{  					copySize = cmdbuf[cmdptr++] & unchecked((int)(0xff));  				}  				if ((cmd & unchecked((int)(0x20))) != 0)  				{  					copySize |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 8;  				}  				if ((cmd & unchecked((int)(0x40))) != 0)  				{  					copySize |= (cmdbuf[cmdptr++] & unchecked((int)(0xff))) << 16;  				}  				if (copySize == 0)  				{  					copySize = unchecked((int)(0x10000));  				}  				return CMD_COPY;  			}  			else  			{  				if (cmd != 0)  				{  					// Anything else the data is literal within the delta  					// itself. Page the entire thing into the cmdbuf' if  					// its not already there.  					//  					Fill(cmd);  					copySize = cmd;  					return CMD_INSERT;  				}  				else  				{  					// cmd == 0 has been reserved for future encoding but  					// for now its not acceptable.  					//  					throw new CorruptObjectException(JGitText.Get().unsupportedCommand0);  				}  			}
Magic Number,NGit.Storage.Pack,DeltaWindow,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaWindow.cs,Delta,The following statement contains a magic number: if (msz <= 8)  			{  				return NEXT_SRC;  			}
Magic Number,NGit.Storage.Pack,DeltaWindow,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaWindow.cs,Delta,The following statement contains a magic number: if (res.Size() < src.Size() / 16)  			{  				return NEXT_SRC;  			}
Magic Number,NGit.Storage.Pack,DeltaWindow,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaWindow.cs,DeflateBound,The following statement contains a magic number: return insz + ((insz + 7) >> 3) + ((insz + 63) >> 6) + 11;
Magic Number,NGit.Storage.Pack,DeltaWindow,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaWindow.cs,DeflateBound,The following statement contains a magic number: return insz + ((insz + 7) >> 3) + ((insz + 63) >> 6) + 11;
Magic Number,NGit.Storage.Pack,DeltaWindow,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaWindow.cs,DeflateBound,The following statement contains a magic number: return insz + ((insz + 7) >> 3) + ((insz + 63) >> 6) + 11;
Magic Number,NGit.Storage.Pack,DeltaWindow,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaWindow.cs,DeflateBound,The following statement contains a magic number: return insz + ((insz + 7) >> 3) + ((insz + 63) >> 6) + 11;
Magic Number,NGit.Storage.Pack,DeltaWindow,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaWindow.cs,DeflateBound,The following statement contains a magic number: return insz + ((insz + 7) >> 3) + ((insz + 63) >> 6) + 11;
Magic Number,NGit.Storage.Pack,DeltaWindow,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaWindow.cs,DeltaSizeLimit,The following statement contains a magic number: int limit = res.Size() / 2 - 20;
Magic Number,NGit.Storage.Pack,DeltaWindow,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\DeltaWindow.cs,DeltaSizeLimit,The following statement contains a magic number: int limit = res.Size() / 2 - 20;
Magic Number,NGit.Storage.Pack,PackConfig,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackConfig.cs,SetDeltaSearchWindowSize,The following statement contains a magic number: if (objectCount <= 2)  			{  				SetDeltaCompress(false);  			}  			else  			{  				deltaSearchWindowSize = objectCount;  			}
Magic Number,NGit.Storage.Pack,PackOutputStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackOutputStream.cs,WriteFileHeader,The following statement contains a magic number: System.Array.Copy(Constants.PACK_SIGNATURE' 0' headerBuffer' 0' 4);
Magic Number,NGit.Storage.Pack,PackOutputStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackOutputStream.cs,WriteFileHeader,The following statement contains a magic number: NB.EncodeInt32(headerBuffer' 4' version);
Magic Number,NGit.Storage.Pack,PackOutputStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackOutputStream.cs,WriteFileHeader,The following statement contains a magic number: NB.EncodeInt32(headerBuffer' 8' (int)objectCount);
Magic Number,NGit.Storage.Pack,PackOutputStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackOutputStream.cs,WriteFileHeader,The following statement contains a magic number: Write(headerBuffer' 0' 12);
Magic Number,NGit.Storage.Pack,PackOutputStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackOutputStream.cs,WriteHeader,The following statement contains a magic number: if (otp.IsDeltaRepresentation())  			{  				if (packWriter.IsDeltaBaseAsOffset())  				{  					ObjectToPack baseInPack = otp.GetDeltaBase();  					if (baseInPack != null && baseInPack.IsWritten())  					{  						long start = count;  						int n = EncodeTypeSize(Constants.OBJ_OFS_DELTA' rawLength);  						Write(headerBuffer' 0' n);  						long offsetDiff = start - baseInPack.GetOffset();  						n = headerBuffer.Length - 1;  						headerBuffer[n] = unchecked((byte)(offsetDiff & unchecked((int)(0x7F))));  						while ((offsetDiff >>= 7) > 0)  						{  							headerBuffer[--n] = unchecked((byte)(unchecked((int)(0x80)) | (--offsetDiff & unchecked(  								(int)(0x7F)))));  						}  						Write(headerBuffer' n' headerBuffer.Length - n);  						return;  					}  				}  				int n_1 = EncodeTypeSize(Constants.OBJ_REF_DELTA' rawLength);  				otp.GetDeltaBaseId().CopyRawTo(headerBuffer' n_1);  				Write(headerBuffer' 0' n_1 + Constants.OBJECT_ID_LENGTH);  			}  			else  			{  				int n = EncodeTypeSize(otp.GetType()' rawLength);  				Write(headerBuffer' 0' n);  			}
Magic Number,NGit.Storage.Pack,PackOutputStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackOutputStream.cs,EncodeTypeSize,The following statement contains a magic number: long nextLength = (long)(((ulong)rawLength) >> 4);
Magic Number,NGit.Storage.Pack,PackOutputStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackOutputStream.cs,EncodeTypeSize,The following statement contains a magic number: headerBuffer[0] = unchecked((byte)((nextLength > 0 ? unchecked((int)(0x80)) : unchecked(  				(int)(0x00))) | (type << 4) | (rawLength & unchecked((int)(0x0F)))));
Magic Number,NGit.Storage.Pack,PackOutputStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackOutputStream.cs,EncodeTypeSize,The following statement contains a magic number: while (rawLength > 0)  			{  				nextLength = (long)(((ulong)nextLength) >> 7);  				headerBuffer[n++] = unchecked((byte)((nextLength > 0 ? unchecked((int)(0x80)) : unchecked(  					(int)(0x00))) | (rawLength & unchecked((int)(0x7F)))));  				rawLength = nextLength;  			}
Magic Number,NGit.Storage.Pack,PackOutputStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackOutputStream.cs,GetCopyBuffer,The following statement contains a magic number: if (copyBuffer == null)  			{  				copyBuffer = new byte[16 * 1024];  			}
Magic Number,NGit.Storage.Pack,PackOutputStream,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackOutputStream.cs,GetCopyBuffer,The following statement contains a magic number: if (copyBuffer == null)  			{  				copyBuffer = new byte[16 * 1024];  			}
Magic Number,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,WritePack,The following statement contains a magic number: if (compressMonitor is BatchingProgressMonitor)  			{  				long delay = 1000;  				if (needSearchForReuse && config.IsDeltaCompress())  				{  					delay = 500;  				}  				((BatchingProgressMonitor)compressMonitor).SetDelayStart(delay' TimeUnit.MILLISECONDS  					);  			}
Magic Number,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,WritePack,The following statement contains a magic number: if (compressMonitor is BatchingProgressMonitor)  			{  				long delay = 1000;  				if (needSearchForReuse && config.IsDeltaCompress())  				{  					delay = 500;  				}  				((BatchingProgressMonitor)compressMonitor).SetDelayStart(delay' TimeUnit.MILLISECONDS  					);  			}
Magic Number,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,SearchForReuse,The following statement contains a magic number: if (cnt <= 4096)  			{  				// For small object counts' do everything as one list.  				BlockList<ObjectToPack> tmp = new BlockList<ObjectToPack>((int)cnt);  				tmp.AddAll(objectsLists[Constants.OBJ_TAG]);  				tmp.AddAll(objectsLists[Constants.OBJ_COMMIT]);  				tmp.AddAll(objectsLists[Constants.OBJ_TREE]);  				tmp.AddAll(objectsLists[Constants.OBJ_BLOB]);  				SearchForReuse(monitor' tmp);  				if (pruneCurrentObjectList)  				{  					// If the list was pruned' we need to re-prune the main lists.  					PruneEdgesFromObjectList(objectsLists[Constants.OBJ_COMMIT]);  					PruneEdgesFromObjectList(objectsLists[Constants.OBJ_TREE]);  					PruneEdgesFromObjectList(objectsLists[Constants.OBJ_BLOB]);  					PruneEdgesFromObjectList(objectsLists[Constants.OBJ_TAG]);  				}  			}  			else  			{  				SearchForReuse(monitor' objectsLists[Constants.OBJ_TAG]);  				SearchForReuse(monitor' objectsLists[Constants.OBJ_COMMIT]);  				SearchForReuse(monitor' objectsLists[Constants.OBJ_TREE]);  				SearchForReuse(monitor' objectsLists[Constants.OBJ_BLOB]);  			}
Magic Number,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,SearchForDeltas,The following statement contains a magic number: if (threads <= 1 || cnt <= 2 * config.GetDeltaSearchWindowSize())  			{  				DeltaCache dc = new DeltaCache(config);  				DeltaWindow dw = new DeltaWindow(config' dc' reader);  				dw.Search(monitor' list' 0' cnt);  				return;  			}
Magic Number,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,SearchForDeltas,The following statement contains a magic number: int estSize = cnt / (threads * 2);
Magic Number,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,SearchForDeltas,The following statement contains a magic number: if (estSize < 2 * config.GetDeltaSearchWindowSize())  			{  				estSize = 2 * config.GetDeltaSearchWindowSize();  			}
Magic Number,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,SearchForDeltas,The following statement contains a magic number: if (estSize < 2 * config.GetDeltaSearchWindowSize())  			{  				estSize = 2 * config.GetDeltaSearchWindowSize();  			}
Magic Number,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,SearchForDeltas,The following statement contains a magic number: IList<DeltaTask> myTasks = new AList<DeltaTask>(threads * 2);
Magic Number,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,SearchForDeltas,The following statement contains a magic number: if (executor is ExecutorService)  			{  				// Caller supplied us a service' use it directly.  				//  				RunTasks((ExecutorService)executor' pm' myTasks' errors);  			}  			else  			{  				if (executor == null)  				{  					// Caller didn't give us a way to run the tasks' spawn up a  					// temporary thread pool and make sure it tears down cleanly.  					//  					ExecutorService pool = Executors.NewFixedThreadPool(threads);  					try  					{  						RunTasks(pool' pm' myTasks' errors);  					}  					finally  					{  						pool.Shutdown();  						for (; ; )  						{  							try  							{  								if (pool.AwaitTermination(60' TimeUnit.SECONDS))  								{  									break;  								}  							}  							catch (Exception)  							{  								throw new IOException(JGitText.Get().packingCancelledDuringObjectsWriting);  							}  						}  					}  				}  				else  				{  					// The caller gave us an executor' but it might not do  					// asynchronous execution.  Wrap everything and hope it  					// can schedule these for us.  					//  					foreach (DeltaTask task in myTasks)  					{  						executor.Execute(new _Runnable_1241(task' errors));  					}  					try  					{  						pm.WaitForCompletion();  					}  					catch (Exception)  					{  						// We can't abort the other tasks as we have no handle.  						// Cross our fingers and just break out anyway.  						//  						throw new IOException(JGitText.Get().packingCancelledDuringObjectsWriting);  					}  				}  			}
Magic Number,NGit.Storage.Pack,PackWriter,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,FindObjectsToPack,The following statement contains a magic number: if (shallowPack)  			{  				foreach (RevCommit cmit in commits)  				{  					AddObject(cmit' 0);  				}  			}  			else  			{  				int commitCnt = 0;  				bool putTagTargets = false;  				foreach (RevCommit cmit in commits)  				{  					if (!cmit.Has(added))  					{  						cmit.Add(added);  						AddObject(cmit' 0);  						commitCnt++;  					}  					for (int i = 0; i < cmit.ParentCount; i++)  					{  						RevCommit p = cmit.GetParent(i);  						if (!p.Has(added) && !p.Has(RevFlag.UNINTERESTING) && !Exclude(p))  						{  							p.Add(added);  							AddObject(p' 0);  							commitCnt++;  						}  					}  					if (!putTagTargets && 4096 < commitCnt)  					{  						foreach (ObjectId id in tagTargets)  						{  							RevObject obj_1 = walker.LookupOrNull(id);  							if (obj_1 is RevCommit && obj_1.Has(include) && !obj_1.Has(RevFlag.UNINTERESTING)  								 && !obj_1.Has(added))  							{  								obj_1.Add(added);  								AddObject(obj_1' 0);  							}  						}  						putTagTargets = true;  					}  				}  			}
Magic Number,NGit.Storage.Pack,Statistics,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,GetTransferRate,The following statement contains a magic number: return GetTotalBytes() / (GetTimeWriting() / 1000.0);
Magic Number,NGit.Storage.Pack,Statistics,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\PackWriter.cs,Statistics,The following statement contains a magic number: {  					objectTypes = new PackWriter.Statistics.ObjectType[5];  					objectTypes[Constants.OBJ_COMMIT] = new PackWriter.Statistics.ObjectType();  					objectTypes[Constants.OBJ_TREE] = new PackWriter.Statistics.ObjectType();  					objectTypes[Constants.OBJ_BLOB] = new PackWriter.Statistics.ObjectType();  					objectTypes[Constants.OBJ_TAG] = new PackWriter.Statistics.ObjectType();  				}
Magic Number,NGit.Storage.Pack,IntSet,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\IntSet.cs,IntSet,The following statement contains a magic number: set = new int[64];
Magic Number,NGit.Storage.Pack,IntSet,C:\repos\mono_ngit\NGit\NGit.Storage.Pack\IntSet.cs,Add,The following statement contains a magic number: if (cnt == set.Length)  			{  				int[] n = new int[set.Length * 2];  				System.Array.Copy(set' 0' n' 0' cnt);  				set = n;  			}
Magic Number,NGit.Treewalk,AbstractTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\AbstractTreeIterator.cs,GetEntryPathHashCode,The following statement contains a magic number: for (int i = Math.Max(0' pathLen - 16); i < pathLen; i++)  			{  				byte c = path[i];  				if (c != ' ')  				{  					hash = ((int)(((uint)hash) >> 2)) + (c << 24);  				}  			}
Magic Number,NGit.Treewalk,AbstractTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\AbstractTreeIterator.cs,GetEntryPathHashCode,The following statement contains a magic number: for (int i = Math.Max(0' pathLen - 16); i < pathLen; i++)  			{  				byte c = path[i];  				if (c != ' ')  				{  					hash = ((int)(((uint)hash) >> 2)) + (c << 24);  				}  			}
Magic Number,NGit.Treewalk,AbstractTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\AbstractTreeIterator.cs,GetEntryPathHashCode,The following statement contains a magic number: for (int i = Math.Max(0' pathLen - 16); i < pathLen; i++)  			{  				byte c = path[i];  				if (c != ' ')  				{  					hash = ((int)(((uint)hash) >> 2)) + (c << 24);  				}  			}
Magic Number,NGit.Treewalk,CanonicalTreeParser,C:\repos\mono_ngit\NGit\NGit.Treewalk\CanonicalTreeParser.cs,ParseEntry,The following statement contains a magic number: for (; ; )  			{  				c = raw[ptr++];  				if (' ' == c)  				{  					break;  				}  				tmp <<= 3;  				tmp += c - '0';  			}
Magic Number,NGit.Treewalk,WorkingTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\WorkingTreeIterator.cs,CompareMetadata,The following statement contains a magic number: if (cacheLastModified % 1000 == 0 || fileLastModified % 1000 == 0)  			{  				cacheLastModified = cacheLastModified - cacheLastModified % 1000;  				fileLastModified = fileLastModified - fileLastModified % 1000;  			}
Magic Number,NGit.Treewalk,WorkingTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\WorkingTreeIterator.cs,CompareMetadata,The following statement contains a magic number: if (cacheLastModified % 1000 == 0 || fileLastModified % 1000 == 0)  			{  				cacheLastModified = cacheLastModified - cacheLastModified % 1000;  				fileLastModified = fileLastModified - fileLastModified % 1000;  			}
Magic Number,NGit.Treewalk,WorkingTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\WorkingTreeIterator.cs,CompareMetadata,The following statement contains a magic number: if (cacheLastModified % 1000 == 0 || fileLastModified % 1000 == 0)  			{  				cacheLastModified = cacheLastModified - cacheLastModified % 1000;  				fileLastModified = fileLastModified - fileLastModified % 1000;  			}
Magic Number,NGit.Treewalk,WorkingTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\WorkingTreeIterator.cs,CompareMetadata,The following statement contains a magic number: if (cacheLastModified % 1000 == 0 || fileLastModified % 1000 == 0)  			{  				cacheLastModified = cacheLastModified - cacheLastModified % 1000;  				fileLastModified = fileLastModified - fileLastModified % 1000;  			}
Magic Number,NGit.Treewalk,WorkingTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\WorkingTreeIterator.cs,ComputeLength,The following statement contains a magic number: for (; ; )  			{  				long n = @in.Skip(1 << 20);  				if (n <= 0)  				{  					break;  				}  				length += n;  			}
Magic Number,NGit.Treewalk,WorkingTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\WorkingTreeIterator.cs,ComputeHash,The following statement contains a magic number: if (sz == 0)  			{  				contentDigest.Update(unchecked((byte)'0'));  			}  			else  			{  				int bufn = contentReadBuffer.Length;  				int p = bufn;  				do  				{  					contentReadBuffer[--p] = digits[(int)(sz % 10)];  					sz /= 10;  				}  				while (sz > 0);  				contentDigest.Update(contentReadBuffer' p' bufn - p);  			}
Magic Number,NGit.Treewalk,WorkingTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\WorkingTreeIterator.cs,ComputeHash,The following statement contains a magic number: if (sz == 0)  			{  				contentDigest.Update(unchecked((byte)'0'));  			}  			else  			{  				int bufn = contentReadBuffer.Length;  				int p = bufn;  				do  				{  					contentReadBuffer[--p] = digits[(int)(sz % 10)];  					sz /= 10;  				}  				while (sz > 0);  				contentDigest.Update(contentReadBuffer' p' bufn - p);  			}
Magic Number,NGit.Treewalk,RootIgnoreNode,C:\repos\mono_ngit\NGit\NGit.Treewalk\WorkingTreeIterator.cs,Load,The following statement contains a magic number: if (path != null)  				{  					FilePath excludesfile;  					if (path.StartsWith("~/"))  					{  						excludesfile = fs.Resolve(fs.UserHome()' Sharpen.Runtime.Substring(path' 2));  					}  					else  					{  						excludesfile = fs.Resolve(null' path);  					}  					LoadRulesFromFile(r' excludesfile);  				}
Magic Number,NGit.Treewalk.Filter,AndTreeFilter,C:\repos\mono_ngit\NGit\NGit.Treewalk.Filter\AndTreeFilter.cs,Create,The following statement contains a magic number: if (list.Length == 2)  			{  				return Create(list[0]' list[1]);  			}
Magic Number,NGit.Treewalk.Filter,AndTreeFilter,C:\repos\mono_ngit\NGit\NGit.Treewalk.Filter\AndTreeFilter.cs,Create,The following statement contains a magic number: if (list.Length < 2)  			{  				throw new ArgumentException(JGitText.Get().atLeastTwoFiltersNeeded);  			}
Magic Number,NGit.Treewalk.Filter,AndTreeFilter,C:\repos\mono_ngit\NGit\NGit.Treewalk.Filter\AndTreeFilter.cs,Create,The following statement contains a magic number: if (list.Count < 2)  			{  				throw new ArgumentException(JGitText.Get().atLeastTwoFiltersNeeded);  			}
Magic Number,NGit.Treewalk.Filter,AndTreeFilter,C:\repos\mono_ngit\NGit\NGit.Treewalk.Filter\AndTreeFilter.cs,Create,The following statement contains a magic number: if (subfilters.Length == 2)  			{  				return Create(subfilters[0]' subfilters[1]);  			}
Magic Number,NGit.Treewalk.Filter,OrTreeFilter,C:\repos\mono_ngit\NGit\NGit.Treewalk.Filter\OrTreeFilter.cs,Create,The following statement contains a magic number: if (list.Length == 2)  			{  				return Create(list[0]' list[1]);  			}
Magic Number,NGit.Treewalk.Filter,OrTreeFilter,C:\repos\mono_ngit\NGit\NGit.Treewalk.Filter\OrTreeFilter.cs,Create,The following statement contains a magic number: if (list.Length < 2)  			{  				throw new ArgumentException(JGitText.Get().atLeastTwoFiltersNeeded);  			}
Magic Number,NGit.Treewalk.Filter,OrTreeFilter,C:\repos\mono_ngit\NGit\NGit.Treewalk.Filter\OrTreeFilter.cs,Create,The following statement contains a magic number: if (list.Count < 2)  			{  				throw new ArgumentException(JGitText.Get().atLeastTwoFiltersNeeded);  			}
Magic Number,NGit.Treewalk.Filter,OrTreeFilter,C:\repos\mono_ngit\NGit\NGit.Treewalk.Filter\OrTreeFilter.cs,Create,The following statement contains a magic number: if (subfilters.Length == 2)  			{  				return Create(subfilters[0]' subfilters[1]);  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Base64,The following statement contains a magic number: DEC = new sbyte[128];
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Base64,The following statement contains a magic number: for (int i = 0; i < 64; i++)  			{  				DEC[ENC[i]] = unchecked((sbyte)i);  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					inBuff |= (int)(((uint)(source[srcOffset + 2] << 24)) >> 24);  					goto case 2;  				}    				case 2:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset + 1] << 24)) >> 16);  					goto case 1;  				}    				case 1:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset] << 24)) >> 8);  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					inBuff |= (int)(((uint)(source[srcOffset + 2] << 24)) >> 24);  					goto case 2;  				}    				case 2:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset + 1] << 24)) >> 16);  					goto case 1;  				}    				case 1:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset] << 24)) >> 8);  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					inBuff |= (int)(((uint)(source[srcOffset + 2] << 24)) >> 24);  					goto case 2;  				}    				case 2:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset + 1] << 24)) >> 16);  					goto case 1;  				}    				case 1:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset] << 24)) >> 8);  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					inBuff |= (int)(((uint)(source[srcOffset + 2] << 24)) >> 24);  					goto case 2;  				}    				case 2:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset + 1] << 24)) >> 16);  					goto case 1;  				}    				case 1:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset] << 24)) >> 8);  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					inBuff |= (int)(((uint)(source[srcOffset + 2] << 24)) >> 24);  					goto case 2;  				}    				case 2:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset + 1] << 24)) >> 16);  					goto case 1;  				}    				case 1:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset] << 24)) >> 8);  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					inBuff |= (int)(((uint)(source[srcOffset + 2] << 24)) >> 24);  					goto case 2;  				}    				case 2:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset + 1] << 24)) >> 16);  					goto case 1;  				}    				case 1:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset] << 24)) >> 8);  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					inBuff |= (int)(((uint)(source[srcOffset + 2] << 24)) >> 24);  					goto case 2;  				}    				case 2:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset + 1] << 24)) >> 16);  					goto case 1;  				}    				case 1:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset] << 24)) >> 8);  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					inBuff |= (int)(((uint)(source[srcOffset + 2] << 24)) >> 24);  					goto case 2;  				}    				case 2:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset + 1] << 24)) >> 16);  					goto case 1;  				}    				case 1:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset] << 24)) >> 8);  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					inBuff |= (int)(((uint)(source[srcOffset + 2] << 24)) >> 24);  					goto case 2;  				}    				case 2:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset + 1] << 24)) >> 16);  					goto case 1;  				}    				case 1:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset] << 24)) >> 8);  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					inBuff |= (int)(((uint)(source[srcOffset + 2] << 24)) >> 24);  					goto case 2;  				}    				case 2:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset + 1] << 24)) >> 16);  					goto case 1;  				}    				case 1:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset] << 24)) >> 8);  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following statement contains a magic number: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,EncodeBytes,The following statement contains a magic number: int len43 = len * 4 / 3;
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,EncodeBytes,The following statement contains a magic number: int len43 = len * 4 / 3;
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,EncodeBytes,The following statement contains a magic number: byte[] outBuff = new byte[len43 + ((len % 3) > 0 ? 4 : 0)];
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,EncodeBytes,The following statement contains a magic number: byte[] outBuff = new byte[len43 + ((len % 3) > 0 ? 4 : 0)];
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,EncodeBytes,The following statement contains a magic number: int len2 = len - 2;
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,EncodeBytes,The following statement contains a magic number: for (; d < len2; d += 3' e += 4)  			{  				Encode3to4(source' d + off' 3' outBuff' e);  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,EncodeBytes,The following statement contains a magic number: for (; d < len2; d += 3' e += 4)  			{  				Encode3to4(source' d + off' 3' outBuff' e);  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,EncodeBytes,The following statement contains a magic number: for (; d < len2; d += 3' e += 4)  			{  				Encode3to4(source' d + off' 3' outBuff' e);  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,EncodeBytes,The following statement contains a magic number: if (d < len)  			{  				Encode3to4(source' d + off' len - d' outBuff' e);  				e += 4;  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Decode4to3,The following statement contains a magic number: if (source[srcOffset + 2] == EQUALS_SIGN)  			{  				int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  					[srcOffset + 1]] & unchecked((int)(0xFF))) << 12);  				destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  				return 1;  			}  			else  			{  				// Example: DkL=  				if (source[srcOffset + 3] == EQUALS_SIGN)  				{  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6);  					destination[destOffset] = unchecked((byte)((int)(((uint)outBuff) >> 16)));  					destination[destOffset + 1] = unchecked((byte)((int)(((uint)outBuff) >> 8)));  					return 2;  				}  				else  				{  					// Example: DkLE  					int outBuff = ((DEC[source[srcOffset]] & unchecked((int)(0xFF))) << 18) | ((DEC[source  						[srcOffset + 1]] & unchecked((int)(0xFF))) << 12) | ((DEC[source[srcOffset + 2]]  						 & unchecked((int)(0xFF))) << 6) | ((DEC[source[srcOffset + 3]] & unchecked((int  						)(0xFF))));  					destination[destOffset] = unchecked((byte)(outBuff >> 16));  					destination[destOffset + 1] = unchecked((byte)(outBuff >> 8));  					destination[destOffset + 2] = unchecked((byte)(outBuff));  					return 3;  				}  			}
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,DecodeBytes,The following statement contains a magic number: byte[] outBuff = new byte[len * 3 / 4];
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,DecodeBytes,The following statement contains a magic number: byte[] outBuff = new byte[len * 3 / 4];
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,DecodeBytes,The following statement contains a magic number: byte[] b4 = new byte[4];
Magic Number,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,DecodeBytes,The following statement contains a magic number: for (int i = off; i < off + len; i++)  			{  				byte sbiCrop = unchecked((byte)(source[i] & unchecked((int)(0x7f))));  				sbyte sbiDecode = DEC[sbiCrop];  				if (unchecked((sbyte)EQUALS_SIGN_DEC) <= sbiDecode)  				{  					b4[b4Posn++] = sbiCrop;  					if (b4Posn > 3)  					{  						outBuffPosn += Decode4to3(b4' 0' outBuff' outBuffPosn);  						b4Posn = 0;  						// If that was the equals sign' break out of 'for' loop  						if (sbiCrop == EQUALS_SIGN)  						{  							break;  						}  					}  				}  				else  				{  					if (sbiDecode != WHITE_SPACE_DEC)  					{  						throw new ArgumentException(MessageFormat.Format(JGitText.Get().badBase64InputCharacterAt  							' Sharpen.Extensions.ValueOf(i)' Sharpen.Extensions.ValueOf(source[i] & unchecked(  							(int)(0xff)))));  					}  				}  			}
Magic Number,NGit.Util,ChangeIdUtil,C:\repos\mono_ngit\NGit\NGit.Util\ChangeIdUtil.cs,InsertId,The following statement contains a magic number: if (message.IndexOf(CHANGE_ID) > 0)  			{  				if (replaceExisting)  				{  					int i = message.IndexOf(CHANGE_ID) + 10;  					while (message[i] == ' ')  					{  						i++;  					}  					string oldId = message.Length == (i + 40) ? Sharpen.Runtime.Substring(message' i)  						 : Sharpen.Runtime.Substring(message' i' i + 41);  					message = message.Replace(oldId' "I" + changeId.GetName());  				}  				return message;  			}
Magic Number,NGit.Util,ChangeIdUtil,C:\repos\mono_ngit\NGit\NGit.Util\ChangeIdUtil.cs,InsertId,The following statement contains a magic number: if (message.IndexOf(CHANGE_ID) > 0)  			{  				if (replaceExisting)  				{  					int i = message.IndexOf(CHANGE_ID) + 10;  					while (message[i] == ' ')  					{  						i++;  					}  					string oldId = message.Length == (i + 40) ? Sharpen.Runtime.Substring(message' i)  						 : Sharpen.Runtime.Substring(message' i' i + 41);  					message = message.Replace(oldId' "I" + changeId.GetName());  				}  				return message;  			}
Magic Number,NGit.Util,ChangeIdUtil,C:\repos\mono_ngit\NGit\NGit.Util\ChangeIdUtil.cs,InsertId,The following statement contains a magic number: if (message.IndexOf(CHANGE_ID) > 0)  			{  				if (replaceExisting)  				{  					int i = message.IndexOf(CHANGE_ID) + 10;  					while (message[i] == ' ')  					{  						i++;  					}  					string oldId = message.Length == (i + 40) ? Sharpen.Runtime.Substring(message' i)  						 : Sharpen.Runtime.Substring(message' i' i + 41);  					message = message.Replace(oldId' "I" + changeId.GetName());  				}  				return message;  			}
Magic Number,NGit.Util,FS_Win32,C:\repos\mono_ngit\NGit\NGit.Util\FS_Win32.cs,RunInShell,The following statement contains a magic number: IList<string> argv = new AList<string>(3 + args.Length);
Magic Number,NGit.Util,FS_Win32_Cygwin,C:\repos\mono_ngit\NGit\NGit.Util\FS_Win32_Cygwin.cs,RunInShell,The following statement contains a magic number: IList<string> argv = new AList<string>(4 + args.Length);
Magic Number,NGit.Util,IntList,C:\repos\mono_ngit\NGit\NGit.Util\IntList.cs,Grow,The following statement contains a magic number: int[] n = new int[(entries.Length + 16) * 3 / 2];
Magic Number,NGit.Util,IntList,C:\repos\mono_ngit\NGit\NGit.Util\IntList.cs,Grow,The following statement contains a magic number: int[] n = new int[(entries.Length + 16) * 3 / 2];
Magic Number,NGit.Util,IntList,C:\repos\mono_ngit\NGit\NGit.Util\IntList.cs,Grow,The following statement contains a magic number: int[] n = new int[(entries.Length + 16) * 3 / 2];
Magic Number,NGit.Util,LongList,C:\repos\mono_ngit\NGit\NGit.Util\LongList.cs,Grow,The following statement contains a magic number: long[] n = new long[(entries.Length + 16) * 3 / 2];
Magic Number,NGit.Util,LongList,C:\repos\mono_ngit\NGit\NGit.Util\LongList.cs,Grow,The following statement contains a magic number: long[] n = new long[(entries.Length + 16) * 3 / 2];
Magic Number,NGit.Util,LongList,C:\repos\mono_ngit\NGit\NGit.Util\LongList.cs,Grow,The following statement contains a magic number: long[] n = new long[(entries.Length + 16) * 3 / 2];
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,DecodeUInt16,The following statement contains a magic number: int r = (intbuf[offset] & unchecked((int)(0xff))) << 8;
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,DecodeInt32,The following statement contains a magic number: int r = intbuf[offset] << 8;
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,DecodeInt32,The following statement contains a magic number: r <<= 8;
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,DecodeInt32,The following statement contains a magic number: r |= intbuf[offset + 2] & unchecked((int)(0xff));
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,DecodeInt32,The following statement contains a magic number: return (r << 8) | (intbuf[offset + 3] & unchecked((int)(0xff)));
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,DecodeInt32,The following statement contains a magic number: return (r << 8) | (intbuf[offset + 3] & unchecked((int)(0xff)));
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,DecodeUInt32,The following statement contains a magic number: int low = (intbuf[offset + 1] & unchecked((int)(0xff))) << 8;
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,DecodeUInt32,The following statement contains a magic number: low |= (intbuf[offset + 2] & unchecked((int)(0xff)));
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,DecodeUInt32,The following statement contains a magic number: low <<= 8;
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,DecodeUInt32,The following statement contains a magic number: low |= (intbuf[offset + 3] & unchecked((int)(0xff)));
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,DecodeUInt32,The following statement contains a magic number: return ((long)(intbuf[offset] & unchecked((int)(0xff)))) << 24 | low;
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,DecodeUInt64,The following statement contains a magic number: return (DecodeUInt32(intbuf' offset) << 32) | DecodeUInt32(intbuf' offset + 4);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,DecodeUInt64,The following statement contains a magic number: return (DecodeUInt32(intbuf' offset) << 32) | DecodeUInt32(intbuf' offset + 4);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt16,The following statement contains a magic number: v = (int)(((uint)v) >> 8);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt32,The following statement contains a magic number: intbuf[offset + 3] = unchecked((byte)v);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt32,The following statement contains a magic number: v = (int)(((uint)v) >> 8);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt32,The following statement contains a magic number: intbuf[offset + 2] = unchecked((byte)v);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt32,The following statement contains a magic number: v = (int)(((uint)v) >> 8);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt32,The following statement contains a magic number: v = (int)(((uint)v) >> 8);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt64,The following statement contains a magic number: intbuf[offset + 7] = unchecked((byte)v);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt64,The following statement contains a magic number: v = (long)(((ulong)v) >> 8);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt64,The following statement contains a magic number: intbuf[offset + 6] = unchecked((byte)v);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt64,The following statement contains a magic number: v = (long)(((ulong)v) >> 8);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt64,The following statement contains a magic number: intbuf[offset + 5] = unchecked((byte)v);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt64,The following statement contains a magic number: v = (long)(((ulong)v) >> 8);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt64,The following statement contains a magic number: intbuf[offset + 4] = unchecked((byte)v);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt64,The following statement contains a magic number: v = (long)(((ulong)v) >> 8);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt64,The following statement contains a magic number: intbuf[offset + 3] = unchecked((byte)v);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt64,The following statement contains a magic number: v = (long)(((ulong)v) >> 8);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt64,The following statement contains a magic number: intbuf[offset + 2] = unchecked((byte)v);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt64,The following statement contains a magic number: v = (long)(((ulong)v) >> 8);
Magic Number,NGit.Util,NB,C:\repos\mono_ngit\NGit\NGit.Util\NB.cs,EncodeInt64,The following statement contains a magic number: v = (long)(((ulong)v) >> 8);
Magic Number,NGit.Util,GitPathStyle,C:\repos\mono_ngit\NGit\NGit.Util\QuotedString.cs,GitPathStyle,The following statement contains a magic number: quote = new byte[128];
Magic Number,NGit.Util,GitPathStyle,C:\repos\mono_ngit\NGit\NGit.Util\QuotedString.cs,Quote,The following statement contains a magic number: StringBuilder r = new StringBuilder(2 + @in.Length);
Magic Number,NGit.Util,GitPathStyle,C:\repos\mono_ngit\NGit\NGit.Util\QuotedString.cs,Quote,The following statement contains a magic number: for (int i = 0; i < @in.Length; i++)  				{  					int c = @in[i] & unchecked((int)(0xff));  					if (c < quote.Length)  					{  						byte style = quote[c];  						if (style == 0)  						{  							r.Append((char)c);  							continue;  						}  						if (style > 0)  						{  							reuse = false;  							r.Append('\\');  							r.Append((char)style);  							continue;  						}  					}  					reuse = false;  					r.Append('\\');  					r.Append((char)(((c >> 6) & 0x3) + '0'));  					r.Append((char)(((c >> 3) & 0x7) + '0'));  					r.Append((char)(((c >> 0) & 0x7) + '0'));  				}
Magic Number,NGit.Util,GitPathStyle,C:\repos\mono_ngit\NGit\NGit.Util\QuotedString.cs,Quote,The following statement contains a magic number: for (int i = 0; i < @in.Length; i++)  				{  					int c = @in[i] & unchecked((int)(0xff));  					if (c < quote.Length)  					{  						byte style = quote[c];  						if (style == 0)  						{  							r.Append((char)c);  							continue;  						}  						if (style > 0)  						{  							reuse = false;  							r.Append('\\');  							r.Append((char)style);  							continue;  						}  					}  					reuse = false;  					r.Append('\\');  					r.Append((char)(((c >> 6) & 0x3) + '0'));  					r.Append((char)(((c >> 3) & 0x7) + '0'));  					r.Append((char)(((c >> 0) & 0x7) + '0'));  				}
Magic Number,NGit.Util,GitPathStyle,C:\repos\mono_ngit\NGit\NGit.Util\QuotedString.cs,Dequote,The following statement contains a magic number: if (2 <= inEnd - inPtr && @in[inPtr] == '"' && @in[inEnd - 1] == '"')  				{  					return Dq(@in' inPtr + 1' inEnd - 1);  				}
Magic Number,NGit.Util,GitPathStyle,C:\repos\mono_ngit\NGit\NGit.Util\QuotedString.cs,Dq,The following statement contains a magic number: while (inPtr < inEnd)  				{  					byte b = @in[inPtr++];  					if (b != '\\')  					{  						r[rPtr++] = b;  						continue;  					}  					if (inPtr == inEnd)  					{  						// Lone trailing backslash. Treat it as a literal.  						//  						r[rPtr++] = (byte)('\\');  						break;  					}  					switch (@in[inPtr++])  					{  						case (byte)('a'):  						{  							r[rPtr++] = unchecked((int)(0x07));  							continue;  							goto case (byte)('b');  						}    						case (byte)('b'):  						{  							r[rPtr++] = (byte)('\b');  							continue;  							goto case (byte)('f');  						}    						case (byte)('f'):  						{  							r[rPtr++] = (byte)('\f');  							continue;  							goto case (byte)('n');  						}    						case (byte)('n'):  						{  							r[rPtr++] = (byte)('\n');  							continue;  							goto case (byte)('r');  						}    						case (byte)('r'):  						{  							r[rPtr++] = (byte)('\r');  							continue;  							goto case (byte)('t');  						}    						case (byte)('t'):  						{  							r[rPtr++] = (byte)('\t');  							continue;  							goto case (byte)('v');  						}    						case (byte)('v'):  						{  							r[rPtr++] = unchecked((int)(0x0B));  							continue;  							goto case (byte)('\\');  						}    						case (byte)('\\'):  						case (byte)('"'):  						{  							r[rPtr++] = @in[inPtr - 1];  							continue;  							goto case (byte)('0');  						}    						case (byte)('0'):  						case (byte)('1'):  						case (byte)('2'):  						case (byte)('3'):  						{  							int cp = @in[inPtr - 1] - '0';  							for (int n = 1; n < 3 && inPtr < inEnd; n++)  							{  								byte c = @in[inPtr];  								if ('0' <= c && ((sbyte)c) <= '7')  								{  									cp <<= 3;  									cp |= c - '0';  									inPtr++;  								}  								else  								{  									break;  								}  							}  							r[rPtr++] = unchecked((byte)cp);  							continue;  							goto default;  						}    						default:  						{  							// Any other code is taken literally.  							//  							r[rPtr++] = (byte)('\\');  							r[rPtr++] = @in[inPtr - 1];  							continue;  							break;  						}  					}  				}
Magic Number,NGit.Util,GitPathStyle,C:\repos\mono_ngit\NGit\NGit.Util\QuotedString.cs,Dq,The following statement contains a magic number: while (inPtr < inEnd)  				{  					byte b = @in[inPtr++];  					if (b != '\\')  					{  						r[rPtr++] = b;  						continue;  					}  					if (inPtr == inEnd)  					{  						// Lone trailing backslash. Treat it as a literal.  						//  						r[rPtr++] = (byte)('\\');  						break;  					}  					switch (@in[inPtr++])  					{  						case (byte)('a'):  						{  							r[rPtr++] = unchecked((int)(0x07));  							continue;  							goto case (byte)('b');  						}    						case (byte)('b'):  						{  							r[rPtr++] = (byte)('\b');  							continue;  							goto case (byte)('f');  						}    						case (byte)('f'):  						{  							r[rPtr++] = (byte)('\f');  							continue;  							goto case (byte)('n');  						}    						case (byte)('n'):  						{  							r[rPtr++] = (byte)('\n');  							continue;  							goto case (byte)('r');  						}    						case (byte)('r'):  						{  							r[rPtr++] = (byte)('\r');  							continue;  							goto case (byte)('t');  						}    						case (byte)('t'):  						{  							r[rPtr++] = (byte)('\t');  							continue;  							goto case (byte)('v');  						}    						case (byte)('v'):  						{  							r[rPtr++] = unchecked((int)(0x0B));  							continue;  							goto case (byte)('\\');  						}    						case (byte)('\\'):  						case (byte)('"'):  						{  							r[rPtr++] = @in[inPtr - 1];  							continue;  							goto case (byte)('0');  						}    						case (byte)('0'):  						case (byte)('1'):  						case (byte)('2'):  						case (byte)('3'):  						{  							int cp = @in[inPtr - 1] - '0';  							for (int n = 1; n < 3 && inPtr < inEnd; n++)  							{  								byte c = @in[inPtr];  								if ('0' <= c && ((sbyte)c) <= '7')  								{  									cp <<= 3;  									cp |= c - '0';  									inPtr++;  								}  								else  								{  									break;  								}  							}  							r[rPtr++] = unchecked((byte)cp);  							continue;  							goto default;  						}    						default:  						{  							// Any other code is taken literally.  							//  							r[rPtr++] = (byte)('\\');  							r[rPtr++] = @in[inPtr - 1];  							continue;  							break;  						}  					}  				}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,RawParseUtils,The following statement contains a magic number: for (char i_2 = 'a'; i_2 <= 'f'; i_2++)  			{  				digits16[i_2] = (sbyte)((i_2 - (sbyte)('a')) + 10);  			}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,RawParseUtils,The following statement contains a magic number: for (char i_3 = 'A'; i_3 <= 'F'; i_3++)  			{  				digits16[i_3] = (sbyte)((i_3 - (sbyte)('A')) + 10);  			}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,FormatBase10,The following statement contains a magic number: while (value != 0)  			{  				b[--o] = base10byte[value % 10];  				value /= 10;  			}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,FormatBase10,The following statement contains a magic number: while (value != 0)  			{  				b[--o] = base10byte[value % 10];  				value /= 10;  			}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseBase10,The following statement contains a magic number: try  			{  				int sz = b.Length;  				while (ptr < sz && b[ptr] == ' ')  				{  					ptr++;  				}  				if (ptr >= sz)  				{  					return 0;  				}  				switch (b[ptr])  				{  					case (byte)('-'):  					{  						sign = -1;  						ptr++;  						break;  					}    					case (byte)('+'):  					{  						ptr++;  						break;  					}  				}  				while (ptr < sz)  				{  					byte v = digits10[b[ptr]];  					if (((sbyte)v) < 0)  					{  						break;  					}  					r = (r * 10) + v;  					ptr++;  				}  			}  			catch (IndexOutOfRangeException)  			{  			}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseLongBase10,The following statement contains a magic number: try  			{  				int sz = b.Length;  				while (ptr < sz && b[ptr] == ' ')  				{  					ptr++;  				}  				if (ptr >= sz)  				{  					return 0;  				}  				switch (b[ptr])  				{  					case (byte)('-'):  					{  						sign = -1;  						ptr++;  						break;  					}    					case (byte)('+'):  					{  						ptr++;  						break;  					}  				}  				while (ptr < sz)  				{  					byte v = digits10[b[ptr]];  					if (((sbyte)v) < 0)  					{  						break;  					}  					r = (r * 10) + v;  					ptr++;  				}  			}  			catch (IndexOutOfRangeException)  			{  			}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt16,The following statement contains a magic number: int r = digits16[bs[p]] << 4;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt16,The following statement contains a magic number: r <<= 4;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt16,The following statement contains a magic number: r |= digits16[bs[p + 2]];
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt16,The following statement contains a magic number: r <<= 4;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt16,The following statement contains a magic number: r |= digits16[bs[p + 3]];
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt32,The following statement contains a magic number: int r = digits16[bs[p]] << 4;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt32,The following statement contains a magic number: r <<= 4;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt32,The following statement contains a magic number: r |= digits16[bs[p + 2]];
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt32,The following statement contains a magic number: r <<= 4;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt32,The following statement contains a magic number: r |= digits16[bs[p + 3]];
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt32,The following statement contains a magic number: r <<= 4;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt32,The following statement contains a magic number: r |= digits16[bs[p + 4]];
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt32,The following statement contains a magic number: r <<= 4;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt32,The following statement contains a magic number: r |= digits16[bs[p + 5]];
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt32,The following statement contains a magic number: r <<= 4;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt32,The following statement contains a magic number: r |= digits16[bs[p + 6]];
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt32,The following statement contains a magic number: int last = digits16[bs[p + 7]];
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseHexInt32,The following statement contains a magic number: return (r << 4) | last;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseTimeZoneOffset,The following statement contains a magic number: int tzMins = v % 100;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseTimeZoneOffset,The following statement contains a magic number: int tzHours = v / 100;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseTimeZoneOffset,The following statement contains a magic number: return tzHours * 60 + tzMins;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,LineMap,The following statement contains a magic number: IntList map = new IntList((end - ptr) / 36);
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,Author,The following statement contains a magic number: if (ptr == 0)  			{  				ptr += 46;  			}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,Author,The following statement contains a magic number: while (ptr < sz && b[ptr] == 'p')  			{  				ptr += 48;  			}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,Committer,The following statement contains a magic number: if (ptr == 0)  			{  				ptr += 46;  			}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,Committer,The following statement contains a magic number: while (ptr < sz && b[ptr] == 'p')  			{  				ptr += 48;  			}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,Tagger,The following statement contains a magic number: if (ptr == 0)  			{  				ptr += 48;  			}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParsePersonIdent,The following statement contains a magic number: int nameEnd = emailB - 2 >= nameB && raw[emailB - 2] == ' ' ? emailB - 2 : emailB  				 - 1;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParsePersonIdent,The following statement contains a magic number: int nameEnd = emailB - 2 >= nameB && raw[emailB - 2] == ' ' ? emailB - 2 : emailB  				 - 1;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParsePersonIdent,The following statement contains a magic number: int nameEnd = emailB - 2 >= nameB && raw[emailB - 2] == ' ' ? emailB - 2 : emailB  				 - 1;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParsePersonIdent,The following statement contains a magic number: int tzBegin = LastIndexOfTrim(raw' ' '' NextLF(raw' emailE - 1) - 2) + 1;
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParsePersonIdentOnly,The following statement contains a magic number: if (emailB < stop)  			{  				name = Decode(raw' nameB' emailB - 2);  			}  			else  			{  				name = Decode(raw' nameB' stop);  			}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,CommitMessage,The following statement contains a magic number: if (ptr == 0)  			{  				ptr += 46;  			}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,CommitMessage,The following statement contains a magic number: while (ptr < sz && b[ptr] == 'p')  			{  				ptr += 48;  			}
Magic Number,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,TagMessage,The following statement contains a magic number: if (ptr == 0)  			{  				ptr += 48;  			}
Magic Number,NGit.Util,RefList<T>,C:\repos\mono_ngit\NGit\NGit.Util\RefList.cs,Copy,The following statement contains a magic number: RefListBuilder<T> r = new RefListBuilder<T>(Math.Max(16' n));
Magic Number,NGit.Util,RefListBuilder<T>,C:\repos\mono_ngit\NGit\NGit.Util\RefList.cs,Add,The following statement contains a magic number: if (list.Length == size)  			{  				Ref[] n = new Ref[size * 2];  				System.Array.Copy(list' 0' n' 0' size);  				list = n;  			}
Magic Number,NGit.Util,RefListBuilder<T>,C:\repos\mono_ngit\NGit\NGit.Util\RefList.cs,AddAll,The following statement contains a magic number: if (list.Length < size + cnt)  			{  				Ref[] n = new Ref[Math.Max(size * 2' size + cnt)];  				System.Array.Copy(list' 0' n' 0' size);  				list = n;  			}
Magic Number,NGit.Util,_SystemReader_71,C:\repos\mono_ngit\NGit\NGit.Util\SystemReader.cs,GetTimezone,The following statement contains a magic number: return this.GetTimeZone().GetOffset(when) / (60 * 1000);
Magic Number,NGit.Util,_SystemReader_71,C:\repos\mono_ngit\NGit\NGit.Util\SystemReader.cs,GetTimezone,The following statement contains a magic number: return this.GetTimeZone().GetOffset(when) / (60 * 1000);
Magic Number,NGit.Util,TemporaryBuffer,C:\repos\mono_ngit\NGit\NGit.Util\TemporaryBuffer.cs,WriteTo,The following statement contains a magic number: foreach (TemporaryBuffer.Block b in blocks)  			{  				os.Write(b.buffer' 0' b.count);  				pm.Update(b.count / 1024);  			}
Magic Number,NGit.Util,LocalFile,C:\repos\mono_ngit\NGit\NGit.Util\TemporaryBuffer.cs,WriteTo,The following statement contains a magic number: try  				{  					int cnt;  					byte[] buf = new byte[TemporaryBuffer.Block.SZ];  					while ((cnt = @in.Read(buf)) >= 0)  					{  						os.Write(buf' 0' cnt);  						pm.Update(cnt / 1024);  					}  				}  				finally  				{  					@in.Close();  				}
Magic Number,NGit.Util,IOUtil,C:\repos\mono_ngit\NGit\NGit.Util\IOUtil.cs,ReadFully,The following statement contains a magic number: try  			{  				long sz = Math.Max(path.Length()' 1);  				if (sz > max)  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().fileIsTooLarge' path));  				}  				byte[] buf = new byte[(int)sz];  				int valid = 0;  				for (; ; )  				{  					if (buf.Length == valid)  					{  						if (buf.Length == max)  						{  							int next = @in.Read();  							if (next < 0)  							{  								break;  							}  							throw new IOException(MessageFormat.Format(JGitText.Get().fileIsTooLarge' path));  						}  						byte[] nb = new byte[Math.Min(buf.Length * 2' max)];  						System.Array.Copy(buf' 0' nb' 0' valid);  						buf = nb;  					}  					int n = @in.Read(buf' valid' buf.Length - valid);  					if (n < 0)  					{  						break;  					}  					valid += n;  				}  				if (valid < buf.Length)  				{  					byte[] nb = new byte[valid];  					System.Array.Copy(buf' 0' nb' 0' valid);  					buf = nb;  				}  				return buf;  			}  			finally  			{  				try  				{  					@in.Close();  				}  				catch (IOException)  				{  				}  			}
Magic Number,NGit.Util,FileUtils,C:\repos\mono_ngit\NGit\NGit.Util\FileUtils.cs,Delete,The following statement contains a magic number: if (!f.Delete())  			{  				if ((options & RETRY) != 0 && f.Exists())  				{  					for (int i = 1; i < 10; i++)  					{  						try  						{  							Sharpen.Thread.Sleep(100);  						}  						catch (Exception)  						{  						}  						// ignore  						if (f.Delete())  						{  							return;  						}  					}  				}  				if ((options & IGNORE_ERRORS) == 0)  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().deleteFileFailed' f.GetAbsolutePath  						()));  				}  			}
Magic Number,NGit.Util,FileUtils,C:\repos\mono_ngit\NGit\NGit.Util\FileUtils.cs,Delete,The following statement contains a magic number: if (!f.Delete())  			{  				if ((options & RETRY) != 0 && f.Exists())  				{  					for (int i = 1; i < 10; i++)  					{  						try  						{  							Sharpen.Thread.Sleep(100);  						}  						catch (Exception)  						{  						}  						// ignore  						if (f.Delete())  						{  							return;  						}  					}  				}  				if ((options & IGNORE_ERRORS) == 0)  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().deleteFileFailed' f.GetAbsolutePath  						()));  				}  			}
Magic Number,NGit.Util,FS_POSIX,C:\repos\mono_ngit\NGit\NGit.Util\FS_POSIX.cs,RunInShell,The following statement contains a magic number: IList<string> argv = new AList<string>(4 + args.Length);
Magic Number,NGit.Util,BlockList<T>,C:\repos\mono_ngit\NGit\NGit.Util\BlockList.cs,BlockList,The following statement contains a magic number: directory = NGit.Util.BlockList<T>.NewDirectory(256);
Magic Number,NGit.Util,BlockList<T>,C:\repos\mono_ngit\NGit\NGit.Util\BlockList.cs,Add,The following statement contains a magic number: if (index == size)  			{  				// Fast-path: append onto the end of the list.  				AddItem(element);  			}  			else  			{  				if (index < 0 || size < index)  				{  					throw new IndexOutOfRangeException(index.ToString());  				}  				else  				{  					// Slow-path: the list needs to expand and insert.  					// Do this the naive way' callers shouldn't abuse  					// this class by entering this code path.  					//  					AddItem(default(T));  					// expand the list by one  					for (int oldIdx = size - 2; index <= oldIdx; oldIdx--)  					{  						Set(oldIdx + 1' this[oldIdx]);  					}  					Set(index' element);  				}  			}
Magic Number,NGit.Util,RelativeDateFormatter,C:\repos\mono_ngit\NGit\NGit.Util\RelativeDateFormatter.cs,Format,The following statement contains a magic number: if (ageMillis < 14 * DAY_IN_MILLIS)  			{  				return MessageFormat.Format(JGitText.Get().daysAgo' Round(ageMillis' DAY_IN_MILLIS  					));  			}
Magic Number,NGit.Util,RelativeDateFormatter,C:\repos\mono_ngit\NGit\NGit.Util\RelativeDateFormatter.cs,Format,The following statement contains a magic number: if (ageMillis < 10 * WEEK_IN_MILLIS)  			{  				return MessageFormat.Format(JGitText.Get().weeksAgo' Round(ageMillis' WEEK_IN_MILLIS  					));  			}
Magic Number,NGit.Util,RelativeDateFormatter,C:\repos\mono_ngit\NGit\NGit.Util\RelativeDateFormatter.cs,Format,The following statement contains a magic number: if (ageMillis < 5 * YEAR_IN_MILLIS)  			{  				long years = ageMillis / YEAR_IN_MILLIS;  				string yearLabel = (years > 1) ? JGitText.Get().years : JGitText.Get().year;  				//  				long months = Round(ageMillis % YEAR_IN_MILLIS' MONTH_IN_MILLIS);  				string monthLabel = (months > 1) ? JGitText.Get().months : (months == 1 ? JGitText  					.Get().month : string.Empty);  				//  				return MessageFormat.Format(months == 0 ? JGitText.Get().years0MonthsAgo : JGitText  					.Get().yearsMonthsAgo' new object[] { years' yearLabel' months' monthLabel });  			}
Magic Number,NGit.Util,RelativeDateFormatter,C:\repos\mono_ngit\NGit\NGit.Util\RelativeDateFormatter.cs,UpperLimit,The following statement contains a magic number: long limit = unit + unit / 2;
Magic Number,NGit.Util,RelativeDateFormatter,C:\repos\mono_ngit\NGit\NGit.Util\RelativeDateFormatter.cs,Round,The following statement contains a magic number: long rounded = (n + unit / 2) / unit;
Magic Number,NGit.Util,GitDateFormatter,C:\repos\mono_ngit\NGit\NGit.Util\GitDateFormatter.cs,FormatDate,The following statement contains a magic number: switch (format)  			{  				case GitDateFormatter.Format.RAW:  				{  					int offset = ident.GetTimeZoneOffset();  					string sign = offset < 0 ? "-" : "+";  					int offset2;  					if (offset < 0)  					{  						offset2 = -offset;  					}  					else  					{  						offset2 = offset;  					}  					int hours = offset2 / 60;  					int minutes = offset2 % 60;  					return string.Format("%d %s%02d%02d"' ident.GetWhen().GetTime() / 1000' sign' hours  						' minutes);  				}    				case GitDateFormatter.Format.RELATIVE:  				{  					return RelativeDateFormatter.Format(ident.GetWhen());  				}    				case GitDateFormatter.Format.LOCALELOCAL:  				case GitDateFormatter.Format.LOCAL:  				{  					dateTimeInstance.SetTimeZone(SystemReader.GetInstance().GetTimeZone());  					return dateTimeInstance.Format(ident.GetWhen());  				}    				case GitDateFormatter.Format.LOCALE:  				{  					tz = ident.GetTimeZone();  					if (tz == null)  					{  						tz = SystemReader.GetInstance().GetTimeZone();  					}  					dateTimeInstance.SetTimeZone(tz);  					dateTimeInstance2.SetTimeZone(tz);  					return dateTimeInstance.Format(ident.GetWhen()) + " " + dateTimeInstance2.Format(  						ident.GetWhen());  				}    				default:  				{  					tz = ident.GetTimeZone();  					if (tz == null)  					{  						tz = SystemReader.GetInstance().GetTimeZone();  					}  					dateTimeInstance.SetTimeZone(ident.GetTimeZone());  					return dateTimeInstance.Format(ident.GetWhen());  					break;  				}  			}
Magic Number,NGit.Util,GitDateFormatter,C:\repos\mono_ngit\NGit\NGit.Util\GitDateFormatter.cs,FormatDate,The following statement contains a magic number: switch (format)  			{  				case GitDateFormatter.Format.RAW:  				{  					int offset = ident.GetTimeZoneOffset();  					string sign = offset < 0 ? "-" : "+";  					int offset2;  					if (offset < 0)  					{  						offset2 = -offset;  					}  					else  					{  						offset2 = offset;  					}  					int hours = offset2 / 60;  					int minutes = offset2 % 60;  					return string.Format("%d %s%02d%02d"' ident.GetWhen().GetTime() / 1000' sign' hours  						' minutes);  				}    				case GitDateFormatter.Format.RELATIVE:  				{  					return RelativeDateFormatter.Format(ident.GetWhen());  				}    				case GitDateFormatter.Format.LOCALELOCAL:  				case GitDateFormatter.Format.LOCAL:  				{  					dateTimeInstance.SetTimeZone(SystemReader.GetInstance().GetTimeZone());  					return dateTimeInstance.Format(ident.GetWhen());  				}    				case GitDateFormatter.Format.LOCALE:  				{  					tz = ident.GetTimeZone();  					if (tz == null)  					{  						tz = SystemReader.GetInstance().GetTimeZone();  					}  					dateTimeInstance.SetTimeZone(tz);  					dateTimeInstance2.SetTimeZone(tz);  					return dateTimeInstance.Format(ident.GetWhen()) + " " + dateTimeInstance2.Format(  						ident.GetWhen());  				}    				default:  				{  					tz = ident.GetTimeZone();  					if (tz == null)  					{  						tz = SystemReader.GetInstance().GetTimeZone();  					}  					dateTimeInstance.SetTimeZone(ident.GetTimeZone());  					return dateTimeInstance.Format(ident.GetWhen());  					break;  				}  			}
Magic Number,NGit.Util,GitDateFormatter,C:\repos\mono_ngit\NGit\NGit.Util\GitDateFormatter.cs,FormatDate,The following statement contains a magic number: switch (format)  			{  				case GitDateFormatter.Format.RAW:  				{  					int offset = ident.GetTimeZoneOffset();  					string sign = offset < 0 ? "-" : "+";  					int offset2;  					if (offset < 0)  					{  						offset2 = -offset;  					}  					else  					{  						offset2 = offset;  					}  					int hours = offset2 / 60;  					int minutes = offset2 % 60;  					return string.Format("%d %s%02d%02d"' ident.GetWhen().GetTime() / 1000' sign' hours  						' minutes);  				}    				case GitDateFormatter.Format.RELATIVE:  				{  					return RelativeDateFormatter.Format(ident.GetWhen());  				}    				case GitDateFormatter.Format.LOCALELOCAL:  				case GitDateFormatter.Format.LOCAL:  				{  					dateTimeInstance.SetTimeZone(SystemReader.GetInstance().GetTimeZone());  					return dateTimeInstance.Format(ident.GetWhen());  				}    				case GitDateFormatter.Format.LOCALE:  				{  					tz = ident.GetTimeZone();  					if (tz == null)  					{  						tz = SystemReader.GetInstance().GetTimeZone();  					}  					dateTimeInstance.SetTimeZone(tz);  					dateTimeInstance2.SetTimeZone(tz);  					return dateTimeInstance.Format(ident.GetWhen()) + " " + dateTimeInstance2.Format(  						ident.GetWhen());  				}    				default:  				{  					tz = ident.GetTimeZone();  					if (tz == null)  					{  						tz = SystemReader.GetInstance().GetTimeZone();  					}  					dateTimeInstance.SetTimeZone(ident.GetTimeZone());  					return dateTimeInstance.Format(ident.GetWhen());  					break;  				}  			}
Magic Number,NGit.Util,GitDateParser,C:\repos\mono_ngit\NGit\NGit.Util\GitDateParser.cs,Parse_relative,The following statement contains a magic number: if (partsLength < 3 || (partsLength & 1) == 0 || !"ago".Equals(parts[parts.Length  				 - 1]))  			{  				return null;  			}
Magic Number,NGit.Util,GitDateParser,C:\repos\mono_ngit\NGit\NGit.Util\GitDateParser.cs,Parse_relative,The following statement contains a magic number: for (int i = 0; i < parts.Length - 2; i += 2)  			{  				try  				{  					number = System.Convert.ToInt32(parts[i]);  				}  				catch (FormatException)  				{  					return null;  				}  				if ("year".Equals(parts[i + 1]) || "years".Equals(parts[i + 1]))  				{  					cal.Add(JavaCalendar.YEAR' -number);  				}  				else  				{  					if ("month".Equals(parts[i + 1]) || "months".Equals(parts[i + 1]))  					{  						cal.Add(JavaCalendar.MONTH' -number);  					}  					else  					{  						if ("week".Equals(parts[i + 1]) || "weeks".Equals(parts[i + 1]))  						{  							cal.Add(JavaCalendar.WEEK_OF_YEAR' -number);  						}  						else  						{  							if ("day".Equals(parts[i + 1]) || "days".Equals(parts[i + 1]))  							{  								cal.Add(JavaCalendar.DATE' -number);  							}  							else  							{  								if ("hour".Equals(parts[i + 1]) || "hours".Equals(parts[i + 1]))  								{  									cal.Add(JavaCalendar.HOUR_OF_DAY' -number);  								}  								else  								{  									if ("minute".Equals(parts[i + 1]) || "minutes".Equals(parts[i + 1]))  									{  										cal.Add(JavaCalendar.MINUTE' -number);  									}  									else  									{  										if ("second".Equals(parts[i + 1]) || "seconds".Equals(parts[i + 1]))  										{  											cal.Add(JavaCalendar.SECOND' -number);  										}  										else  										{  											return null;  										}  									}  								}  							}  						}  					}  				}  			}
Magic Number,NGit.Util,GitDateParser,C:\repos\mono_ngit\NGit\NGit.Util\GitDateParser.cs,Parse_relative,The following statement contains a magic number: for (int i = 0; i < parts.Length - 2; i += 2)  			{  				try  				{  					number = System.Convert.ToInt32(parts[i]);  				}  				catch (FormatException)  				{  					return null;  				}  				if ("year".Equals(parts[i + 1]) || "years".Equals(parts[i + 1]))  				{  					cal.Add(JavaCalendar.YEAR' -number);  				}  				else  				{  					if ("month".Equals(parts[i + 1]) || "months".Equals(parts[i + 1]))  					{  						cal.Add(JavaCalendar.MONTH' -number);  					}  					else  					{  						if ("week".Equals(parts[i + 1]) || "weeks".Equals(parts[i + 1]))  						{  							cal.Add(JavaCalendar.WEEK_OF_YEAR' -number);  						}  						else  						{  							if ("day".Equals(parts[i + 1]) || "days".Equals(parts[i + 1]))  							{  								cal.Add(JavaCalendar.DATE' -number);  							}  							else  							{  								if ("hour".Equals(parts[i + 1]) || "hours".Equals(parts[i + 1]))  								{  									cal.Add(JavaCalendar.HOUR_OF_DAY' -number);  								}  								else  								{  									if ("minute".Equals(parts[i + 1]) || "minutes".Equals(parts[i + 1]))  									{  										cal.Add(JavaCalendar.MINUTE' -number);  									}  									else  									{  										if ("second".Equals(parts[i + 1]) || "seconds".Equals(parts[i + 1]))  										{  											cal.Add(JavaCalendar.SECOND' -number);  										}  										else  										{  											return null;  										}  									}  								}  							}  						}  					}  				}  			}
Magic Number,NGit.Util.IO,AlarmState,C:\repos\mono_ngit\NGit\NGit.Util.IO\InterruptTimer.cs,Run,The following statement contains a magic number: lock (this)  				{  					while (!terminated && callingThread.IsAlive())  					{  						try  						{  							if (0 < deadline)  							{  								long delay = deadline - Now();  								if (delay <= 0)  								{  									deadline = 0;  									callingThread.Interrupt();  								}  								else  								{  									Sharpen.Runtime.Wait(this' delay);  								}  							}  							else  							{  								Sharpen.Runtime.Wait(this' 1000);  							}  						}  						catch (Exception)  						{  						}  					}  				}
Magic Number,NGit.Util.IO,StreamCopyThread,C:\repos\mono_ngit\NGit\NGit.Util.IO\StreamCopyThread.cs,Halt,The following statement contains a magic number: for (; ; )  			{  				Join(250);  				if (IsAlive())  				{  					done = true;  					Interrupt();  				}  				else  				{  					break;  				}  			}
Magic Number,NGit.Util.IO,TeeInputStream,C:\repos\mono_ngit\NGit\NGit.Util.IO\TeeInputStream.cs,SkipBuffer,The following statement contains a magic number: if (skipBuffer == null)  			{  				skipBuffer = new byte[2048];  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Matches())  			{  				scheme = matcher.Group(1);  				rawPath = CleanLeadingSlashes(matcher.Group(2)' scheme);  				path = Unescape(rawPath);  				return;  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Matches())  			{  				scheme = matcher.Group(1);  				user = Unescape(matcher.Group(2));  				pass = Unescape(matcher.Group(3));  				host = Unescape(matcher.Group(4));  				if (matcher.Group(5) != null)  				{  					port = System.Convert.ToInt32(matcher.Group(5));  				}  				rawPath = CleanLeadingSlashes(N2e(matcher.Group(6)) + N2e(matcher.Group(7))' scheme  					);  				path = Unescape(rawPath);  				return;  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Matches())  			{  				scheme = matcher.Group(1);  				user = Unescape(matcher.Group(2));  				pass = Unescape(matcher.Group(3));  				host = Unescape(matcher.Group(4));  				if (matcher.Group(5) != null)  				{  					port = System.Convert.ToInt32(matcher.Group(5));  				}  				rawPath = CleanLeadingSlashes(N2e(matcher.Group(6)) + N2e(matcher.Group(7))' scheme  					);  				path = Unescape(rawPath);  				return;  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Matches())  			{  				scheme = matcher.Group(1);  				user = Unescape(matcher.Group(2));  				pass = Unescape(matcher.Group(3));  				host = Unescape(matcher.Group(4));  				if (matcher.Group(5) != null)  				{  					port = System.Convert.ToInt32(matcher.Group(5));  				}  				rawPath = CleanLeadingSlashes(N2e(matcher.Group(6)) + N2e(matcher.Group(7))' scheme  					);  				path = Unescape(rawPath);  				return;  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Matches())  			{  				scheme = matcher.Group(1);  				user = Unescape(matcher.Group(2));  				pass = Unescape(matcher.Group(3));  				host = Unescape(matcher.Group(4));  				if (matcher.Group(5) != null)  				{  					port = System.Convert.ToInt32(matcher.Group(5));  				}  				rawPath = CleanLeadingSlashes(N2e(matcher.Group(6)) + N2e(matcher.Group(7))' scheme  					);  				path = Unescape(rawPath);  				return;  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Matches())  			{  				scheme = matcher.Group(1);  				user = Unescape(matcher.Group(2));  				pass = Unescape(matcher.Group(3));  				host = Unescape(matcher.Group(4));  				if (matcher.Group(5) != null)  				{  					port = System.Convert.ToInt32(matcher.Group(5));  				}  				rawPath = CleanLeadingSlashes(N2e(matcher.Group(6)) + N2e(matcher.Group(7))' scheme  					);  				path = Unescape(rawPath);  				return;  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Matches())  			{  				scheme = matcher.Group(1);  				user = Unescape(matcher.Group(2));  				pass = Unescape(matcher.Group(3));  				host = Unescape(matcher.Group(4));  				if (matcher.Group(5) != null)  				{  					port = System.Convert.ToInt32(matcher.Group(5));  				}  				rawPath = CleanLeadingSlashes(N2e(matcher.Group(6)) + N2e(matcher.Group(7))' scheme  					);  				path = Unescape(rawPath);  				return;  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Matches())  			{  				scheme = matcher.Group(1);  				user = Unescape(matcher.Group(2));  				pass = Unescape(matcher.Group(3));  				host = Unescape(matcher.Group(4));  				if (matcher.Group(5) != null)  				{  					port = System.Convert.ToInt32(matcher.Group(5));  				}  				rawPath = CleanLeadingSlashes(N2e(matcher.Group(6)) + N2e(matcher.Group(7))' scheme  					);  				path = Unescape(rawPath);  				return;  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Matches())  			{  				user = matcher.Group(1);  				pass = matcher.Group(2);  				host = matcher.Group(3);  				rawPath = matcher.Group(4);  				path = rawPath;  				return;  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Matches())  			{  				user = matcher.Group(1);  				pass = matcher.Group(2);  				host = matcher.Group(3);  				rawPath = matcher.Group(4);  				path = rawPath;  				return;  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Matches())  			{  				user = matcher.Group(1);  				pass = matcher.Group(2);  				host = matcher.Group(3);  				rawPath = matcher.Group(4);  				path = rawPath;  				return;  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Matches())  			{  				user = matcher.Group(1);  				pass = matcher.Group(2);  				host = matcher.Group(3);  				rawPath = matcher.Group(4);  				path = rawPath;  				return;  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Matches())  			{  				user = matcher.Group(1);  				pass = matcher.Group(2);  				host = matcher.Group(3);  				rawPath = matcher.Group(4);  				path = rawPath;  				return;  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Matches())  			{  				user = matcher.Group(1);  				pass = matcher.Group(2);  				host = matcher.Group(3);  				rawPath = matcher.Group(4);  				path = rawPath;  				return;  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < bytes.Length; ++i)  			{  				byte c = bytes[i];  				if (c == '%')  				{  					if (i + 2 >= bytes.Length)  					{  						throw new URISyntaxException(s' JGitText.Get().cannotParseGitURIish);  					}  					int val = (RawParseUtils.ParseHexInt4(bytes[i + 1]) << 4) | RawParseUtils.ParseHexInt4  						(bytes[i + 2]);  					os[j++] = unchecked((byte)val);  					i += 2;  				}  				else  				{  					os[j++] = c;  				}  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < bytes.Length; ++i)  			{  				byte c = bytes[i];  				if (c == '%')  				{  					if (i + 2 >= bytes.Length)  					{  						throw new URISyntaxException(s' JGitText.Get().cannotParseGitURIish);  					}  					int val = (RawParseUtils.ParseHexInt4(bytes[i + 1]) << 4) | RawParseUtils.ParseHexInt4  						(bytes[i + 2]);  					os[j++] = unchecked((byte)val);  					i += 2;  				}  				else  				{  					os[j++] = c;  				}  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < bytes.Length; ++i)  			{  				byte c = bytes[i];  				if (c == '%')  				{  					if (i + 2 >= bytes.Length)  					{  						throw new URISyntaxException(s' JGitText.Get().cannotParseGitURIish);  					}  					int val = (RawParseUtils.ParseHexInt4(bytes[i + 1]) << 4) | RawParseUtils.ParseHexInt4  						(bytes[i + 2]);  					os[j++] = unchecked((byte)val);  					i += 2;  				}  				else  				{  					os[j++] = c;  				}  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < bytes.Length; ++i)  			{  				byte c = bytes[i];  				if (c == '%')  				{  					if (i + 2 >= bytes.Length)  					{  						throw new URISyntaxException(s' JGitText.Get().cannotParseGitURIish);  					}  					int val = (RawParseUtils.ParseHexInt4(bytes[i + 1]) << 4) | RawParseUtils.ParseHexInt4  						(bytes[i + 2]);  					os[j++] = unchecked((byte)val);  					i += 2;  				}  				else  				{  					os[j++] = c;  				}  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,Escape,The following statement contains a magic number: for (int i = 0; i < bytes.Length; ++i)  			{  				int b = bytes[i] & unchecked((int)(0xFF));  				if (b <= 32 || (encodeNonAscii && b > 127) || b == '%' || (escapeReservedChars &&  					 reservedChars.Get(b)))  				{  					os.Write('%');  					byte[] tmp = Constants.EncodeASCII(string.Format("{0:x2}"' Sharpen.Extensions.ValueOf  						(b)));  					os.Write(tmp[0]);  					os.Write(tmp[1]);  				}  				else  				{  					os.Write(b);  				}  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,Escape,The following statement contains a magic number: for (int i = 0; i < bytes.Length; ++i)  			{  				int b = bytes[i] & unchecked((int)(0xFF));  				if (b <= 32 || (encodeNonAscii && b > 127) || b == '%' || (escapeReservedChars &&  					 reservedChars.Get(b)))  				{  					os.Write('%');  					byte[] tmp = Constants.EncodeASCII(string.Format("{0:x2}"' Sharpen.Extensions.ValueOf  						(b)));  					os.Write(tmp[0]);  					os.Write(tmp[1]);  				}  				else  				{  					os.Write(b);  				}  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,CleanLeadingSlashes,The following statement contains a magic number: if (p.Length >= 3 && p[0] == '/' && p[2] == ':' && (p[1] >= 'A' && p[1] <= 'Z' ||  				 p[1] >= 'a' && p[1] <= 'z'))  			{  				return Sharpen.Runtime.Substring(p' 1);  			}  			else  			{  				if (s != null && p.Length >= 2 && p[0] == '/' && p[1] == '~')  				{  					return Sharpen.Runtime.Substring(p' 1);  				}  				else  				{  					return p;  				}  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,CleanLeadingSlashes,The following statement contains a magic number: if (p.Length >= 3 && p[0] == '/' && p[2] == ':' && (p[1] >= 'A' && p[1] <= 'Z' ||  				 p[1] >= 'a' && p[1] <= 'z'))  			{  				return Sharpen.Runtime.Substring(p' 1);  			}  			else  			{  				if (s != null && p.Length >= 2 && p[0] == '/' && p[1] == '~')  				{  					return Sharpen.Runtime.Substring(p' 1);  				}  				else  				{  					return p;  				}  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,CleanLeadingSlashes,The following statement contains a magic number: if (p.Length >= 3 && p[0] == '/' && p[2] == ':' && (p[1] >= 'A' && p[1] <= 'Z' ||  				 p[1] >= 'a' && p[1] <= 'z'))  			{  				return Sharpen.Runtime.Substring(p' 1);  			}  			else  			{  				if (s != null && p.Length >= 2 && p[0] == '/' && p[1] == '~')  				{  					return Sharpen.Runtime.Substring(p' 1);  				}  				else  				{  					return p;  				}  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (GetScheme() != null)  			{  				hc = hc * 31 + GetScheme().GetHashCode();  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (GetUser() != null)  			{  				hc = hc * 31 + GetUser().GetHashCode();  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (GetPass() != null)  			{  				hc = hc * 31 + GetPass().GetHashCode();  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (GetHost() != null)  			{  				hc = hc * 31 + GetHost().GetHashCode();  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (GetPort() > 0)  			{  				hc = hc * 31 + GetPort();  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (GetPath() != null)  			{  				hc = hc * 31 + GetPath().GetHashCode();  			}
Magic Number,NGit.Transport,URIish,C:\repos\mono_ngit\NGit\NGit.Transport\URIish.cs,GetHumanishName,The following statement contains a magic number: if (Constants.DOT_GIT.Equals(result))  			{  				result = elements[elements.Length - 2];  			}  			else  			{  				if (result.EndsWith(Constants.DOT_GIT_EXT))  				{  					result = Sharpen.Runtime.Substring(result' 0' result.Length - Constants.DOT_GIT_EXT  						.Length);  				}  			}
Magic Number,NGit.Transport,LongMap<V>,C:\repos\mono_ngit\NGit\NGit.Transport\LongMap.cs,LongMap,The following statement contains a magic number: table = CreateArray<V>(64);
Magic Number,NGit.Transport,LongMap<V>,C:\repos\mono_ngit\NGit\NGit.Transport\LongMap.cs,Index,The following statement contains a magic number: h ^= ((int)(((uint)h) >> 20)) ^ ((int)(((uint)h) >> 12));
Magic Number,NGit.Transport,LongMap<V>,C:\repos\mono_ngit\NGit\NGit.Transport\LongMap.cs,Index,The following statement contains a magic number: h ^= ((int)(((uint)h) >> 20)) ^ ((int)(((uint)h) >> 12));
Magic Number,NGit.Transport,RefSpec,C:\repos\mono_ngit\NGit\NGit.Transport\RefSpec.cs,GetHashCode,The following statement contains a magic number: if (GetSource() != null)  			{  				hc = hc * 31 + GetSource().GetHashCode();  			}
Magic Number,NGit.Transport,RefSpec,C:\repos\mono_ngit\NGit\NGit.Transport\RefSpec.cs,GetHashCode,The following statement contains a magic number: if (GetDestination() != null)  			{  				hc = hc * 31 + GetDestination().GetHashCode();  			}
Magic Number,NGit.Transport,PacketLineIn,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineIn.cs,ReadACK,The following statement contains a magic number: if (line.StartsWith("ACK "))  			{  				returnedId.FromString(Sharpen.Runtime.Substring(line' 4' 44));  				if (line.Length == 44)  				{  					return PacketLineIn.AckNackResult.ACK;  				}  				string arg = Sharpen.Runtime.Substring(line' 44);  				if (arg.Equals(" continue"))  				{  					return PacketLineIn.AckNackResult.ACK_CONTINUE;  				}  				else  				{  					if (arg.Equals(" common"))  					{  						return PacketLineIn.AckNackResult.ACK_COMMON;  					}  					else  					{  						if (arg.Equals(" ready"))  						{  							return PacketLineIn.AckNackResult.ACK_READY;  						}  					}  				}  			}
Magic Number,NGit.Transport,PacketLineIn,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineIn.cs,ReadACK,The following statement contains a magic number: if (line.StartsWith("ACK "))  			{  				returnedId.FromString(Sharpen.Runtime.Substring(line' 4' 44));  				if (line.Length == 44)  				{  					return PacketLineIn.AckNackResult.ACK;  				}  				string arg = Sharpen.Runtime.Substring(line' 44);  				if (arg.Equals(" continue"))  				{  					return PacketLineIn.AckNackResult.ACK_CONTINUE;  				}  				else  				{  					if (arg.Equals(" common"))  					{  						return PacketLineIn.AckNackResult.ACK_COMMON;  					}  					else  					{  						if (arg.Equals(" ready"))  						{  							return PacketLineIn.AckNackResult.ACK_READY;  						}  					}  				}  			}
Magic Number,NGit.Transport,PacketLineIn,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineIn.cs,ReadACK,The following statement contains a magic number: if (line.StartsWith("ACK "))  			{  				returnedId.FromString(Sharpen.Runtime.Substring(line' 4' 44));  				if (line.Length == 44)  				{  					return PacketLineIn.AckNackResult.ACK;  				}  				string arg = Sharpen.Runtime.Substring(line' 44);  				if (arg.Equals(" continue"))  				{  					return PacketLineIn.AckNackResult.ACK_CONTINUE;  				}  				else  				{  					if (arg.Equals(" common"))  					{  						return PacketLineIn.AckNackResult.ACK_COMMON;  					}  					else  					{  						if (arg.Equals(" ready"))  						{  							return PacketLineIn.AckNackResult.ACK_READY;  						}  					}  				}  			}
Magic Number,NGit.Transport,PacketLineIn,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineIn.cs,ReadACK,The following statement contains a magic number: if (line.StartsWith("ACK "))  			{  				returnedId.FromString(Sharpen.Runtime.Substring(line' 4' 44));  				if (line.Length == 44)  				{  					return PacketLineIn.AckNackResult.ACK;  				}  				string arg = Sharpen.Runtime.Substring(line' 44);  				if (arg.Equals(" continue"))  				{  					return PacketLineIn.AckNackResult.ACK_CONTINUE;  				}  				else  				{  					if (arg.Equals(" common"))  					{  						return PacketLineIn.AckNackResult.ACK_COMMON;  					}  					else  					{  						if (arg.Equals(" ready"))  						{  							return PacketLineIn.AckNackResult.ACK_READY;  						}  					}  				}  			}
Magic Number,NGit.Transport,PacketLineIn,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineIn.cs,ReadACK,The following statement contains a magic number: if (line.StartsWith("ERR "))  			{  				throw new PackProtocolException(Sharpen.Runtime.Substring(line' 4));  			}
Magic Number,NGit.Transport,PacketLineIn,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineIn.cs,ReadString,The following statement contains a magic number: len -= 4;
Magic Number,NGit.Transport,PacketLineIn,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineIn.cs,ReadStringRaw,The following statement contains a magic number: len -= 4;
Magic Number,NGit.Transport,PacketLineIn,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: IOUtil.ReadFully(@in' lineBuffer' 0' 4);
Magic Number,NGit.Transport,PacketLineIn,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: try  			{  				int len = RawParseUtils.ParseHexInt16(lineBuffer' 0);  				if (len != 0 && len < 4)  				{  					throw new IndexOutOfRangeException();  				}  				return len;  			}  			catch (IndexOutOfRangeException)  			{  				throw new IOException(MessageFormat.Format(JGitText.Get().invalidPacketLineHeader  					' string.Empty + (char)lineBuffer[0] + (char)lineBuffer[1] + (char)lineBuffer[2]  					 + (char)lineBuffer[3]));  			}
Magic Number,NGit.Transport,PacketLineIn,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: try  			{  				int len = RawParseUtils.ParseHexInt16(lineBuffer' 0);  				if (len != 0 && len < 4)  				{  					throw new IndexOutOfRangeException();  				}  				return len;  			}  			catch (IndexOutOfRangeException)  			{  				throw new IOException(MessageFormat.Format(JGitText.Get().invalidPacketLineHeader  					' string.Empty + (char)lineBuffer[0] + (char)lineBuffer[1] + (char)lineBuffer[2]  					 + (char)lineBuffer[3]));  			}
Magic Number,NGit.Transport,PacketLineIn,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: try  			{  				int len = RawParseUtils.ParseHexInt16(lineBuffer' 0);  				if (len != 0 && len < 4)  				{  					throw new IndexOutOfRangeException();  				}  				return len;  			}  			catch (IndexOutOfRangeException)  			{  				throw new IOException(MessageFormat.Format(JGitText.Get().invalidPacketLineHeader  					' string.Empty + (char)lineBuffer[0] + (char)lineBuffer[1] + (char)lineBuffer[2]  					 + (char)lineBuffer[3]));  			}
Magic Number,NGit.Transport,SideBandInputStream,C:\repos\mono_ngit\NGit\NGit.Transport\SideBandInputStream.cs,DoProgressLine,The following statement contains a magic number: if (matcher.Matches())  			{  				string taskname = matcher.Group(1);  				if (!currentTask.Equals(taskname))  				{  					currentTask = taskname;  					lastCnt = 0;  					BeginTask(System.Convert.ToInt32(matcher.Group(3)));  				}  				int cnt = System.Convert.ToInt32(matcher.Group(2));  				monitor.Update(cnt - lastCnt);  				lastCnt = cnt;  				return;  			}
Magic Number,NGit.Transport,SideBandInputStream,C:\repos\mono_ngit\NGit\NGit.Transport\SideBandInputStream.cs,DoProgressLine,The following statement contains a magic number: if (matcher.Matches())  			{  				string taskname = matcher.Group(1);  				if (!currentTask.Equals(taskname))  				{  					currentTask = taskname;  					lastCnt = 0;  					BeginTask(System.Convert.ToInt32(matcher.Group(3)));  				}  				int cnt = System.Convert.ToInt32(matcher.Group(2));  				monitor.Update(cnt - lastCnt);  				lastCnt = cnt;  				return;  			}
Magic Number,NGit.Transport,SideBandInputStream,C:\repos\mono_ngit\NGit\NGit.Transport\SideBandInputStream.cs,DoProgressLine,The following statement contains a magic number: if (matcher.Matches())  			{  				string taskname = matcher.Group(1);  				if (!currentTask.Equals(taskname))  				{  					currentTask = taskname;  					lastCnt = 0;  					BeginTask(ProgressMonitor.UNKNOWN);  				}  				int cnt = System.Convert.ToInt32(matcher.Group(2));  				monitor.Update(cnt - lastCnt);  				lastCnt = cnt;  				return;  			}
Magic Number,NGit.Transport,SideBandOutputStream,C:\repos\mono_ngit\NGit\NGit.Transport\SideBandOutputStream.cs,SideBandOutputStream,The following statement contains a magic number: if (chan <= 0 || chan > 255)  			{  				throw new ArgumentException(MessageFormat.Format(JGitText.Get().channelMustBeInRange0_255  					' Sharpen.Extensions.ValueOf(chan)));  			}
Magic Number,NGit.Transport,SideBandOutputStream,C:\repos\mono_ngit\NGit\NGit.Transport\SideBandOutputStream.cs,SideBandOutputStream,The following statement contains a magic number: buffer[4] = unchecked((byte)chan);
Magic Number,NGit.Transport,PacketLineOut,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineOut.cs,PacketLineOut,The following statement contains a magic number: lenbuffer = new byte[5];
Magic Number,NGit.Transport,PacketLineOut,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineOut.cs,WritePacket,The following statement contains a magic number: FormatLength(packet.Length + 4);
Magic Number,NGit.Transport,PacketLineOut,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineOut.cs,WritePacket,The following statement contains a magic number: @out.Write(lenbuffer' 0' 4);
Magic Number,NGit.Transport,PacketLineOut,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineOut.cs,End,The following statement contains a magic number: @out.Write(lenbuffer' 0' 4);
Magic Number,NGit.Transport,PacketLineOut,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineOut.cs,FormatLength,The following statement contains a magic number: int o = 3;
Magic Number,NGit.Transport,PacketLineOut,C:\repos\mono_ngit\NGit\NGit.Transport\PacketLineOut.cs,FormatLength,The following statement contains a magic number: while (o >= 0 && w != 0)  			{  				lenbuffer[o--] = hexchar[w & unchecked((int)(0xf))];  				w = (int)(((uint)w) >> 4);  			}
Magic Number,NGit.Transport,TrackingRefUpdate,C:\repos\mono_ngit\NGit\NGit.Transport\TrackingRefUpdate.cs,ToString,The following statement contains a magic number: sb.Append(oldObjectId == null ? string.Empty : oldObjectId.Abbreviate(7).Name);
Magic Number,NGit.Transport,TrackingRefUpdate,C:\repos\mono_ngit\NGit\NGit.Transport\TrackingRefUpdate.cs,ToString,The following statement contains a magic number: sb.Append(newObjectId == null ? string.Empty : newObjectId.Abbreviate(7).Name);
Magic Number,NGit.Transport,FetchProcess,C:\repos\mono_ngit\NGit\NGit.Transport\FetchProcess.cs,ExecuteImp,The following statement contains a magic number: try  			{  				if (monitor is BatchingProgressMonitor)  				{  					((BatchingProgressMonitor)monitor).SetDelayStart(250' TimeUnit.MILLISECONDS);  				}  				if (transport.IsRemoveDeletedRefs())  				{  					DeleteStaleTrackingRefs(result' batch);  				}  				foreach (TrackingRefUpdate u in localUpdates)  				{  					result.Add(u);  					batch.AddCommand(u.AsReceiveCommand());  				}  				foreach (ReceiveCommand cmd in batch.GetCommands())  				{  					cmd.UpdateType(walk);  					if (cmd.GetType() == ReceiveCommand.Type.UPDATE_NONFASTFORWARD && cmd is TrackingRefUpdate.Command  						 && !((TrackingRefUpdate.Command)cmd).CanForceUpdate())  					{  						cmd.SetResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);  					}  				}  				if (transport.IsDryRun())  				{  					foreach (ReceiveCommand cmd_1 in batch.GetCommands())  					{  						if (cmd_1.GetResult() == ReceiveCommand.Result.NOT_ATTEMPTED)  						{  							cmd_1.SetResult(ReceiveCommand.Result.OK);  						}  					}  				}  				else  				{  					batch.Execute(walk' monitor);  				}  			}  			catch (IOException err)  			{  				throw new TransportException(MessageFormat.Format(JGitText.Get().failureUpdatingTrackingRef  					' GetFirstFailedRefName(batch)' err.Message)' err);  			}  			finally  			{  				walk.Release();  			}
Magic Number,NGit.Transport,BasePackConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackConnection.cs,Init,The following statement contains a magic number: if (timeout > 0)  			{  				Sharpen.Thread caller = Sharpen.Thread.CurrentThread();  				myTimer = new InterruptTimer(caller.GetName() + "-Timer");  				timeoutIn = new TimeoutInputStream(myIn' myTimer);  				timeoutOut = new TimeoutOutputStream(myOut' myTimer);  				timeoutIn.SetTimeout(timeout * 1000);  				timeoutOut.SetTimeout(timeout * 1000);  				myIn = timeoutIn;  				myOut = timeoutOut;  			}
Magic Number,NGit.Transport,BasePackConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackConnection.cs,Init,The following statement contains a magic number: if (timeout > 0)  			{  				Sharpen.Thread caller = Sharpen.Thread.CurrentThread();  				myTimer = new InterruptTimer(caller.GetName() + "-Timer");  				timeoutIn = new TimeoutInputStream(myIn' myTimer);  				timeoutOut = new TimeoutOutputStream(myOut' myTimer);  				timeoutIn.SetTimeout(timeout * 1000);  				timeoutOut.SetTimeout(timeout * 1000);  				myIn = timeoutIn;  				myOut = timeoutOut;  			}
Magic Number,NGit.Transport,BasePackConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackConnection.cs,ReadAdvertisedRefsImpl,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadString();  				}  				catch (EOFException eof)  				{  					if (avail.IsEmpty())  					{  						throw NoRepository();  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					break;  				}  				if (line.StartsWith("ERR "))  				{  					// This is a customized remote service error.  					// Users should be informed about it.  					throw new RemoteRepositoryException(uri' Sharpen.Runtime.Substring(line' 4));  				}  				if (avail.IsEmpty())  				{  					int nul = line.IndexOf('\0');  					if (nul >= 0)  					{  						// The first line (if any) may contain "hidden"  						// capability values after a NUL byte.  						foreach (string c in Sharpen.Runtime.Substring(line' nul + 1).Split(" "))  						{  							remoteCapablities.AddItem(c);  						}  						line = Sharpen.Runtime.Substring(line' 0' nul);  					}  				}  				string name = Sharpen.Runtime.Substring(line' 41' line.Length);  				if (avail.IsEmpty() && name.Equals("capabilities^{}"))  				{  					// special line from git-receive-pack to show  					// capabilities when there are no refs to advertise  					continue;  				}  				ObjectId id = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' 40));  				if (name.Equals(".have"))  				{  					additionalHaves.AddItem(id);  				}  				else  				{  					if (name.EndsWith("^{}"))  					{  						name = Sharpen.Runtime.Substring(name' 0' name.Length - 3);  						Ref prior = avail.Get(name);  						if (prior == null)  						{  							throw new PackProtocolException(uri' MessageFormat.Format(JGitText.Get().advertisementCameBefore  								' name' name));  						}  						if (prior.GetPeeledObjectId() != null)  						{  							throw DuplicateAdvertisement(name + "^{}");  						}  						avail.Put(name' new ObjectIdRef.PeeledTag(RefStorage.NETWORK' name' prior.GetObjectId  							()' id));  					}  					else  					{  						Ref prior = avail.Put(name' new ObjectIdRef.PeeledNonTag(RefStorage.NETWORK' name  							' id));  						if (prior != null)  						{  							throw DuplicateAdvertisement(name);  						}  					}  				}  			}
Magic Number,NGit.Transport,BasePackConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackConnection.cs,ReadAdvertisedRefsImpl,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadString();  				}  				catch (EOFException eof)  				{  					if (avail.IsEmpty())  					{  						throw NoRepository();  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					break;  				}  				if (line.StartsWith("ERR "))  				{  					// This is a customized remote service error.  					// Users should be informed about it.  					throw new RemoteRepositoryException(uri' Sharpen.Runtime.Substring(line' 4));  				}  				if (avail.IsEmpty())  				{  					int nul = line.IndexOf('\0');  					if (nul >= 0)  					{  						// The first line (if any) may contain "hidden"  						// capability values after a NUL byte.  						foreach (string c in Sharpen.Runtime.Substring(line' nul + 1).Split(" "))  						{  							remoteCapablities.AddItem(c);  						}  						line = Sharpen.Runtime.Substring(line' 0' nul);  					}  				}  				string name = Sharpen.Runtime.Substring(line' 41' line.Length);  				if (avail.IsEmpty() && name.Equals("capabilities^{}"))  				{  					// special line from git-receive-pack to show  					// capabilities when there are no refs to advertise  					continue;  				}  				ObjectId id = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' 40));  				if (name.Equals(".have"))  				{  					additionalHaves.AddItem(id);  				}  				else  				{  					if (name.EndsWith("^{}"))  					{  						name = Sharpen.Runtime.Substring(name' 0' name.Length - 3);  						Ref prior = avail.Get(name);  						if (prior == null)  						{  							throw new PackProtocolException(uri' MessageFormat.Format(JGitText.Get().advertisementCameBefore  								' name' name));  						}  						if (prior.GetPeeledObjectId() != null)  						{  							throw DuplicateAdvertisement(name + "^{}");  						}  						avail.Put(name' new ObjectIdRef.PeeledTag(RefStorage.NETWORK' name' prior.GetObjectId  							()' id));  					}  					else  					{  						Ref prior = avail.Put(name' new ObjectIdRef.PeeledNonTag(RefStorage.NETWORK' name  							' id));  						if (prior != null)  						{  							throw DuplicateAdvertisement(name);  						}  					}  				}  			}
Magic Number,NGit.Transport,BasePackConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackConnection.cs,ReadAdvertisedRefsImpl,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadString();  				}  				catch (EOFException eof)  				{  					if (avail.IsEmpty())  					{  						throw NoRepository();  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					break;  				}  				if (line.StartsWith("ERR "))  				{  					// This is a customized remote service error.  					// Users should be informed about it.  					throw new RemoteRepositoryException(uri' Sharpen.Runtime.Substring(line' 4));  				}  				if (avail.IsEmpty())  				{  					int nul = line.IndexOf('\0');  					if (nul >= 0)  					{  						// The first line (if any) may contain "hidden"  						// capability values after a NUL byte.  						foreach (string c in Sharpen.Runtime.Substring(line' nul + 1).Split(" "))  						{  							remoteCapablities.AddItem(c);  						}  						line = Sharpen.Runtime.Substring(line' 0' nul);  					}  				}  				string name = Sharpen.Runtime.Substring(line' 41' line.Length);  				if (avail.IsEmpty() && name.Equals("capabilities^{}"))  				{  					// special line from git-receive-pack to show  					// capabilities when there are no refs to advertise  					continue;  				}  				ObjectId id = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' 40));  				if (name.Equals(".have"))  				{  					additionalHaves.AddItem(id);  				}  				else  				{  					if (name.EndsWith("^{}"))  					{  						name = Sharpen.Runtime.Substring(name' 0' name.Length - 3);  						Ref prior = avail.Get(name);  						if (prior == null)  						{  							throw new PackProtocolException(uri' MessageFormat.Format(JGitText.Get().advertisementCameBefore  								' name' name));  						}  						if (prior.GetPeeledObjectId() != null)  						{  							throw DuplicateAdvertisement(name + "^{}");  						}  						avail.Put(name' new ObjectIdRef.PeeledTag(RefStorage.NETWORK' name' prior.GetObjectId  							()' id));  					}  					else  					{  						Ref prior = avail.Put(name' new ObjectIdRef.PeeledNonTag(RefStorage.NETWORK' name  							' id));  						if (prior != null)  						{  							throw DuplicateAdvertisement(name);  						}  					}  				}  			}
Magic Number,NGit.Transport,BasePackConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackConnection.cs,ReadAdvertisedRefsImpl,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadString();  				}  				catch (EOFException eof)  				{  					if (avail.IsEmpty())  					{  						throw NoRepository();  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					break;  				}  				if (line.StartsWith("ERR "))  				{  					// This is a customized remote service error.  					// Users should be informed about it.  					throw new RemoteRepositoryException(uri' Sharpen.Runtime.Substring(line' 4));  				}  				if (avail.IsEmpty())  				{  					int nul = line.IndexOf('\0');  					if (nul >= 0)  					{  						// The first line (if any) may contain "hidden"  						// capability values after a NUL byte.  						foreach (string c in Sharpen.Runtime.Substring(line' nul + 1).Split(" "))  						{  							remoteCapablities.AddItem(c);  						}  						line = Sharpen.Runtime.Substring(line' 0' nul);  					}  				}  				string name = Sharpen.Runtime.Substring(line' 41' line.Length);  				if (avail.IsEmpty() && name.Equals("capabilities^{}"))  				{  					// special line from git-receive-pack to show  					// capabilities when there are no refs to advertise  					continue;  				}  				ObjectId id = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' 40));  				if (name.Equals(".have"))  				{  					additionalHaves.AddItem(id);  				}  				else  				{  					if (name.EndsWith("^{}"))  					{  						name = Sharpen.Runtime.Substring(name' 0' name.Length - 3);  						Ref prior = avail.Get(name);  						if (prior == null)  						{  							throw new PackProtocolException(uri' MessageFormat.Format(JGitText.Get().advertisementCameBefore  								' name' name));  						}  						if (prior.GetPeeledObjectId() != null)  						{  							throw DuplicateAdvertisement(name + "^{}");  						}  						avail.Put(name' new ObjectIdRef.PeeledTag(RefStorage.NETWORK' name' prior.GetObjectId  							()' id));  					}  					else  					{  						Ref prior = avail.Put(name' new ObjectIdRef.PeeledNonTag(RefStorage.NETWORK' name  							' id));  						if (prior != null)  						{  							throw DuplicateAdvertisement(name);  						}  					}  				}  			}
Magic Number,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,SendWants,The following statement contains a magic number: foreach (Ref r in want)  			{  				try  				{  					if (walk.ParseAny(r.GetObjectId()).Has(REACHABLE))  					{  						// We already have this object. Asking for it is  						// not a very good idea.  						//  						continue;  					}  				}  				catch (IOException)  				{  				}  				// Its OK' we don't have it' but we want to fix that  				// by fetching the object from the other side.  				StringBuilder line = new StringBuilder(46);  				line.Append("want ");  				line.Append(r.GetObjectId().Name);  				if (first)  				{  					line.Append(EnableCapabilities());  					first = false;  				}  				line.Append('\n');  				p.WriteString(line.ToString());  			}
Magic Number,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,Negotiate,The following statement contains a magic number: for (; ; )  			{  				RevCommit c = walk.Next();  				if (c == null)  				{  					goto SEND_HAVES_break;  				}  				pckOut.WriteString("have " + c.Id.Name + "\n");  				havesSent++;  				havesSinceLastContinue++;  				if ((31 & havesSent) != 0)  				{  					// We group the have lines into blocks of 32' each marked  					// with a flush (aka end). This one is within a block so  					// continue with another have line.  					//  					continue;  				}  				if (monitor.IsCancelled())  				{  					throw new BasePackFetchConnection.CancelledException();  				}  				pckOut.End();  				resultsPending++;  				// Each end will cause a result to come back.  				if (havesSent == 32 && !statelessRPC)  				{  					// On the first block we race ahead and try to send  					// more of the second block while waiting for the  					// remote to respond to our first block request.  					// This keeps us one block ahead of the peer.  					//  					continue;  				}  				for (; ; )  				{  					PacketLineIn.AckNackResult anr = pckIn.ReadACK(ackId);  					switch (anr)  					{  						case PacketLineIn.AckNackResult.NAK:  						{  							// More have lines are necessary to compute the  							// pack on the remote side. Keep doing that.  							//  							resultsPending--;  							goto READ_RESULT_break;  						}    						case PacketLineIn.AckNackResult.ACK:  						{  							// The remote side is happy and knows exactly what  							// to send us. There is no further negotiation and  							// we can break out immediately.  							//  							multiAck = BasePackFetchConnection.MultiAck.OFF;  							resultsPending = 0;  							receivedAck = true;  							if (statelessRPC)  							{  								state.WriteTo(@out' null);  							}  							goto SEND_HAVES_break;  						}    						case PacketLineIn.AckNackResult.ACK_CONTINUE:  						case PacketLineIn.AckNackResult.ACK_COMMON:  						case PacketLineIn.AckNackResult.ACK_READY:  						{  							// The server knows this commit (ackId). We don't  							// need to send any further along its ancestry' but  							// we need to continue to talk about other parts of  							// our local history.  							//  							MarkCommon(walk.ParseAny(ackId)' anr);  							receivedAck = true;  							receivedContinue = true;  							havesSinceLastContinue = 0;  							if (anr == PacketLineIn.AckNackResult.ACK_READY)  							{  								receivedReady = true;  							}  							break;  						}  					}  					if (monitor.IsCancelled())  					{  						throw new BasePackFetchConnection.CancelledException();  					}  READ_RESULT_continue: ;  				}  READ_RESULT_break: ;  				if (noDone & receivedReady)  				{  					goto SEND_HAVES_break;  				}  				if (statelessRPC)  				{  					state.WriteTo(@out' null);  				}  				if (receivedContinue && havesSinceLastContinue > MAX_HAVES)  				{  					// Our history must be really different from the remote's.  					// We just sent a whole slew of have lines' and it did not  					// recognize any of them. Avoid sending our entire history  					// to them by giving up early.  					//  					goto SEND_HAVES_break;  				}  SEND_HAVES_continue: ;  			}
Magic Number,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,Negotiate,The following statement contains a magic number: for (; ; )  			{  				RevCommit c = walk.Next();  				if (c == null)  				{  					goto SEND_HAVES_break;  				}  				pckOut.WriteString("have " + c.Id.Name + "\n");  				havesSent++;  				havesSinceLastContinue++;  				if ((31 & havesSent) != 0)  				{  					// We group the have lines into blocks of 32' each marked  					// with a flush (aka end). This one is within a block so  					// continue with another have line.  					//  					continue;  				}  				if (monitor.IsCancelled())  				{  					throw new BasePackFetchConnection.CancelledException();  				}  				pckOut.End();  				resultsPending++;  				// Each end will cause a result to come back.  				if (havesSent == 32 && !statelessRPC)  				{  					// On the first block we race ahead and try to send  					// more of the second block while waiting for the  					// remote to respond to our first block request.  					// This keeps us one block ahead of the peer.  					//  					continue;  				}  				for (; ; )  				{  					PacketLineIn.AckNackResult anr = pckIn.ReadACK(ackId);  					switch (anr)  					{  						case PacketLineIn.AckNackResult.NAK:  						{  							// More have lines are necessary to compute the  							// pack on the remote side. Keep doing that.  							//  							resultsPending--;  							goto READ_RESULT_break;  						}    						case PacketLineIn.AckNackResult.ACK:  						{  							// The remote side is happy and knows exactly what  							// to send us. There is no further negotiation and  							// we can break out immediately.  							//  							multiAck = BasePackFetchConnection.MultiAck.OFF;  							resultsPending = 0;  							receivedAck = true;  							if (statelessRPC)  							{  								state.WriteTo(@out' null);  							}  							goto SEND_HAVES_break;  						}    						case PacketLineIn.AckNackResult.ACK_CONTINUE:  						case PacketLineIn.AckNackResult.ACK_COMMON:  						case PacketLineIn.AckNackResult.ACK_READY:  						{  							// The server knows this commit (ackId). We don't  							// need to send any further along its ancestry' but  							// we need to continue to talk about other parts of  							// our local history.  							//  							MarkCommon(walk.ParseAny(ackId)' anr);  							receivedAck = true;  							receivedContinue = true;  							havesSinceLastContinue = 0;  							if (anr == PacketLineIn.AckNackResult.ACK_READY)  							{  								receivedReady = true;  							}  							break;  						}  					}  					if (monitor.IsCancelled())  					{  						throw new BasePackFetchConnection.CancelledException();  					}  READ_RESULT_continue: ;  				}  READ_RESULT_break: ;  				if (noDone & receivedReady)  				{  					goto SEND_HAVES_break;  				}  				if (statelessRPC)  				{  					state.WriteTo(@out' null);  				}  				if (receivedContinue && havesSinceLastContinue > MAX_HAVES)  				{  					// Our history must be really different from the remote's.  					// We just sent a whole slew of have lines' and it did not  					// recognize any of them. Avoid sending our entire history  					// to them by giving up early.  					//  					goto SEND_HAVES_break;  				}  SEND_HAVES_continue: ;  			}
Magic Number,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,MarkCommon,The following statement contains a magic number: if (statelessRPC && anr == PacketLineIn.AckNackResult.ACK_COMMON && !obj.Has(STATE  				))  			{  				StringBuilder s;  				s = new StringBuilder(6 + Constants.OBJECT_ID_STRING_LENGTH);  				s.Append("have ");  				//$NON-NLS-1$  				s.Append(obj.Name);  				s.Append('\n');  				pckState.WriteString(s.ToString());  				obj.Add(STATE);  			}
Magic Number,NGit.Transport,BasePackPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackPushConnection.cs,ReadStatusReport,The following statement contains a magic number: while ((refLine = pckIn.ReadString()) != PacketLineIn.END)  			{  				bool ok = false;  				int refNameEnd = -1;  				if (refLine.StartsWith("ok "))  				{  					ok = true;  					refNameEnd = refLine.Length;  				}  				else  				{  					if (refLine.StartsWith("ng "))  					{  						ok = false;  						refNameEnd = refLine.IndexOf(" "' 3);  					}  				}  				if (refNameEnd == -1)  				{  					throw new PackProtocolException(MessageFormat.Format(JGitText.Get().unexpectedReportLine2  						' uri' refLine));  				}  				string refName = Sharpen.Runtime.Substring(refLine' 3' refNameEnd);  				string message = (ok ? null : Sharpen.Runtime.Substring(refLine' refNameEnd + 1));  				RemoteRefUpdate rru = refUpdates.Get(refName);  				if (rru == null)  				{  					throw new PackProtocolException(MessageFormat.Format(JGitText.Get().unexpectedRefReport  						' uri' refName));  				}  				if (ok)  				{  					rru.SetStatus(RemoteRefUpdate.Status.OK);  				}  				else  				{  					rru.SetStatus(RemoteRefUpdate.Status.REJECTED_OTHER_REASON);  					rru.SetMessage(message);  				}  			}
Magic Number,NGit.Transport,BasePackPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackPushConnection.cs,ReadStatusReport,The following statement contains a magic number: while ((refLine = pckIn.ReadString()) != PacketLineIn.END)  			{  				bool ok = false;  				int refNameEnd = -1;  				if (refLine.StartsWith("ok "))  				{  					ok = true;  					refNameEnd = refLine.Length;  				}  				else  				{  					if (refLine.StartsWith("ng "))  					{  						ok = false;  						refNameEnd = refLine.IndexOf(" "' 3);  					}  				}  				if (refNameEnd == -1)  				{  					throw new PackProtocolException(MessageFormat.Format(JGitText.Get().unexpectedReportLine2  						' uri' refLine));  				}  				string refName = Sharpen.Runtime.Substring(refLine' 3' refNameEnd);  				string message = (ok ? null : Sharpen.Runtime.Substring(refLine' refNameEnd + 1));  				RemoteRefUpdate rru = refUpdates.Get(refName);  				if (rru == null)  				{  					throw new PackProtocolException(MessageFormat.Format(JGitText.Get().unexpectedRefReport  						' uri' refName));  				}  				if (ok)  				{  					rru.SetStatus(RemoteRefUpdate.Status.OK);  				}  				else  				{  					rru.SetStatus(RemoteRefUpdate.Status.REJECTED_OTHER_REASON);  					rru.SetMessage(message);  				}  			}
Magic Number,NGit.Transport,BasePackPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackPushConnection.cs,ReadStringLongTimeout,The following statement contains a magic number: try  			{  				timeoutIn.SetTimeout(10 * Math.Max(sendTime' oldTimeout));  				return pckIn.ReadString();  			}  			finally  			{  				timeoutIn.SetTimeout(oldTimeout);  			}
Magic Number,NGit.Transport,BundleFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BundleFetchConnection.cs,BundleFetchConnection,The following statement contains a magic number: try  			{  				switch (ReadSignature())  				{  					case 2:  					{  						ReadBundleV2();  						break;  					}    					default:  					{  						throw new TransportException(transport.uri' JGitText.Get().notABundle);  					}  				}  			}  			catch (TransportException err)  			{  				Close();  				throw;  			}  			catch (IOException err)  			{  				Close();  				throw new TransportException(transport.uri' err.Message' err);  			}  			catch (RuntimeException err)  			{  				Close();  				throw new TransportException(transport.uri' err.Message' err);  			}
Magic Number,NGit.Transport,BundleFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BundleFetchConnection.cs,ReadSignature,The following statement contains a magic number: string rev = ReadLine(new byte[1024]);
Magic Number,NGit.Transport,BundleFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BundleFetchConnection.cs,ReadSignature,The following statement contains a magic number: if (NGit.Transport.TransportBundleConstants.V2_BUNDLE_SIGNATURE.Equals(rev))  			{  				return 2;  			}
Magic Number,NGit.Transport,BundleFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BundleFetchConnection.cs,ReadBundleV2,The following statement contains a magic number: byte[] hdrbuf = new byte[1024];
Magic Number,NGit.Transport,BundleFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BundleFetchConnection.cs,ReadBundleV2,The following statement contains a magic number: for (; ; )  			{  				string line = ReadLine(hdrbuf);  				if (line.Length == 0)  				{  					break;  				}  				if (line[0] == '-')  				{  					ObjectId id = ObjectId.FromString(Sharpen.Runtime.Substring(line' 1' 41));  					string shortDesc = null;  					if (line.Length > 42)  					{  						shortDesc = Sharpen.Runtime.Substring(line' 42);  					}  					prereqs.Put(id' shortDesc);  					continue;  				}  				string name = Sharpen.Runtime.Substring(line' 41' line.Length);  				ObjectId id_1 = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' 40));  				Ref prior = avail.Put(name' new ObjectIdRef.Unpeeled(RefStorage.NETWORK' name' id_1  					));  				if (prior != null)  				{  					throw DuplicateAdvertisement(name);  				}  			}
Magic Number,NGit.Transport,BundleFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BundleFetchConnection.cs,ReadBundleV2,The following statement contains a magic number: for (; ; )  			{  				string line = ReadLine(hdrbuf);  				if (line.Length == 0)  				{  					break;  				}  				if (line[0] == '-')  				{  					ObjectId id = ObjectId.FromString(Sharpen.Runtime.Substring(line' 1' 41));  					string shortDesc = null;  					if (line.Length > 42)  					{  						shortDesc = Sharpen.Runtime.Substring(line' 42);  					}  					prereqs.Put(id' shortDesc);  					continue;  				}  				string name = Sharpen.Runtime.Substring(line' 41' line.Length);  				ObjectId id_1 = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' 40));  				Ref prior = avail.Put(name' new ObjectIdRef.Unpeeled(RefStorage.NETWORK' name' id_1  					));  				if (prior != null)  				{  					throw DuplicateAdvertisement(name);  				}  			}
Magic Number,NGit.Transport,BundleFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BundleFetchConnection.cs,ReadBundleV2,The following statement contains a magic number: for (; ; )  			{  				string line = ReadLine(hdrbuf);  				if (line.Length == 0)  				{  					break;  				}  				if (line[0] == '-')  				{  					ObjectId id = ObjectId.FromString(Sharpen.Runtime.Substring(line' 1' 41));  					string shortDesc = null;  					if (line.Length > 42)  					{  						shortDesc = Sharpen.Runtime.Substring(line' 42);  					}  					prereqs.Put(id' shortDesc);  					continue;  				}  				string name = Sharpen.Runtime.Substring(line' 41' line.Length);  				ObjectId id_1 = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' 40));  				Ref prior = avail.Put(name' new ObjectIdRef.Unpeeled(RefStorage.NETWORK' name' id_1  					));  				if (prior != null)  				{  					throw DuplicateAdvertisement(name);  				}  			}
Magic Number,NGit.Transport,BundleFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BundleFetchConnection.cs,ReadBundleV2,The following statement contains a magic number: for (; ; )  			{  				string line = ReadLine(hdrbuf);  				if (line.Length == 0)  				{  					break;  				}  				if (line[0] == '-')  				{  					ObjectId id = ObjectId.FromString(Sharpen.Runtime.Substring(line' 1' 41));  					string shortDesc = null;  					if (line.Length > 42)  					{  						shortDesc = Sharpen.Runtime.Substring(line' 42);  					}  					prereqs.Put(id' shortDesc);  					continue;  				}  				string name = Sharpen.Runtime.Substring(line' 41' line.Length);  				ObjectId id_1 = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' 40));  				Ref prior = avail.Put(name' new ObjectIdRef.Unpeeled(RefStorage.NETWORK' name' id_1  					));  				if (prior != null)  				{  					throw DuplicateAdvertisement(name);  				}  			}
Magic Number,NGit.Transport,BundleFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BundleFetchConnection.cs,ReadBundleV2,The following statement contains a magic number: for (; ; )  			{  				string line = ReadLine(hdrbuf);  				if (line.Length == 0)  				{  					break;  				}  				if (line[0] == '-')  				{  					ObjectId id = ObjectId.FromString(Sharpen.Runtime.Substring(line' 1' 41));  					string shortDesc = null;  					if (line.Length > 42)  					{  						shortDesc = Sharpen.Runtime.Substring(line' 42);  					}  					prereqs.Put(id' shortDesc);  					continue;  				}  				string name = Sharpen.Runtime.Substring(line' 41' line.Length);  				ObjectId id_1 = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' 40));  				Ref prior = avail.Put(name' new ObjectIdRef.Unpeeled(RefStorage.NETWORK' name' id_1  					));  				if (prior != null)  				{  					throw DuplicateAdvertisement(name);  				}  			}
Magic Number,NGit.Transport,ReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\ReceivePack.cs,Service,The following statement contains a magic number: if (HasCommands())  			{  				EnableCapabilities();  				Exception unpackError = null;  				if (NeedPack())  				{  					try  					{  						ReceivePackAndCheckConnectivity();  					}  					catch (IOException err)  					{  						unpackError = err;  					}  					catch (RuntimeException err)  					{  						unpackError = err;  					}  					catch (Error err)  					{  						unpackError = err;  					}  				}  				if (unpackError == null)  				{  					ValidateCommands();  					preReceive.OnPreReceive(this' FilterCommands(ReceiveCommand.Result.NOT_ATTEMPTED)  						);  					ExecuteCommands();  				}  				UnlockPack();  				if (reportStatus)  				{  					if (echoCommandFailures && msgOut != null)  					{  						SendStatusReport(false' unpackError' new _Reporter_210(this));  						msgOut.Flush();  						try  						{  							Sharpen.Thread.Sleep(500);  						}  						catch (Exception)  						{  						}  					}  					// Ignore an early wake up.  					SendStatusReport(true' unpackError' new _Reporter_222(this));  					pckOut.End();  				}  				else  				{  					if (msgOut != null)  					{  						SendStatusReport(false' unpackError' new _Reporter_229(this));  					}  				}  				postReceive.OnPostReceive(this' FilterCommands(ReceiveCommand.Result.OK));  				if (unpackError != null)  				{  					throw new UnpackException(unpackError);  				}  			}
Magic Number,NGit.Transport,SideBandProgressMonitor,C:\repos\mono_ngit\NGit\NGit.Transport\SideBandProgressMonitor.cs,Format,The following statement contains a magic number: if (pcnt < 100)  			{  				s.Append(' ');  			}
Magic Number,NGit.Transport,SideBandProgressMonitor,C:\repos\mono_ngit\NGit\NGit.Transport\SideBandProgressMonitor.cs,Format,The following statement contains a magic number: if (pcnt < 10)  			{  				s.Append(' ');  			}
Magic Number,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,Upload,The following statement contains a magic number: try  			{  				rawIn = input;  				rawOut = output;  				if (timeout > 0)  				{  					Sharpen.Thread caller = Sharpen.Thread.CurrentThread();  					timer = new InterruptTimer(caller.GetName() + "-Timer");  					TimeoutInputStream i = new TimeoutInputStream(rawIn' timer);  					TimeoutOutputStream o = new TimeoutOutputStream(rawOut' timer);  					i.SetTimeout(timeout * 1000);  					o.SetTimeout(timeout * 1000);  					rawIn = i;  					rawOut = o;  				}  				pckIn = new PacketLineIn(rawIn);  				pckOut = new PacketLineOut(rawOut);  				Service();  			}  			finally  			{  				walk.Release();  				if (timer != null)  				{  					try  					{  						timer.Terminate();  					}  					finally  					{  						timer = null;  					}  				}  			}
Magic Number,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,Upload,The following statement contains a magic number: try  			{  				rawIn = input;  				rawOut = output;  				if (timeout > 0)  				{  					Sharpen.Thread caller = Sharpen.Thread.CurrentThread();  					timer = new InterruptTimer(caller.GetName() + "-Timer");  					TimeoutInputStream i = new TimeoutInputStream(rawIn' timer);  					TimeoutOutputStream o = new TimeoutOutputStream(rawOut' timer);  					i.SetTimeout(timeout * 1000);  					o.SetTimeout(timeout * 1000);  					rawIn = i;  					rawOut = o;  				}  				pckIn = new PacketLineIn(rawIn);  				pckOut = new PacketLineOut(rawOut);  				Service();  			}  			finally  			{  				walk.Release();  				if (timer != null)  				{  					try  					{  						timer.Terminate();  					}  					finally  					{  						timer = null;  					}  				}  			}
Magic Number,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadString();  				}  				catch (EOFException eof)  				{  					if (isFirst)  					{  						break;  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					break;  				}  				if (line.StartsWith("deepen "))  				{  					depth = System.Convert.ToInt32(Sharpen.Runtime.Substring(line' 7));  					continue;  				}  				if (line.StartsWith("shallow "))  				{  					clientShallowCommits.AddItem(ObjectId.FromString(Sharpen.Runtime.Substring(line'   						8)));  					continue;  				}  				if (!line.StartsWith("want ") || line.Length < 45)  				{  					throw new PackProtocolException(MessageFormat.Format(JGitText.Get().expectedGot'   						"want"' line));  				}  				if (isFirst && line.Length > 45)  				{  					UploadPack.FirstLine firstLine = new UploadPack.FirstLine(line);  					options = firstLine.GetOptions();  					line = firstLine.GetLine();  				}  				wantIds.AddItem(ObjectId.FromString(Sharpen.Runtime.Substring(line' 5)));  				isFirst = false;  			}
Magic Number,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadString();  				}  				catch (EOFException eof)  				{  					if (isFirst)  					{  						break;  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					break;  				}  				if (line.StartsWith("deepen "))  				{  					depth = System.Convert.ToInt32(Sharpen.Runtime.Substring(line' 7));  					continue;  				}  				if (line.StartsWith("shallow "))  				{  					clientShallowCommits.AddItem(ObjectId.FromString(Sharpen.Runtime.Substring(line'   						8)));  					continue;  				}  				if (!line.StartsWith("want ") || line.Length < 45)  				{  					throw new PackProtocolException(MessageFormat.Format(JGitText.Get().expectedGot'   						"want"' line));  				}  				if (isFirst && line.Length > 45)  				{  					UploadPack.FirstLine firstLine = new UploadPack.FirstLine(line);  					options = firstLine.GetOptions();  					line = firstLine.GetLine();  				}  				wantIds.AddItem(ObjectId.FromString(Sharpen.Runtime.Substring(line' 5)));  				isFirst = false;  			}
Magic Number,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadString();  				}  				catch (EOFException eof)  				{  					if (isFirst)  					{  						break;  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					break;  				}  				if (line.StartsWith("deepen "))  				{  					depth = System.Convert.ToInt32(Sharpen.Runtime.Substring(line' 7));  					continue;  				}  				if (line.StartsWith("shallow "))  				{  					clientShallowCommits.AddItem(ObjectId.FromString(Sharpen.Runtime.Substring(line'   						8)));  					continue;  				}  				if (!line.StartsWith("want ") || line.Length < 45)  				{  					throw new PackProtocolException(MessageFormat.Format(JGitText.Get().expectedGot'   						"want"' line));  				}  				if (isFirst && line.Length > 45)  				{  					UploadPack.FirstLine firstLine = new UploadPack.FirstLine(line);  					options = firstLine.GetOptions();  					line = firstLine.GetLine();  				}  				wantIds.AddItem(ObjectId.FromString(Sharpen.Runtime.Substring(line' 5)));  				isFirst = false;  			}
Magic Number,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadString();  				}  				catch (EOFException eof)  				{  					if (isFirst)  					{  						break;  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					break;  				}  				if (line.StartsWith("deepen "))  				{  					depth = System.Convert.ToInt32(Sharpen.Runtime.Substring(line' 7));  					continue;  				}  				if (line.StartsWith("shallow "))  				{  					clientShallowCommits.AddItem(ObjectId.FromString(Sharpen.Runtime.Substring(line'   						8)));  					continue;  				}  				if (!line.StartsWith("want ") || line.Length < 45)  				{  					throw new PackProtocolException(MessageFormat.Format(JGitText.Get().expectedGot'   						"want"' line));  				}  				if (isFirst && line.Length > 45)  				{  					UploadPack.FirstLine firstLine = new UploadPack.FirstLine(line);  					options = firstLine.GetOptions();  					line = firstLine.GetLine();  				}  				wantIds.AddItem(ObjectId.FromString(Sharpen.Runtime.Substring(line' 5)));  				isFirst = false;  			}
Magic Number,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadString();  				}  				catch (EOFException eof)  				{  					if (isFirst)  					{  						break;  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					break;  				}  				if (line.StartsWith("deepen "))  				{  					depth = System.Convert.ToInt32(Sharpen.Runtime.Substring(line' 7));  					continue;  				}  				if (line.StartsWith("shallow "))  				{  					clientShallowCommits.AddItem(ObjectId.FromString(Sharpen.Runtime.Substring(line'   						8)));  					continue;  				}  				if (!line.StartsWith("want ") || line.Length < 45)  				{  					throw new PackProtocolException(MessageFormat.Format(JGitText.Get().expectedGot'   						"want"' line));  				}  				if (isFirst && line.Length > 45)  				{  					UploadPack.FirstLine firstLine = new UploadPack.FirstLine(line);  					options = firstLine.GetOptions();  					line = firstLine.GetLine();  				}  				wantIds.AddItem(ObjectId.FromString(Sharpen.Runtime.Substring(line' 5)));  				isFirst = false;  			}
Magic Number,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,Negotiate,The following statement contains a magic number: IList<ObjectId> peerHas = new AList<ObjectId>(64);
Magic Number,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,Negotiate,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadString();  				}  				catch (EOFException eof)  				{  					// EOF on stateless RPC (aka smart HTTP) and non-shallow request  					// means the client asked for the updated shallow/unshallow data'  					// disconnected' and will try another request with actual want/have.  					// Don't report the EOF here' its a bug in the protocol that the client  					// just disconnects without sending an END.  					if (!biDirectionalPipe && depth > 0)  					{  						return false;  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					last = ProcessHaveLines(peerHas' last);  					if (commonBase.IsEmpty() || multiAck != BasePackFetchConnection.MultiAck.OFF)  					{  						pckOut.WriteString("NAK\n");  					}  					if (noDone && sentReady)  					{  						pckOut.WriteString("ACK " + last.Name + "\n");  						return true;  					}  					if (!biDirectionalPipe)  					{  						return false;  					}  					pckOut.Flush();  				}  				else  				{  					if (line.StartsWith("have ") && line.Length == 45)  					{  						peerHas.AddItem(ObjectId.FromString(Sharpen.Runtime.Substring(line' 5)));  					}  					else  					{  						if (line.Equals("done"))  						{  							last = ProcessHaveLines(peerHas' last);  							if (commonBase.IsEmpty())  							{  								pckOut.WriteString("NAK\n");  							}  							else  							{  								if (multiAck != BasePackFetchConnection.MultiAck.OFF)  								{  									pckOut.WriteString("ACK " + last.Name + "\n");  								}  							}  							return true;  						}  						else  						{  							throw new PackProtocolException(MessageFormat.Format(JGitText.Get().expectedGot'   								"have"' line));  						}  					}  				}  			}
Magic Number,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,Negotiate,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadString();  				}  				catch (EOFException eof)  				{  					// EOF on stateless RPC (aka smart HTTP) and non-shallow request  					// means the client asked for the updated shallow/unshallow data'  					// disconnected' and will try another request with actual want/have.  					// Don't report the EOF here' its a bug in the protocol that the client  					// just disconnects without sending an END.  					if (!biDirectionalPipe && depth > 0)  					{  						return false;  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					last = ProcessHaveLines(peerHas' last);  					if (commonBase.IsEmpty() || multiAck != BasePackFetchConnection.MultiAck.OFF)  					{  						pckOut.WriteString("NAK\n");  					}  					if (noDone && sentReady)  					{  						pckOut.WriteString("ACK " + last.Name + "\n");  						return true;  					}  					if (!biDirectionalPipe)  					{  						return false;  					}  					pckOut.Flush();  				}  				else  				{  					if (line.StartsWith("have ") && line.Length == 45)  					{  						peerHas.AddItem(ObjectId.FromString(Sharpen.Runtime.Substring(line' 5)));  					}  					else  					{  						if (line.Equals("done"))  						{  							last = ProcessHaveLines(peerHas' last);  							if (commonBase.IsEmpty())  							{  								pckOut.WriteString("NAK\n");  							}  							else  							{  								if (multiAck != BasePackFetchConnection.MultiAck.OFF)  								{  									pckOut.WriteString("ACK " + last.Name + "\n");  								}  							}  							return true;  						}  						else  						{  							throw new PackProtocolException(MessageFormat.Format(JGitText.Get().expectedGot'   								"have"' line));  						}  					}  				}  			}
Magic Number,NGit.Transport,FirstLine,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,FirstLine,The following statement contains a magic number: if (line.Length > 45)  				{  					HashSet<string> opts = new HashSet<string>();  					string opt = Sharpen.Runtime.Substring(line' 45);  					if (opt.StartsWith(" "))  					{  						opt = Sharpen.Runtime.Substring(opt' 1);  					}  					foreach (string c in opt.Split(" "))  					{  						opts.AddItem(c);  					}  					this.line = Sharpen.Runtime.Substring(line' 0' 45);  					this.options = Sharpen.Collections.UnmodifiableSet(opts);  				}  				else  				{  					this.line = line;  					this.options = Sharpen.Collections.EmptySet<string>();  				}
Magic Number,NGit.Transport,FirstLine,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,FirstLine,The following statement contains a magic number: if (line.Length > 45)  				{  					HashSet<string> opts = new HashSet<string>();  					string opt = Sharpen.Runtime.Substring(line' 45);  					if (opt.StartsWith(" "))  					{  						opt = Sharpen.Runtime.Substring(opt' 1);  					}  					foreach (string c in opt.Split(" "))  					{  						opts.AddItem(c);  					}  					this.line = Sharpen.Runtime.Substring(line' 0' 45);  					this.options = Sharpen.Collections.UnmodifiableSet(opts);  				}  				else  				{  					this.line = line;  					this.options = Sharpen.Collections.EmptySet<string>();  				}
Magic Number,NGit.Transport,FirstLine,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,FirstLine,The following statement contains a magic number: if (line.Length > 45)  				{  					HashSet<string> opts = new HashSet<string>();  					string opt = Sharpen.Runtime.Substring(line' 45);  					if (opt.StartsWith(" "))  					{  						opt = Sharpen.Runtime.Substring(opt' 1);  					}  					foreach (string c in opt.Split(" "))  					{  						opts.AddItem(c);  					}  					this.line = Sharpen.Runtime.Substring(line' 0' 45);  					this.options = Sharpen.Collections.UnmodifiableSet(opts);  				}  				else  				{  					this.line = line;  					this.options = Sharpen.Collections.EmptySet<string>();  				}
Magic Number,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,WalkFetchConnection,The following statement contains a magic number: packLocks = new AList<PackLock>(4);
Magic Number,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,DownloadObject,The following statement contains a magic number: for (; ; )  			{  				// Try a pack file we know about' but don't have yet. Odds are  				// that if it has this object' it has others related to it so  				// getting the pack is a good bet.  				//  				if (DownloadPackedObject(pm' id))  				{  					return;  				}  				// Search for a loose object over all alternates' starting  				// from the one we last successfully located an object through.  				//  				string idStr = id.Name;  				string subdir = Sharpen.Runtime.Substring(idStr' 0' 2);  				string file = Sharpen.Runtime.Substring(idStr' 2);  				string looseName = subdir + "/" + file;  				for (int i = lastRemoteIdx; i < remotes.Count; i++)  				{  					if (DownloadLooseObject(id' looseName' remotes[i]))  					{  						lastRemoteIdx = i;  						return;  					}  				}  				for (int i_1 = 0; i_1 < lastRemoteIdx; i_1++)  				{  					if (DownloadLooseObject(id' looseName' remotes[i_1]))  					{  						lastRemoteIdx = i_1;  						return;  					}  				}  				// Try to obtain more pack information and search those.  				//  				while (!noPacksYet.IsEmpty())  				{  					WalkRemoteObjectDatabase wrr = noPacksYet.RemoveFirst();  					ICollection<string> packNameList;  					try  					{  						pm.BeginTask("Listing packs"' ProgressMonitor.UNKNOWN);  						packNameList = wrr.GetPackNames();  					}  					catch (IOException e)  					{  						// Try another repository.  						//  						RecordError(id' e);  						continue;  					}  					finally  					{  						pm.EndTask();  					}  					if (packNameList == null || packNameList.IsEmpty())  					{  						continue;  					}  					foreach (string packName in packNameList)  					{  						if (packsConsidered.AddItem(packName))  						{  							unfetchedPacks.AddItem(new WalkFetchConnection.RemotePack(this' wrr' packName));  						}  					}  					if (DownloadPackedObject(pm' id))  					{  						return;  					}  				}  				// Try to expand the first alternate we haven't expanded yet.  				//  				ICollection<WalkRemoteObjectDatabase> al = ExpandOneAlternate(id' pm);  				if (al != null && !al.IsEmpty())  				{  					foreach (WalkRemoteObjectDatabase alt in al)  					{  						remotes.AddItem(alt);  						noPacksYet.AddItem(alt);  						noAlternatesYet.AddItem(alt);  					}  					continue;  				}  				// We could not obtain the object. There may be reasons why.  				//  				IList<Exception> failures = fetchErrors.Get((ObjectId)id);  				TransportException te;  				te = new TransportException(MessageFormat.Format(JGitText.Get().cannotGet' id.Name  					));  				if (failures != null && !failures.IsEmpty())  				{  					if (failures.Count == 1)  					{  						Sharpen.Extensions.InitCause(te' failures[0]);  					}  					else  					{  						Sharpen.Extensions.InitCause(te' new CompoundException(failures));  					}  				}  				throw te;  			}
Magic Number,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,DownloadObject,The following statement contains a magic number: for (; ; )  			{  				// Try a pack file we know about' but don't have yet. Odds are  				// that if it has this object' it has others related to it so  				// getting the pack is a good bet.  				//  				if (DownloadPackedObject(pm' id))  				{  					return;  				}  				// Search for a loose object over all alternates' starting  				// from the one we last successfully located an object through.  				//  				string idStr = id.Name;  				string subdir = Sharpen.Runtime.Substring(idStr' 0' 2);  				string file = Sharpen.Runtime.Substring(idStr' 2);  				string looseName = subdir + "/" + file;  				for (int i = lastRemoteIdx; i < remotes.Count; i++)  				{  					if (DownloadLooseObject(id' looseName' remotes[i]))  					{  						lastRemoteIdx = i;  						return;  					}  				}  				for (int i_1 = 0; i_1 < lastRemoteIdx; i_1++)  				{  					if (DownloadLooseObject(id' looseName' remotes[i_1]))  					{  						lastRemoteIdx = i_1;  						return;  					}  				}  				// Try to obtain more pack information and search those.  				//  				while (!noPacksYet.IsEmpty())  				{  					WalkRemoteObjectDatabase wrr = noPacksYet.RemoveFirst();  					ICollection<string> packNameList;  					try  					{  						pm.BeginTask("Listing packs"' ProgressMonitor.UNKNOWN);  						packNameList = wrr.GetPackNames();  					}  					catch (IOException e)  					{  						// Try another repository.  						//  						RecordError(id' e);  						continue;  					}  					finally  					{  						pm.EndTask();  					}  					if (packNameList == null || packNameList.IsEmpty())  					{  						continue;  					}  					foreach (string packName in packNameList)  					{  						if (packsConsidered.AddItem(packName))  						{  							unfetchedPacks.AddItem(new WalkFetchConnection.RemotePack(this' wrr' packName));  						}  					}  					if (DownloadPackedObject(pm' id))  					{  						return;  					}  				}  				// Try to expand the first alternate we haven't expanded yet.  				//  				ICollection<WalkRemoteObjectDatabase> al = ExpandOneAlternate(id' pm);  				if (al != null && !al.IsEmpty())  				{  					foreach (WalkRemoteObjectDatabase alt in al)  					{  						remotes.AddItem(alt);  						noPacksYet.AddItem(alt);  						noAlternatesYet.AddItem(alt);  					}  					continue;  				}  				// We could not obtain the object. There may be reasons why.  				//  				IList<Exception> failures = fetchErrors.Get((ObjectId)id);  				TransportException te;  				te = new TransportException(MessageFormat.Format(JGitText.Get().cannotGet' id.Name  					));  				if (failures != null && !failures.IsEmpty())  				{  					if (failures.Count == 1)  					{  						Sharpen.Extensions.InitCause(te' failures[0]);  					}  					else  					{  						Sharpen.Extensions.InitCause(te' new CompoundException(failures));  					}  				}  				throw te;  			}
Magic Number,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,RecordError,The following statement contains a magic number: if (errors == null)  			{  				errors = new AList<Exception>(2);  				fetchErrors.Put(objId' errors);  			}
Magic Number,NGit.Transport,RemotePack,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,RemotePack,The following statement contains a magic number: this.idxName = Sharpen.Runtime.Substring(this.packName' 0' this.packName.Length -  					 5) + ".idx";
Magic Number,NGit.Transport,RemotePack,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,RemotePack,The following statement contains a magic number: if (tn.StartsWith("pack-"))  				{  					tn = Sharpen.Runtime.Substring(tn' 5);  				}
Magic Number,NGit.Transport,RemotePack,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,RemotePack,The following statement contains a magic number: if (tn.EndsWith(".idx"))  				{  					tn = Sharpen.Runtime.Substring(tn' 0' tn.Length - 4);  				}
Magic Number,NGit.Transport,RemotePack,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,OpenIndex,The following statement contains a magic number: pm.BeginTask("Get " + Sharpen.Runtime.Substring(this.idxName' 0' 12) + "..idx"' s  					.length < 0 ? ProgressMonitor.UNKNOWN : (int)(s.length / 1024));
Magic Number,NGit.Transport,RemotePack,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,OpenIndex,The following statement contains a magic number: pm.BeginTask("Get " + Sharpen.Runtime.Substring(this.idxName' 0' 12) + "..idx"' s  					.length < 0 ? ProgressMonitor.UNKNOWN : (int)(s.length / 1024));
Magic Number,NGit.Transport,RemotePack,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,OpenIndex,The following statement contains a magic number: try  				{  					FileOutputStream fos = new FileOutputStream(this.tmpIdx);  					try  					{  						byte[] buf = new byte[2048];  						int cnt;  						while (!pm.IsCancelled() && (cnt = s.@in.Read(buf)) >= 0)  						{  							fos.Write(buf' 0' cnt);  							pm.Update(cnt / 1024);  						}  					}  					finally  					{  						fos.Close();  					}  				}  				catch (IOException err)  				{  					FileUtils.Delete(this.tmpIdx);  					throw;  				}  				finally  				{  					s.@in.Close();  				}
Magic Number,NGit.Transport,RemotePack,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,OpenIndex,The following statement contains a magic number: try  				{  					FileOutputStream fos = new FileOutputStream(this.tmpIdx);  					try  					{  						byte[] buf = new byte[2048];  						int cnt;  						while (!pm.IsCancelled() && (cnt = s.@in.Read(buf)) >= 0)  						{  							fos.Write(buf' 0' cnt);  							pm.Update(cnt / 1024);  						}  					}  					finally  					{  						fos.Close();  					}  				}  				catch (IOException err)  				{  					FileUtils.Delete(this.tmpIdx);  					throw;  				}  				finally  				{  					s.@in.Close();  				}
Magic Number,NGit.Transport,FileStream,C:\repos\mono_ngit\NGit\NGit.Transport\WalkRemoteObjectDatabase.cs,ToArray,The following statement contains a magic number: try  				{  					if (length >= 0)  					{  						byte[] r = new byte[(int)length];  						IOUtil.ReadFully(@in' r' 0' r.Length);  						return r;  					}  					ByteArrayOutputStream r_1 = new ByteArrayOutputStream();  					byte[] buf = new byte[2048];  					int n;  					while ((n = @in.Read(buf)) >= 0)  					{  						r_1.Write(buf' 0' n);  					}  					return r_1.ToByteArray();  				}  				finally  				{  					@in.Close();  				}
Magic Number,NGit.Transport,WalkPushConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkPushConnection.cs,Sendpack,The following statement contains a magic number: try  			{  				ICollection<ObjectId> need = new HashSet<ObjectId>();  				ICollection<ObjectId> have = new HashSet<ObjectId>();  				foreach (RemoteRefUpdate r in updates)  				{  					need.AddItem(r.GetNewObjectId());  				}  				foreach (Ref r_1 in GetRefs())  				{  					have.AddItem(r_1.GetObjectId());  					if (r_1.GetPeeledObjectId() != null)  					{  						have.AddItem(r_1.GetPeeledObjectId());  					}  				}  				writer.PreparePack(monitor' need' have);  				// We don't have to continue further if the pack will  				// be an empty pack' as the remote has all objects it  				// needs to complete this change.  				//  				if (writer.GetObjectCount() == 0)  				{  					return;  				}  				packNames = new LinkedHashMap<string' string>();  				foreach (string n in dest.GetPackNames())  				{  					packNames.Put(n' n);  				}  				string @base = "pack-" + writer.ComputeName().Name;  				string packName = @base + ".pack";  				pathPack = "pack/" + packName;  				pathIdx = "pack/" + @base + ".idx";  				if (Sharpen.Collections.Remove(packNames' packName) != null)  				{  					// The remote already contains this pack. We should  					// remove the index before overwriting to prevent bad  					// offsets from appearing to clients.  					//  					dest.WriteInfoPacks(packNames.Keys);  					dest.DeleteFile(pathIdx);  				}  				// Write the pack file' then the index' as readers look the  				// other direction (index' then pack file).  				//  				string wt = "Put " + Sharpen.Runtime.Substring(@base' 0' 12);  				OutputStream os = dest.WriteFile(pathPack' monitor' wt + "..pack");  				try  				{  					os = new SafeBufferedOutputStream(os);  					writer.WritePack(monitor' monitor' os);  				}  				finally  				{  					os.Close();  				}  				os = dest.WriteFile(pathIdx' monitor' wt + "..idx");  				try  				{  					os = new SafeBufferedOutputStream(os);  					writer.WriteIndex(os);  				}  				finally  				{  					os.Close();  				}  				// Record the pack at the start of the pack info list. This  				// way clients are likely to consult the newest pack first'  				// and discover the most recent objects there.  				//  				AList<string> infoPacks = new AList<string>();  				infoPacks.AddItem(packName);  				Sharpen.Collections.AddAll(infoPacks' packNames.Keys);  				dest.WriteInfoPacks(infoPacks);  			}  			catch (IOException err)  			{  				SafeDelete(pathIdx);  				SafeDelete(pathPack);  				throw new TransportException(uri' JGitText.Get().cannotStoreObjects' err);  			}  			finally  			{  				writer.Release();  			}
Magic Number,NGit.Transport,DaemonClient,C:\repos\mono_ngit\NGit\NGit.Transport\DaemonClient.cs,Execute,The following statement contains a magic number: if (0 < daemon.GetTimeout())  			{  				sock.ReceiveTimeout = daemon.GetTimeout() * 1000;  			}
Magic Number,NGit.Transport,OpenSshConfig,C:\repos\mono_ngit\NGit\NGit.Transport\OpenSshConfig.cs,Parse,The following statement contains a magic number: IList<OpenSshConfig.Host> current = new AList<OpenSshConfig.Host>(4);
Magic Number,NGit.Transport,OpenSshConfig,C:\repos\mono_ngit\NGit\NGit.Transport\OpenSshConfig.cs,Parse,The following statement contains a magic number: while ((line = br.ReadLine()) != null)  			{  				line = line.Trim();  				if (line.Length == 0 || line.StartsWith("#"))  				{  					continue;  				}  				string[] parts = line.Split("[ \t]*[= \t]"' 2);  				string keyword = parts[0].Trim();  				string argValue = parts[1].Trim();  				if (StringUtils.EqualsIgnoreCase("Host"' keyword))  				{  					current.Clear();  					foreach (string pattern in argValue.Split("[ \t]"))  					{  						string name = Dequote(pattern);  						OpenSshConfig.Host c = m.Get(name);  						if (c == null)  						{  							c = new OpenSshConfig.Host();  							m.Put(name' c);  						}  						current.AddItem(c);  					}  					continue;  				}  				if (current.IsEmpty())  				{  					// We received an option outside of a Host block. We  					// don't know who this should match against' so skip.  					//  					continue;  				}  				if (StringUtils.EqualsIgnoreCase("HostName"' keyword))  				{  					foreach (OpenSshConfig.Host c in current)  					{  						if (c.hostName == null)  						{  							c.hostName = Dequote(argValue);  						}  					}  				}  				else  				{  					if (StringUtils.EqualsIgnoreCase("User"' keyword))  					{  						foreach (OpenSshConfig.Host c in current)  						{  							if (c.user == null)  							{  								c.user = Dequote(argValue);  							}  						}  					}  					else  					{  						if (StringUtils.EqualsIgnoreCase("Port"' keyword))  						{  							try  							{  								int port = System.Convert.ToInt32(Dequote(argValue));  								foreach (OpenSshConfig.Host c in current)  								{  									if (c.port == 0)  									{  										c.port = port;  									}  								}  							}  							catch (FormatException)  							{  							}  						}  						else  						{  							// Bad port number. Don't set it.  							if (StringUtils.EqualsIgnoreCase("IdentityFile"' keyword))  							{  								foreach (OpenSshConfig.Host c in current)  								{  									if (c.identityFile == null)  									{  										c.identityFile = ToFile(Dequote(argValue));  									}  								}  							}  							else  							{  								if (StringUtils.EqualsIgnoreCase("PreferredAuthentications"' keyword))  								{  									foreach (OpenSshConfig.Host c in current)  									{  										if (c.preferredAuthentications == null)  										{  											c.preferredAuthentications = Nows(Dequote(argValue));  										}  									}  								}  								else  								{  									if (StringUtils.EqualsIgnoreCase("BatchMode"' keyword))  									{  										foreach (OpenSshConfig.Host c in current)  										{  											if (c.batchMode == null)  											{  												c.batchMode = Yesno(Dequote(argValue));  											}  										}  									}  									else  									{  										if (StringUtils.EqualsIgnoreCase("StrictHostKeyChecking"' keyword))  										{  											string value = Dequote(argValue);  											foreach (OpenSshConfig.Host c in current)  											{  												if (c.strictHostKeyChecking == null)  												{  													c.strictHostKeyChecking = value;  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}
Magic Number,NGit.Transport,OpenSshConfig,C:\repos\mono_ngit\NGit\NGit.Transport\OpenSshConfig.cs,ToFile,The following statement contains a magic number: if (path.StartsWith("~/"))  			{  				return new FilePath(home' Sharpen.Runtime.Substring(path' 2));  			}
Magic Number,NGit.Transport,TransportGitAnon,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitAnon.cs,OpenConnection,The following statement contains a magic number: int tms = GetTimeout() > 0 ? GetTimeout() * 1000 : 0;
Magic Number,NGit.Transport,TransportHttp,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,HttpOpen,The following statement contains a magic number: if (timeOut != -1)  			{  				int effTimeOut = timeOut * 1000;  				conn.SetConnectTimeout(effTimeOut);  				conn.SetReadTimeout(effTimeOut);  			}
Magic Number,NGit.Transport,TransportHttp,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,ReadSmartHeaders,The following statement contains a magic number: byte[] magic = new byte[5];
Magic Number,NGit.Transport,TransportHttp,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,ReadSmartHeaders,The following statement contains a magic number: if (magic[4] != '#')  			{  				throw new TransportException(uri' MessageFormat.Format(JGitText.Get().expectedPktLineWithService  					' RawParseUtils.Decode(magic)));  			}
Magic Number,NGit.Transport,_TransportProtocol_137,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,GetDefaultPort,The following statement contains a magic number: return 80;
Magic Number,NGit.Transport,_TransportProtocol_176,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,GetDefaultPort,The following statement contains a magic number: return 21;
Magic Number,NGit.Transport,HttpConfig,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,HttpConfig,The following statement contains a magic number: postBuffer = rc.GetInt("http"' "postbuffer"' 1 * 1024 * 1024);
Magic Number,NGit.Transport,HttpConfig,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,HttpConfig,The following statement contains a magic number: postBuffer = rc.GetInt("http"' "postbuffer"' 1 * 1024 * 1024);
Magic Number,NGit.Transport,HttpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,GetPackNames,The following statement contains a magic number: try  				{  					BufferedReader br = this.OpenReader(WalkRemoteObjectDatabase.INFO_PACKS);  					try  					{  						for (; ; )  						{  							string s = br.ReadLine();  							if (s == null || s.Length == 0)  							{  								break;  							}  							if (!s.StartsWith("P pack-") || !s.EndsWith(".pack"))  							{  								//$NON-NLS-1$ //$NON-NLS-2$  								throw this.InvalidAdvertisement(s);  							}  							packs.AddItem(Sharpen.Runtime.Substring(s' 2));  						}  						return packs;  					}  					finally  					{  						br.Close();  					}  				}  				catch (FileNotFoundException)  				{  					return packs;  				}
Magic Number,NGit.Transport,HttpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportHttp.cs,ReadAdvertisedImpl,The following statement contains a magic number: for (; ; )  				{  					string line = br.ReadLine();  					if (line == null)  					{  						break;  					}  					int tab = line.IndexOf('\t');  					if (tab < 0)  					{  						throw this.InvalidAdvertisement(line);  					}  					string name;  					ObjectId id;  					name = Sharpen.Runtime.Substring(line' tab + 1);  					id = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' tab));  					if (name.EndsWith("^{}"))  					{  						//$NON-NLS-1$  						name = Sharpen.Runtime.Substring(name' 0' name.Length - 3);  						Ref prior = avail.Get(name);  						if (prior == null)  						{  							throw this.OutOfOrderAdvertisement(name);  						}  						if (prior.GetPeeledObjectId() != null)  						{  							throw this.DuplicateAdvertisement(name + "^{}");  						}  						//$NON-NLS-1$  						avail.Put(name' new ObjectIdRef.PeeledTag(RefStorage.NETWORK' name' prior.GetObjectId  							()' id));  					}  					else  					{  						Ref prior = avail.Put(name' new ObjectIdRef.PeeledNonTag(RefStorage.NETWORK' name  							' id));  						if (prior != null)  						{  							throw this.DuplicateAdvertisement(name);  						}  					}  				}
Magic Number,NGit.Transport,SshTransport,C:\repos\mono_ngit\NGit\NGit.Transport\SshTransport.cs,GetSession,The following statement contains a magic number: int tms = GetTimeout() > 0 ? GetTimeout() * 1000 : 0;
Magic Number,NGit.Transport,TransportGitSsh,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,CheckExecFailure,The following statement contains a magic number: if (status == 127)  			{  				IOException cause = null;  				if (why != null && why.Length > 0)  				{  					cause = new IOException(why);  				}  				throw new TransportException(uri' MessageFormat.Format(JGitText.Get().cannotExecute  					' CommandFor(exe))' cause);  			}
Magic Number,NGit.Transport,_TransportProtocol_84,C:\repos\mono_ngit\NGit\NGit.Transport\TransportGitSsh.cs,GetDefaultPort,The following statement contains a magic number: return 22;
Magic Number,NGit.Transport,TransportSftp,C:\repos\mono_ngit\NGit\NGit.Transport\TransportSftp.cs,NewSftp,The following statement contains a magic number: int tms = GetTimeout() > 0 ? GetTimeout() * 1000 : 0;
Magic Number,NGit.Transport,_TransportProtocol_100,C:\repos\mono_ngit\NGit\NGit.Transport\TransportSftp.cs,GetDefaultPort,The following statement contains a magic number: return 22;
Magic Number,NGit.Transport,SftpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportSftp.cs,SftpObjectDB,The following statement contains a magic number: if (path.StartsWith("~/"))  				{  					path = Sharpen.Runtime.Substring(path' 2);  				}
Magic Number,NGit.Transport,SftpObjectDB,C:\repos\mono_ngit\NGit\NGit.Transport\TransportSftp.cs,GetPackNames,The following statement contains a magic number: try  				{  					ArrayList list = this.ftp.Ls("pack");  					Dictionary<string' ChannelSftp.LsEntry> files;  					Dictionary<string' int> mtimes;  					files = new Dictionary<string' ChannelSftp.LsEntry>();  					mtimes = new Dictionary<string' int>();  					foreach (ChannelSftp.LsEntry ent in list)  					{  						files.Put(ent.GetFilename()' ent);  					}  					foreach (ChannelSftp.LsEntry ent_1 in list)  					{  						string n = ent_1.GetFilename();  						if (!n.StartsWith("pack-") || !n.EndsWith(".pack"))  						{  							continue;  						}  						string @in = Sharpen.Runtime.Substring(n' 0' n.Length - 5) + ".idx";  						if (!files.ContainsKey(@in))  						{  							continue;  						}  						mtimes.Put(n' Sharpen.Extensions.ValueOf(ent_1.GetAttrs().GetMTime()));  						packs.AddItem(n);  					}  					packs.Sort(new _IComparer_249(mtimes));  				}  				catch (SftpException je)  				{  					throw new TransportException("Can't ls " + this.objectsPath + "/pack: " + je.Message  						' je);  				}
Magic Number,NGit.Transport,Digest,C:\repos\mono_ngit\NGit\NGit.Transport\HttpAuthMethod.cs,Digest,The following statement contains a magic number: if ("auth".Equals(qop))  				{  					byte[] bin = new byte[8];  					PRNG.NextBytes(bin);  					@params.Put("cnonce"' Base64.EncodeBytes(bin));  				}
Magic Number,NGit.Transport,Digest,C:\repos\mono_ngit\NGit\NGit.Transport\HttpAuthMethod.cs,Uri,The following statement contains a magic number: if (0 < u.Port)  				{  					if (u.Port == 80 && "http".Equals(u.Scheme))  					{  					}  					else  					{  						if (u.Port == 443 && "https".Equals(u.Scheme))  						{  						}  						else  						{  							r.Append(':').Append(u.Port);  						}  					}  				}
Magic Number,NGit.Transport,Digest,C:\repos\mono_ngit\NGit\NGit.Transport\HttpAuthMethod.cs,Uri,The following statement contains a magic number: if (0 < u.Port)  				{  					if (u.Port == 80 && "http".Equals(u.Scheme))  					{  					}  					else  					{  						if (u.Port == 443 && "https".Equals(u.Scheme))  						{  						}  						else  						{  							r.Append(':').Append(u.Port);  						}  					}  				}
Magic Number,NGit.Transport,Digest,C:\repos\mono_ngit\NGit\NGit.Transport\HttpAuthMethod.cs,Lhex,The following statement contains a magic number: StringBuilder r = new StringBuilder(bin.Length * 2);
Magic Number,NGit.Transport,Digest,C:\repos\mono_ngit\NGit\NGit.Transport\HttpAuthMethod.cs,Lhex,The following statement contains a magic number: for (int i = 0; i < bin.Length; i++)  				{  					byte b = bin[i];  					r.Append(LHEX[(b >> 4) & unchecked((int)(0x0f))]);  					r.Append(LHEX[b & unchecked((int)(0x0f))]);  				}
Magic Number,NGit.Transport,Digest,C:\repos\mono_ngit\NGit\NGit.Transport\HttpAuthMethod.cs,Parse,The following statement contains a magic number: while (next < auth.Length)  				{  					if (next < auth.Length && auth[next] == ''')  					{  						next++;  					}  					while (next < auth.Length && char.IsWhiteSpace(auth[next]))  					{  						next++;  					}  					int eq = auth.IndexOf('='' next);  					if (eq < 0 || eq + 1 == auth.Length)  					{  						return Sharpen.Collections.EmptyMap<string' string>();  					}  					string name = Sharpen.Runtime.Substring(auth' next' eq);  					string value;  					if (auth[eq + 1] == '"')  					{  						int dq = auth.IndexOf('"'' eq + 2);  						if (dq < 0)  						{  							return Sharpen.Collections.EmptyMap<string' string>();  						}  						value = Sharpen.Runtime.Substring(auth' eq + 2' dq);  						next = dq + 1;  					}  					else  					{  						int space = auth.IndexOf(' '' eq + 1);  						int comma = auth.IndexOf('''' eq + 1);  						if (space < 0)  						{  							space = auth.Length;  						}  						if (comma < 0)  						{  							comma = auth.Length;  						}  						int e = Math.Min(space' comma);  						value = Sharpen.Runtime.Substring(auth' eq + 1' e);  						next = e + 1;  					}  					p.Put(name' value);  				}
Magic Number,NGit.Transport,Digest,C:\repos\mono_ngit\NGit\NGit.Transport\HttpAuthMethod.cs,Parse,The following statement contains a magic number: while (next < auth.Length)  				{  					if (next < auth.Length && auth[next] == ''')  					{  						next++;  					}  					while (next < auth.Length && char.IsWhiteSpace(auth[next]))  					{  						next++;  					}  					int eq = auth.IndexOf('='' next);  					if (eq < 0 || eq + 1 == auth.Length)  					{  						return Sharpen.Collections.EmptyMap<string' string>();  					}  					string name = Sharpen.Runtime.Substring(auth' next' eq);  					string value;  					if (auth[eq + 1] == '"')  					{  						int dq = auth.IndexOf('"'' eq + 2);  						if (dq < 0)  						{  							return Sharpen.Collections.EmptyMap<string' string>();  						}  						value = Sharpen.Runtime.Substring(auth' eq + 2' dq);  						next = dq + 1;  					}  					else  					{  						int space = auth.IndexOf(' '' eq + 1);  						int comma = auth.IndexOf('''' eq + 1);  						if (space < 0)  						{  							space = auth.Length;  						}  						if (comma < 0)  						{  							comma = auth.Length;  						}  						int e = Math.Min(space' comma);  						value = Sharpen.Runtime.Substring(auth' eq + 1' e);  						next = e + 1;  					}  					p.Put(name' value);  				}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,PackParser,The following statement contains a magic number: hdrBuf = new byte[64];
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,Parse,The following statement contains a magic number: if (receiving == resolving)  			{  				receiving.Start(2);  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,Parse,The following statement contains a magic number: try  			{  				ReadPackHeader();  				entries = new PackedObjectInfo[(int)objectCount];  				baseById = new ObjectIdOwnerMap<PackParser.DeltaChain>();  				baseByPos = new LongMap<PackParser.UnresolvedDelta>();  				deferredCheckBlobs = new BlockList<PackedObjectInfo>();  				receiving.BeginTask(JGitText.Get().receivingObjects' (int)objectCount);  				try  				{  					for (int done = 0; done < objectCount; done++)  					{  						IndexOneObject();  						receiving.Update(1);  						if (receiving.IsCancelled())  						{  							throw new IOException(JGitText.Get().downloadCancelled);  						}  					}  					ReadPackFooter();  					EndInput();  				}  				finally  				{  					receiving.EndTask();  				}  				if (!deferredCheckBlobs.IsEmpty())  				{  					DoDeferredCheckBlobs();  				}  				if (deltaCount > 0)  				{  					if (resolving is BatchingProgressMonitor)  					{  						((BatchingProgressMonitor)resolving).SetDelayStart(1000' TimeUnit.MILLISECONDS);  					}  					resolving.BeginTask(JGitText.Get().resolvingDeltas' deltaCount);  					ResolveDeltas(resolving);  					if (entryCount < objectCount)  					{  						if (!IsAllowThin())  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().packHasUnresolvedDeltas  								' Sharpen.Extensions.ValueOf(objectCount - entryCount)));  						}  						ResolveDeltasWithExternalBases(resolving);  						if (entryCount < objectCount)  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().packHasUnresolvedDeltas  								' Sharpen.Extensions.ValueOf(objectCount - entryCount)));  						}  					}  					resolving.EndTask();  				}  				packDigest = null;  				baseById = null;  				baseByPos = null;  			}  			finally  			{  				try  				{  					if (readCurs != null)  					{  						readCurs.Release();  					}  				}  				finally  				{  					readCurs = null;  				}  				try  				{  					inflater.Release();  				}  				finally  				{  					inflater = null;  				}  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadObjectHeader,The following statement contains a magic number: info.type = (c >> 4) & 7;
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadObjectHeader,The following statement contains a magic number: info.type = (c >> 4) & 7;
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadObjectHeader,The following statement contains a magic number: long sz = c & 15;
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadObjectHeader,The following statement contains a magic number: int shift = 4;
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadObjectHeader,The following statement contains a magic number: while ((c & unchecked((int)(0x80))) != 0)  			{  				c = ReadFrom(PackParser.Source.DATABASE);  				hdrBuf[hdrPtr++] = unchecked((byte)c);  				sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  				shift += 7;  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadObjectHeader,The following statement contains a magic number: switch (info.type)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ReadFrom(PackParser.Source.DATABASE);  					hdrBuf[hdrPtr++] = unchecked((byte)c);  					while ((c & 128) != 0)  					{  						c = ReadFrom(PackParser.Source.DATABASE);  						hdrBuf[hdrPtr++] = unchecked((byte)c);  					}  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					System.Array.Copy(buf' Fill(PackParser.Source.DATABASE' 20)' hdrBuf' hdrPtr' 20);  					hdrPtr += 20;  					Use(20);  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(info.type)));  				}  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadObjectHeader,The following statement contains a magic number: switch (info.type)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ReadFrom(PackParser.Source.DATABASE);  					hdrBuf[hdrPtr++] = unchecked((byte)c);  					while ((c & 128) != 0)  					{  						c = ReadFrom(PackParser.Source.DATABASE);  						hdrBuf[hdrPtr++] = unchecked((byte)c);  					}  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					System.Array.Copy(buf' Fill(PackParser.Source.DATABASE' 20)' hdrBuf' hdrPtr' 20);  					hdrPtr += 20;  					Use(20);  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(info.type)));  				}  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadObjectHeader,The following statement contains a magic number: switch (info.type)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ReadFrom(PackParser.Source.DATABASE);  					hdrBuf[hdrPtr++] = unchecked((byte)c);  					while ((c & 128) != 0)  					{  						c = ReadFrom(PackParser.Source.DATABASE);  						hdrBuf[hdrPtr++] = unchecked((byte)c);  					}  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					System.Array.Copy(buf' Fill(PackParser.Source.DATABASE' 20)' hdrBuf' hdrPtr' 20);  					hdrPtr += 20;  					Use(20);  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(info.type)));  				}  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadObjectHeader,The following statement contains a magic number: switch (info.type)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ReadFrom(PackParser.Source.DATABASE);  					hdrBuf[hdrPtr++] = unchecked((byte)c);  					while ((c & 128) != 0)  					{  						c = ReadFrom(PackParser.Source.DATABASE);  						hdrBuf[hdrPtr++] = unchecked((byte)c);  					}  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					System.Array.Copy(buf' Fill(PackParser.Source.DATABASE' 20)' hdrBuf' hdrPtr' 20);  					hdrPtr += 20;  					Use(20);  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(info.type)));  				}  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadObjectHeader,The following statement contains a magic number: switch (info.type)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ReadFrom(PackParser.Source.DATABASE);  					hdrBuf[hdrPtr++] = unchecked((byte)c);  					while ((c & 128) != 0)  					{  						c = ReadFrom(PackParser.Source.DATABASE);  						hdrBuf[hdrPtr++] = unchecked((byte)c);  					}  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					System.Array.Copy(buf' Fill(PackParser.Source.DATABASE' 20)' hdrBuf' hdrPtr' 20);  					hdrPtr += 20;  					Use(20);  					OnObjectHeader(PackParser.Source.DATABASE' hdrBuf' 0' hdrPtr);  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(info.type)));  				}  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ResolveDeltasWithExternalBases,The following statement contains a magic number: IList<PackParser.DeltaChain> missing = new AList<PackParser.DeltaChain>(64);
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadPackHeader,The following statement contains a magic number: int hdrln = Constants.PACK_SIGNATURE.Length + 4 + 4;
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadPackHeader,The following statement contains a magic number: int hdrln = Constants.PACK_SIGNATURE.Length + 4 + 4;
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadPackHeader,The following statement contains a magic number: long vers = NB.DecodeUInt32(buf' p + 4);
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadPackHeader,The following statement contains a magic number: if (vers != 2 && vers != 3)  			{  				throw new IOException(MessageFormat.Format(JGitText.Get().unsupportedPackVersion'   					Sharpen.Extensions.ValueOf(vers)));  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadPackHeader,The following statement contains a magic number: if (vers != 2 && vers != 3)  			{  				throw new IOException(MessageFormat.Format(JGitText.Get().unsupportedPackVersion'   					Sharpen.Extensions.ValueOf(vers)));  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadPackHeader,The following statement contains a magic number: objectCount = NB.DecodeUInt32(buf' p + 8);
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadPackFooter,The following statement contains a magic number: int c = Fill(PackParser.Source.INPUT' 20);
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadPackFooter,The following statement contains a magic number: byte[] srcHash = new byte[20];
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadPackFooter,The following statement contains a magic number: System.Array.Copy(buf' c' srcHash' 0' 20);
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,ReadPackFooter,The following statement contains a magic number: Use(20);
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,IndexOneObject,The following statement contains a magic number: int typeCode = (c >> 4) & 7;
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,IndexOneObject,The following statement contains a magic number: int typeCode = (c >> 4) & 7;
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,IndexOneObject,The following statement contains a magic number: long sz = c & 15;
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,IndexOneObject,The following statement contains a magic number: int shift = 4;
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,IndexOneObject,The following statement contains a magic number: while ((c & unchecked((int)(0x80))) != 0)  			{  				c = ReadFrom(PackParser.Source.INPUT);  				hdrBuf[hdrPtr++] = unchecked((byte)c);  				sz += ((long)(c & unchecked((int)(0x7f)))) << shift;  				shift += 7;  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					OnBeginWholeObject(streamPosition' typeCode' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					Whole(streamPosition' typeCode' sz);  					break;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ReadFrom(PackParser.Source.INPUT);  					hdrBuf[hdrPtr++] = unchecked((byte)c);  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFrom(PackParser.Source.INPUT);  						hdrBuf[hdrPtr++] = unchecked((byte)c);  						ofs <<= 7;  						ofs += (c & 127);  					}  					long @base = streamPosition - ofs;  					OnBeginOfsDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					n.next = baseByPos.Put(@base' n);  					deltaCount++;  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					c = Fill(PackParser.Source.INPUT' 20);  					ObjectId @base = ObjectId.FromRaw(buf' c);  					System.Array.Copy(buf' c' hdrBuf' hdrPtr' 20);  					hdrPtr += 20;  					Use(20);  					PackParser.DeltaChain r = baseById.Get(@base);  					if (r == null)  					{  						r = new PackParser.DeltaChain(@base);  						baseById.Add(r);  					}  					OnBeginRefDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					r.Add(n);  					deltaCount++;  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(typeCode)));  				}  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					OnBeginWholeObject(streamPosition' typeCode' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					Whole(streamPosition' typeCode' sz);  					break;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ReadFrom(PackParser.Source.INPUT);  					hdrBuf[hdrPtr++] = unchecked((byte)c);  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFrom(PackParser.Source.INPUT);  						hdrBuf[hdrPtr++] = unchecked((byte)c);  						ofs <<= 7;  						ofs += (c & 127);  					}  					long @base = streamPosition - ofs;  					OnBeginOfsDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					n.next = baseByPos.Put(@base' n);  					deltaCount++;  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					c = Fill(PackParser.Source.INPUT' 20);  					ObjectId @base = ObjectId.FromRaw(buf' c);  					System.Array.Copy(buf' c' hdrBuf' hdrPtr' 20);  					hdrPtr += 20;  					Use(20);  					PackParser.DeltaChain r = baseById.Get(@base);  					if (r == null)  					{  						r = new PackParser.DeltaChain(@base);  						baseById.Add(r);  					}  					OnBeginRefDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					r.Add(n);  					deltaCount++;  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(typeCode)));  				}  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					OnBeginWholeObject(streamPosition' typeCode' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					Whole(streamPosition' typeCode' sz);  					break;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ReadFrom(PackParser.Source.INPUT);  					hdrBuf[hdrPtr++] = unchecked((byte)c);  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFrom(PackParser.Source.INPUT);  						hdrBuf[hdrPtr++] = unchecked((byte)c);  						ofs <<= 7;  						ofs += (c & 127);  					}  					long @base = streamPosition - ofs;  					OnBeginOfsDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					n.next = baseByPos.Put(@base' n);  					deltaCount++;  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					c = Fill(PackParser.Source.INPUT' 20);  					ObjectId @base = ObjectId.FromRaw(buf' c);  					System.Array.Copy(buf' c' hdrBuf' hdrPtr' 20);  					hdrPtr += 20;  					Use(20);  					PackParser.DeltaChain r = baseById.Get(@base);  					if (r == null)  					{  						r = new PackParser.DeltaChain(@base);  						baseById.Add(r);  					}  					OnBeginRefDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					r.Add(n);  					deltaCount++;  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(typeCode)));  				}  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					OnBeginWholeObject(streamPosition' typeCode' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					Whole(streamPosition' typeCode' sz);  					break;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ReadFrom(PackParser.Source.INPUT);  					hdrBuf[hdrPtr++] = unchecked((byte)c);  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFrom(PackParser.Source.INPUT);  						hdrBuf[hdrPtr++] = unchecked((byte)c);  						ofs <<= 7;  						ofs += (c & 127);  					}  					long @base = streamPosition - ofs;  					OnBeginOfsDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					n.next = baseByPos.Put(@base' n);  					deltaCount++;  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					c = Fill(PackParser.Source.INPUT' 20);  					ObjectId @base = ObjectId.FromRaw(buf' c);  					System.Array.Copy(buf' c' hdrBuf' hdrPtr' 20);  					hdrPtr += 20;  					Use(20);  					PackParser.DeltaChain r = baseById.Get(@base);  					if (r == null)  					{  						r = new PackParser.DeltaChain(@base);  						baseById.Add(r);  					}  					OnBeginRefDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					r.Add(n);  					deltaCount++;  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(typeCode)));  				}  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					OnBeginWholeObject(streamPosition' typeCode' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					Whole(streamPosition' typeCode' sz);  					break;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ReadFrom(PackParser.Source.INPUT);  					hdrBuf[hdrPtr++] = unchecked((byte)c);  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFrom(PackParser.Source.INPUT);  						hdrBuf[hdrPtr++] = unchecked((byte)c);  						ofs <<= 7;  						ofs += (c & 127);  					}  					long @base = streamPosition - ofs;  					OnBeginOfsDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					n.next = baseByPos.Put(@base' n);  					deltaCount++;  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					c = Fill(PackParser.Source.INPUT' 20);  					ObjectId @base = ObjectId.FromRaw(buf' c);  					System.Array.Copy(buf' c' hdrBuf' hdrPtr' 20);  					hdrPtr += 20;  					Use(20);  					PackParser.DeltaChain r = baseById.Get(@base);  					if (r == null)  					{  						r = new PackParser.DeltaChain(@base);  						baseById.Add(r);  					}  					OnBeginRefDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					r.Add(n);  					deltaCount++;  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(typeCode)));  				}  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					OnBeginWholeObject(streamPosition' typeCode' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					Whole(streamPosition' typeCode' sz);  					break;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ReadFrom(PackParser.Source.INPUT);  					hdrBuf[hdrPtr++] = unchecked((byte)c);  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFrom(PackParser.Source.INPUT);  						hdrBuf[hdrPtr++] = unchecked((byte)c);  						ofs <<= 7;  						ofs += (c & 127);  					}  					long @base = streamPosition - ofs;  					OnBeginOfsDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					n.next = baseByPos.Put(@base' n);  					deltaCount++;  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					c = Fill(PackParser.Source.INPUT' 20);  					ObjectId @base = ObjectId.FromRaw(buf' c);  					System.Array.Copy(buf' c' hdrBuf' hdrPtr' 20);  					hdrPtr += 20;  					Use(20);  					PackParser.DeltaChain r = baseById.Get(@base);  					if (r == null)  					{  						r = new PackParser.DeltaChain(@base);  						baseById.Add(r);  					}  					OnBeginRefDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					r.Add(n);  					deltaCount++;  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(typeCode)));  				}  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					OnBeginWholeObject(streamPosition' typeCode' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					Whole(streamPosition' typeCode' sz);  					break;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ReadFrom(PackParser.Source.INPUT);  					hdrBuf[hdrPtr++] = unchecked((byte)c);  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFrom(PackParser.Source.INPUT);  						hdrBuf[hdrPtr++] = unchecked((byte)c);  						ofs <<= 7;  						ofs += (c & 127);  					}  					long @base = streamPosition - ofs;  					OnBeginOfsDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					n.next = baseByPos.Put(@base' n);  					deltaCount++;  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					c = Fill(PackParser.Source.INPUT' 20);  					ObjectId @base = ObjectId.FromRaw(buf' c);  					System.Array.Copy(buf' c' hdrBuf' hdrPtr' 20);  					hdrPtr += 20;  					Use(20);  					PackParser.DeltaChain r = baseById.Get(@base);  					if (r == null)  					{  						r = new PackParser.DeltaChain(@base);  						baseById.Add(r);  					}  					OnBeginRefDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					r.Add(n);  					deltaCount++;  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(typeCode)));  				}  			}
Magic Number,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  				{  					OnBeginWholeObject(streamPosition' typeCode' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					Whole(streamPosition' typeCode' sz);  					break;  				}    				case Constants.OBJ_OFS_DELTA:  				{  					c = ReadFrom(PackParser.Source.INPUT);  					hdrBuf[hdrPtr++] = unchecked((byte)c);  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFrom(PackParser.Source.INPUT);  						hdrBuf[hdrPtr++] = unchecked((byte)c);  						ofs <<= 7;  						ofs += (c & 127);  					}  					long @base = streamPosition - ofs;  					OnBeginOfsDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					n.next = baseByPos.Put(@base' n);  					deltaCount++;  					break;  				}    				case Constants.OBJ_REF_DELTA:  				{  					c = Fill(PackParser.Source.INPUT' 20);  					ObjectId @base = ObjectId.FromRaw(buf' c);  					System.Array.Copy(buf' c' hdrBuf' hdrPtr' 20);  					hdrPtr += 20;  					Use(20);  					PackParser.DeltaChain r = baseById.Get(@base);  					if (r == null)  					{  						r = new PackParser.DeltaChain(@base);  						baseById.Add(r);  					}  					OnBeginRefDelta(streamPosition' @base' sz);  					OnObjectHeader(PackParser.Source.INPUT' hdrBuf' 0' hdrPtr);  					InflateAndSkip(PackParser.Source.INPUT' sz);  					PackParser.UnresolvedDelta n = OnEndDelta();  					n.position = streamPosition;  					r.Add(n);  					deltaCount++;  					break;  				}    				default:  				{  					throw new IOException(MessageFormat.Format(JGitText.Get().unknownObjectType' Sharpen.Extensions.ValueOf  						(typeCode)));  				}  			}
Magic Number,NGit.Transport,InflaterStream,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,InflaterStream,The following statement contains a magic number: this.skipBuffer = new byte[512];
Magic Number,NGit.Transport,JschConfigSessionFactory,C:\repos\mono_ngit\NGit\NGit.Transport\JschConfigSessionFactory.cs,GetSession,The following statement contains a magic number: lock (this)  			{  				string user = uri.GetUser();  				string pass = uri.GetPass();  				string host = uri.GetHost();  				int port = uri.GetPort();  				try  				{  					if (config == null)  					{  						config = OpenSshConfig.Get(fs);  					}  					OpenSshConfig.Host hc = config.Lookup(host);  					host = hc.GetHostName();  					if (port <= 0)  					{  						port = hc.GetPort();  					}  					if (user == null)  					{  						user = hc.GetUser();  					}  					Session session = CreateSession(credentialsProvider' fs' user' pass' host' port'   						hc);  					int retries = 0;  					while (!session.IsConnected() && retries < 3)  					{  						try  						{  							retries++;  							session.Connect(tms);  						}  						catch (JSchException e)  						{  							session.Disconnect();  							session = null;  							// if authentication failed maybe credentials changed at the  							// remote end therefore reset credentials and retry  							if (credentialsProvider != null && e.InnerException == null && e.Message.Equals("Auth fail"  								) && retries < 3)  							{  								credentialsProvider.Reset(uri);  								session = CreateSession(credentialsProvider' fs' user' pass' host' port' hc);  							}  							else  							{  								throw;  							}  						}  					}  					return new JschSession(session' uri);  				}  				catch (JSchException je)  				{  					Exception c = je.InnerException;  					if (c is UnknownHostException)  					{  						throw new TransportException(uri' JGitText.Get().unknownHost);  					}  					if (c is ConnectException)  					{  						throw new TransportException(uri' c.Message);  					}  					throw new TransportException(uri' je.Message' je);  				}  			}
Magic Number,NGit.Transport,JschConfigSessionFactory,C:\repos\mono_ngit\NGit\NGit.Transport\JschConfigSessionFactory.cs,GetSession,The following statement contains a magic number: lock (this)  			{  				string user = uri.GetUser();  				string pass = uri.GetPass();  				string host = uri.GetHost();  				int port = uri.GetPort();  				try  				{  					if (config == null)  					{  						config = OpenSshConfig.Get(fs);  					}  					OpenSshConfig.Host hc = config.Lookup(host);  					host = hc.GetHostName();  					if (port <= 0)  					{  						port = hc.GetPort();  					}  					if (user == null)  					{  						user = hc.GetUser();  					}  					Session session = CreateSession(credentialsProvider' fs' user' pass' host' port'   						hc);  					int retries = 0;  					while (!session.IsConnected() && retries < 3)  					{  						try  						{  							retries++;  							session.Connect(tms);  						}  						catch (JSchException e)  						{  							session.Disconnect();  							session = null;  							// if authentication failed maybe credentials changed at the  							// remote end therefore reset credentials and retry  							if (credentialsProvider != null && e.InnerException == null && e.Message.Equals("Auth fail"  								) && retries < 3)  							{  								credentialsProvider.Reset(uri);  								session = CreateSession(credentialsProvider' fs' user' pass' host' port' hc);  							}  							else  							{  								throw;  							}  						}  					}  					return new JschSession(session' uri);  				}  				catch (JSchException je)  				{  					Exception c = je.InnerException;  					if (c is UnknownHostException)  					{  						throw new TransportException(uri' JGitText.Get().unknownHost);  					}  					if (c is ConnectException)  					{  						throw new TransportException(uri' c.Message);  					}  					throw new TransportException(uri' je.Message' je);  				}  			}
Magic Number,NGit.Transport,JschProcess,C:\repos\mono_ngit\NGit\NGit.Transport\JschSession.cs,JschProcess,The following statement contains a magic number: try  				{  					this.channel = (ChannelExec)this._enclosing.sock.OpenChannel("exec");  					this.channel.SetCommand(commandName);  					this.SetupStreams();  					this.channel.Connect(this.timeout > 0 ? this.timeout * 1000 : 0);  					if (!this.channel.IsConnected())  					{  						throw new TransportException(this._enclosing.uri' "connection failed");  					}  				}  				catch (JSchException e)  				{  					throw new TransportException(this._enclosing.uri' e.Message' e);  				}
Magic Number,NGit.Transport,JschProcess,C:\repos\mono_ngit\NGit\NGit.Transport\JschSession.cs,WaitFor,The following statement contains a magic number: while (this.IsRunning())  				{  					Sharpen.Thread.Sleep(100);  				}
Magic Number,NGit.Transport,_PipedOutputStream_173,C:\repos\mono_ngit\NGit\NGit.Transport\JschSession.cs,Close,The following statement contains a magic number: try  					{  						copier.Join(this._enclosing.timeout * 1000);  					}  					catch (Exception)  					{  					}
Magic Number,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,Init,The following statement contains a magic number: if (timeout > 0)  			{  				Sharpen.Thread caller = Sharpen.Thread.CurrentThread();  				timer = new InterruptTimer(caller.GetName() + "-Timer");  				timeoutIn = new TimeoutInputStream(rawIn' timer);  				TimeoutOutputStream o = new TimeoutOutputStream(rawOut' timer);  				timeoutIn.SetTimeout(timeout * 1000);  				o.SetTimeout(timeout * 1000);  				rawIn = timeoutIn;  				rawOut = o;  			}
Magic Number,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,Init,The following statement contains a magic number: if (timeout > 0)  			{  				Sharpen.Thread caller = Sharpen.Thread.CurrentThread();  				timer = new InterruptTimer(caller.GetName() + "-Timer");  				timeoutIn = new TimeoutInputStream(rawIn' timer);  				TimeoutOutputStream o = new TimeoutOutputStream(rawOut' timer);  				timeoutIn.SetTimeout(timeout * 1000);  				o.SetTimeout(timeout * 1000);  				rawIn = timeoutIn;  				rawOut = o;  			}
Magic Number,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,RecvCommands,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadStringRaw();  				}  				catch (EOFException eof)  				{  					if (commands.IsEmpty())  					{  						return;  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					break;  				}  				if (commands.IsEmpty())  				{  					BaseReceivePack.FirstLine firstLine = new BaseReceivePack.FirstLine(line);  					enabledCapabilities = firstLine.GetCapabilities();  					line = firstLine.GetLine();  				}  				if (line.Length < 83)  				{  					string m = JGitText.Get().errorInvalidProtocolWantedOldNewRef;  					SendError(m);  					throw new PackProtocolException(m);  				}  				ObjectId oldId = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' 40));  				ObjectId newId = ObjectId.FromString(Sharpen.Runtime.Substring(line' 41' 81));  				string name = Sharpen.Runtime.Substring(line' 82);  				ReceiveCommand cmd = new ReceiveCommand(oldId' newId' name);  				if (name.Equals(Constants.HEAD))  				{  					cmd.SetResult(ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  				}  				else  				{  					cmd.SetRef(refs.Get(cmd.GetRefName()));  				}  				commands.AddItem(cmd);  			}
Magic Number,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,RecvCommands,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadStringRaw();  				}  				catch (EOFException eof)  				{  					if (commands.IsEmpty())  					{  						return;  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					break;  				}  				if (commands.IsEmpty())  				{  					BaseReceivePack.FirstLine firstLine = new BaseReceivePack.FirstLine(line);  					enabledCapabilities = firstLine.GetCapabilities();  					line = firstLine.GetLine();  				}  				if (line.Length < 83)  				{  					string m = JGitText.Get().errorInvalidProtocolWantedOldNewRef;  					SendError(m);  					throw new PackProtocolException(m);  				}  				ObjectId oldId = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' 40));  				ObjectId newId = ObjectId.FromString(Sharpen.Runtime.Substring(line' 41' 81));  				string name = Sharpen.Runtime.Substring(line' 82);  				ReceiveCommand cmd = new ReceiveCommand(oldId' newId' name);  				if (name.Equals(Constants.HEAD))  				{  					cmd.SetResult(ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  				}  				else  				{  					cmd.SetRef(refs.Get(cmd.GetRefName()));  				}  				commands.AddItem(cmd);  			}
Magic Number,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,RecvCommands,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadStringRaw();  				}  				catch (EOFException eof)  				{  					if (commands.IsEmpty())  					{  						return;  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					break;  				}  				if (commands.IsEmpty())  				{  					BaseReceivePack.FirstLine firstLine = new BaseReceivePack.FirstLine(line);  					enabledCapabilities = firstLine.GetCapabilities();  					line = firstLine.GetLine();  				}  				if (line.Length < 83)  				{  					string m = JGitText.Get().errorInvalidProtocolWantedOldNewRef;  					SendError(m);  					throw new PackProtocolException(m);  				}  				ObjectId oldId = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' 40));  				ObjectId newId = ObjectId.FromString(Sharpen.Runtime.Substring(line' 41' 81));  				string name = Sharpen.Runtime.Substring(line' 82);  				ReceiveCommand cmd = new ReceiveCommand(oldId' newId' name);  				if (name.Equals(Constants.HEAD))  				{  					cmd.SetResult(ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  				}  				else  				{  					cmd.SetRef(refs.Get(cmd.GetRefName()));  				}  				commands.AddItem(cmd);  			}
Magic Number,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,RecvCommands,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadStringRaw();  				}  				catch (EOFException eof)  				{  					if (commands.IsEmpty())  					{  						return;  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					break;  				}  				if (commands.IsEmpty())  				{  					BaseReceivePack.FirstLine firstLine = new BaseReceivePack.FirstLine(line);  					enabledCapabilities = firstLine.GetCapabilities();  					line = firstLine.GetLine();  				}  				if (line.Length < 83)  				{  					string m = JGitText.Get().errorInvalidProtocolWantedOldNewRef;  					SendError(m);  					throw new PackProtocolException(m);  				}  				ObjectId oldId = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' 40));  				ObjectId newId = ObjectId.FromString(Sharpen.Runtime.Substring(line' 41' 81));  				string name = Sharpen.Runtime.Substring(line' 82);  				ReceiveCommand cmd = new ReceiveCommand(oldId' newId' name);  				if (name.Equals(Constants.HEAD))  				{  					cmd.SetResult(ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  				}  				else  				{  					cmd.SetRef(refs.Get(cmd.GetRefName()));  				}  				commands.AddItem(cmd);  			}
Magic Number,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,RecvCommands,The following statement contains a magic number: for (; ; )  			{  				string line;  				try  				{  					line = pckIn.ReadStringRaw();  				}  				catch (EOFException eof)  				{  					if (commands.IsEmpty())  					{  						return;  					}  					throw;  				}  				if (line == PacketLineIn.END)  				{  					break;  				}  				if (commands.IsEmpty())  				{  					BaseReceivePack.FirstLine firstLine = new BaseReceivePack.FirstLine(line);  					enabledCapabilities = firstLine.GetCapabilities();  					line = firstLine.GetLine();  				}  				if (line.Length < 83)  				{  					string m = JGitText.Get().errorInvalidProtocolWantedOldNewRef;  					SendError(m);  					throw new PackProtocolException(m);  				}  				ObjectId oldId = ObjectId.FromString(Sharpen.Runtime.Substring(line' 0' 40));  				ObjectId newId = ObjectId.FromString(Sharpen.Runtime.Substring(line' 41' 81));  				string name = Sharpen.Runtime.Substring(line' 82);  				ReceiveCommand cmd = new ReceiveCommand(oldId' newId' name);  				if (name.Equals(Constants.HEAD))  				{  					cmd.SetResult(ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  				}  				else  				{  					cmd.SetRef(refs.Get(cmd.GetRefName()));  				}  				commands.AddItem(cmd);  			}
Magic Number,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,ReceivePack,The following statement contains a magic number: if (timeoutIn != null)  			{  				timeoutIn.SetTimeout(10 * timeout * 1000);  			}
Magic Number,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,ReceivePack,The following statement contains a magic number: if (timeoutIn != null)  			{  				timeoutIn.SetTimeout(10 * timeout * 1000);  			}
Magic Number,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,ReceivePack,The following statement contains a magic number: if (timeoutIn != null)  			{  				timeoutIn.SetTimeout(timeout * 1000);  			}
Magic Number,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,ExecuteCommands,The following statement contains a magic number: if (sideBand)  			{  				SideBandProgressMonitor pm = new SideBandProgressMonitor(msgOut);  				pm.SetDelayStart(250' TimeUnit.MILLISECONDS);  				updating = pm;  			}
Magic Number,NGit.Notes,FanoutBucket,C:\repos\mono_ngit\NGit\NGit.Notes\FanoutBucket.cs,FanoutBucket,The following statement contains a magic number: table = new NoteBucket[256];
Magic Number,NGit.Notes,FanoutBucket,C:\repos\mono_ngit\NGit\NGit.Notes\FanoutBucket.cs,EstimateSize,The following statement contains a magic number: if (LeafBucket.MAX_SIZE * 3 / 4 <= cnt)  			{  				return 1 + LeafBucket.MAX_SIZE;  			}
Magic Number,NGit.Notes,FanoutBucket,C:\repos\mono_ngit\NGit\NGit.Notes\FanoutBucket.cs,EstimateSize,The following statement contains a magic number: if (LeafBucket.MAX_SIZE * 3 / 4 <= cnt)  			{  				return 1 + LeafBucket.MAX_SIZE;  			}
Magic Number,NGit.Notes,FanoutBucket,C:\repos\mono_ngit\NGit\NGit.Notes\FanoutBucket.cs,EstimateSize,The following statement contains a magic number: for (int cell = 0; cell < 256; cell++)  			{  				NoteBucket b = table[cell];  				if (b == null)  				{  					continue;  				}  				id.SetByte(prefixLen >> 1' cell);  				sz += b.EstimateSize(id' or);  				if (LeafBucket.MAX_SIZE < sz)  				{  					break;  				}  			}
Magic Number,NGit.Notes,FanoutBucket,C:\repos\mono_ngit\NGit\NGit.Notes\FanoutBucket.cs,Set,The following statement contains a magic number: if (b == null)  			{  				if (noteData == null)  				{  					return this;  				}  				LeafBucket n = new LeafBucket(prefixLen + 2);  				table[cell] = n.Set(noteOn' noteData' or);  				cnt++;  				return this;  			}  			else  			{  				NoteBucket n = b.Set(noteOn' noteData' or);  				if (n == null)  				{  					table[cell] = null;  					cnt--;  					if (cnt == 0)  					{  						return null;  					}  					return ContractIfTooSmall(noteOn' or);  				}  				else  				{  					if (n != b)  					{  						table[cell] = n;  					}  				}  				return this;  			}
Magic Number,NGit.Notes,FanoutBucket,C:\repos\mono_ngit\NGit\NGit.Notes\FanoutBucket.cs,Build,The following statement contains a magic number: byte[] nameBuf = new byte[2];
Magic Number,NGit.Notes,FanoutBucket,C:\repos\mono_ngit\NGit\NGit.Notes\FanoutBucket.cs,Build,The following statement contains a magic number: for (int cell = 0; cell < 256; cell++)  			{  				NoteBucket b = table[cell];  				if (b == null)  				{  					continue;  				}  				nameBuf[0] = hexchar[(int)(((uint)cell) >> 4)];  				nameBuf[1] = hexchar[cell & unchecked((int)(0x0f))];  				while (e != null && e.PathCompare(nameBuf' 0' 2' FileMode.TREE) < 0)  				{  					e.Format(fmt);  					e = e.next;  				}  				ObjectId id;  				if (insert)  				{  					id = b.WriteTree(inserter);  				}  				else  				{  					id = b.GetTreeId();  				}  				fmt.Append(nameBuf' 0' 2' FileMode.TREE' id);  			}
Magic Number,NGit.Notes,FanoutBucket,C:\repos\mono_ngit\NGit\NGit.Notes\FanoutBucket.cs,Build,The following statement contains a magic number: for (int cell = 0; cell < 256; cell++)  			{  				NoteBucket b = table[cell];  				if (b == null)  				{  					continue;  				}  				nameBuf[0] = hexchar[(int)(((uint)cell) >> 4)];  				nameBuf[1] = hexchar[cell & unchecked((int)(0x0f))];  				while (e != null && e.PathCompare(nameBuf' 0' 2' FileMode.TREE) < 0)  				{  					e.Format(fmt);  					e = e.next;  				}  				ObjectId id;  				if (insert)  				{  					id = b.WriteTree(inserter);  				}  				else  				{  					id = b.GetTreeId();  				}  				fmt.Append(nameBuf' 0' 2' FileMode.TREE' id);  			}
Magic Number,NGit.Notes,FanoutBucket,C:\repos\mono_ngit\NGit\NGit.Notes\FanoutBucket.cs,Build,The following statement contains a magic number: for (int cell = 0; cell < 256; cell++)  			{  				NoteBucket b = table[cell];  				if (b == null)  				{  					continue;  				}  				nameBuf[0] = hexchar[(int)(((uint)cell) >> 4)];  				nameBuf[1] = hexchar[cell & unchecked((int)(0x0f))];  				while (e != null && e.PathCompare(nameBuf' 0' 2' FileMode.TREE) < 0)  				{  					e.Format(fmt);  					e = e.next;  				}  				ObjectId id;  				if (insert)  				{  					id = b.WriteTree(inserter);  				}  				else  				{  					id = b.GetTreeId();  				}  				fmt.Append(nameBuf' 0' 2' FileMode.TREE' id);  			}
Magic Number,NGit.Notes,FanoutBucket,C:\repos\mono_ngit\NGit\NGit.Notes\FanoutBucket.cs,Build,The following statement contains a magic number: for (int cell = 0; cell < 256; cell++)  			{  				NoteBucket b = table[cell];  				if (b == null)  				{  					continue;  				}  				nameBuf[0] = hexchar[(int)(((uint)cell) >> 4)];  				nameBuf[1] = hexchar[cell & unchecked((int)(0x0f))];  				while (e != null && e.PathCompare(nameBuf' 0' 2' FileMode.TREE) < 0)  				{  					e.Format(fmt);  					e = e.next;  				}  				ObjectId id;  				if (insert)  				{  					id = b.WriteTree(inserter);  				}  				else  				{  					id = b.GetTreeId();  				}  				fmt.Append(nameBuf' 0' 2' FileMode.TREE' id);  			}
Magic Number,NGit.Notes,FanoutBucket,C:\repos\mono_ngit\NGit\NGit.Notes\FanoutBucket.cs,TreeSize,The following statement contains a magic number: int sz = cnt * TreeFormatter.EntrySize(FileMode.TREE' 2);
Magic Number,NGit.Notes,FanoutBucket,C:\repos\mono_ngit\NGit\NGit.Notes\FanoutBucket.cs,Append,The following statement contains a magic number: if (b == null)  			{  				LeafBucket n = new LeafBucket(prefixLen + 2);  				table[cell] = n.Append(note);  				cnt++;  			}  			else  			{  				InMemoryNoteBucket n = b.Append(note);  				if (n != b)  				{  					table[cell] = n;  				}  			}
Magic Number,NGit.Notes,LazyNoteBucket,C:\repos\mono_ngit\NGit\NGit.Notes\FanoutBucket.cs,Load,The following statement contains a magic number: AbbreviatedObjectId p = prefix.Abbreviate(this._enclosing.prefixLen + 2);
Magic Number,NGit.Notes,LeafBucket,C:\repos\mono_ngit\NGit\NGit.Notes\LeafBucket.cs,LeafBucket,The following statement contains a magic number: notes = new Note[4];
Magic Number,NGit.Notes,LeafBucket,C:\repos\mono_ngit\NGit\NGit.Notes\LeafBucket.cs,GrowIfFull,The following statement contains a magic number: if (notes.Length == cnt)  			{  				Note[] n = new Note[notes.Length * 2];  				System.Array.Copy(notes' 0' n' 0' cnt);  				notes = n;  			}
Magic Number,NGit.Notes,LeafBucket,C:\repos\mono_ngit\NGit\NGit.Notes\LeafBucket.cs,ShouldSplit,The following statement contains a magic number: return MAX_SIZE <= cnt && prefixLen + 2 < Constants.OBJECT_ID_STRING_LENGTH;
Magic Number,NGit.Notes,NoteParser,C:\repos\mono_ngit\NGit\NGit.Notes\NoteParser.cs,ParseTree,The following statement contains a magic number: for (; !Eof; Next(1))  			{  				if (pathLen == pathPadding + Constants.OBJECT_ID_STRING_LENGTH && IsHex())  				{  					return ParseLeafTree();  				}  				else  				{  					if (NameLength == 2 && IsHex() && IsTree())  					{  						return ParseFanoutTree();  					}  					else  					{  						StoreNonNote();  					}  				}  			}
Magic Number,NGit.Notes,NoteParser,C:\repos\mono_ngit\NGit\NGit.Notes\NoteParser.cs,ParseFanoutCell,The following statement contains a magic number: if (NameLength == 2 && IsTree())  			{  				try  				{  					return (RawParseUtils.ParseHexInt4(path[pathOffset + 0]) << 4) | RawParseUtils.ParseHexInt4  						(path[pathOffset + 1]);  				}  				catch (IndexOutOfRangeException)  				{  					return -1;  				}  			}  			else  			{  				return -1;  			}
Magic Number,NGit.Notes,NoteParser,C:\repos\mono_ngit\NGit\NGit.Notes\NoteParser.cs,ParseFanoutCell,The following statement contains a magic number: if (NameLength == 2 && IsTree())  			{  				try  				{  					return (RawParseUtils.ParseHexInt4(path[pathOffset + 0]) << 4) | RawParseUtils.ParseHexInt4  						(path[pathOffset + 1]);  				}  				catch (IndexOutOfRangeException)  				{  					return -1;  				}  			}  			else  			{  				return -1;  			}
Magic Number,NGit.Notes,NoteMapMerger,C:\repos\mono_ngit\NGit\NGit.Notes\NoteMapMerger.cs,MergeFanoutBucket,The following statement contains a magic number: FanoutBucket result = new FanoutBucket(treeDepth * 2);
Magic Number,NGit.Notes,NoteMapMerger,C:\repos\mono_ngit\NGit\NGit.Notes\NoteMapMerger.cs,MergeFanoutBucket,The following statement contains a magic number: for (int i = 0; i < 256; i++)  			{  				NoteBucket b = @base.GetBucket(i);  				NoteBucket o = ours.GetBucket(i);  				NoteBucket t = theirs.GetBucket(i);  				if (Equals(o' t))  				{  					AddIfNotNull(result' i' o);  				}  				else  				{  					if (Equals(b' o))  					{  						AddIfNotNull(result' i' t);  					}  					else  					{  						if (Equals(b' t))  						{  							AddIfNotNull(result' i' o);  						}  						else  						{  							objectIdPrefix.SetByte(treeDepth' i);  							InMemoryNoteBucket mergedBucket = Merge(treeDepth + 1' FanoutBucket.LoadIfLazy(b'   								objectIdPrefix' reader)' FanoutBucket.LoadIfLazy(o' objectIdPrefix' reader)' FanoutBucket  								.LoadIfLazy(t' objectIdPrefix' reader));  							result.SetBucket(i' mergedBucket);  						}  					}  				}  			}
Magic Number,NGit.Notes,NoteMapMerger,C:\repos\mono_ngit\NGit\NGit.Notes\NoteMapMerger.cs,MergeLeafBucket,The following statement contains a magic number: InMemoryNoteBucket result = new LeafBucket(treeDepth * 2);
Magic Number,NGit.Blame,Candidate,C:\repos\mono_ngit\NGit\NGit.Blame\Candidate.cs,ToString,The following statement contains a magic number: if (sourceCommit != null)  			{  				r.Append(" @ ").Append(sourceCommit.Abbreviate(6).Name);  			}
Magic Number,NGit.Submodule,SubmoduleWalk,C:\repos\mono_ngit\NGit\NGit.Submodule\SubmoduleWalk.cs,GetSubmoduleRemoteUrl,The following statement contains a magic number: while (submoduleUrl.Length > 0)  			{  				if (submoduleUrl.StartsWith("./"))  				{  					submoduleUrl = Sharpen.Runtime.Substring(submoduleUrl' 2);  				}  				else  				{  					if (submoduleUrl.StartsWith("../"))  					{  						int lastSeparator = remoteUrl.LastIndexOf('/');  						if (lastSeparator < 1)  						{  							lastSeparator = remoteUrl.LastIndexOf(':');  							separator = ':';  						}  						if (lastSeparator < 1)  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().submoduleParentRemoteUrlInvalid  								' remoteUrl));  						}  						remoteUrl = Sharpen.Runtime.Substring(remoteUrl' 0' lastSeparator);  						submoduleUrl = Sharpen.Runtime.Substring(submoduleUrl' 3);  					}  					else  					{  						break;  					}  				}  			}
Magic Number,NGit.Submodule,SubmoduleWalk,C:\repos\mono_ngit\NGit\NGit.Submodule\SubmoduleWalk.cs,GetSubmoduleRemoteUrl,The following statement contains a magic number: while (submoduleUrl.Length > 0)  			{  				if (submoduleUrl.StartsWith("./"))  				{  					submoduleUrl = Sharpen.Runtime.Substring(submoduleUrl' 2);  				}  				else  				{  					if (submoduleUrl.StartsWith("../"))  					{  						int lastSeparator = remoteUrl.LastIndexOf('/');  						if (lastSeparator < 1)  						{  							lastSeparator = remoteUrl.LastIndexOf(':');  							separator = ':';  						}  						if (lastSeparator < 1)  						{  							throw new IOException(MessageFormat.Format(JGitText.Get().submoduleParentRemoteUrlInvalid  								' remoteUrl));  						}  						remoteUrl = Sharpen.Runtime.Substring(remoteUrl' 0' lastSeparator);  						submoduleUrl = Sharpen.Runtime.Substring(submoduleUrl' 3);  					}  					else  					{  						break;  					}  				}  			}
Duplicate Code,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,Resolve,The method contains a code clone-set at the following line numbers (starting from the method definition): ((11' 32)' (190' 211))
Duplicate Code,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,FindObjectId,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 25)' (10' 29)' (14' 33)' (18' 37)' (22' 41)' (26' 45)' (30' 49)' (34' 53)' (38' 57)' (42' 61)' (46' 65)' (50' 69))
Duplicate Code,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,FindObjectId,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 64)' (10' 68))
Duplicate Code,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,FindObjectId,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 25)' (14' 33)' (18' 37)' (22' 41)' (26' 45)' (30' 49)' (34' 53)' (38' 57)' (42' 61)' (46' 65)' (50' 69))
Duplicate Code,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ParseMode,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 25)' (13' 32)' (20' 39)' (27' 46)' (34' 53))
Duplicate Code,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ParseMode,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 45)' (13' 52))
Duplicate Code,NGit.Revwalk,ObjectWalk,C:\repos\mono_ngit\NGit\NGit.Revwalk\ObjectWalk.cs,ParseMode,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 25)' (20' 39)' (27' 46)' (34' 53))
Missing Default,NGit,Config,C:\repos\mono_ngit\NGit\NGit\Config.cs,GetLong,The following switch statement is missing a default case: switch (StringUtils.ToLowerCase(n[n.Length - 1]))  			{  				case 'g':  				{  					mul = GiB;  					break;  				}    				case 'm':  				{  					mul = MiB;  					break;  				}    				case 'k':  				{  					mul = KiB;  					break;  				}  			}
Missing Default,NGit,FileMode,C:\repos\mono_ngit\NGit\NGit\FileMode.cs,FromBits,The following switch statement is missing a default case: switch (bits & TYPE_MASK)  			{  				case TYPE_MISSING:  				{  					if (bits == 0)  					{  						return MISSING;  					}  					break;  				}    				case TYPE_TREE:  				{  					return TREE;  				}    				case TYPE_FILE:  				{  					if ((bits & 0x49) != 0)  					{  						return EXECUTABLE_FILE;  					}  					return REGULAR_FILE;  				}    				case TYPE_SYMLINK:  				{  					return SYMLINK;  				}    				case TYPE_GITLINK:  				{  					return GITLINK;  				}  			}
Missing Default,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,IsValidRefName,The following switch statement is missing a default case: switch (c)  				{  					case '.':  					{  						switch (p)  						{  							case '\0':  							case '/':  							case '.':  							{  								return false;  							}  						}  						if (i == len - 1)  						{  							return false;  						}  						break;  					}    					case '/':  					{  						if (i == 0 || i == len - 1)  						{  							return false;  						}  						if (p == '/')  						{  							return false;  						}  						components++;  						break;  					}    					case '{':  					{  						if (p == '@')  						{  							return false;  						}  						break;  					}    					case '~':  					case '^':  					case ':':  					case '?':  					case '[':  					case '*':  					case '\\':  					case '\u007F':  					{  						return false;  					}  				}
Missing Default,NGit,Repository,C:\repos\mono_ngit\NGit\NGit\Repository.cs,IsValidRefName,The following switch statement is missing a default case: switch (p)  						{  							case '\0':  							case '/':  							case '.':  							{  								return false;  							}  						}
Missing Default,NGit,BatchRefUpdate,C:\repos\mono_ngit\NGit\NGit\BatchRefUpdate.cs,Execute,The following switch statement is missing a default case: switch (cmd.GetType())  						{  							case ReceiveCommand.Type.DELETE:  							{  								cmd.SetResult(ru.Delete(walk));  								continue;  								goto case ReceiveCommand.Type.CREATE;  							}    							case ReceiveCommand.Type.CREATE:  							case ReceiveCommand.Type.UPDATE:  							case ReceiveCommand.Type.UPDATE_NONFASTFORWARD:  							{  								cmd.SetResult(ru.Update(walk));  								continue;  							}  						}
Missing Default,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,Call,The following switch statement is missing a default case: switch (operation)  				{  					case RebaseCommand.Operation.ABORT:  					{  						try  						{  							return Abort(RebaseResult.ABORTED_RESULT);  						}  						catch (IOException ioe)  						{  							throw new JGitInternalException(ioe.Message' ioe);  						}  						goto case RebaseCommand.Operation.SKIP;  					}    					case RebaseCommand.Operation.SKIP:  					case RebaseCommand.Operation.CONTINUE:  					{  						// fall through  						string upstreamCommitId = ReadFile(rebaseDir' ONTO);  						try  						{  							upstreamCommitName = ReadFile(rebaseDir' ONTO_NAME);  						}  						catch (FileNotFoundException)  						{  							// Fall back to commit ID if file doesn't exist (e.g. rebase  							// was started by C Git)  							upstreamCommitName = upstreamCommitId;  						}  						this.upstreamCommit = walk.ParseCommit(repo.Resolve(upstreamCommitId));  						break;  					}    					case RebaseCommand.Operation.BEGIN:  					{  						RebaseResult res = InitFilesAndRewind();  						if (res != null)  						{  							return res;  						}  					break;  					}  				}
Missing Default,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,Call,The following switch statement is missing a default case: switch (cherryPickResult.GetStatus())  							{  								case CherryPickResult.CherryPickStatus.FAILED:  								{  									if (operation == RebaseCommand.Operation.BEGIN)  									{  										return Abort(new RebaseResult(cherryPickResult.GetFailingPaths()));  									}  									else  									{  										return Stop(commitToPick);  									}  									goto case CherryPickResult.CherryPickStatus.CONFLICTING;  								}    								case CherryPickResult.CherryPickStatus.CONFLICTING:  								{  									return Stop(commitToPick);  								}    								case CherryPickResult.CherryPickStatus.OK:  								{  									newHead = cherryPickResult.GetNewHead();  									break;  								}  							}
Missing Default,NGit.Api,RebaseCommand,C:\repos\mono_ngit\NGit\NGit.Api\RebaseCommand.cs,LoadSteps,The following switch statement is missing a default case: switch (tokenCount)  					{  						case 0:  						{  							string actionToken = Sharpen.Runtime.GetStringForBytes(buf' tokenBegin' nextSpace  								 - tokenBegin - 1);  							tokenBegin = nextSpace;  							if (actionToken[0] == '#')  							{  								tokenCount = 3;  								break;  							}  							RebaseCommand.Action action = RebaseCommand.Action.Parse(actionToken);  							if (action != null)  							{  								current = new RebaseCommand.Step(RebaseCommand.Action.Parse(actionToken));  							}  							break;  						}    						case 1:  						{  							if (current == null)  							{  								break;  							}  							nextSpace = RawParseUtils.Next(buf' tokenBegin' ' ');  							string commitToken = Sharpen.Runtime.GetStringForBytes(buf' tokenBegin' nextSpace  								 - tokenBegin - 1);  							tokenBegin = nextSpace;  							current.commit = AbbreviatedObjectId.FromString(commitToken);  							break;  						}    						case 2:  						{  							if (current == null)  							{  								break;  							}  							nextSpace = ptr;  							int length = ptr - tokenBegin;  							current.shortMessage = new byte[length];  							System.Array.Copy(buf' tokenBegin' current.shortMessage' 0' length);  							r.AddItem(current);  							break;  						}  					}
Missing Default,NGit.Api,ResetCommand,C:\repos\mono_ngit\NGit\NGit.Api\ResetCommand.cs,Call,The following switch statement is missing a default case: switch (mode)  				{  					case ResetCommand.ResetType.HARD:  					{  						CheckoutIndex(commit);  						break;  					}    					case ResetCommand.ResetType.MIXED:  					{  						ResetIndex(commit);  						break;  					}    					case ResetCommand.ResetType.SOFT:  					{  						// do nothing' only the ref was changed  						break;  					}    					case ResetCommand.ResetType.KEEP:  					case ResetCommand.ResetType.MERGE:  					{  						// TODO  						// TODO  						throw new NotSupportedException();  					}  				}
Missing Default,NGit.Api,ApplyCommand,C:\repos\mono_ngit\NGit\NGit.Api\ApplyCommand.cs,Call,The following switch statement is missing a default case: switch (type)  					{  						case DiffEntry.ChangeType.ADD:  						{  							f = GetFile(fh.GetNewPath()' true);  							Apply(f' fh);  							break;  						}    						case DiffEntry.ChangeType.MODIFY:  						{  							f = GetFile(fh.GetOldPath()' false);  							Apply(f' fh);  							break;  						}    						case DiffEntry.ChangeType.DELETE:  						{  							f = GetFile(fh.GetOldPath()' false);  							if (!f.Delete())  							{  								throw new PatchApplyException(MessageFormat.Format(JGitText.Get().cannotDeleteFile  									' f));  							}  							break;  						}    						case DiffEntry.ChangeType.RENAME:  						{  							f = GetFile(fh.GetOldPath()' false);  							FilePath dest = GetFile(fh.GetNewPath()' false);  							if (!f.RenameTo(dest))  							{  								throw new PatchApplyException(MessageFormat.Format(JGitText.Get().renameFileFailed  									' f' dest));  							}  							break;  						}    						case DiffEntry.ChangeType.COPY:  						{  							f = GetFile(fh.GetOldPath()' false);  							byte[] bs = IOUtil.ReadFully(f);  							FileWriter fw = new FileWriter(GetFile(fh.GetNewPath()' true));  							fw.Write(Sharpen.Runtime.GetStringForBytes(bs));  							fw.Close();  							break;  						}  					}
Missing Default,NGit.Api,ApplyCommand,C:\repos\mono_ngit\NGit\NGit.Api\ApplyCommand.cs,Apply,The following switch statement is missing a default case: switch (hunkLine[0])  					{  						case ' ':  						{  							if (!newLines[hh.GetNewStartLine() - 1 + pos].Equals(Sharpen.Runtime.Substring(hunkLine  								' 1)))  							{  								throw new PatchApplyException(MessageFormat.Format(JGitText.Get().patchApplyException  									' hh));  							}  							pos++;  							break;  						}    						case '-':  						{  							if (!newLines[hh.GetNewStartLine() - 1 + pos].Equals(Sharpen.Runtime.Substring(hunkLine  								' 1)))  							{  								throw new PatchApplyException(MessageFormat.Format(JGitText.Get().patchApplyException  									' hh));  							}  							newLines.Remove(hh.GetNewStartLine() - 1 + pos);  							break;  						}    						case '+':  						{  							newLines.Add(hh.GetNewStartLine() - 1 + pos' Sharpen.Runtime.Substring(hunkLine'   								1));  							pos++;  							break;  						}  					}
Missing Default,NGit.Diff,DiffEntry,C:\repos\mono_ngit\NGit\NGit.Diff\DiffEntry.cs,ToString,The following switch statement is missing a default case: switch (changeType)  			{  				case DiffEntry.ChangeType.ADD:  				{  					buf.Append(newPath);  					break;  				}    				case DiffEntry.ChangeType.COPY:  				{  					buf.Append(oldPath + "->" + newPath);  					break;  				}    				case DiffEntry.ChangeType.DELETE:  				{  					buf.Append(oldPath);  					break;  				}    				case DiffEntry.ChangeType.MODIFY:  				{  					buf.Append(oldPath);  					break;  				}    				case DiffEntry.ChangeType.RENAME:  				{  					buf.Append(oldPath + "->" + newPath);  					break;  				}  			}
Missing Default,NGit.Diff,DiffFormatter,C:\repos\mono_ngit\NGit\NGit.Diff\DiffFormatter.cs,Open,The following switch statement is missing a default case: switch (side)  					{  						case DiffEntry.Side.OLD:  						{  							entry.oldId = id;  							break;  						}    						case DiffEntry.Side.NEW:  						{  							entry.newId = id;  							break;  						}  					}
Missing Default,NGit.Diff,DiffFormatter,C:\repos\mono_ngit\NGit\NGit.Diff\DiffFormatter.cs,FormatHeader,The following switch statement is missing a default case: switch (type)  			{  				case DiffEntry.ChangeType.ADD:  				{  					o.Write(Constants.EncodeASCII("new file mode "));  					newMode.CopyTo(o);  					o.Write('\n');  					break;  				}    				case DiffEntry.ChangeType.DELETE:  				{  					o.Write(Constants.EncodeASCII("deleted file mode "));  					oldMode.CopyTo(o);  					o.Write('\n');  					break;  				}    				case DiffEntry.ChangeType.RENAME:  				{  					o.Write(Constants.EncodeASCII("similarity index " + ent.GetScore() + "%"));  					o.Write('\n');  					o.Write(Constants.Encode("rename from " + QuotePath(oldp)));  					o.Write('\n');  					o.Write(Constants.Encode("rename to " + QuotePath(newp)));  					o.Write('\n');  					break;  				}    				case DiffEntry.ChangeType.COPY:  				{  					o.Write(Constants.EncodeASCII("similarity index " + ent.GetScore() + "%"));  					o.Write('\n');  					o.Write(Constants.Encode("copy from " + QuotePath(oldp)));  					o.Write('\n');  					o.Write(Constants.Encode("copy to " + QuotePath(newp)));  					o.Write('\n');  					if (!oldMode.Equals(newMode))  					{  						o.Write(Constants.EncodeASCII("new file mode "));  						newMode.CopyTo(o);  						o.Write('\n');  					}  					break;  				}    				case DiffEntry.ChangeType.MODIFY:  				{  					if (0 < ent.GetScore())  					{  						o.Write(Constants.EncodeASCII("dissimilarity index " + (100 - ent.GetScore()) + "%"  							));  						o.Write('\n');  					}  					break;  				}  			}
Missing Default,NGit.Revwalk.Filter,SubStringRevFilter,C:\repos\mono_ngit\NGit\NGit.Revwalk.Filter\SubStringRevFilter.cs,Safe,The following switch statement is missing a default case: switch (c)  				{  					case '.':  					case '?':  					case '*':  					case '+':  					case '{':  					case '}':  					case '(':  					case ')':  					case '[':  					case ']':  					case '\\':  					{  						return false;  					}  				}
Missing Default,NGit.Storage.File,CachedObjectDirectory,C:\repos\mono_ngit\NGit\NGit.Storage.File\CachedObjectDirectory.cs,InsertUnpackedObject,The following switch statement is missing a default case: switch (result)  			{  				case FileObjectDatabase.InsertLooseObjectResult.INSERTED:  				case FileObjectDatabase.InsertLooseObjectResult.EXISTS_LOOSE:  				{  					unpackedObjects.AddIfAbsent(new CachedObjectDirectory.UnpackedObjectId(objectId));  					break;  				}    				case FileObjectDatabase.InsertLooseObjectResult.EXISTS_PACKED:  				case FileObjectDatabase.InsertLooseObjectResult.FAILURE:  				{  					break;  				}  			}
Missing Default,NGit.Storage.File,PackIndexWriter,C:\repos\mono_ngit\NGit\NGit.Storage.File\PackIndexWriter.cs,CreateOldestPossible,The following switch statement is missing a default case: switch (version)  				{  					case 1:  					{  						if (PackIndexWriterV1.CanStore(oe))  						{  							continue;  						}  						version = 2;  						goto case 2;  					}    					case 2:  					{  						goto LOOP_break;  					}  				}
Missing Default,NGit.Treewalk,WorkingTreeIterator,C:\repos\mono_ngit\NGit\NGit.Treewalk\WorkingTreeIterator.cs,IsEntryIgnoredInternal,The following switch statement is missing a default case: switch (rules.IsIgnored(p' FileMode.TREE.Equals(mode)))  				{  					case IgnoreNode.MatchResult.IGNORED:  					{  						return true;  					}    					case IgnoreNode.MatchResult.NOT_IGNORED:  					{  						return false;  					}    					case IgnoreNode.MatchResult.CHECK_PARENT:  					{  						break;  					}  				}
Missing Default,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following switch statement is missing a default case: switch (numSigBytes)  			{  				case 3:  				{  					inBuff |= (int)(((uint)(source[srcOffset + 2] << 24)) >> 24);  					goto case 2;  				}    				case 2:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset + 1] << 24)) >> 16);  					goto case 1;  				}    				case 1:  				{  					//$FALL-THROUGH$  					inBuff |= (int)(((uint)(source[srcOffset] << 24)) >> 8);  					break;  				}  			}
Missing Default,NGit.Util,Base64,C:\repos\mono_ngit\NGit\NGit.Util\Base64.cs,Encode3to4,The following switch statement is missing a default case: switch (numSigBytes)  			{  				case 3:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = ENC[(inBuff) & unchecked((int)(0x3f))];  					break;  				}    				case 2:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = ENC[((int)(((uint)inBuff) >> 6)) & unchecked((int)(  						0x3f))];  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}    				case 1:  				{  					destination[destOffset] = ENC[((int)(((uint)inBuff) >> 18))];  					destination[destOffset + 1] = ENC[((int)(((uint)inBuff) >> 12)) & unchecked((int)  						(0x3f))];  					destination[destOffset + 2] = (byte)EQUALS_SIGN;  					destination[destOffset + 3] = (byte)EQUALS_SIGN;  					break;  				}  			}
Missing Default,NGit.Util,BourneStyle,C:\repos\mono_ngit\NGit\NGit.Util\QuotedString.cs,Quote,The following switch statement is missing a default case: switch (@in[i])  					{  						case '\'':  						case '!':  						{  							r.AppendRange(@in' start' i);  							r.Append('\'');  							r.Append('\\');  							r.Append(@in[i]);  							r.Append('\'');  							start = i + 1;  							break;  						}  					}
Missing Default,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseBase10,The following switch statement is missing a default case: switch (b[ptr])  				{  					case (byte)('-'):  					{  						sign = -1;  						ptr++;  						break;  					}    					case (byte)('+'):  					{  						ptr++;  						break;  					}  				}
Missing Default,NGit.Util,RawParseUtils,C:\repos\mono_ngit\NGit\NGit.Util\RawParseUtils.cs,ParseLongBase10,The following switch statement is missing a default case: switch (b[ptr])  				{  					case (byte)('-'):  					{  						sign = -1;  						ptr++;  						break;  					}    					case (byte)('+'):  					{  						ptr++;  						break;  					}  				}
Missing Default,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,Negotiate,The following switch statement is missing a default case: switch (anr)  					{  						case PacketLineIn.AckNackResult.NAK:  						{  							// More have lines are necessary to compute the  							// pack on the remote side. Keep doing that.  							//  							resultsPending--;  							goto READ_RESULT_break;  						}    						case PacketLineIn.AckNackResult.ACK:  						{  							// The remote side is happy and knows exactly what  							// to send us. There is no further negotiation and  							// we can break out immediately.  							//  							multiAck = BasePackFetchConnection.MultiAck.OFF;  							resultsPending = 0;  							receivedAck = true;  							if (statelessRPC)  							{  								state.WriteTo(@out' null);  							}  							goto SEND_HAVES_break;  						}    						case PacketLineIn.AckNackResult.ACK_CONTINUE:  						case PacketLineIn.AckNackResult.ACK_COMMON:  						case PacketLineIn.AckNackResult.ACK_READY:  						{  							// The server knows this commit (ackId). We don't  							// need to send any further along its ancestry' but  							// we need to continue to talk about other parts of  							// our local history.  							//  							MarkCommon(walk.ParseAny(ackId)' anr);  							receivedAck = true;  							receivedContinue = true;  							havesSinceLastContinue = 0;  							if (anr == PacketLineIn.AckNackResult.ACK_READY)  							{  								receivedReady = true;  							}  							break;  						}  					}
Missing Default,NGit.Transport,BasePackFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\BasePackFetchConnection.cs,Negotiate,The following switch statement is missing a default case: switch (anr)  				{  					case PacketLineIn.AckNackResult.NAK:  					{  						// A NAK is a response to an end we queued earlier  						// we eat it and look for another ACK/NAK message.  						//  						break;  					}    					case PacketLineIn.AckNackResult.ACK:  					{  						// A solitary ACK at this point means the remote won't  						// speak anymore' but is going to send us a pack now.  						//  						goto READ_RESULT_break2;  					}    					case PacketLineIn.AckNackResult.ACK_CONTINUE:  					case PacketLineIn.AckNackResult.ACK_COMMON:  					case PacketLineIn.AckNackResult.ACK_READY:  					{  						// We will expect a normal ACK to break out of the loop.  						//  						multiAck = BasePackFetchConnection.MultiAck.CONTINUE;  						break;  					}  				}
Missing Default,NGit.Transport,ReceiveCommand,C:\repos\mono_ngit\NGit\NGit.Transport\ReceiveCommand.cs,Execute,The following switch statement is missing a default case: switch (GetType())  				{  					case ReceiveCommand.Type.DELETE:  					{  						if (!ObjectId.ZeroId.Equals(GetOldId()))  						{  							// We can only do a CAS style delete if the client  							// didn't bork its delete request by sending the  							// wrong zero id rather than the advertised one.  							//  							ru.SetExpectedOldObjectId(GetOldId());  						}  						ru.SetForceUpdate(true);  						SetResult(ru.Delete(rp.GetRevWalk()));  						break;  					}    					case ReceiveCommand.Type.CREATE:  					case ReceiveCommand.Type.UPDATE:  					case ReceiveCommand.Type.UPDATE_NONFASTFORWARD:  					{  						ru.SetForceUpdate(rp.IsAllowNonFastForwards());  						ru.SetExpectedOldObjectId(GetOldId());  						ru.SetNewObjectId(GetNewId());  						ru.SetRefLogMessage("push"' true);  						SetResult(ru.Update(rp.GetRevWalk()));  						break;  					}  				}
Missing Default,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,ProcessHaveLines,The following switch statement is missing a default case: switch (multiAck)  					{  						case BasePackFetchConnection.MultiAck.OFF:  						{  							// If both sides have the same object; let the client know.  							//  							if (commonBase.Count == 1)  							{  								pckOut.WriteString("ACK " + obj.Name + "\n");  							}  							break;  						}    						case BasePackFetchConnection.MultiAck.CONTINUE:  						{  							pckOut.WriteString("ACK " + obj.Name + " continue\n");  							break;  						}    						case BasePackFetchConnection.MultiAck.DETAILED:  						{  							pckOut.WriteString("ACK " + obj.Name + " common\n");  							break;  						}  					}
Missing Default,NGit.Transport,UploadPack,C:\repos\mono_ngit\NGit\NGit.Transport\UploadPack.cs,ProcessHaveLines,The following switch statement is missing a default case: switch (multiAck)  							{  								case BasePackFetchConnection.MultiAck.OFF:  								{  									break;  								}    								case BasePackFetchConnection.MultiAck.CONTINUE:  								{  									pckOut.WriteString("ACK " + id.Name + " continue\n");  									break;  								}    								case BasePackFetchConnection.MultiAck.DETAILED:  								{  									pckOut.WriteString("ACK " + id.Name + " ready\n");  									sentReady = true;  									break;  								}  							}
Missing Default,NGit.Transport,WalkFetchConnection,C:\repos\mono_ngit\NGit\NGit.Transport\WalkFetchConnection.cs,MarkLocalObjComplete,The following switch statement is missing a default case: switch (obj.Type)  			{  				case Constants.OBJ_BLOB:  				{  					obj.Add(COMPLETE);  					break;  				}    				case Constants.OBJ_COMMIT:  				{  					PushLocalCommit((RevCommit)obj);  					break;  				}    				case Constants.OBJ_TREE:  				{  					MarkTreeComplete((RevTree)obj);  					break;  				}  			}
Missing Default,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,Fill,The following switch statement is missing a default case: switch (src)  					{  						case PackParser.Source.INPUT:  						{  							Sync();  							break;  						}    						case PackParser.Source.DATABASE:  						{  							if (bAvail > 0)  							{  								System.Array.Copy(buf' bOffset' buf' 0' bAvail);  							}  							bOffset = 0;  							break;  						}  					}
Missing Default,NGit.Transport,PackParser,C:\repos\mono_ngit\NGit\NGit.Transport\PackParser.cs,Fill,The following switch statement is missing a default case: switch (src)  				{  					case PackParser.Source.INPUT:  					{  						next = @in.Read(buf' next' free);  						break;  					}    					case PackParser.Source.DATABASE:  					{  						next = ReadDatabase(buf' next' free);  						break;  					}  				}
Missing Default,NGit.Transport,BaseReceivePack,C:\repos\mono_ngit\NGit\NGit.Transport\BaseReceivePack.cs,SendStatusReport,The following switch statement is missing a default case: switch (cmd_1.GetResult())  				{  					case ReceiveCommand.Result.NOT_ATTEMPTED:  					{  						r.Append("server bug; ref not processed");  						break;  					}    					case ReceiveCommand.Result.REJECTED_NOCREATE:  					{  						r.Append("creation prohibited");  						break;  					}    					case ReceiveCommand.Result.REJECTED_NODELETE:  					{  						r.Append("deletion prohibited");  						break;  					}    					case ReceiveCommand.Result.REJECTED_NONFASTFORWARD:  					{  						r.Append("non-fast forward");  						break;  					}    					case ReceiveCommand.Result.REJECTED_CURRENT_BRANCH:  					{  						r.Append("branch is currently checked out");  						break;  					}    					case ReceiveCommand.Result.REJECTED_MISSING_OBJECT:  					{  						if (cmd_1.GetMessage() == null)  						{  							r.Append("missing object(s)");  						}  						else  						{  							if (cmd_1.GetMessage().Length == Constants.OBJECT_ID_STRING_LENGTH)  							{  								r.Append("object " + cmd_1.GetMessage() + " missing");  							}  							else  							{  								r.Append(cmd_1.GetMessage());  							}  						}  						break;  					}    					case ReceiveCommand.Result.REJECTED_OTHER_REASON:  					{  						if (cmd_1.GetMessage() == null)  						{  							r.Append("unspecified reason");  						}  						else  						{  							r.Append(cmd_1.GetMessage());  						}  						break;  					}    					case ReceiveCommand.Result.LOCK_FAILURE:  					{  						r.Append("failed to lock");  						break;  					}    					case ReceiveCommand.Result.OK:  					{  						// We shouldn't have reached this case (see 'ok' case above).  						continue;  					}  				}
