Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PackOne,The method has 141 lines of code.
Long Method,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The method has 234 lines of code.
Complex Method,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PackOne,Cyclomatic complexity of the method is 35
Complex Method,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,Cyclomatic complexity of the method is 60
Complex Method,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,GetTimeZone,Cyclomatic complexity of the method is 8
Complex Method,Sharpen,MessageFormat,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\MessageFormat.cs,Format,Cyclomatic complexity of the method is 9
Complex Method,Sharpen,HttpURLConnection,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\HttpURLConnection.cs,SetRequestProperty,Cyclomatic complexity of the method is 8
Complex Method,Sharpen,JavaCalendar,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\JavaCalendar.cs,Add,Cyclomatic complexity of the method is 8
Long Parameter List,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,RegionMatches,The method has 6 parameters. Parameters: str' ignoreCase' toOffset' other' ooffset' len
Long Identifier,Sharpen,ScheduledThreadPoolExecutor,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\ScheduledThreadPoolExecutor.cs,,The length of the parameter continueExistingPeriodicTasksAfterShutdownPolicy is 48.
Long Identifier,Sharpen,ScheduledThreadPoolExecutor,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\ScheduledThreadPoolExecutor.cs,,The length of the parameter executeExistingDelayedTasksAfterShutdownPolicy is 46.
Long Statement,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,GetTime,The length of the statement  "			return new DateTimeOffset (DateTime.SpecifyKind (dateTime' DateTimeKind.Utc)' TimeSpan.Zero).ToMillisecondsSinceEpoch ();" is 121.
Long Statement,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,ToMillisecondsSinceEpoch,The length of the statement  "			return new DateTimeOffset (DateTime.SpecifyKind (dateTime' DateTimeKind.Utc)' TimeSpan.Zero).ToMillisecondsSinceEpoch ();" is 121.
Long Statement,Sharpen,SimpleDateFormat,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\SimpleDateFormat.cs,Format,The length of the statement  "			return Extensions.MillisToDateTimeOffset (date' (int)GetTimeZone ().BaseUtcOffset.TotalMinutes).DateTime.ToString (format);" is 123.
Long Statement,Sharpen,ResourceBundle,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\ResourceBundle.cs,GetBundle,The length of the statement  "			manifestResourceStream = asm.GetManifestResourceStream (bundleClass + "_" + culture.ToString().Replace ('-'''_') + ".properties");" is 130.
Long Statement,Sharpen,ResourceBundle,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\ResourceBundle.cs,GetBundle,The length of the statement  "				manifestResourceStream = asm.GetManifestResourceStream (bundleClass + "_" + culture.TwoLetterISOLanguageName + ".properties");" is 126.
Long Statement,Sharpen,ScheduledThreadPoolExecutor,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\ScheduledThreadPoolExecutor.cs,Shutdown,The length of the statement  "					Scheduler.Instance.Shutdown (this' continueExistingPeriodicTasksAfterShutdownPolicy' executeExistingDelayedTasksAfterShutdownPolicy);" is 133.
Complex Conditional,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The conditional expression  "buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0"  is complex.
Complex Conditional,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,RegionMatches,The conditional expression  "toOffset < 0 || ooffset < 0 || toOffset + len > str.Length || ooffset + len > other.Length"  is complex.
Complex Conditional,Sharpen,FilePath,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\FilePath.cs,FilePath,The conditional expression  "child != null && child.Length > 0 && (child[0] == Path.DirectorySeparatorChar || child[0] == Path.AltDirectorySeparatorChar)"  is complex.
Empty Catch Block,Sharpen,TaskFuture<T>,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Executors.cs,Cancel,The method has an empty catch block.
Empty Catch Block,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The method has an empty catch block.
Empty Catch Block,Sharpen,Task<T>,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\ScheduledThreadPoolExecutor.cs,Cancel,The method has an empty catch block.
Empty Catch Block,Sharpen,ThreadPoolExecutor,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\ThreadPoolExecutor.cs,RunPoolThread,The method has an empty catch block.
Empty Catch Block,Sharpen,ThreadPoolExecutor,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\ThreadPoolExecutor.cs,ShutdownNow,The method has an empty catch block.
Empty Catch Block,Sharpen,SystemProcess,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Process.cs,Destroy,The method has an empty catch block.
Empty Catch Block,Sharpen,FileHelper,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\FileHelper.cs,SetLastModified,The method has an empty catch block.
Magic Number,Sharpen,CRC32,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\CRC32.cs,Update,The following statement contains a magic number: this._value = (this._value >> 8) ^ CrcTable[(int)((IntPtr)((this._value & 0xff) ^ value))];
Magic Number,Sharpen,CRC32,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\CRC32.cs,Update,The following statement contains a magic number: this._value = CrcTable[(int)((IntPtr)((this._value ^ value) & 0xff))] ^ (this._value >> 8);
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [8];
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [4];
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [4];
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [8];
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [2];
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [2];
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [4];
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [8];
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Sharpen,PackContext,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Add,The following statement contains a magic number: byte [] nb = new byte [System.Math.Max (next' 16) * 2 + group.Length];
Magic Number,Sharpen,PackContext,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Add,The following statement contains a magic number: byte [] nb = new byte [System.Math.Max (next' 16) * 2 + group.Length];
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetDouble,The following statement contains a magic number: data.Length - index < 8
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetDouble,The following statement contains a magic number: i < 8
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetUInt64,The following statement contains a magic number: data.Length - index < 8
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetUInt64,The following statement contains a magic number: i < 8
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetInt64,The following statement contains a magic number: data.Length - index < 8
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetInt64,The following statement contains a magic number: i < 8
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetFloat,The following statement contains a magic number: data.Length - index < 4
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetFloat,The following statement contains a magic number: i < 4
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetInt32,The following statement contains a magic number: data.Length - index < 4
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetInt32,The following statement contains a magic number: i < 4
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetUInt32,The following statement contains a magic number: data.Length - index < 4
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetUInt32,The following statement contains a magic number: i < 4
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetInt16,The following statement contains a magic number: data.Length - index < 2
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetInt16,The following statement contains a magic number: i < 2
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetUInt16,The following statement contains a magic number: data.Length - index < 2
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetUInt16,The following statement contains a magic number: i < 2
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 8);
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 4);
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 4);
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 4);
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 8);
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 8);
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 2);
Magic Number,Sharpen,CopyConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 2);
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetDouble,The following statement contains a magic number: data.Length - index < 8
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetDouble,The following statement contains a magic number: b [7-i] = data [index+i];
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetDouble,The following statement contains a magic number: i < 8
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetUInt64,The following statement contains a magic number: data.Length - index < 8
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetUInt64,The following statement contains a magic number: b [7-i] = data [index+i];
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetUInt64,The following statement contains a magic number: i < 8
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetInt64,The following statement contains a magic number: data.Length - index < 8
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetInt64,The following statement contains a magic number: b [7-i] = data [index+i];
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetInt64,The following statement contains a magic number: i < 8
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetFloat,The following statement contains a magic number: data.Length - index < 4
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetFloat,The following statement contains a magic number: b [3-i] = data [index+i];
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetFloat,The following statement contains a magic number: i < 4
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetInt32,The following statement contains a magic number: data.Length - index < 4
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetInt32,The following statement contains a magic number: b [3-i] = data [index+i];
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetInt32,The following statement contains a magic number: i < 4
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetUInt32,The following statement contains a magic number: data.Length - index < 4
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetUInt32,The following statement contains a magic number: b [3-i] = data [index+i];
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetUInt32,The following statement contains a magic number: i < 4
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetInt16,The following statement contains a magic number: data.Length - index < 2
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetInt16,The following statement contains a magic number: i < 2
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetUInt16,The following statement contains a magic number: data.Length - index < 2
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,GetUInt16,The following statement contains a magic number: i < 2
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 8);
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: target [i] = source [7-i];
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: i < 8
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 4);
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: target [i] = source [3-i];
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: i < 4
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 4);
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: target [i] = source [3-i];
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: i < 4
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 4);
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: target [i] = source [3-i];
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: i < 4
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 8);
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: target [i] = source [7-i];
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: i < 8
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 8);
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: target [i] = source [7-i];
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: i < 4
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 2);
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: i < 2
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 2);
Magic Number,Sharpen,SwapConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,PutBytes,The following statement contains a magic number: i < 2
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,Extensions,The following statement contains a magic number: DateTime time = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,BitCount,The following statement contains a magic number: i < 32
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: tzone.Length <= 4
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: string[] strArray = tzone.Substring (4).Split (separator);
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: hours = int.Parse (strArray[0].Substring (0' 2));
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: minutes = int.Parse (strArray[0].Substring (2));
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: strArray.Length == 1 && strArray[0].Length > 2
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: tzone[3] == '-'
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,CreateDate,The following statement contains a magic number: long num = EPOCH_TICKS + (milliSecondsSinceEpoch * 10000);
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,MillisToDateTimeOffset,The following statement contains a magic number: long num = EPOCH_TICKS + (milliSecondsSinceEpoch * 10000);
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,ToOctalString,The following statement contains a magic number: return Convert.ToString (val' 8);
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,ToHexString,The following statement contains a magic number: return Convert.ToString (val' 16);
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,GetTotalInFixed,The following statement contains a magic number: return Convert.ToInt32( inf.TotalIn ) + 4;
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,GetRemainingInputFixed,The following statement contains a magic number: return inf.RemainingInput - 4;
Magic Number,Sharpen,Extensions,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Extensions.cs,GetRemainingInputFixed,The following statement contains a magic number: inf.RemainingInput >= 4
Magic Number,Sharpen,FileChannel,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\FileChannel.cs,TransferFrom,The following statement contains a magic number: buffer = new byte [8092];
Magic Number,Sharpen,MessageFormat,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\MessageFormat.cs,Format,The following statement contains a magic number: List<string> placeholderArgs = new List<string> (3);
Magic Number,Sharpen,MessageFormat,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\MessageFormat.cs,AddFormatted,The following statement contains a magic number: placeholderArgs.Count > 3
Magic Number,Sharpen,Pattern,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Pattern.cs,Compile,The following statement contains a magic number: (flags & 2) != DOTALL
Magic Number,Sharpen,Pattern,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Pattern.cs,Compile,The following statement contains a magic number: (flags & 4) != MULTILINE
Magic Number,Sharpen,RandomAccessFile,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\RandomAccessFile.cs,Write,The following statement contains a magic number: stream.Write (BitConverter.GetBytes (value)' 0' 4);
Magic Number,Sharpen,Runtime,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Runtime.cs,NanoTime,The following statement contains a magic number: return Environment.TickCount * 1000 * 1000;
Magic Number,Sharpen,Runtime,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\Runtime.cs,NanoTime,The following statement contains a magic number: return Environment.TickCount * 1000 * 1000;
Magic Number,Sharpen,ByteBuffer,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\ByteBuffer.cs,GetInt,The following statement contains a magic number: CheckGetLimit (4);
Magic Number,Sharpen,ByteBuffer,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\ByteBuffer.cs,GetInt,The following statement contains a magic number: index += 4;
Magic Number,Sharpen,ByteBuffer,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\ByteBuffer.cs,GetShort,The following statement contains a magic number: CheckGetLimit (2);
Magic Number,Sharpen,ByteBuffer,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\ByteBuffer.cs,GetShort,The following statement contains a magic number: index += 2;
Magic Number,Sharpen,FilePath,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\FilePath.cs,CreateTempFile,The following statement contains a magic number: prefix.Length < 3
Magic Number,Sharpen,MessageDigest<TAlgorithm>,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\MessageDigest.cs,GetDigestLength,The following statement contains a magic number: return (this._hash.HashSize / 8);
Magic Number,Sharpen,JavaCalendar,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) { 			case 0: 				Time.AddHours (value); 				break; 			case 1: 				Time.AddMinutes (value); 				break; 			case 2: 				Time.AddSeconds (value); 				break; 			case 3: 				Time.AddMilliseconds (value); 				break; 			case 5: 				Time.AddYears (value); 				break; 			case 6: 				Time.AddMonths (value); 				break; 			case 7: 				Time.AddDays (7 * value); 				break; 			default: 				throw new NotSupportedException (); 			}
Magic Number,Sharpen,JavaCalendar,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) { 			case 0: 				Time.AddHours (value); 				break; 			case 1: 				Time.AddMinutes (value); 				break; 			case 2: 				Time.AddSeconds (value); 				break; 			case 3: 				Time.AddMilliseconds (value); 				break; 			case 5: 				Time.AddYears (value); 				break; 			case 6: 				Time.AddMonths (value); 				break; 			case 7: 				Time.AddDays (7 * value); 				break; 			default: 				throw new NotSupportedException (); 			}
Magic Number,Sharpen,JavaCalendar,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) { 			case 0: 				Time.AddHours (value); 				break; 			case 1: 				Time.AddMinutes (value); 				break; 			case 2: 				Time.AddSeconds (value); 				break; 			case 3: 				Time.AddMilliseconds (value); 				break; 			case 5: 				Time.AddYears (value); 				break; 			case 6: 				Time.AddMonths (value); 				break; 			case 7: 				Time.AddDays (7 * value); 				break; 			default: 				throw new NotSupportedException (); 			}
Magic Number,Sharpen,JavaCalendar,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) { 			case 0: 				Time.AddHours (value); 				break; 			case 1: 				Time.AddMinutes (value); 				break; 			case 2: 				Time.AddSeconds (value); 				break; 			case 3: 				Time.AddMilliseconds (value); 				break; 			case 5: 				Time.AddYears (value); 				break; 			case 6: 				Time.AddMonths (value); 				break; 			case 7: 				Time.AddDays (7 * value); 				break; 			default: 				throw new NotSupportedException (); 			}
Magic Number,Sharpen,JavaCalendar,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) { 			case 0: 				Time.AddHours (value); 				break; 			case 1: 				Time.AddMinutes (value); 				break; 			case 2: 				Time.AddSeconds (value); 				break; 			case 3: 				Time.AddMilliseconds (value); 				break; 			case 5: 				Time.AddYears (value); 				break; 			case 6: 				Time.AddMonths (value); 				break; 			case 7: 				Time.AddDays (7 * value); 				break; 			default: 				throw new NotSupportedException (); 			}
Magic Number,Sharpen,JavaCalendar,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) { 			case 0: 				Time.AddHours (value); 				break; 			case 1: 				Time.AddMinutes (value); 				break; 			case 2: 				Time.AddSeconds (value); 				break; 			case 3: 				Time.AddMilliseconds (value); 				break; 			case 5: 				Time.AddYears (value); 				break; 			case 6: 				Time.AddMonths (value); 				break; 			case 7: 				Time.AddDays (7 * value); 				break; 			default: 				throw new NotSupportedException (); 			}
Magic Number,Sharpen,JavaCalendar,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\JavaCalendar.cs,Set,The following statement contains a magic number: switch (type) { 			case 0: 				Time.AddHours (value - Time.Hour); 				break; 			case 1: 				Time.AddMinutes (value - Time.Minute); 				break; 			case 2: 				Time.AddSeconds (value - Time.Second); 				break; 			case 3: 				Time.AddMilliseconds (value - Time.Millisecond); 				break; 			case 5: 				Time.AddYears (value - Time.Year); 				break; 			case 6: 				Time.AddMonths (value - Time.Month); 				break; 			default: 				throw new NotSupportedException (); 			}
Magic Number,Sharpen,JavaCalendar,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\JavaCalendar.cs,Set,The following statement contains a magic number: switch (type) { 			case 0: 				Time.AddHours (value - Time.Hour); 				break; 			case 1: 				Time.AddMinutes (value - Time.Minute); 				break; 			case 2: 				Time.AddSeconds (value - Time.Second); 				break; 			case 3: 				Time.AddMilliseconds (value - Time.Millisecond); 				break; 			case 5: 				Time.AddYears (value - Time.Year); 				break; 			case 6: 				Time.AddMonths (value - Time.Month); 				break; 			default: 				throw new NotSupportedException (); 			}
Magic Number,Sharpen,JavaCalendar,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\JavaCalendar.cs,Set,The following statement contains a magic number: switch (type) { 			case 0: 				Time.AddHours (value - Time.Hour); 				break; 			case 1: 				Time.AddMinutes (value - Time.Minute); 				break; 			case 2: 				Time.AddSeconds (value - Time.Second); 				break; 			case 3: 				Time.AddMilliseconds (value - Time.Millisecond); 				break; 			case 5: 				Time.AddYears (value - Time.Year); 				break; 			case 6: 				Time.AddMonths (value - Time.Month); 				break; 			default: 				throw new NotSupportedException (); 			}
Magic Number,Sharpen,JavaCalendar,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\JavaCalendar.cs,Set,The following statement contains a magic number: switch (type) { 			case 0: 				Time.AddHours (value - Time.Hour); 				break; 			case 1: 				Time.AddMinutes (value - Time.Minute); 				break; 			case 2: 				Time.AddSeconds (value - Time.Second); 				break; 			case 3: 				Time.AddMilliseconds (value - Time.Millisecond); 				break; 			case 5: 				Time.AddYears (value - Time.Year); 				break; 			case 6: 				Time.AddMonths (value - Time.Month); 				break; 			default: 				throw new NotSupportedException (); 			}
Missing Default,Sharpen,DataConverter,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\DataConverter.cs,Unpack,The following switch statement is missing a default case: switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}
Missing Default,Sharpen,MessageDigest,C:\research\architectureSmells\repos\mono_ngit\Sharpen\Sharpen\MessageDigest.cs,GetInstance,The following switch statement is missing a default case: switch (algorithm.ToLower ()) { 			case "sha-1": 				return new MessageDigest<SHA1Managed> (); 			case "md5": 				return new MessageDigest<MD5CryptoServiceProvider> (); 			}
