Implementation smell,Namespace,Class,File,Method,Description
Long Method,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The method has 343 lines of code.
Long Method,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteTo,The method has 384 lines of code.
Long Method,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ReadFrom,The method has 406 lines of code.
Complex Method,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteAnnotationSet,Cyclomatic complexity of the method is 9
Complex Method,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteAnnotationsDirectory,Cyclomatic complexity of the method is 13
Complex Method,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteCode,Cyclomatic complexity of the method is 13
Complex Method,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteDebugInfo,Cyclomatic complexity of the method is 10
Complex Method,Dexer.IO,DexReader,C:\repos\sailro_Dexer\Dexer\IO\DexReader.cs,ReadExceptionHandlers,Cyclomatic complexity of the method is 8
Complex Method,Dexer.Metadata,ValueFormat,C:\repos\sailro_Dexer\Dexer\Metadata\ValueFormat.cs,GetFormat,Cyclomatic complexity of the method is 17
Long Statement,Dexer.Core,AnnotationArgument,C:\repos\sailro_Dexer\Dexer\Core\AnnotationArgument.cs,Equals,The length of the statement  "				&& (((ValueFormat.GetFormat(Value) == ValueFormats.Array) && ArrayEquals(Value as Array' other.Value as Array)) || Equals(Value' other.Value)); " is 143.
Long Statement,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteStringId,The length of the statement  "				Map.Add(TypeCodes.StringId' new MapItem(TypeCodes.StringId' (uint)Dex.Strings.Count' (uint)writer.BaseStream.Position)); " is 120.
Long Statement,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteStringData,The length of the statement  "				Map.Add(TypeCodes.StringData' new MapItem(TypeCodes.StringData' (uint)Dex.Strings.Count' (uint)writer.BaseStream.Position)); " is 124.
Long Statement,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WritePrototypeId,The length of the statement  "				Map.Add(TypeCodes.ProtoId' new MapItem(TypeCodes.ProtoId' (uint)Dex.Prototypes.Count' (uint)writer.BaseStream.Position)); " is 121.
Long Statement,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteFieldId,The length of the statement  "				HeaderMarkers.FieldReferencesMarker.Value = new SizeOffset((uint)Dex.FieldReferences.Count' (uint)writer.BaseStream.Position); " is 126.
Long Statement,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteFieldId,The length of the statement  "				Map.Add(TypeCodes.FieldId' new MapItem(TypeCodes.FieldId' (uint)Dex.FieldReferences.Count' (uint)writer.BaseStream.Position)); " is 126.
Long Statement,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteMethodId,The length of the statement  "				HeaderMarkers.MethodReferencesMarker.Value = new SizeOffset((uint)Dex.MethodReferences.Count' (uint)writer.BaseStream.Position); " is 128.
Long Statement,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteMethodId,The length of the statement  "				Map.Add(TypeCodes.MethodId' new MapItem(TypeCodes.MethodId' (uint)Dex.MethodReferences.Count' (uint)writer.BaseStream.Position)); " is 129.
Long Statement,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteTypeId,The length of the statement  "				HeaderMarkers.TypeReferencesMarker.Value = new SizeOffset((uint)Dex.TypeReferences.Count' (uint)writer.BaseStream.Position); " is 124.
Long Statement,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteTypeId,The length of the statement  "				Map.Add(TypeCodes.TypeId' new MapItem(TypeCodes.TypeId' (uint)Dex.TypeReferences.Count' (uint)writer.BaseStream.Position)); " is 123.
Long Statement,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteAnnotationSetRefList,The length of the statement  "				Map.Add(TypeCodes.AnnotationSetRefList' new MapItem(TypeCodes.AnnotationSetRefList' (uint)AnnotationSetRefLists.Count' sectionOffset)); " is 135.
Long Statement,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteValue,The length of the statement  "					valueArgument = writer.GetByteCountForSignedPackedNumber(BitConverter.ToInt32(BitConverter.GetBytes(Convert.ToSingle(value))' 0)) - 1; " is 134.
Long Statement,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,CheckOperand,The length of the statement  "					throw new DebugInstructionException(ins' string.Format("Expecting '{0}' Type (or compatible) for Operands[{1}]"' types[i]' i)); " is 127.
Long Statement,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteClassData,The length of the statement  "				var virtualMethods = (@class.Methods.Where(method => method.IsVirtual).OrderBy(method => MethodLookup[method])).ToList(); " is 121.
Long Statement,Dexer.Metadata,TypeDescriptor,C:\repos\sailro_Dexer\Dexer\Metadata\TypeDescriptor.cs,Encode,The length of the statement  "					result.Append(string.Concat((tref as ClassReference).Fullname.Replace(ClassReference.NamespaceSeparator' ClassReference.InternalNamespaceSeparator)' ";")); " is 155.
Complex Conditional,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,WriteSLEB128,The conditional expression  "(value == 0 && ((partial & 0x40) == 0)) || (value == -1 && ((partial & 0x40) != 0))"  is complex.
Complex Conditional,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,CheckArrayData,The conditional expression  "!(elementtype == typeof(sbyte)  				|| elementtype == typeof(short)  				|| elementtype == typeof(int)  				|| elementtype == typeof(long))"  is complex.
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,WriteULEB128,The following statement contains a magic number: do  			{  				var partial = (byte) (value & 0x7f);  				value >>= 7;  				if (value != 0)  					partial |= 0x80;  				writer.Write(partial);  			} while (value != 0);
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,WriteSLEB128,The following statement contains a magic number: while (next)  			{  				var partial = (byte) (value & 0x7f);  				value >>= 7;  				if (negative)  					value |= -(1 << 24);    				if ((value == 0 && ((partial & 0x40) == 0)) || (value == -1 && ((partial & 0x40) != 0)))  					next = false;  				else  					partial |= 0x80;    				writer.Write(partial);  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,WriteSLEB128,The following statement contains a magic number: while (next)  			{  				var partial = (byte) (value & 0x7f);  				value >>= 7;  				if (negative)  					value |= -(1 << 24);    				if ((value == 0 && ((partial & 0x40) == 0)) || (value == -1 && ((partial & 0x40) != 0)))  					next = false;  				else  					partial |= 0x80;    				writer.Write(partial);  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,WriteMUTF8String,The following statement contains a magic number: foreach (var c in value)  			{  				if ((c != 0) && (c < 0x80))  				{  					writer.Write((byte) c);  				}  				else if (c < 0x800)  				{  					writer.Write((byte) (((c >> 6) & 0x1f) | 0xc0));  					writer.Write((byte) ((c & 0x3f) | 0x80));  				}  				else  				{  					writer.Write((byte) (((c >> 12) & 0x0f) | 0xe0));  					writer.Write((byte) (((c >> 6) & 0x3f) | 0xc0));  					writer.Write((byte) ((c & 0x3f) | 0x80));  				}  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,WriteMUTF8String,The following statement contains a magic number: foreach (var c in value)  			{  				if ((c != 0) && (c < 0x80))  				{  					writer.Write((byte) c);  				}  				else if (c < 0x800)  				{  					writer.Write((byte) (((c >> 6) & 0x1f) | 0xc0));  					writer.Write((byte) ((c & 0x3f) | 0x80));  				}  				else  				{  					writer.Write((byte) (((c >> 12) & 0x0f) | 0xe0));  					writer.Write((byte) (((c >> 6) & 0x3f) | 0xc0));  					writer.Write((byte) ((c & 0x3f) | 0x80));  				}  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,WriteMUTF8String,The following statement contains a magic number: foreach (var c in value)  			{  				if ((c != 0) && (c < 0x80))  				{  					writer.Write((byte) c);  				}  				else if (c < 0x800)  				{  					writer.Write((byte) (((c >> 6) & 0x1f) | 0xc0));  					writer.Write((byte) ((c & 0x3f) | 0x80));  				}  				else  				{  					writer.Write((byte) (((c >> 12) & 0x0f) | 0xe0));  					writer.Write((byte) (((c >> 6) & 0x3f) | 0xc0));  					writer.Write((byte) ((c & 0x3f) | 0x80));  				}  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (i == 0)  				return 64;
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: var x = (int) TripleShift(i' 32);
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (x == 0)  			{  				n += 32;  				x = (int) i;  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (TripleShift(x' 16) == 0)  			{  				n += 16;  				x <<= 16;  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (TripleShift(x' 16) == 0)  			{  				n += 16;  				x <<= 16;  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (TripleShift(x' 16) == 0)  			{  				n += 16;  				x <<= 16;  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (TripleShift(x' 24) == 0)  			{  				n += 8;  				x <<= 8;  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (TripleShift(x' 24) == 0)  			{  				n += 8;  				x <<= 8;  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (TripleShift(x' 24) == 0)  			{  				n += 8;  				x <<= 8;  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (TripleShift(x' 28) == 0)  			{  				n += 4;  				x <<= 4;  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (TripleShift(x' 28) == 0)  			{  				n += 4;  				x <<= 4;  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (TripleShift(x' 28) == 0)  			{  				n += 4;  				x <<= 4;  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (TripleShift(x' 30) == 0)  			{  				n += 2;  				x <<= 2;  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (TripleShift(x' 30) == 0)  			{  				n += 2;  				x <<= 2;  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (TripleShift(x' 30) == 0)  			{  				n += 2;  				x <<= 2;  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,NumberOfLeadingZeros,The following statement contains a magic number: n -= (int) TripleShift(x' 31);
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,TripleShift,The following statement contains a magic number: return (n >> s) + (2 << ~s);
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,GetByteCountForSignedPackedNumber,The following statement contains a magic number: var requiredBits = 65 - NumberOfLeadingZeros(value ^ (value >> 63));
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,GetByteCountForSignedPackedNumber,The following statement contains a magic number: var requiredBits = 65 - NumberOfLeadingZeros(value ^ (value >> 63));
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,GetByteCountForSignedPackedNumber,The following statement contains a magic number: int result = (byte) ((requiredBits + 0x07) >> 3);
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,GetByteCountForUnsignedPackedNumber,The following statement contains a magic number: var requiredBits = 64 - NumberOfLeadingZeros(value);
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,GetByteCountForUnsignedPackedNumber,The following statement contains a magic number: int result = (byte) ((requiredBits + 0x07) >> 3);
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,WritePackedSignedNumber,The following statement contains a magic number: for (var i = 0; i < requiredBytes; i++)  			{  				writer.Write((byte) value);  				value >>= 8;  			}
Magic Number,Dexer.Extensions,BinaryWriterExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryWriterExtensions.cs,WriteUnsignedPackedNumber,The following statement contains a magic number: for (var i = 0; i < requiredBytes; i++)  			{  				writer.Write((byte) value);  				value >>= 8;  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadULEB128,The following statement contains a magic number: do  			{  				partial = reader.ReadByte();  				result |= (partial & 0x7f) << shift;  				shift += 7;  			} while ((partial & 0x80) != 0);
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadSLEB128,The following statement contains a magic number: do  			{  				partial = reader.ReadByte();  				result |= (partial & 0x7F) << shift;  				shift += 7;  			} while ((partial & 0x80) != 0);
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadSLEB128,The following statement contains a magic number: if ((shift < 31) && ((partial & 0x40) == 0x40))  				result |= -(1 << shift);
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadMUTF8String,The following statement contains a magic number: for (int j = 0' jLength = chars.Length; j < jLength; j++)  			{  				int data = reader.ReadByte();  				switch (data >> 4)  				{  					case 0:  					case 1:  					case 2:  					case 3:  					case 4:  					case 5:  					case 6:  					case 7:  						chars[j] = (char) data;  						break;  					case 12:  					case 13:  						chars[j] = (char) (((data & 0x1F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					case 14:  						chars[j] = (char) (((data & 0x0F) << 12) | ((reader.ReadByte() & 0x3F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					default:  						throw new ArgumentException("illegal MUTF8 byte");  				}  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadMUTF8String,The following statement contains a magic number: for (int j = 0' jLength = chars.Length; j < jLength; j++)  			{  				int data = reader.ReadByte();  				switch (data >> 4)  				{  					case 0:  					case 1:  					case 2:  					case 3:  					case 4:  					case 5:  					case 6:  					case 7:  						chars[j] = (char) data;  						break;  					case 12:  					case 13:  						chars[j] = (char) (((data & 0x1F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					case 14:  						chars[j] = (char) (((data & 0x0F) << 12) | ((reader.ReadByte() & 0x3F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					default:  						throw new ArgumentException("illegal MUTF8 byte");  				}  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadMUTF8String,The following statement contains a magic number: for (int j = 0' jLength = chars.Length; j < jLength; j++)  			{  				int data = reader.ReadByte();  				switch (data >> 4)  				{  					case 0:  					case 1:  					case 2:  					case 3:  					case 4:  					case 5:  					case 6:  					case 7:  						chars[j] = (char) data;  						break;  					case 12:  					case 13:  						chars[j] = (char) (((data & 0x1F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					case 14:  						chars[j] = (char) (((data & 0x0F) << 12) | ((reader.ReadByte() & 0x3F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					default:  						throw new ArgumentException("illegal MUTF8 byte");  				}  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadMUTF8String,The following statement contains a magic number: for (int j = 0' jLength = chars.Length; j < jLength; j++)  			{  				int data = reader.ReadByte();  				switch (data >> 4)  				{  					case 0:  					case 1:  					case 2:  					case 3:  					case 4:  					case 5:  					case 6:  					case 7:  						chars[j] = (char) data;  						break;  					case 12:  					case 13:  						chars[j] = (char) (((data & 0x1F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					case 14:  						chars[j] = (char) (((data & 0x0F) << 12) | ((reader.ReadByte() & 0x3F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					default:  						throw new ArgumentException("illegal MUTF8 byte");  				}  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadMUTF8String,The following statement contains a magic number: for (int j = 0' jLength = chars.Length; j < jLength; j++)  			{  				int data = reader.ReadByte();  				switch (data >> 4)  				{  					case 0:  					case 1:  					case 2:  					case 3:  					case 4:  					case 5:  					case 6:  					case 7:  						chars[j] = (char) data;  						break;  					case 12:  					case 13:  						chars[j] = (char) (((data & 0x1F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					case 14:  						chars[j] = (char) (((data & 0x0F) << 12) | ((reader.ReadByte() & 0x3F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					default:  						throw new ArgumentException("illegal MUTF8 byte");  				}  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadMUTF8String,The following statement contains a magic number: for (int j = 0' jLength = chars.Length; j < jLength; j++)  			{  				int data = reader.ReadByte();  				switch (data >> 4)  				{  					case 0:  					case 1:  					case 2:  					case 3:  					case 4:  					case 5:  					case 6:  					case 7:  						chars[j] = (char) data;  						break;  					case 12:  					case 13:  						chars[j] = (char) (((data & 0x1F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					case 14:  						chars[j] = (char) (((data & 0x0F) << 12) | ((reader.ReadByte() & 0x3F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					default:  						throw new ArgumentException("illegal MUTF8 byte");  				}  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadMUTF8String,The following statement contains a magic number: for (int j = 0' jLength = chars.Length; j < jLength; j++)  			{  				int data = reader.ReadByte();  				switch (data >> 4)  				{  					case 0:  					case 1:  					case 2:  					case 3:  					case 4:  					case 5:  					case 6:  					case 7:  						chars[j] = (char) data;  						break;  					case 12:  					case 13:  						chars[j] = (char) (((data & 0x1F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					case 14:  						chars[j] = (char) (((data & 0x0F) << 12) | ((reader.ReadByte() & 0x3F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					default:  						throw new ArgumentException("illegal MUTF8 byte");  				}  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadMUTF8String,The following statement contains a magic number: for (int j = 0' jLength = chars.Length; j < jLength; j++)  			{  				int data = reader.ReadByte();  				switch (data >> 4)  				{  					case 0:  					case 1:  					case 2:  					case 3:  					case 4:  					case 5:  					case 6:  					case 7:  						chars[j] = (char) data;  						break;  					case 12:  					case 13:  						chars[j] = (char) (((data & 0x1F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					case 14:  						chars[j] = (char) (((data & 0x0F) << 12) | ((reader.ReadByte() & 0x3F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					default:  						throw new ArgumentException("illegal MUTF8 byte");  				}  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadMUTF8String,The following statement contains a magic number: for (int j = 0' jLength = chars.Length; j < jLength; j++)  			{  				int data = reader.ReadByte();  				switch (data >> 4)  				{  					case 0:  					case 1:  					case 2:  					case 3:  					case 4:  					case 5:  					case 6:  					case 7:  						chars[j] = (char) data;  						break;  					case 12:  					case 13:  						chars[j] = (char) (((data & 0x1F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					case 14:  						chars[j] = (char) (((data & 0x0F) << 12) | ((reader.ReadByte() & 0x3F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					default:  						throw new ArgumentException("illegal MUTF8 byte");  				}  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadMUTF8String,The following statement contains a magic number: for (int j = 0' jLength = chars.Length; j < jLength; j++)  			{  				int data = reader.ReadByte();  				switch (data >> 4)  				{  					case 0:  					case 1:  					case 2:  					case 3:  					case 4:  					case 5:  					case 6:  					case 7:  						chars[j] = (char) data;  						break;  					case 12:  					case 13:  						chars[j] = (char) (((data & 0x1F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					case 14:  						chars[j] = (char) (((data & 0x0F) << 12) | ((reader.ReadByte() & 0x3F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					default:  						throw new ArgumentException("illegal MUTF8 byte");  				}  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadMUTF8String,The following statement contains a magic number: for (int j = 0' jLength = chars.Length; j < jLength; j++)  			{  				int data = reader.ReadByte();  				switch (data >> 4)  				{  					case 0:  					case 1:  					case 2:  					case 3:  					case 4:  					case 5:  					case 6:  					case 7:  						chars[j] = (char) data;  						break;  					case 12:  					case 13:  						chars[j] = (char) (((data & 0x1F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					case 14:  						chars[j] = (char) (((data & 0x0F) << 12) | ((reader.ReadByte() & 0x3F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					default:  						throw new ArgumentException("illegal MUTF8 byte");  				}  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadMUTF8String,The following statement contains a magic number: for (int j = 0' jLength = chars.Length; j < jLength; j++)  			{  				int data = reader.ReadByte();  				switch (data >> 4)  				{  					case 0:  					case 1:  					case 2:  					case 3:  					case 4:  					case 5:  					case 6:  					case 7:  						chars[j] = (char) data;  						break;  					case 12:  					case 13:  						chars[j] = (char) (((data & 0x1F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					case 14:  						chars[j] = (char) (((data & 0x0F) << 12) | ((reader.ReadByte() & 0x3F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					default:  						throw new ArgumentException("illegal MUTF8 byte");  				}  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadMUTF8String,The following statement contains a magic number: for (int j = 0' jLength = chars.Length; j < jLength; j++)  			{  				int data = reader.ReadByte();  				switch (data >> 4)  				{  					case 0:  					case 1:  					case 2:  					case 3:  					case 4:  					case 5:  					case 6:  					case 7:  						chars[j] = (char) data;  						break;  					case 12:  					case 13:  						chars[j] = (char) (((data & 0x1F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					case 14:  						chars[j] = (char) (((data & 0x0F) << 12) | ((reader.ReadByte() & 0x3F) << 6) | (reader.ReadByte() & 0x3F));  						break;  					default:  						throw new ArgumentException("illegal MUTF8 byte");  				}  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadUnsignedPackedNumber,The following statement contains a magic number: for (var i = 0; i < byteLength; i++)  			{  				value |= (long) (reader.ReadByte() & 0xFF) << i*8;  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadSignedPackedNumber,The following statement contains a magic number: for (var i = 0; i < byteLength; i++)  			{  				value |= (long) (reader.ReadByte() & 0xFF) << (i*8);  			}
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadSignedPackedNumber,The following statement contains a magic number: var shift = (8 - byteLength)*8;
Magic Number,Dexer.Extensions,BinaryReaderExtensions,C:\repos\sailro_Dexer\Dexer\Extensions\BinaryReaderExtensions.cs,ReadSignedPackedNumber,The following statement contains a magic number: var shift = (8 - byteLength)*8;
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.Instructions,MethodBody,C:\repos\sailro_Dexer\Dexer\Instructions\MethodBody.cs,UpdateInstructionOffsets,The following statement contains a magic number: foreach (var ins in Instructions)  			{  				ins.Offset = ip;  				switch (ins.OpCode)  				{  					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ip += 1;  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ip += 1;  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ip += 2;  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ip += 3;  						break;  					case OpCodes.Const4:  						// vA' #+B  						ip++;  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ip += 2;  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ip += 3;  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ip += 3;    						Array elements;  						Type elementtype;  						int elementsize;  						CheckArrayData(ins' out elements' out elementtype' out elementsize);    						// Keep 4-byte alignment for this block  						if (extra%2 != 0)  							extra++;    						extra += (elements.Length * elementsize + 1) / 2 + 4;  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ip += 2;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ip += 5;  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ip += 2;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ip += 2;  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ip += 3;  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ip += 2;  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ip += 2;  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						ip += 3;  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						ip += 3;  						break;  					case OpCodes.Goto:  						// +AA  						ip += 1;  						break;  					case OpCodes.Goto16:  						// +AAAA  						ip += 2;  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						ip += 3;  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is PackedSwitchData))  							throw new InstructionException(ins' "Expecting PackedSwitchData");  						var pdata = (PackedSwitchData) ins.Operand;    						ip += 3;  						extra += (pdata.Targets.Count * 2) + 4;  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						if (!(ins.Operand is SparseSwitchData))  							throw new InstructionException(ins' "Expecting SparseSwitchData");  						var sdata = (SparseSwitchData) ins.Operand;    						ip += 3;  						extra += (sdata.Targets.Count * 4) + 2;  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ip += 2;  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ip += 2;  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ip += 2;  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ip += 2;  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ip += 2;  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						ip += 3;  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						ip += 3;  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ip += 2;  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ip += 2;  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteTo,The following statement contains a magic number: foreach (var ins in MethodDefinition.Body.Instructions)  			{  				if (_ip != ins.Offset)  					throw new InstructionException(ins' "Instruction pointer do not match");    				Codes[_ip] = (ushort)ins.OpCode;  				int registerMask;  				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						WritevAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						WritevA(ins);  						WritevB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						WritevAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						WritevAAAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						WritevA(ins);  						WriteNibble(ins);  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						WritevAA(ins);  						WriteShort(ins);  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						WritevAA(ins);  						WriteInt(ins);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						WritevAA(ins);    						// Keep 4-byte alignment for this block  						if (_extraOffset%2 != 0)  							_extraOffset++;    						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteArrayData(ins);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						WritevAA(ins);  						WriteShort(ins' 16);  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						WritevAA(ins);  						WriteLong(ins);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						WritevAA(ins);  						WriteShort(ins' 48);  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						WritevAA(ins);  						WriteShortStringIndex(ins);  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						WritevAA(ins);  						WriteIntStringIndex(ins);  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						WritevAA(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.FilledNewArrayRange:  						WriteSByte(ins.Registers.Count);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.Goto:  						// +AA  						WriteSbyteInstructionOffset(ins);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						WriteIntInstructionOffset(ins);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WritePackedSwitch(ins);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteSparseSwitch(ins);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						WritevAA(ins);  						WritevBB(ins);  						WritevCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						WritevAA(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						WritevAA(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						WriteSByte(ins.Registers.Count);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShort(ins);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						WritevAA(ins);  						WritevBB(ins);  						WriteSByte(ins);  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(ins' _ip - 1);  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteTo,The following statement contains a magic number: foreach (var ins in MethodDefinition.Body.Instructions)  			{  				if (_ip != ins.Offset)  					throw new InstructionException(ins' "Instruction pointer do not match");    				Codes[_ip] = (ushort)ins.OpCode;  				int registerMask;  				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						WritevAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						WritevA(ins);  						WritevB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						WritevAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						WritevAAAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						WritevA(ins);  						WriteNibble(ins);  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						WritevAA(ins);  						WriteShort(ins);  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						WritevAA(ins);  						WriteInt(ins);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						WritevAA(ins);    						// Keep 4-byte alignment for this block  						if (_extraOffset%2 != 0)  							_extraOffset++;    						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteArrayData(ins);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						WritevAA(ins);  						WriteShort(ins' 16);  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						WritevAA(ins);  						WriteLong(ins);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						WritevAA(ins);  						WriteShort(ins' 48);  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						WritevAA(ins);  						WriteShortStringIndex(ins);  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						WritevAA(ins);  						WriteIntStringIndex(ins);  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						WritevAA(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.FilledNewArrayRange:  						WriteSByte(ins.Registers.Count);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.Goto:  						// +AA  						WriteSbyteInstructionOffset(ins);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						WriteIntInstructionOffset(ins);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WritePackedSwitch(ins);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteSparseSwitch(ins);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						WritevAA(ins);  						WritevBB(ins);  						WritevCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						WritevAA(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						WritevAA(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						WriteSByte(ins.Registers.Count);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShort(ins);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						WritevAA(ins);  						WritevBB(ins);  						WriteSByte(ins);  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(ins' _ip - 1);  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteTo,The following statement contains a magic number: foreach (var ins in MethodDefinition.Body.Instructions)  			{  				if (_ip != ins.Offset)  					throw new InstructionException(ins' "Instruction pointer do not match");    				Codes[_ip] = (ushort)ins.OpCode;  				int registerMask;  				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						WritevAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						WritevA(ins);  						WritevB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						WritevAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						WritevAAAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						WritevA(ins);  						WriteNibble(ins);  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						WritevAA(ins);  						WriteShort(ins);  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						WritevAA(ins);  						WriteInt(ins);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						WritevAA(ins);    						// Keep 4-byte alignment for this block  						if (_extraOffset%2 != 0)  							_extraOffset++;    						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteArrayData(ins);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						WritevAA(ins);  						WriteShort(ins' 16);  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						WritevAA(ins);  						WriteLong(ins);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						WritevAA(ins);  						WriteShort(ins' 48);  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						WritevAA(ins);  						WriteShortStringIndex(ins);  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						WritevAA(ins);  						WriteIntStringIndex(ins);  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						WritevAA(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.FilledNewArrayRange:  						WriteSByte(ins.Registers.Count);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.Goto:  						// +AA  						WriteSbyteInstructionOffset(ins);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						WriteIntInstructionOffset(ins);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WritePackedSwitch(ins);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteSparseSwitch(ins);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						WritevAA(ins);  						WritevBB(ins);  						WritevCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						WritevAA(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						WritevAA(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						WriteSByte(ins.Registers.Count);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShort(ins);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						WritevAA(ins);  						WritevBB(ins);  						WriteSByte(ins);  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(ins' _ip - 1);  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteTo,The following statement contains a magic number: foreach (var ins in MethodDefinition.Body.Instructions)  			{  				if (_ip != ins.Offset)  					throw new InstructionException(ins' "Instruction pointer do not match");    				Codes[_ip] = (ushort)ins.OpCode;  				int registerMask;  				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						WritevAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						WritevA(ins);  						WritevB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						WritevAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						WritevAAAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						WritevA(ins);  						WriteNibble(ins);  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						WritevAA(ins);  						WriteShort(ins);  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						WritevAA(ins);  						WriteInt(ins);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						WritevAA(ins);    						// Keep 4-byte alignment for this block  						if (_extraOffset%2 != 0)  							_extraOffset++;    						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteArrayData(ins);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						WritevAA(ins);  						WriteShort(ins' 16);  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						WritevAA(ins);  						WriteLong(ins);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						WritevAA(ins);  						WriteShort(ins' 48);  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						WritevAA(ins);  						WriteShortStringIndex(ins);  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						WritevAA(ins);  						WriteIntStringIndex(ins);  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						WritevAA(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.FilledNewArrayRange:  						WriteSByte(ins.Registers.Count);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.Goto:  						// +AA  						WriteSbyteInstructionOffset(ins);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						WriteIntInstructionOffset(ins);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WritePackedSwitch(ins);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteSparseSwitch(ins);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						WritevAA(ins);  						WritevBB(ins);  						WritevCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						WritevAA(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						WritevAA(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						WriteSByte(ins.Registers.Count);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShort(ins);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						WritevAA(ins);  						WritevBB(ins);  						WriteSByte(ins);  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(ins' _ip - 1);  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteTo,The following statement contains a magic number: foreach (var ins in MethodDefinition.Body.Instructions)  			{  				if (_ip != ins.Offset)  					throw new InstructionException(ins' "Instruction pointer do not match");    				Codes[_ip] = (ushort)ins.OpCode;  				int registerMask;  				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						WritevAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						WritevA(ins);  						WritevB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						WritevAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						WritevAAAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						WritevA(ins);  						WriteNibble(ins);  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						WritevAA(ins);  						WriteShort(ins);  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						WritevAA(ins);  						WriteInt(ins);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						WritevAA(ins);    						// Keep 4-byte alignment for this block  						if (_extraOffset%2 != 0)  							_extraOffset++;    						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteArrayData(ins);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						WritevAA(ins);  						WriteShort(ins' 16);  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						WritevAA(ins);  						WriteLong(ins);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						WritevAA(ins);  						WriteShort(ins' 48);  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						WritevAA(ins);  						WriteShortStringIndex(ins);  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						WritevAA(ins);  						WriteIntStringIndex(ins);  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						WritevAA(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.FilledNewArrayRange:  						WriteSByte(ins.Registers.Count);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.Goto:  						// +AA  						WriteSbyteInstructionOffset(ins);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						WriteIntInstructionOffset(ins);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WritePackedSwitch(ins);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteSparseSwitch(ins);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						WritevAA(ins);  						WritevBB(ins);  						WritevCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						WritevAA(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						WritevAA(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						WriteSByte(ins.Registers.Count);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShort(ins);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						WritevAA(ins);  						WritevBB(ins);  						WriteSByte(ins);  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(ins' _ip - 1);  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteTo,The following statement contains a magic number: foreach (var ins in MethodDefinition.Body.Instructions)  			{  				if (_ip != ins.Offset)  					throw new InstructionException(ins' "Instruction pointer do not match");    				Codes[_ip] = (ushort)ins.OpCode;  				int registerMask;  				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						WritevAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						WritevA(ins);  						WritevB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						WritevAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						WritevAAAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						WritevA(ins);  						WriteNibble(ins);  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						WritevAA(ins);  						WriteShort(ins);  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						WritevAA(ins);  						WriteInt(ins);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						WritevAA(ins);    						// Keep 4-byte alignment for this block  						if (_extraOffset%2 != 0)  							_extraOffset++;    						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteArrayData(ins);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						WritevAA(ins);  						WriteShort(ins' 16);  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						WritevAA(ins);  						WriteLong(ins);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						WritevAA(ins);  						WriteShort(ins' 48);  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						WritevAA(ins);  						WriteShortStringIndex(ins);  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						WritevAA(ins);  						WriteIntStringIndex(ins);  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						WritevAA(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.FilledNewArrayRange:  						WriteSByte(ins.Registers.Count);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.Goto:  						// +AA  						WriteSbyteInstructionOffset(ins);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						WriteIntInstructionOffset(ins);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WritePackedSwitch(ins);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteSparseSwitch(ins);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						WritevAA(ins);  						WritevBB(ins);  						WritevCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						WritevAA(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						WritevAA(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						WriteSByte(ins.Registers.Count);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShort(ins);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						WritevAA(ins);  						WritevBB(ins);  						WriteSByte(ins);  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(ins' _ip - 1);  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteTo,The following statement contains a magic number: foreach (var ins in MethodDefinition.Body.Instructions)  			{  				if (_ip != ins.Offset)  					throw new InstructionException(ins' "Instruction pointer do not match");    				Codes[_ip] = (ushort)ins.OpCode;  				int registerMask;  				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						WritevAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						WritevA(ins);  						WritevB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						WritevAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						WritevAAAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						WritevA(ins);  						WriteNibble(ins);  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						WritevAA(ins);  						WriteShort(ins);  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						WritevAA(ins);  						WriteInt(ins);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						WritevAA(ins);    						// Keep 4-byte alignment for this block  						if (_extraOffset%2 != 0)  							_extraOffset++;    						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteArrayData(ins);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						WritevAA(ins);  						WriteShort(ins' 16);  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						WritevAA(ins);  						WriteLong(ins);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						WritevAA(ins);  						WriteShort(ins' 48);  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						WritevAA(ins);  						WriteShortStringIndex(ins);  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						WritevAA(ins);  						WriteIntStringIndex(ins);  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						WritevAA(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.FilledNewArrayRange:  						WriteSByte(ins.Registers.Count);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.Goto:  						// +AA  						WriteSbyteInstructionOffset(ins);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						WriteIntInstructionOffset(ins);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WritePackedSwitch(ins);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteSparseSwitch(ins);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						WritevAA(ins);  						WritevBB(ins);  						WritevCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						WritevAA(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						WritevAA(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						WriteSByte(ins.Registers.Count);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShort(ins);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						WritevAA(ins);  						WritevBB(ins);  						WriteSByte(ins);  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(ins' _ip - 1);  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteTo,The following statement contains a magic number: foreach (var ins in MethodDefinition.Body.Instructions)  			{  				if (_ip != ins.Offset)  					throw new InstructionException(ins' "Instruction pointer do not match");    				Codes[_ip] = (ushort)ins.OpCode;  				int registerMask;  				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						WritevAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						WritevA(ins);  						WritevB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						WritevAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						WritevAAAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						WritevA(ins);  						WriteNibble(ins);  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						WritevAA(ins);  						WriteShort(ins);  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						WritevAA(ins);  						WriteInt(ins);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						WritevAA(ins);    						// Keep 4-byte alignment for this block  						if (_extraOffset%2 != 0)  							_extraOffset++;    						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteArrayData(ins);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						WritevAA(ins);  						WriteShort(ins' 16);  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						WritevAA(ins);  						WriteLong(ins);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						WritevAA(ins);  						WriteShort(ins' 48);  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						WritevAA(ins);  						WriteShortStringIndex(ins);  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						WritevAA(ins);  						WriteIntStringIndex(ins);  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						WritevAA(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.FilledNewArrayRange:  						WriteSByte(ins.Registers.Count);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.Goto:  						// +AA  						WriteSbyteInstructionOffset(ins);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						WriteIntInstructionOffset(ins);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WritePackedSwitch(ins);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteSparseSwitch(ins);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						WritevAA(ins);  						WritevBB(ins);  						WritevCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						WritevAA(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						WritevAA(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						WriteSByte(ins.Registers.Count);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShort(ins);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						WritevAA(ins);  						WritevBB(ins);  						WriteSByte(ins);  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(ins' _ip - 1);  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteTo,The following statement contains a magic number: foreach (var ins in MethodDefinition.Body.Instructions)  			{  				if (_ip != ins.Offset)  					throw new InstructionException(ins' "Instruction pointer do not match");    				Codes[_ip] = (ushort)ins.OpCode;  				int registerMask;  				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						WritevAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						WritevA(ins);  						WritevB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						WritevAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						WritevAAAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						WritevA(ins);  						WriteNibble(ins);  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						WritevAA(ins);  						WriteShort(ins);  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						WritevAA(ins);  						WriteInt(ins);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						WritevAA(ins);    						// Keep 4-byte alignment for this block  						if (_extraOffset%2 != 0)  							_extraOffset++;    						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteArrayData(ins);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						WritevAA(ins);  						WriteShort(ins' 16);  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						WritevAA(ins);  						WriteLong(ins);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						WritevAA(ins);  						WriteShort(ins' 48);  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						WritevAA(ins);  						WriteShortStringIndex(ins);  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						WritevAA(ins);  						WriteIntStringIndex(ins);  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						WritevAA(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.FilledNewArrayRange:  						WriteSByte(ins.Registers.Count);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.Goto:  						// +AA  						WriteSbyteInstructionOffset(ins);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						WriteIntInstructionOffset(ins);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WritePackedSwitch(ins);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteSparseSwitch(ins);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						WritevAA(ins);  						WritevBB(ins);  						WritevCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						WritevAA(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						WritevAA(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						WriteSByte(ins.Registers.Count);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShort(ins);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						WritevAA(ins);  						WritevBB(ins);  						WriteSByte(ins);  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(ins' _ip - 1);  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteTo,The following statement contains a magic number: foreach (var ins in MethodDefinition.Body.Instructions)  			{  				if (_ip != ins.Offset)  					throw new InstructionException(ins' "Instruction pointer do not match");    				Codes[_ip] = (ushort)ins.OpCode;  				int registerMask;  				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						WritevAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						WritevA(ins);  						WritevB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						WritevAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						WritevAAAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						WritevA(ins);  						WriteNibble(ins);  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						WritevAA(ins);  						WriteShort(ins);  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						WritevAA(ins);  						WriteInt(ins);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						WritevAA(ins);    						// Keep 4-byte alignment for this block  						if (_extraOffset%2 != 0)  							_extraOffset++;    						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteArrayData(ins);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						WritevAA(ins);  						WriteShort(ins' 16);  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						WritevAA(ins);  						WriteLong(ins);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						WritevAA(ins);  						WriteShort(ins' 48);  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						WritevAA(ins);  						WriteShortStringIndex(ins);  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						WritevAA(ins);  						WriteIntStringIndex(ins);  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						WritevAA(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.FilledNewArrayRange:  						WriteSByte(ins.Registers.Count);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.Goto:  						// +AA  						WriteSbyteInstructionOffset(ins);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						WriteIntInstructionOffset(ins);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WritePackedSwitch(ins);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteSparseSwitch(ins);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						WritevAA(ins);  						WritevBB(ins);  						WritevCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						WritevAA(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						WritevAA(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						WriteSByte(ins.Registers.Count);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShort(ins);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						WritevAA(ins);  						WritevBB(ins);  						WriteSByte(ins);  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(ins' _ip - 1);  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteTo,The following statement contains a magic number: foreach (var ins in MethodDefinition.Body.Instructions)  			{  				if (_ip != ins.Offset)  					throw new InstructionException(ins' "Instruction pointer do not match");    				Codes[_ip] = (ushort)ins.OpCode;  				int registerMask;  				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						WritevAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						WritevA(ins);  						WritevB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						WritevAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						WritevAAAA(ins);  						WritevBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						WritevA(ins);  						WriteNibble(ins);  						break;  					case OpCodes.Const16:  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						WritevAA(ins);  						WriteShort(ins);  						break;  					case OpCodes.Const:  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						WritevAA(ins);  						WriteInt(ins);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						WritevAA(ins);    						// Keep 4-byte alignment for this block  						if (_extraOffset%2 != 0)  							_extraOffset++;    						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteArrayData(ins);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						WritevAA(ins);  						WriteShort(ins' 16);  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						WritevAA(ins);  						WriteLong(ins);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						WritevAA(ins);  						WriteShort(ins' 48);  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						WritevAA(ins);  						WriteShortStringIndex(ins);  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						WritevAA(ins);  						WriteIntStringIndex(ins);  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						WritevAA(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortTypeIndex(ins);  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.FilledNewArrayRange:  						WriteSByte(ins.Registers.Count);  						WriteShortTypeIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.Goto:  						// +AA  						WriteSbyteInstructionOffset(ins);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						WriteIntInstructionOffset(ins);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WritePackedSwitch(ins);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						WritevAA(ins);  						WriteInt(_extraOffset - ins.Offset' ref _ip);  						WriteSparseSwitch(ins);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						WritevAA(ins);  						WritevBB(ins);  						WritevCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						WritevAA(ins);  						WriteShortInstructionOffset(ins);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						WritevAA(ins);  						WriteShortFieldIndex(ins);  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = GetRegisterMask(ins);  						Codes[_ip++] |= (ushort)(registerMask >> 16 << 8);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)(registerMask << 12 >> 12);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						WriteSByte(ins.Registers.Count);  						WriteShortMethodIndex(ins);  						Codes[_ip++] |= (ushort)CheckRegister(ins' 0' 0xFFFF);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						WritevA(ins);  						WritevB(ins);  						WriteShort(ins);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						WritevAA(ins);  						WritevBB(ins);  						WriteSByte(ins);  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(ins' _ip - 1);  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,GetRegisterMask,The following statement contains a magic number: var registerMask = registerCount << 20;
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,GetRegisterMask,The following statement contains a magic number: for (var i = 0; i < registerCount; i++)  				registerMask |= CheckRegister(ins' i' 0xF) << (i * 4);
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteNibble,The following statement contains a magic number: Codes[_ip++] |= (ushort)((int)ins.Operand << 12);
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteSByte,The following statement contains a magic number: Codes[_ip++] |= (ushort)(Convert.ToSByte(value) << 8);
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteInt,The following statement contains a magic number: Codes[codeUnitOffset++] = (ushort)(result >> 16);
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteUInt,The following statement contains a magic number: Codes[codeUnitOffset++] = (ushort)(result >> 16);
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteLong,The following statement contains a magic number: Codes[codeUnitOffset++] = (ushort)((result >> 16) & 0xffff);
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteLong,The following statement contains a magic number: Codes[codeUnitOffset++] = (ushort)((result >> 32) & 0xffff);
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteLong,The following statement contains a magic number: Codes[codeUnitOffset++] = (ushort)(result >> 48);
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteArrayData,The following statement contains a magic number: foreach (var element in elements)  			{  				switch (elementsize)  				{  					case 1:  						if (next)  							Codes[_extraOffset++] |= (ushort)((byte)(Convert.ToSByte(element)) << 8);  						else  							Codes[_extraOffset] |= (byte)Convert.ToSByte(element);  						next = !next;  						break;  					case 2:  						WriteShort(element' ref _extraOffset);  						break;  					case 4:  						WriteInt(element' ref _extraOffset);  						break;  					case 8:  						WriteLong(element' ref _extraOffset);  						break;  					default:  						throw new InstructionException(ins' "Unexpected Fill-array-data element size");  				}  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteArrayData,The following statement contains a magic number: foreach (var element in elements)  			{  				switch (elementsize)  				{  					case 1:  						if (next)  							Codes[_extraOffset++] |= (ushort)((byte)(Convert.ToSByte(element)) << 8);  						else  							Codes[_extraOffset] |= (byte)Convert.ToSByte(element);  						next = !next;  						break;  					case 2:  						WriteShort(element' ref _extraOffset);  						break;  					case 4:  						WriteInt(element' ref _extraOffset);  						break;  					case 8:  						WriteLong(element' ref _extraOffset);  						break;  					default:  						throw new InstructionException(ins' "Unexpected Fill-array-data element size");  				}  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteArrayData,The following statement contains a magic number: foreach (var element in elements)  			{  				switch (elementsize)  				{  					case 1:  						if (next)  							Codes[_extraOffset++] |= (ushort)((byte)(Convert.ToSByte(element)) << 8);  						else  							Codes[_extraOffset] |= (byte)Convert.ToSByte(element);  						next = !next;  						break;  					case 2:  						WriteShort(element' ref _extraOffset);  						break;  					case 4:  						WriteInt(element' ref _extraOffset);  						break;  					case 8:  						WriteLong(element' ref _extraOffset);  						break;  					default:  						throw new InstructionException(ins' "Unexpected Fill-array-data element size");  				}  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteArrayData,The following statement contains a magic number: foreach (var element in elements)  			{  				switch (elementsize)  				{  					case 1:  						if (next)  							Codes[_extraOffset++] |= (ushort)((byte)(Convert.ToSByte(element)) << 8);  						else  							Codes[_extraOffset] |= (byte)Convert.ToSByte(element);  						next = !next;  						break;  					case 2:  						WriteShort(element' ref _extraOffset);  						break;  					case 4:  						WriteInt(element' ref _extraOffset);  						break;  					case 8:  						WriteLong(element' ref _extraOffset);  						break;  					default:  						throw new InstructionException(ins' "Unexpected Fill-array-data element size");  				}  			}
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WriteArrayData,The following statement contains a magic number: if ((elements.Length % 2 != 0) && (elementsize == 1))  				_extraOffset++;
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WritevA,The following statement contains a magic number: Codes[_ip] |= (ushort)(CheckRegister(ins' 0' 0xF) << 8);
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WritevAA,The following statement contains a magic number: Codes[_ip++] |= (ushort)(CheckRegister(ins' 0' 0xFF) << 8);
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WritevB,The following statement contains a magic number: Codes[_ip++] |= (ushort)(CheckRegister(ins' 1' 0xF) << 12);
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WritevCC,The following statement contains a magic number: Codes[_ip++] |= (ushort)(CheckRegister(ins' 2' 0xFF) << 8);
Magic Number,Dexer.IO,InstructionWriter,C:\repos\sailro_Dexer\Dexer\IO\InstructionWriter.cs,WritevCC,The following statement contains a magic number: Codes[_ip++] |= (ushort)(CheckRegister(ins' 2' 0xFF) << 8);
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteHeader,The following statement contains a magic number: writer.EnsureSectionAlignment(ref sectionOffset' 4);
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteTypeList,The following statement contains a magic number: if (!TypeLists.ContainsKey(key))  			{  				writer.EnsureSectionAlignment(ref sectionOffset' 4);  				writer.EnsureAlignmentWithSection(sectionOffset' 4);    				TypeLists.Add(key' (uint)writer.BaseStream.Position);  				writer.Write((uint)typelist.Length);    				foreach (var item in typelist)  					writer.Write(item);  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteTypeList,The following statement contains a magic number: if (!TypeLists.ContainsKey(key))  			{  				writer.EnsureSectionAlignment(ref sectionOffset' 4);  				writer.EnsureAlignmentWithSection(sectionOffset' 4);    				TypeLists.Add(key' (uint)writer.BaseStream.Position);  				writer.Write((uint)typelist.Length);    				foreach (var item in typelist)  					writer.Write(item);  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteClassDef,The following statement contains a magic number: if (FlatClasses.Count > 0)  			{  				writer.EnsureSectionAlignment(ref sectionOffset' 4);  				HeaderMarkers.ClassDefinitionsMarker.Value = new SizeOffset((uint)FlatClasses.Count' sectionOffset);  				Map.Add(TypeCodes.ClassDef' new MapItem(TypeCodes.ClassDef' (uint)FlatClasses.Count' sectionOffset));  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteClassDef,The following statement contains a magic number: foreach (var flatclass in FlatClasses)  			{  				writer.EnsureAlignmentWithSection(sectionOffset' 4);    				var @class = flatclass;  				var markers = new ClassDefinitionMarkers();  				ClassDefinitionsMarkers.Add(markers);    				writer.Write(TypeLookup[@class]);  				writer.Write((uint) @class.AccessFlags);  				writer.Write(@class.SuperClass == null ? DexConsts.NoIndex : (uint) TypeLookup[@class.SuperClass]);  				markers.InterfacesMarker = writer.MarkUInt();  				writer.Write(string.IsNullOrEmpty(@class.SourceFile) ? DexConsts.NoIndex : (uint) StringLookup[@class.SourceFile]);  				markers.AnnotationsMarker = writer.MarkUInt();  				markers.ClassDataMarker = writer.MarkUInt();  				markers.StaticValuesMarker = writer.MarkUInt();  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteAnnotationSetRefList,The following statement contains a magic number: foreach (var flatclass in FlatClasses)  			{  				var @class = flatclass;  				var annotatedMethods = @class.Methods.Where(mdef => mdef.Prototype.ContainsAnnotation()).ToList();    				if (annotatedMethods.Count > 0)  				{  					writer.EnsureSectionAlignment(ref sectionOffset' 4);  					writer.EnsureAlignmentWithSection(sectionOffset' 4);  				}    				foreach (var mdef in annotatedMethods)  				{  					AnnotationSetRefLists.Add(mdef' (uint) writer.BaseStream.Position);  					writer.Write(mdef.Prototype.Parameters.Count);  					foreach (var parameter in mdef.Prototype.Parameters)  						AnnotationSetRefListMarkers.Add(parameter' writer.MarkUInt());  				}  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteAnnotationSetRefList,The following statement contains a magic number: foreach (var flatclass in FlatClasses)  			{  				var @class = flatclass;  				var annotatedMethods = @class.Methods.Where(mdef => mdef.Prototype.ContainsAnnotation()).ToList();    				if (annotatedMethods.Count > 0)  				{  					writer.EnsureSectionAlignment(ref sectionOffset' 4);  					writer.EnsureAlignmentWithSection(sectionOffset' 4);  				}    				foreach (var mdef in annotatedMethods)  				{  					AnnotationSetRefLists.Add(mdef' (uint) writer.BaseStream.Position);  					writer.Write(mdef.Prototype.Parameters.Count);  					foreach (var parameter in mdef.Prototype.Parameters)  						AnnotationSetRefListMarkers.Add(parameter' writer.MarkUInt());  				}  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteAnnotationSet,The following statement contains a magic number: if (!AnnotationSets.ContainsKey(key))  			{  				writer.EnsureAlignmentWithSection(sectionOffset' 4);    				offset = (uint) writer.BaseStream.Position;    				if (provider.Annotations.Count > 0 || writezero)  					writer.Write(provider.Annotations.Count);    				foreach (var annotation in provider.Annotations)  					if (AnnotationSetMarkers.ContainsKey(annotation))  						AnnotationSetMarkers[annotation].CloneMarker();  					else  						AnnotationSetMarkers.Add(annotation' writer.MarkUInt());    				if (provider.Annotations.Count > 0 || writezero)  					AnnotationSets.Add(key' offset);  				else  					offset = DexConsts.NoIndex;  			}  			else  				offset = AnnotationSets[key];
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteValue,The following statement contains a magic number: var data = (byte)(valueArgument << 5);
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteAnnotationsDirectory,The following statement contains a magic number: for (var index = 0; index < FlatClasses.Count; index++)  			{  				var i = index;  				var @class = FlatClasses[i];    				var annotatedMethods = new List<MethodDefinition>(); // by method index  				var annotatedParametersList = new List<MethodDefinition>(); // by method index  				var annotatedFields = @class.Fields.Where(field => field.Annotations.Count > 0).ToList(); // by field index    				foreach (var method in @class.Methods)  				{  					if (method.Annotations.Count > 0)  						annotatedMethods.Add(method);  					if (method.Prototype.ContainsAnnotation())  						annotatedParametersList.Add(method);  				}    				var total = @class.Annotations.Count + annotatedFields.Count + annotatedMethods.Count +  				            annotatedParametersList.Count;  				if (total <= 0)  					continue;    				writer.EnsureSectionAlignment(ref sectionOffset' 4);  				writer.EnsureAlignmentWithSection(sectionOffset' 4);      				// all datas except class annotations are specific.  				if (total == @class.Annotations.Count)  				{  					var set = new AnnotationSet(@class);  					if (classAnnotationSets.ContainsKey(set))  					{  						ClassDefinitionsMarkers[i].AnnotationsMarker.Value = classAnnotationSets[set];  						continue;  					}    					classAnnotationSets.Add(set' (uint) writer.BaseStream.Position);  				}    				ClassDefinitionsMarkers[i].AnnotationsMarker.Value = (uint) writer.BaseStream.Position;  				count++;    				if (@class.Annotations.Count > 0)  					writer.Write(AnnotationSets[new AnnotationSet(@class)]);  				else  					writer.Write((uint) 0);    				writer.Write(annotatedFields.Count);  				writer.Write(annotatedMethods.Count);  				writer.Write(annotatedParametersList.Count);    				var fields = new List<FieldReference>(annotatedFields.Cast<FieldReference>());  				fields.Sort(new FieldReferenceComparer());  				foreach (var field in fields)  				{  					writer.Write(FieldLookup[field]);  					writer.Write(AnnotationSets[new AnnotationSet(field as IAnnotationProvider)]);  				}    				var methods = new List<MethodReference>(annotatedMethods.Cast<MethodReference>());  				methods.Sort(new MethodReferenceComparer());  				foreach (var method in methods)  				{  					writer.Write(MethodLookup[method]);  					writer.Write(AnnotationSets[new AnnotationSet(method as IAnnotationProvider)]);  				}    				methods = new List<MethodReference>(annotatedParametersList.Cast<MethodReference>());  				methods.Sort(new MethodReferenceComparer());  				foreach (var method in methods)  				{  					writer.Write(MethodLookup[method]);  					writer.Write(AnnotationSetRefLists[(MethodDefinition) method]);  				}  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteAnnotationsDirectory,The following statement contains a magic number: for (var index = 0; index < FlatClasses.Count; index++)  			{  				var i = index;  				var @class = FlatClasses[i];    				var annotatedMethods = new List<MethodDefinition>(); // by method index  				var annotatedParametersList = new List<MethodDefinition>(); // by method index  				var annotatedFields = @class.Fields.Where(field => field.Annotations.Count > 0).ToList(); // by field index    				foreach (var method in @class.Methods)  				{  					if (method.Annotations.Count > 0)  						annotatedMethods.Add(method);  					if (method.Prototype.ContainsAnnotation())  						annotatedParametersList.Add(method);  				}    				var total = @class.Annotations.Count + annotatedFields.Count + annotatedMethods.Count +  				            annotatedParametersList.Count;  				if (total <= 0)  					continue;    				writer.EnsureSectionAlignment(ref sectionOffset' 4);  				writer.EnsureAlignmentWithSection(sectionOffset' 4);      				// all datas except class annotations are specific.  				if (total == @class.Annotations.Count)  				{  					var set = new AnnotationSet(@class);  					if (classAnnotationSets.ContainsKey(set))  					{  						ClassDefinitionsMarkers[i].AnnotationsMarker.Value = classAnnotationSets[set];  						continue;  					}    					classAnnotationSets.Add(set' (uint) writer.BaseStream.Position);  				}    				ClassDefinitionsMarkers[i].AnnotationsMarker.Value = (uint) writer.BaseStream.Position;  				count++;    				if (@class.Annotations.Count > 0)  					writer.Write(AnnotationSets[new AnnotationSet(@class)]);  				else  					writer.Write((uint) 0);    				writer.Write(annotatedFields.Count);  				writer.Write(annotatedMethods.Count);  				writer.Write(annotatedParametersList.Count);    				var fields = new List<FieldReference>(annotatedFields.Cast<FieldReference>());  				fields.Sort(new FieldReferenceComparer());  				foreach (var field in fields)  				{  					writer.Write(FieldLookup[field]);  					writer.Write(AnnotationSets[new AnnotationSet(field as IAnnotationProvider)]);  				}    				var methods = new List<MethodReference>(annotatedMethods.Cast<MethodReference>());  				methods.Sort(new MethodReferenceComparer());  				foreach (var method in methods)  				{  					writer.Write(MethodLookup[method]);  					writer.Write(AnnotationSets[new AnnotationSet(method as IAnnotationProvider)]);  				}    				methods = new List<MethodReference>(annotatedParametersList.Cast<MethodReference>());  				methods.Sort(new MethodReferenceComparer());  				foreach (var method in methods)  				{  					writer.Write(MethodLookup[method]);  					writer.Write(AnnotationSetRefLists[(MethodDefinition) method]);  				}  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteCode,The following statement contains a magic number: foreach (var method in FlatClasses.SelectMany(@class => @class.Methods))  			{  				Codes.Add(method' 0);  				var body = method.Body;  				if (body == null)  					continue;    				writer.EnsureSectionAlignment(ref sectionOffset' 4);  				writer.EnsureAlignmentWithSection(sectionOffset' 4);    				Codes[method] = (uint)writer.BaseStream.Position;  				count++;    				writer.Write((ushort)body.Registers.Count);  				writer.Write(body.IncomingArguments);  				writer.Write(body.OutgoingArguments);  				writer.Write((ushort)body.Exceptions.Count);  				DebugMarkers.Add(method' writer.MarkUInt());    				var iwriter = new InstructionWriter(this' method);  				iwriter.WriteTo(writer);    				if ((body.Exceptions.Count != 0) && (iwriter.Codes.Length % 2 != 0))  					writer.Write((ushort)0); // padding (tries 4-byte alignment)    				var catchHandlers = new Dictionary<CatchSet' List<ExceptionHandler>>();  				var exceptionsMarkers = new Dictionary<ExceptionHandler' UShortMarker>();  				foreach (var handler in body.Exceptions)  				{  					writer.Write(handler.TryStart.Offset);  					writer.Write((ushort)(iwriter.LookupLast[handler.TryEnd] - handler.TryStart.Offset + 1));  					exceptionsMarkers.Add(handler' writer.MarkUShort());    					var set = new CatchSet(handler);  					if (!catchHandlers.ContainsKey(set))  						catchHandlers.Add(set' new List<ExceptionHandler>());    					catchHandlers[set].Add(handler);  				}    				var catchSets = catchHandlers.Keys.ToList();  				catchSets.Sort(new CatchSetComparer());    				if (catchSets.Count <= 0)  					continue;    				var baseOffset = writer.BaseStream.Position;  				writer.WriteULEB128((uint)catchSets.Count);  				foreach (var set in catchSets)  				{  					var itemoffset = writer.BaseStream.Position - baseOffset;    					if (set.CatchAll != null)  						writer.WriteSLEB128(-set.Count);  					else  						writer.WriteSLEB128(set.Count);    					foreach (var handler in catchHandlers[set])  						exceptionsMarkers[handler].Value = (ushort)itemoffset;    					foreach (var @catch in set)  					{  						writer.WriteULEB128((uint)TypeLookup[@catch.Type]);  						writer.WriteULEB128((uint)@catch.Instruction.Offset);  					}    					if (set.CatchAll != null)  						writer.WriteULEB128((uint)set.CatchAll.Offset);  				}  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteCode,The following statement contains a magic number: foreach (var method in FlatClasses.SelectMany(@class => @class.Methods))  			{  				Codes.Add(method' 0);  				var body = method.Body;  				if (body == null)  					continue;    				writer.EnsureSectionAlignment(ref sectionOffset' 4);  				writer.EnsureAlignmentWithSection(sectionOffset' 4);    				Codes[method] = (uint)writer.BaseStream.Position;  				count++;    				writer.Write((ushort)body.Registers.Count);  				writer.Write(body.IncomingArguments);  				writer.Write(body.OutgoingArguments);  				writer.Write((ushort)body.Exceptions.Count);  				DebugMarkers.Add(method' writer.MarkUInt());    				var iwriter = new InstructionWriter(this' method);  				iwriter.WriteTo(writer);    				if ((body.Exceptions.Count != 0) && (iwriter.Codes.Length % 2 != 0))  					writer.Write((ushort)0); // padding (tries 4-byte alignment)    				var catchHandlers = new Dictionary<CatchSet' List<ExceptionHandler>>();  				var exceptionsMarkers = new Dictionary<ExceptionHandler' UShortMarker>();  				foreach (var handler in body.Exceptions)  				{  					writer.Write(handler.TryStart.Offset);  					writer.Write((ushort)(iwriter.LookupLast[handler.TryEnd] - handler.TryStart.Offset + 1));  					exceptionsMarkers.Add(handler' writer.MarkUShort());    					var set = new CatchSet(handler);  					if (!catchHandlers.ContainsKey(set))  						catchHandlers.Add(set' new List<ExceptionHandler>());    					catchHandlers[set].Add(handler);  				}    				var catchSets = catchHandlers.Keys.ToList();  				catchSets.Sort(new CatchSetComparer());    				if (catchSets.Count <= 0)  					continue;    				var baseOffset = writer.BaseStream.Position;  				writer.WriteULEB128((uint)catchSets.Count);  				foreach (var set in catchSets)  				{  					var itemoffset = writer.BaseStream.Position - baseOffset;    					if (set.CatchAll != null)  						writer.WriteSLEB128(-set.Count);  					else  						writer.WriteSLEB128(set.Count);    					foreach (var handler in catchHandlers[set])  						exceptionsMarkers[handler].Value = (ushort)itemoffset;    					foreach (var @catch in set)  					{  						writer.WriteULEB128((uint)TypeLookup[@catch.Type]);  						writer.WriteULEB128((uint)@catch.Instruction.Offset);  					}    					if (set.CatchAll != null)  						writer.WriteULEB128((uint)set.CatchAll.Offset);  				}  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteCode,The following statement contains a magic number: foreach (var method in FlatClasses.SelectMany(@class => @class.Methods))  			{  				Codes.Add(method' 0);  				var body = method.Body;  				if (body == null)  					continue;    				writer.EnsureSectionAlignment(ref sectionOffset' 4);  				writer.EnsureAlignmentWithSection(sectionOffset' 4);    				Codes[method] = (uint)writer.BaseStream.Position;  				count++;    				writer.Write((ushort)body.Registers.Count);  				writer.Write(body.IncomingArguments);  				writer.Write(body.OutgoingArguments);  				writer.Write((ushort)body.Exceptions.Count);  				DebugMarkers.Add(method' writer.MarkUInt());    				var iwriter = new InstructionWriter(this' method);  				iwriter.WriteTo(writer);    				if ((body.Exceptions.Count != 0) && (iwriter.Codes.Length % 2 != 0))  					writer.Write((ushort)0); // padding (tries 4-byte alignment)    				var catchHandlers = new Dictionary<CatchSet' List<ExceptionHandler>>();  				var exceptionsMarkers = new Dictionary<ExceptionHandler' UShortMarker>();  				foreach (var handler in body.Exceptions)  				{  					writer.Write(handler.TryStart.Offset);  					writer.Write((ushort)(iwriter.LookupLast[handler.TryEnd] - handler.TryStart.Offset + 1));  					exceptionsMarkers.Add(handler' writer.MarkUShort());    					var set = new CatchSet(handler);  					if (!catchHandlers.ContainsKey(set))  						catchHandlers.Add(set' new List<ExceptionHandler>());    					catchHandlers[set].Add(handler);  				}    				var catchSets = catchHandlers.Keys.ToList();  				catchSets.Sort(new CatchSetComparer());    				if (catchSets.Count <= 0)  					continue;    				var baseOffset = writer.BaseStream.Position;  				writer.WriteULEB128((uint)catchSets.Count);  				foreach (var set in catchSets)  				{  					var itemoffset = writer.BaseStream.Position - baseOffset;    					if (set.CatchAll != null)  						writer.WriteSLEB128(-set.Count);  					else  						writer.WriteSLEB128(set.Count);    					foreach (var handler in catchHandlers[set])  						exceptionsMarkers[handler].Value = (ushort)itemoffset;    					foreach (var @catch in set)  					{  						writer.WriteULEB128((uint)TypeLookup[@catch.Type]);  						writer.WriteULEB128((uint)@catch.Instruction.Offset);  					}    					if (set.CatchAll != null)  						writer.WriteULEB128((uint)set.CatchAll.Offset);  				}  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteDebugInfo,The following statement contains a magic number: foreach (var @class in FlatClasses)  			{  				foreach (var method in @class.Methods)  				{  					var body = method.Body;  					if (body == null || body.DebugInfo == null)  						continue;    					DebugMarkers[method].Value = (uint)writer.BaseStream.Position;  					count++;    					// byte aligned  					var debugInfo = body.DebugInfo;  					writer.WriteULEB128(debugInfo.LineStart);    					if (debugInfo.Parameters.Count != method.Prototype.Parameters.Count)  						throw new MalformedException("Unexpected parameter count in DebugInfo' must match with prototype");    					writer.WriteULEB128((uint)debugInfo.Parameters.Count);  					foreach (var parameter in debugInfo.Parameters)  					{  						if (string.IsNullOrEmpty(parameter))  							writer.WriteULEB128P1(DexConsts.NoIndex);  						else  							writer.WriteULEB128P1(StringLookup[parameter]);  					}    					foreach (var ins in debugInfo.DebugInstructions)  					{  						String name;    						writer.Write((byte)ins.OpCode);  						switch (ins.OpCode)  						{  							case DebugOpCodes.AdvancePc:  								// uleb128 addr_diff  								CheckOperand(ins' 1' typeof(uint));  								writer.WriteULEB128(Convert.ToUInt32(ins.Operands[0]));  								break;  							case DebugOpCodes.AdvanceLine:  								// sleb128 line_diff  								CheckOperand(ins' 1' typeof(int));  								writer.WriteSLEB128(Convert.ToInt32(ins.Operands[0]));  								break;  							case DebugOpCodes.EndLocal:  							case DebugOpCodes.RestartLocal:  								// uleb128 register_num  								CheckOperand(ins' 1' typeof(Register));  								writer.WriteULEB128((uint)((Register)ins.Operands[0]).Index);  								break;  							case DebugOpCodes.SetFile:  								// uleb128p1 name_idx  								CheckOperand(ins' 1' typeof(String));  								name = (String)ins.Operands[0];  								if (string.IsNullOrEmpty(name))  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(StringLookup[name]);  								break;  							case DebugOpCodes.StartLocalExtended:  							case DebugOpCodes.StartLocal:  								// StartLocalExtended : uleb128 register_num' uleb128p1 name_idx' uleb128p1 type_idx' uleb128p1 sig_idx  								// StartLocal : uleb128 register_num' uleb128p1 name_idx' uleb128p1 type_idx  								var isExtended = ins.OpCode == DebugOpCodes.StartLocalExtended;    								if (isExtended)  									CheckOperand(ins' 4' typeof(Register)' typeof(String)' typeof(TypeReference)' typeof(String));  								else  									CheckOperand(ins' 3' typeof(Register)' typeof(String)' typeof(TypeReference));    								writer.WriteULEB128((uint)((Register)ins.Operands[0]).Index);    								name = (String)ins.Operands[1];  								if (string.IsNullOrEmpty(name))  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(StringLookup[name]);    								var type = (TypeReference)ins.Operands[2];  								if (type == null)  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(TypeLookup[type]);    								if (isExtended)  								{  									var signature = (String)ins.Operands[3];  									if (string.IsNullOrEmpty(signature))  										writer.WriteULEB128P1(DexConsts.NoIndex);  									else  										writer.WriteULEB128P1(StringLookup[signature]);  								}    								break;  								//case DebugOpCodes.EndSequence:  								//case DebugOpCodes.Special:  								// between 0x0a and 0xff (inclusive)  								//case DebugOpCodes.SetPrologueEnd:  								//case DebugOpCodes.SetEpilogueBegin:  								//default:  								//    break;  						}  					}  				}  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteDebugInfo,The following statement contains a magic number: foreach (var @class in FlatClasses)  			{  				foreach (var method in @class.Methods)  				{  					var body = method.Body;  					if (body == null || body.DebugInfo == null)  						continue;    					DebugMarkers[method].Value = (uint)writer.BaseStream.Position;  					count++;    					// byte aligned  					var debugInfo = body.DebugInfo;  					writer.WriteULEB128(debugInfo.LineStart);    					if (debugInfo.Parameters.Count != method.Prototype.Parameters.Count)  						throw new MalformedException("Unexpected parameter count in DebugInfo' must match with prototype");    					writer.WriteULEB128((uint)debugInfo.Parameters.Count);  					foreach (var parameter in debugInfo.Parameters)  					{  						if (string.IsNullOrEmpty(parameter))  							writer.WriteULEB128P1(DexConsts.NoIndex);  						else  							writer.WriteULEB128P1(StringLookup[parameter]);  					}    					foreach (var ins in debugInfo.DebugInstructions)  					{  						String name;    						writer.Write((byte)ins.OpCode);  						switch (ins.OpCode)  						{  							case DebugOpCodes.AdvancePc:  								// uleb128 addr_diff  								CheckOperand(ins' 1' typeof(uint));  								writer.WriteULEB128(Convert.ToUInt32(ins.Operands[0]));  								break;  							case DebugOpCodes.AdvanceLine:  								// sleb128 line_diff  								CheckOperand(ins' 1' typeof(int));  								writer.WriteSLEB128(Convert.ToInt32(ins.Operands[0]));  								break;  							case DebugOpCodes.EndLocal:  							case DebugOpCodes.RestartLocal:  								// uleb128 register_num  								CheckOperand(ins' 1' typeof(Register));  								writer.WriteULEB128((uint)((Register)ins.Operands[0]).Index);  								break;  							case DebugOpCodes.SetFile:  								// uleb128p1 name_idx  								CheckOperand(ins' 1' typeof(String));  								name = (String)ins.Operands[0];  								if (string.IsNullOrEmpty(name))  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(StringLookup[name]);  								break;  							case DebugOpCodes.StartLocalExtended:  							case DebugOpCodes.StartLocal:  								// StartLocalExtended : uleb128 register_num' uleb128p1 name_idx' uleb128p1 type_idx' uleb128p1 sig_idx  								// StartLocal : uleb128 register_num' uleb128p1 name_idx' uleb128p1 type_idx  								var isExtended = ins.OpCode == DebugOpCodes.StartLocalExtended;    								if (isExtended)  									CheckOperand(ins' 4' typeof(Register)' typeof(String)' typeof(TypeReference)' typeof(String));  								else  									CheckOperand(ins' 3' typeof(Register)' typeof(String)' typeof(TypeReference));    								writer.WriteULEB128((uint)((Register)ins.Operands[0]).Index);    								name = (String)ins.Operands[1];  								if (string.IsNullOrEmpty(name))  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(StringLookup[name]);    								var type = (TypeReference)ins.Operands[2];  								if (type == null)  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(TypeLookup[type]);    								if (isExtended)  								{  									var signature = (String)ins.Operands[3];  									if (string.IsNullOrEmpty(signature))  										writer.WriteULEB128P1(DexConsts.NoIndex);  									else  										writer.WriteULEB128P1(StringLookup[signature]);  								}    								break;  								//case DebugOpCodes.EndSequence:  								//case DebugOpCodes.Special:  								// between 0x0a and 0xff (inclusive)  								//case DebugOpCodes.SetPrologueEnd:  								//case DebugOpCodes.SetEpilogueBegin:  								//default:  								//    break;  						}  					}  				}  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteDebugInfo,The following statement contains a magic number: foreach (var @class in FlatClasses)  			{  				foreach (var method in @class.Methods)  				{  					var body = method.Body;  					if (body == null || body.DebugInfo == null)  						continue;    					DebugMarkers[method].Value = (uint)writer.BaseStream.Position;  					count++;    					// byte aligned  					var debugInfo = body.DebugInfo;  					writer.WriteULEB128(debugInfo.LineStart);    					if (debugInfo.Parameters.Count != method.Prototype.Parameters.Count)  						throw new MalformedException("Unexpected parameter count in DebugInfo' must match with prototype");    					writer.WriteULEB128((uint)debugInfo.Parameters.Count);  					foreach (var parameter in debugInfo.Parameters)  					{  						if (string.IsNullOrEmpty(parameter))  							writer.WriteULEB128P1(DexConsts.NoIndex);  						else  							writer.WriteULEB128P1(StringLookup[parameter]);  					}    					foreach (var ins in debugInfo.DebugInstructions)  					{  						String name;    						writer.Write((byte)ins.OpCode);  						switch (ins.OpCode)  						{  							case DebugOpCodes.AdvancePc:  								// uleb128 addr_diff  								CheckOperand(ins' 1' typeof(uint));  								writer.WriteULEB128(Convert.ToUInt32(ins.Operands[0]));  								break;  							case DebugOpCodes.AdvanceLine:  								// sleb128 line_diff  								CheckOperand(ins' 1' typeof(int));  								writer.WriteSLEB128(Convert.ToInt32(ins.Operands[0]));  								break;  							case DebugOpCodes.EndLocal:  							case DebugOpCodes.RestartLocal:  								// uleb128 register_num  								CheckOperand(ins' 1' typeof(Register));  								writer.WriteULEB128((uint)((Register)ins.Operands[0]).Index);  								break;  							case DebugOpCodes.SetFile:  								// uleb128p1 name_idx  								CheckOperand(ins' 1' typeof(String));  								name = (String)ins.Operands[0];  								if (string.IsNullOrEmpty(name))  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(StringLookup[name]);  								break;  							case DebugOpCodes.StartLocalExtended:  							case DebugOpCodes.StartLocal:  								// StartLocalExtended : uleb128 register_num' uleb128p1 name_idx' uleb128p1 type_idx' uleb128p1 sig_idx  								// StartLocal : uleb128 register_num' uleb128p1 name_idx' uleb128p1 type_idx  								var isExtended = ins.OpCode == DebugOpCodes.StartLocalExtended;    								if (isExtended)  									CheckOperand(ins' 4' typeof(Register)' typeof(String)' typeof(TypeReference)' typeof(String));  								else  									CheckOperand(ins' 3' typeof(Register)' typeof(String)' typeof(TypeReference));    								writer.WriteULEB128((uint)((Register)ins.Operands[0]).Index);    								name = (String)ins.Operands[1];  								if (string.IsNullOrEmpty(name))  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(StringLookup[name]);    								var type = (TypeReference)ins.Operands[2];  								if (type == null)  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(TypeLookup[type]);    								if (isExtended)  								{  									var signature = (String)ins.Operands[3];  									if (string.IsNullOrEmpty(signature))  										writer.WriteULEB128P1(DexConsts.NoIndex);  									else  										writer.WriteULEB128P1(StringLookup[signature]);  								}    								break;  								//case DebugOpCodes.EndSequence:  								//case DebugOpCodes.Special:  								// between 0x0a and 0xff (inclusive)  								//case DebugOpCodes.SetPrologueEnd:  								//case DebugOpCodes.SetEpilogueBegin:  								//default:  								//    break;  						}  					}  				}  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteDebugInfo,The following statement contains a magic number: foreach (var @class in FlatClasses)  			{  				foreach (var method in @class.Methods)  				{  					var body = method.Body;  					if (body == null || body.DebugInfo == null)  						continue;    					DebugMarkers[method].Value = (uint)writer.BaseStream.Position;  					count++;    					// byte aligned  					var debugInfo = body.DebugInfo;  					writer.WriteULEB128(debugInfo.LineStart);    					if (debugInfo.Parameters.Count != method.Prototype.Parameters.Count)  						throw new MalformedException("Unexpected parameter count in DebugInfo' must match with prototype");    					writer.WriteULEB128((uint)debugInfo.Parameters.Count);  					foreach (var parameter in debugInfo.Parameters)  					{  						if (string.IsNullOrEmpty(parameter))  							writer.WriteULEB128P1(DexConsts.NoIndex);  						else  							writer.WriteULEB128P1(StringLookup[parameter]);  					}    					foreach (var ins in debugInfo.DebugInstructions)  					{  						String name;    						writer.Write((byte)ins.OpCode);  						switch (ins.OpCode)  						{  							case DebugOpCodes.AdvancePc:  								// uleb128 addr_diff  								CheckOperand(ins' 1' typeof(uint));  								writer.WriteULEB128(Convert.ToUInt32(ins.Operands[0]));  								break;  							case DebugOpCodes.AdvanceLine:  								// sleb128 line_diff  								CheckOperand(ins' 1' typeof(int));  								writer.WriteSLEB128(Convert.ToInt32(ins.Operands[0]));  								break;  							case DebugOpCodes.EndLocal:  							case DebugOpCodes.RestartLocal:  								// uleb128 register_num  								CheckOperand(ins' 1' typeof(Register));  								writer.WriteULEB128((uint)((Register)ins.Operands[0]).Index);  								break;  							case DebugOpCodes.SetFile:  								// uleb128p1 name_idx  								CheckOperand(ins' 1' typeof(String));  								name = (String)ins.Operands[0];  								if (string.IsNullOrEmpty(name))  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(StringLookup[name]);  								break;  							case DebugOpCodes.StartLocalExtended:  							case DebugOpCodes.StartLocal:  								// StartLocalExtended : uleb128 register_num' uleb128p1 name_idx' uleb128p1 type_idx' uleb128p1 sig_idx  								// StartLocal : uleb128 register_num' uleb128p1 name_idx' uleb128p1 type_idx  								var isExtended = ins.OpCode == DebugOpCodes.StartLocalExtended;    								if (isExtended)  									CheckOperand(ins' 4' typeof(Register)' typeof(String)' typeof(TypeReference)' typeof(String));  								else  									CheckOperand(ins' 3' typeof(Register)' typeof(String)' typeof(TypeReference));    								writer.WriteULEB128((uint)((Register)ins.Operands[0]).Index);    								name = (String)ins.Operands[1];  								if (string.IsNullOrEmpty(name))  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(StringLookup[name]);    								var type = (TypeReference)ins.Operands[2];  								if (type == null)  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(TypeLookup[type]);    								if (isExtended)  								{  									var signature = (String)ins.Operands[3];  									if (string.IsNullOrEmpty(signature))  										writer.WriteULEB128P1(DexConsts.NoIndex);  									else  										writer.WriteULEB128P1(StringLookup[signature]);  								}    								break;  								//case DebugOpCodes.EndSequence:  								//case DebugOpCodes.Special:  								// between 0x0a and 0xff (inclusive)  								//case DebugOpCodes.SetPrologueEnd:  								//case DebugOpCodes.SetEpilogueBegin:  								//default:  								//    break;  						}  					}  				}  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteClassData,The following statement contains a magic number: while ((writer.BaseStream.Position % 4) != 0)  				writer.Write((byte)0);
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteMapList,The following statement contains a magic number: writer.EnsureSectionAlignment(ref sectionOffset' 4);
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,ComputeAdlerCheckSum,The following statement contains a magic number: while ((value = writer.BaseStream.ReadByte()) != -1)  			{  				s1 = (ushort)((s1 + value) % 65521);  				s2 = (ushort)((s1 + s2) % 65521);  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,ComputeAdlerCheckSum,The following statement contains a magic number: while ((value = writer.BaseStream.ReadByte()) != -1)  			{  				s1 = (ushort)((s1 + value) % 65521);  				s2 = (ushort)((s1 + s2) % 65521);  			}
Magic Number,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,ComputeAdlerCheckSum,The following statement contains a magic number: var checksum = (uint)(s2 << 16 | s1);
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ReadvB,The following statement contains a magic number: ins.Registers.Add(MethodDefinition.Body.Registers[Upper[_ip++] >> 4]);
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ReadNibble,The following statement contains a magic number: return (sbyte)((Upper[_ip++] << 24) >> 28);
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ReadNibble,The following statement contains a magic number: return (sbyte)((Upper[_ip++] << 24) >> 28);
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ReadInt,The following statement contains a magic number: result |= Codes[codeUnitOffset++] << 16;
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ReadLong,The following statement contains a magic number: result |= ((long)Codes[codeUnitOffset++]) << 16;
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ReadLong,The following statement contains a magic number: result |= ((long)Codes[codeUnitOffset++]) << 32;
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ReadLong,The following statement contains a magic number: result |= ((long)Codes[codeUnitOffset++]) << 48;
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ReadFrom,The following statement contains a magic number: for (var i = 0; i < InstructionsSize; i++)  			{  				Codes[i] = reader.ReadUInt16();  				Lower[i] = Codes[i] & 0xFF;  				Upper[i] = Codes[i] >> 8;  			}
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ReadFrom,The following statement contains a magic number: while (_ip < InstructionsSize)  			{  				int offset;  				int registerCount;  				int registerMask;    				var ins = new Instruction { OpCode = (OpCodes)Lower[_ip]' Offset = _ip };    				Lookup.Add(_ip' ins);  				MethodDefinition.Body.Instructions.Add(ins);    				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ReadvAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ReadvA(ins);  						ReadvB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ReadvAA(ins);  						ReadvBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ReadvAAAA(ins);  						ReadvBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						ReadvA(ins);  						ins.Operand = (int)ReadNibble();  						break;  					case OpCodes.Const16:  						// vAA' #+BBBB  						ReadvAA(ins);  						ins.Operand = (int)ReadShort(ref _ip);  						break;  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ReadvAA(ins);  						ins.Operand = (long)ReadShort(ref _ip);  						break;  					case OpCodes.Const:  						// vAA' #+BBBBBBBB  						ReadvAA(ins);  						ins.Operand = ReadInt(ref _ip);  						break;  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ReadvAA(ins);  						ins.Operand = (long)ReadInt(ref _ip);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ReadvAA(ins);  						offset = ReadInt(ref _ip);  						ins.Operand = ExtractArrayData(ins.Offset + offset);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ReadvAA(ins);  						ins.Operand = ((long)ReadShort(ref _ip)) << 16;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ReadvAA(ins);  						ins.Operand = ReadLong(ref _ip);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ReadvAA(ins);  						ins.Operand = ((long)ReadUShort(ref _ip)) << 48;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ReadvAA(ins);  						ins.Operand = Dex.Strings[ReadUShort(ref _ip)];  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ReadvAA(ins);  						ins.Operand = Dex.Strings[ReadInt(ref _ip)];  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ReadvAA(ins);  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ReadvA(ins);  						ReadvB(ins);  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = Upper[_ip++] << 16;  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						registerMask |= Codes[_ip++];  						SetRegistersByMask(ins' registerMask);  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						registerCount = ReadUByte();  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						ReadvBBBB(ins);  						for (var i = 1; i < registerCount; i++)  							ins.Registers.Add(registers[i + ins.Registers[0].Index]);  						break;  					case OpCodes.Goto:  						// +AA  						offset = ReadSByte();  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						offset = ReadShort(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						offset = ReadInt(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						ReadvAA(ins);  						offset = ReadInt(ref _ip);  						ins.Operand = ExtractPackedSwitch(ins' ins.Offset + offset);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						ReadvAA(ins);  						offset = ReadInt(ref _ip);  						ins.Operand = ExtractSparseSwitch(ins' ins.Offset + offset);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ReadvAA(ins);  						ReadvBB(ins);  						ReadvCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ReadvA(ins);  						ReadvB(ins);  						offset = ReadShort(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ReadvAA(ins);  						offset = ReadShort(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ReadvA(ins);  						ReadvB(ins);  						ins.Operand = Dex.FieldReferences[ReadUShort(ref _ip)];  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ReadvAA(ins);  						ins.Operand = Dex.FieldReferences[ReadUShort(ref _ip)];  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = Upper[_ip++] << 16;  						ins.Operand = Dex.MethodReferences[ReadUShort(ref _ip)];  						registerMask |= Codes[_ip++];  						SetRegistersByMask(ins' registerMask);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						registerCount = ReadSByte();  						ins.Operand = Dex.MethodReferences[ReadUShort(ref _ip)];  						ReadvBBBB(ins);  						for (var i = 1; i < registerCount; i++)  							ins.Registers.Add(registers[i + ins.Registers[0].Index]);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ReadvA(ins);  						ReadvB(ins);  						ins.Operand = (int)ReadShort(ref _ip);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ReadvAA(ins);  						ReadvBB(ins);  						ins.Operand = ReadSByte();  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(_ip - 1' ins);  			}
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ReadFrom,The following statement contains a magic number: while (_ip < InstructionsSize)  			{  				int offset;  				int registerCount;  				int registerMask;    				var ins = new Instruction { OpCode = (OpCodes)Lower[_ip]' Offset = _ip };    				Lookup.Add(_ip' ins);  				MethodDefinition.Body.Instructions.Add(ins);    				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ReadvAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ReadvA(ins);  						ReadvB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ReadvAA(ins);  						ReadvBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ReadvAAAA(ins);  						ReadvBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						ReadvA(ins);  						ins.Operand = (int)ReadNibble();  						break;  					case OpCodes.Const16:  						// vAA' #+BBBB  						ReadvAA(ins);  						ins.Operand = (int)ReadShort(ref _ip);  						break;  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ReadvAA(ins);  						ins.Operand = (long)ReadShort(ref _ip);  						break;  					case OpCodes.Const:  						// vAA' #+BBBBBBBB  						ReadvAA(ins);  						ins.Operand = ReadInt(ref _ip);  						break;  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ReadvAA(ins);  						ins.Operand = (long)ReadInt(ref _ip);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ReadvAA(ins);  						offset = ReadInt(ref _ip);  						ins.Operand = ExtractArrayData(ins.Offset + offset);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ReadvAA(ins);  						ins.Operand = ((long)ReadShort(ref _ip)) << 16;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ReadvAA(ins);  						ins.Operand = ReadLong(ref _ip);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ReadvAA(ins);  						ins.Operand = ((long)ReadUShort(ref _ip)) << 48;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ReadvAA(ins);  						ins.Operand = Dex.Strings[ReadUShort(ref _ip)];  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ReadvAA(ins);  						ins.Operand = Dex.Strings[ReadInt(ref _ip)];  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ReadvAA(ins);  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ReadvA(ins);  						ReadvB(ins);  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = Upper[_ip++] << 16;  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						registerMask |= Codes[_ip++];  						SetRegistersByMask(ins' registerMask);  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						registerCount = ReadUByte();  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						ReadvBBBB(ins);  						for (var i = 1; i < registerCount; i++)  							ins.Registers.Add(registers[i + ins.Registers[0].Index]);  						break;  					case OpCodes.Goto:  						// +AA  						offset = ReadSByte();  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						offset = ReadShort(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						offset = ReadInt(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						ReadvAA(ins);  						offset = ReadInt(ref _ip);  						ins.Operand = ExtractPackedSwitch(ins' ins.Offset + offset);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						ReadvAA(ins);  						offset = ReadInt(ref _ip);  						ins.Operand = ExtractSparseSwitch(ins' ins.Offset + offset);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ReadvAA(ins);  						ReadvBB(ins);  						ReadvCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ReadvA(ins);  						ReadvB(ins);  						offset = ReadShort(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ReadvAA(ins);  						offset = ReadShort(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ReadvA(ins);  						ReadvB(ins);  						ins.Operand = Dex.FieldReferences[ReadUShort(ref _ip)];  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ReadvAA(ins);  						ins.Operand = Dex.FieldReferences[ReadUShort(ref _ip)];  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = Upper[_ip++] << 16;  						ins.Operand = Dex.MethodReferences[ReadUShort(ref _ip)];  						registerMask |= Codes[_ip++];  						SetRegistersByMask(ins' registerMask);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						registerCount = ReadSByte();  						ins.Operand = Dex.MethodReferences[ReadUShort(ref _ip)];  						ReadvBBBB(ins);  						for (var i = 1; i < registerCount; i++)  							ins.Registers.Add(registers[i + ins.Registers[0].Index]);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ReadvA(ins);  						ReadvB(ins);  						ins.Operand = (int)ReadShort(ref _ip);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ReadvAA(ins);  						ReadvBB(ins);  						ins.Operand = ReadSByte();  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(_ip - 1' ins);  			}
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ReadFrom,The following statement contains a magic number: while (_ip < InstructionsSize)  			{  				int offset;  				int registerCount;  				int registerMask;    				var ins = new Instruction { OpCode = (OpCodes)Lower[_ip]' Offset = _ip };    				Lookup.Add(_ip' ins);  				MethodDefinition.Body.Instructions.Add(ins);    				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ReadvAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ReadvA(ins);  						ReadvB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ReadvAA(ins);  						ReadvBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ReadvAAAA(ins);  						ReadvBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						ReadvA(ins);  						ins.Operand = (int)ReadNibble();  						break;  					case OpCodes.Const16:  						// vAA' #+BBBB  						ReadvAA(ins);  						ins.Operand = (int)ReadShort(ref _ip);  						break;  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ReadvAA(ins);  						ins.Operand = (long)ReadShort(ref _ip);  						break;  					case OpCodes.Const:  						// vAA' #+BBBBBBBB  						ReadvAA(ins);  						ins.Operand = ReadInt(ref _ip);  						break;  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ReadvAA(ins);  						ins.Operand = (long)ReadInt(ref _ip);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ReadvAA(ins);  						offset = ReadInt(ref _ip);  						ins.Operand = ExtractArrayData(ins.Offset + offset);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ReadvAA(ins);  						ins.Operand = ((long)ReadShort(ref _ip)) << 16;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ReadvAA(ins);  						ins.Operand = ReadLong(ref _ip);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ReadvAA(ins);  						ins.Operand = ((long)ReadUShort(ref _ip)) << 48;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ReadvAA(ins);  						ins.Operand = Dex.Strings[ReadUShort(ref _ip)];  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ReadvAA(ins);  						ins.Operand = Dex.Strings[ReadInt(ref _ip)];  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ReadvAA(ins);  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ReadvA(ins);  						ReadvB(ins);  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = Upper[_ip++] << 16;  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						registerMask |= Codes[_ip++];  						SetRegistersByMask(ins' registerMask);  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						registerCount = ReadUByte();  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						ReadvBBBB(ins);  						for (var i = 1; i < registerCount; i++)  							ins.Registers.Add(registers[i + ins.Registers[0].Index]);  						break;  					case OpCodes.Goto:  						// +AA  						offset = ReadSByte();  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						offset = ReadShort(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						offset = ReadInt(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						ReadvAA(ins);  						offset = ReadInt(ref _ip);  						ins.Operand = ExtractPackedSwitch(ins' ins.Offset + offset);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						ReadvAA(ins);  						offset = ReadInt(ref _ip);  						ins.Operand = ExtractSparseSwitch(ins' ins.Offset + offset);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ReadvAA(ins);  						ReadvBB(ins);  						ReadvCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ReadvA(ins);  						ReadvB(ins);  						offset = ReadShort(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ReadvAA(ins);  						offset = ReadShort(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ReadvA(ins);  						ReadvB(ins);  						ins.Operand = Dex.FieldReferences[ReadUShort(ref _ip)];  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ReadvAA(ins);  						ins.Operand = Dex.FieldReferences[ReadUShort(ref _ip)];  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = Upper[_ip++] << 16;  						ins.Operand = Dex.MethodReferences[ReadUShort(ref _ip)];  						registerMask |= Codes[_ip++];  						SetRegistersByMask(ins' registerMask);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						registerCount = ReadSByte();  						ins.Operand = Dex.MethodReferences[ReadUShort(ref _ip)];  						ReadvBBBB(ins);  						for (var i = 1; i < registerCount; i++)  							ins.Registers.Add(registers[i + ins.Registers[0].Index]);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ReadvA(ins);  						ReadvB(ins);  						ins.Operand = (int)ReadShort(ref _ip);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ReadvAA(ins);  						ReadvBB(ins);  						ins.Operand = ReadSByte();  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(_ip - 1' ins);  			}
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ReadFrom,The following statement contains a magic number: while (_ip < InstructionsSize)  			{  				int offset;  				int registerCount;  				int registerMask;    				var ins = new Instruction { OpCode = (OpCodes)Lower[_ip]' Offset = _ip };    				Lookup.Add(_ip' ins);  				MethodDefinition.Body.Instructions.Add(ins);    				switch (ins.OpCode)  				{    					case OpCodes.Nop:  					case OpCodes.ReturnVoid:  						_ip++;  						break;  					case OpCodes.MoveResult:  					case OpCodes.MoveResultWide:  					case OpCodes.MoveResultObject:  					case OpCodes.MoveException:  					case OpCodes.Return:  					case OpCodes.ReturnWide:  					case OpCodes.ReturnObject:  					case OpCodes.MonitorEnter:  					case OpCodes.MonitorExit:  					case OpCodes.Throw:  						// vAA  						ReadvAA(ins);  						break;  					case OpCodes.MoveObject:  					case OpCodes.MoveWide:  					case OpCodes.Move:  					case OpCodes.ArrayLength:  					case OpCodes.NegInt:  					case OpCodes.NotInt:  					case OpCodes.NegLong:  					case OpCodes.NotLong:  					case OpCodes.NegFloat:  					case OpCodes.NegDouble:  					case OpCodes.IntToLong:  					case OpCodes.IntToFloat:  					case OpCodes.IntToDouble:  					case OpCodes.LongToInt:  					case OpCodes.LongToFloat:  					case OpCodes.LongToDouble:  					case OpCodes.FloatToInt:  					case OpCodes.FloatToLong:  					case OpCodes.FloatToDouble:  					case OpCodes.DoubleToInt:  					case OpCodes.DoubleToLong:  					case OpCodes.DoubleToFloat:  					case OpCodes.IntToByte:  					case OpCodes.IntToChar:  					case OpCodes.IntToShort:  					case OpCodes.AddInt2Addr:  					case OpCodes.SubInt2Addr:  					case OpCodes.MulInt2Addr:  					case OpCodes.DivInt2Addr:  					case OpCodes.RemInt2Addr:  					case OpCodes.AndInt2Addr:  					case OpCodes.OrInt2Addr:  					case OpCodes.XorInt2Addr:  					case OpCodes.ShlInt2Addr:  					case OpCodes.ShrInt2Addr:  					case OpCodes.UshrInt2Addr:  					case OpCodes.AddLong2Addr:  					case OpCodes.SubLong2Addr:  					case OpCodes.MulLong2Addr:  					case OpCodes.DivLong2Addr:  					case OpCodes.RemLong2Addr:  					case OpCodes.AndLong2Addr:  					case OpCodes.OrLong2Addr:  					case OpCodes.XorLong2Addr:  					case OpCodes.ShlLong2Addr:  					case OpCodes.ShrLong2Addr:  					case OpCodes.UshrLong2Addr:  					case OpCodes.AddFloat2Addr:  					case OpCodes.SubFloat2Addr:  					case OpCodes.MulFloat2Addr:  					case OpCodes.DivFloat2Addr:  					case OpCodes.RemFloat2Addr:  					case OpCodes.AddDouble2Addr:  					case OpCodes.SubDouble2Addr:  					case OpCodes.MulDouble2Addr:  					case OpCodes.DivDouble2Addr:  					case OpCodes.RemDouble2Addr:  						// vA' vB  						ReadvA(ins);  						ReadvB(ins);  						break;  					case OpCodes.MoveWideFrom16:  					case OpCodes.MoveFrom16:  					case OpCodes.MoveObjectFrom16:  						// vAA' vBBBB  						ReadvAA(ins);  						ReadvBBBB(ins);  						break;  					case OpCodes.Move16:  					case OpCodes.MoveWide16:  					case OpCodes.MoveObject16:  						// vAAAA' vBBBB  						ReadvAAAA(ins);  						ReadvBBBB(ins);  						break;  					case OpCodes.Const4:  						// vA' #+B  						ReadvA(ins);  						ins.Operand = (int)ReadNibble();  						break;  					case OpCodes.Const16:  						// vAA' #+BBBB  						ReadvAA(ins);  						ins.Operand = (int)ReadShort(ref _ip);  						break;  					case OpCodes.ConstWide16:  						// vAA' #+BBBB  						ReadvAA(ins);  						ins.Operand = (long)ReadShort(ref _ip);  						break;  					case OpCodes.Const:  						// vAA' #+BBBBBBBB  						ReadvAA(ins);  						ins.Operand = ReadInt(ref _ip);  						break;  					case OpCodes.ConstWide32:  						// vAA' #+BBBBBBBB  						ReadvAA(ins);  						ins.Operand = (long)ReadInt(ref _ip);  						break;  					case OpCodes.FillArrayData:  						// vAA' #+BBBBBBBB  						ReadvAA(ins);  						offset = ReadInt(ref _ip);  						ins.Operand = ExtractArrayData(ins.Offset + offset);  						break;  					case OpCodes.ConstHigh16:  						// vAA' #+BBBB0000  						ReadvAA(ins);  						ins.Operand = ((long)ReadShort(ref _ip)) << 16;  						break;  					case OpCodes.ConstWide:  						// vAA' #+BBBBBBBBBBBBBBBB  						ReadvAA(ins);  						ins.Operand = ReadLong(ref _ip);  						break;  					case OpCodes.ConstWideHigh16:  						// vAA' #+BBBB000000000000  						ReadvAA(ins);  						ins.Operand = ((long)ReadUShort(ref _ip)) << 48;  						break;  					case OpCodes.ConstString:  						// vAA' string@BBBB  						ReadvAA(ins);  						ins.Operand = Dex.Strings[ReadUShort(ref _ip)];  						break;  					case OpCodes.ConstStringJumbo:  						// vAA' string@BBBBBBBB  						ReadvAA(ins);  						ins.Operand = Dex.Strings[ReadInt(ref _ip)];  						break;  					case OpCodes.ConstClass:  					case OpCodes.NewInstance:  					case OpCodes.CheckCast:  						// vAA' type@BBBB  						ReadvAA(ins);  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						break;  					case OpCodes.InstanceOf:  					case OpCodes.NewArray:  						// vA' vB' type@CCCC  						ReadvA(ins);  						ReadvB(ins);  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						break;  					case OpCodes.FilledNewArray:  						// {vD' vE' vF' vG' vA}' type@CCCC  						registerMask = Upper[_ip++] << 16;  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						registerMask |= Codes[_ip++];  						SetRegistersByMask(ins' registerMask);  						break;  					case OpCodes.FilledNewArrayRange:  						// {vCCCC .. vNNNN}' type@BBBB  						registerCount = ReadUByte();  						ins.Operand = Dex.TypeReferences[ReadShort(ref _ip)];  						ReadvBBBB(ins);  						for (var i = 1; i < registerCount; i++)  							ins.Registers.Add(registers[i + ins.Registers[0].Index]);  						break;  					case OpCodes.Goto:  						// +AA  						offset = ReadSByte();  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.Goto16:  						// +AAAA  						_ip++;  						offset = ReadShort(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.Goto32:  						// +AAAAAAAA  						_ip++;  						offset = ReadInt(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.PackedSwitch:  						// vAA' +BBBBBBBB  						ReadvAA(ins);  						offset = ReadInt(ref _ip);  						ins.Operand = ExtractPackedSwitch(ins' ins.Offset + offset);  						break;  					case OpCodes.SparseSwitch:  						// vAA' +BBBBBBBB  						ReadvAA(ins);  						offset = ReadInt(ref _ip);  						ins.Operand = ExtractSparseSwitch(ins' ins.Offset + offset);  						break;  					case OpCodes.CmplFloat:  					case OpCodes.CmpgFloat:  					case OpCodes.CmplDouble:  					case OpCodes.CmpgDouble:  					case OpCodes.CmpLong:  					case OpCodes.Aget:  					case OpCodes.AgetWide:  					case OpCodes.AgetObject:  					case OpCodes.AgetBoolean:  					case OpCodes.AgetByte:  					case OpCodes.AgetChar:  					case OpCodes.AgetShort:  					case OpCodes.Aput:  					case OpCodes.AputWide:  					case OpCodes.AputObject:  					case OpCodes.AputBoolean:  					case OpCodes.AputByte:  					case OpCodes.AputChar:  					case OpCodes.AputShort:  					case OpCodes.AddInt:  					case OpCodes.SubInt:  					case OpCodes.MulInt:  					case OpCodes.DivInt:  					case OpCodes.RemInt:  					case OpCodes.AndInt:  					case OpCodes.OrInt:  					case OpCodes.XorInt:  					case OpCodes.ShlInt:  					case OpCodes.ShrInt:  					case OpCodes.UshrInt:  					case OpCodes.AddLong:  					case OpCodes.SubLong:  					case OpCodes.MulLong:  					case OpCodes.DivLong:  					case OpCodes.RemLong:  					case OpCodes.AndLong:  					case OpCodes.OrLong:  					case OpCodes.XorLong:  					case OpCodes.ShlLong:  					case OpCodes.ShrLong:  					case OpCodes.UshrLong:  					case OpCodes.AddFloat:  					case OpCodes.SubFloat:  					case OpCodes.MulFloat:  					case OpCodes.DivFloat:  					case OpCodes.RemFloat:  					case OpCodes.AddDouble:  					case OpCodes.SubDouble:  					case OpCodes.MulDouble:  					case OpCodes.DivDouble:  					case OpCodes.RemDouble:  						// vAA' vBB' vCC  						ReadvAA(ins);  						ReadvBB(ins);  						ReadvCC(ins);  						break;  					case OpCodes.IfEq:  					case OpCodes.IfNe:  					case OpCodes.IfLt:  					case OpCodes.IfGe:  					case OpCodes.IfGt:  					case OpCodes.IfLe:  						// vA' vB' +CCCC  						ReadvA(ins);  						ReadvB(ins);  						offset = ReadShort(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.IfEqz:  					case OpCodes.IfNez:  					case OpCodes.IfLtz:  					case OpCodes.IfGez:  					case OpCodes.IfGtz:  					case OpCodes.IfLez:  						// vAA' +BBBB  						ReadvAA(ins);  						offset = ReadShort(ref _ip);  						LazyInstructionsSetters.Add(() => ins.Operand = Lookup[(ushort)(ins.Offset + offset)]);  						break;  					case OpCodes.Iget:  					case OpCodes.IgetWide:  					case OpCodes.IgetObject:  					case OpCodes.IgetBoolean:  					case OpCodes.IgetByte:  					case OpCodes.IgetChar:  					case OpCodes.IgetShort:  					case OpCodes.Iput:  					case OpCodes.IputWide:  					case OpCodes.IputObject:  					case OpCodes.IputBoolean:  					case OpCodes.IputByte:  					case OpCodes.IputChar:  					case OpCodes.IputShort:  						// vA' vB' field@CCCC  						ReadvA(ins);  						ReadvB(ins);  						ins.Operand = Dex.FieldReferences[ReadUShort(ref _ip)];  						break;  					case OpCodes.Sget:  					case OpCodes.SgetWide:  					case OpCodes.SgetObject:  					case OpCodes.SgetBoolean:  					case OpCodes.SgetByte:  					case OpCodes.SgetChar:  					case OpCodes.SgetShort:  					case OpCodes.Sput:  					case OpCodes.SputWide:  					case OpCodes.SputObject:  					case OpCodes.SputBoolean:  					case OpCodes.SputByte:  					case OpCodes.SputChar:  					case OpCodes.SputShort:  						// vAA' field@BBBB  						ReadvAA(ins);  						ins.Operand = Dex.FieldReferences[ReadUShort(ref _ip)];  						break;  					case OpCodes.InvokeVirtual:  					case OpCodes.InvokeSuper:  					case OpCodes.InvokeDirect:  					case OpCodes.InvokeStatic:  					case OpCodes.InvokeInterface:  						// {vD' vE' vF' vG' vA}' meth@CCCC  						registerMask = Upper[_ip++] << 16;  						ins.Operand = Dex.MethodReferences[ReadUShort(ref _ip)];  						registerMask |= Codes[_ip++];  						SetRegistersByMask(ins' registerMask);  						break;  					case OpCodes.InvokeVirtualRange:  					case OpCodes.InvokeSuperRange:  					case OpCodes.InvokeDirectRange:  					case OpCodes.InvokeStaticRange:  					case OpCodes.InvokeInterfaceRange:  						// {vCCCC .. vNNNN}' meth@BBBB  						registerCount = ReadSByte();  						ins.Operand = Dex.MethodReferences[ReadUShort(ref _ip)];  						ReadvBBBB(ins);  						for (var i = 1; i < registerCount; i++)  							ins.Registers.Add(registers[i + ins.Registers[0].Index]);  						break;  					case OpCodes.AddIntLit16:  					case OpCodes.RsubInt:  					case OpCodes.MulIntLit16:  					case OpCodes.DivIntLit16:  					case OpCodes.RemIntLit16:  					case OpCodes.AndIntLit16:  					case OpCodes.OrIntLit16:  					case OpCodes.XorIntLit16:  						// vA' vB' #+CCCC  						ReadvA(ins);  						ReadvB(ins);  						ins.Operand = (int)ReadShort(ref _ip);  						break;  					case OpCodes.AddIntLit8:  					case OpCodes.RsubIntLit8:  					case OpCodes.MulIntLit8:  					case OpCodes.DivIntLit8:  					case OpCodes.RemIntLit8:  					case OpCodes.AndIntLit8:  					case OpCodes.OrIntLit8:  					case OpCodes.XorIntLit8:  					case OpCodes.ShlIntLit8:  					case OpCodes.ShrIntLit8:  					case OpCodes.UshrIntLit8:  						// vAA' vBB' #+CC  						ReadvAA(ins);  						ReadvBB(ins);  						ins.Operand = ReadSByte();  						break;    					default:  						throw new NotImplementedException(string.Concat("Unknown opcode:"' ins.OpCode));  				}    				LookupLast.Add(_ip - 1' ins);  			}
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,SetRegistersByMask,The following statement contains a magic number: var registerCount = registerMask >> 20;
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,SetRegistersByMask,The following statement contains a magic number: for (var i = 0; i < registerCount; i++)  				ins.Registers.Add(MethodDefinition.Body.Registers[(registerMask >> (i * 4)) & 0xF]);
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ExtractSparseSwitch,The following statement contains a magic number: if (offset - baseOffset != targetcount * 4 + 2)  				throw new MalformedException("Unexpected Sparse switch blocksize");
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ExtractSparseSwitch,The following statement contains a magic number: if (offset - baseOffset != targetcount * 4 + 2)  				throw new MalformedException("Unexpected Sparse switch blocksize");
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ExtractPackedSwitch,The following statement contains a magic number: if (offset - baseOffset != targetcount * 2 + 4)  				throw new MalformedException("Unexpected Packed switch blocksize");
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ExtractPackedSwitch,The following statement contains a magic number: if (offset - baseOffset != targetcount * 2 + 4)  				throw new MalformedException("Unexpected Packed switch blocksize");
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ExtractArrayData,The following statement contains a magic number: for (var i = 0; i < elementcount; i++)  			{  				switch (elementsize)  				{  					case 1:  						items.Add(next ? (sbyte)((Codes[offset++] >> 8) & 0xff) : (sbyte)(Codes[offset] & 0xff));  						next = !next;  						break;  					case 2:  						items.Add(ReadShort(ref offset));  						break;  					case 4:  						items.Add(ReadInt(ref offset));  						break;  					case 8:  						items.Add(ReadLong(ref offset));  						break;  					default:  						throw new MalformedException("Unexpected Fill-array-data element size");  				}  			}
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ExtractArrayData,The following statement contains a magic number: for (var i = 0; i < elementcount; i++)  			{  				switch (elementsize)  				{  					case 1:  						items.Add(next ? (sbyte)((Codes[offset++] >> 8) & 0xff) : (sbyte)(Codes[offset] & 0xff));  						next = !next;  						break;  					case 2:  						items.Add(ReadShort(ref offset));  						break;  					case 4:  						items.Add(ReadInt(ref offset));  						break;  					case 8:  						items.Add(ReadLong(ref offset));  						break;  					default:  						throw new MalformedException("Unexpected Fill-array-data element size");  				}  			}
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ExtractArrayData,The following statement contains a magic number: for (var i = 0; i < elementcount; i++)  			{  				switch (elementsize)  				{  					case 1:  						items.Add(next ? (sbyte)((Codes[offset++] >> 8) & 0xff) : (sbyte)(Codes[offset] & 0xff));  						next = !next;  						break;  					case 2:  						items.Add(ReadShort(ref offset));  						break;  					case 4:  						items.Add(ReadInt(ref offset));  						break;  					case 8:  						items.Add(ReadLong(ref offset));  						break;  					default:  						throw new MalformedException("Unexpected Fill-array-data element size");  				}  			}
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ExtractArrayData,The following statement contains a magic number: for (var i = 0; i < elementcount; i++)  			{  				switch (elementsize)  				{  					case 1:  						items.Add(next ? (sbyte)((Codes[offset++] >> 8) & 0xff) : (sbyte)(Codes[offset] & 0xff));  						next = !next;  						break;  					case 2:  						items.Add(ReadShort(ref offset));  						break;  					case 4:  						items.Add(ReadInt(ref offset));  						break;  					case 8:  						items.Add(ReadLong(ref offset));  						break;  					default:  						throw new MalformedException("Unexpected Fill-array-data element size");  				}  			}
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ExtractArrayData,The following statement contains a magic number: if ((elementcount % 2 != 0) && (elementsize == 1))  				offset++;
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ExtractArrayData,The following statement contains a magic number: if (offset - baseOffset != (elementsize * elementcount + 1) / 2 + 4)  				throw new MalformedException("Unexpected Fill-array-data blocksize");
Magic Number,Dexer.IO,InstructionReader,C:\repos\sailro_Dexer\Dexer\IO\InstructionReader.cs,ExtractArrayData,The following statement contains a magic number: if (offset - baseOffset != (elementsize * elementcount + 1) / 2 + 4)  				throw new MalformedException("Unexpected Fill-array-data blocksize");
Magic Number,Dexer.IO,DexReader,C:\repos\sailro_Dexer\Dexer\IO\DexReader.cs,ReadValue,The following statement contains a magic number: var valueArgument = data >> 5;
Magic Number,Dexer.IO,DexReader,C:\repos\sailro_Dexer\Dexer\IO\DexReader.cs,ReadMethodBody,The following statement contains a magic number: reader.PreserveCurrentPosition(codeOffset' () =>  			{  				var registersSize = reader.ReadUInt16();  				var incomingArgsSize = reader.ReadUInt16();  				var outgoingArgsSize = reader.ReadUInt16();  				var triesSize = reader.ReadUInt16();  				var debugOffset = reader.ReadUInt32();    				mdef.Body = new MethodBody(mdef' registersSize)  				{  					IncomingArguments = incomingArgsSize'  					OutgoingArguments = outgoingArgsSize  				};    				var ireader = new InstructionReader(Dex' mdef);  				ireader.ReadFrom(reader);    				if ((triesSize != 0) && (ireader.Codes.Length % 2 != 0))  					reader.ReadUInt16(); // padding (4-byte alignment)    				if (triesSize != 0)  					ReadExceptionHandlers(reader' mdef' ireader' triesSize);    				if (debugOffset != 0)  					ReadDebugInfo(reader' mdef' debugOffset);  			});
Magic Number,Dexer.Metadata,TypeDescriptor,C:\repos\sailro_Dexer\Dexer\Metadata\TypeDescriptor.cs,Fill,The following statement contains a magic number: if (!string.IsNullOrEmpty(tdString))  			{  				char prefix = tdString[0];  				var td = (TypeDescriptors)prefix;  				switch (td)  				{  					case TypeDescriptors.Array:  						var atype = (ArrayType)item;    						TypeReference elementType = Allocate(tdString.Substring(1));  						Fill(tdString.Substring(1)' elementType' context);    						/* All types are already allocated                           * We want to reuse object reference if already in type repository                           * BUT if not' we don't want to add a new reference to this type:                           * it's a 'transient' type only used in the Dexer object model but                           * not persisted in dex file.                           */  						atype.ElementType = context.Import(elementType' false);    						break;  					case TypeDescriptors.FullyQualifiedName:  						var cref = (ClassReference)item;  						cref.Fullname = tdString.Substring(1' tdString.Length - 2);  						break;  				}  			}
Missing Default,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteValue,The following switch statement is missing a default case: switch (format)  			{  				case ValueFormats.Char:  					valueArgument = writer.GetByteCountForUnsignedPackedNumber(Convert.ToInt64(value)) - 1;  					break;  				case ValueFormats.Byte:  				case ValueFormats.Short:  				case ValueFormats.Int:  				case ValueFormats.Long:  					valueArgument = writer.GetByteCountForSignedPackedNumber(Convert.ToInt64(value)) - 1;  					break;  				case ValueFormats.Float:  					valueArgument = writer.GetByteCountForSignedPackedNumber(BitConverter.ToInt32(BitConverter.GetBytes(Convert.ToSingle(value))' 0)) - 1;  					break;  				case ValueFormats.Double:  					valueArgument = writer.GetByteCountForSignedPackedNumber(BitConverter.DoubleToInt64Bits(Convert.ToDouble(value))) - 1;  					break;  				case ValueFormats.String:  					valueArgument = writer.GetByteCountForUnsignedPackedNumber(StringLookup[(String)value]) - 1;  					break;  				case ValueFormats.Type:  					valueArgument = writer.GetByteCountForUnsignedPackedNumber(TypeLookup[(TypeReference)value]) - 1;  					break;  				case ValueFormats.Field:  				case ValueFormats.Enum:  					valueArgument = writer.GetByteCountForUnsignedPackedNumber(FieldLookup[(FieldReference)value]) - 1;  					break;  				case ValueFormats.Method:  					valueArgument = writer.GetByteCountForUnsignedPackedNumber(MethodLookup[(MethodReference)value]) - 1;  					break;  				case ValueFormats.Boolean:  					valueArgument = Convert.ToInt32(Convert.ToBoolean(value));  					break;  			}
Missing Default,Dexer.IO,DexWriter,C:\repos\sailro_Dexer\Dexer\IO\DexWriter.cs,WriteDebugInfo,The following switch statement is missing a default case: switch (ins.OpCode)  						{  							case DebugOpCodes.AdvancePc:  								// uleb128 addr_diff  								CheckOperand(ins' 1' typeof(uint));  								writer.WriteULEB128(Convert.ToUInt32(ins.Operands[0]));  								break;  							case DebugOpCodes.AdvanceLine:  								// sleb128 line_diff  								CheckOperand(ins' 1' typeof(int));  								writer.WriteSLEB128(Convert.ToInt32(ins.Operands[0]));  								break;  							case DebugOpCodes.EndLocal:  							case DebugOpCodes.RestartLocal:  								// uleb128 register_num  								CheckOperand(ins' 1' typeof(Register));  								writer.WriteULEB128((uint)((Register)ins.Operands[0]).Index);  								break;  							case DebugOpCodes.SetFile:  								// uleb128p1 name_idx  								CheckOperand(ins' 1' typeof(String));  								name = (String)ins.Operands[0];  								if (string.IsNullOrEmpty(name))  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(StringLookup[name]);  								break;  							case DebugOpCodes.StartLocalExtended:  							case DebugOpCodes.StartLocal:  								// StartLocalExtended : uleb128 register_num' uleb128p1 name_idx' uleb128p1 type_idx' uleb128p1 sig_idx  								// StartLocal : uleb128 register_num' uleb128p1 name_idx' uleb128p1 type_idx  								var isExtended = ins.OpCode == DebugOpCodes.StartLocalExtended;    								if (isExtended)  									CheckOperand(ins' 4' typeof(Register)' typeof(String)' typeof(TypeReference)' typeof(String));  								else  									CheckOperand(ins' 3' typeof(Register)' typeof(String)' typeof(TypeReference));    								writer.WriteULEB128((uint)((Register)ins.Operands[0]).Index);    								name = (String)ins.Operands[1];  								if (string.IsNullOrEmpty(name))  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(StringLookup[name]);    								var type = (TypeReference)ins.Operands[2];  								if (type == null)  									writer.WriteULEB128P1(DexConsts.NoIndex);  								else  									writer.WriteULEB128P1(TypeLookup[type]);    								if (isExtended)  								{  									var signature = (String)ins.Operands[3];  									if (string.IsNullOrEmpty(signature))  										writer.WriteULEB128P1(DexConsts.NoIndex);  									else  										writer.WriteULEB128P1(StringLookup[signature]);  								}    								break;  								//case DebugOpCodes.EndSequence:  								//case DebugOpCodes.Special:  								// between 0x0a and 0xff (inclusive)  								//case DebugOpCodes.SetPrologueEnd:  								//case DebugOpCodes.SetEpilogueBegin:  								//default:  								//    break;  						}
Missing Default,Dexer.IO,DexReader,C:\repos\sailro_Dexer\Dexer\IO\DexReader.cs,ReadDebugInfo,The following switch statement is missing a default case: switch (ins.OpCode)  					{  						case DebugOpCodes.AdvancePc:  							// uleb128 addr_diff  							var addrDiff = reader.ReadULEB128();  							ins.Operands.Add(addrDiff);  							break;  						case DebugOpCodes.AdvanceLine:  							// sleb128 line_diff  							var lineDiff = reader.ReadSLEB128();  							ins.Operands.Add(lineDiff);  							break;  						case DebugOpCodes.EndLocal:  						case DebugOpCodes.RestartLocal:  							// uleb128 register_num  							registerIndex = reader.ReadULEB128();  							ins.Operands.Add(mdef.Body.Registers[(int)registerIndex]);  							break;  						case DebugOpCodes.SetFile:  							// uleb128p1 name_idx  							nameIndex = reader.ReadULEB128P1();  							name = null;  							if (nameIndex != DexConsts.NoIndex && nameIndex >= 0)  								name = Dex.Strings[(int)nameIndex];  							ins.Operands.Add(name);  							break;  						case DebugOpCodes.StartLocalExtended:  						case DebugOpCodes.StartLocal:  							// StartLocalExtended : uleb128 register_num' uleb128p1 name_idx' uleb128p1 type_idx' uleb128p1 sig_idx  							// StartLocal : uleb128 register_num' uleb128p1 name_idx' uleb128p1 type_idx  							var isExtended = ins.OpCode == DebugOpCodes.StartLocalExtended;    							registerIndex = reader.ReadULEB128();  							ins.Operands.Add(mdef.Body.Registers[(int)registerIndex]);    							nameIndex = reader.ReadULEB128P1();  							name = null;  							if (nameIndex != DexConsts.NoIndex && nameIndex >= 0)  								name = Dex.Strings[(int)nameIndex];  							ins.Operands.Add(name);    							var typeIndex = reader.ReadULEB128P1();  							TypeReference type = null;  							if (typeIndex != DexConsts.NoIndex && typeIndex >= 0)  								type = Dex.TypeReferences[(int)typeIndex];  							ins.Operands.Add(type);    							if (isExtended)  							{  								var signatureIndex = reader.ReadULEB128P1();  								string signature = null;  								if (signatureIndex != DexConsts.NoIndex && signatureIndex >= 0)  									signature = Dex.Strings[(int)signatureIndex];  								ins.Operands.Add(signature);  							}    							break;  						case DebugOpCodes.EndSequence:  							return;  							//case DebugOpCodes.Special:  							// between 0x0a and 0xff (inclusive)  							//case DebugOpCodes.SetPrologueEnd:  							//case DebugOpCodes.SetEpilogueBegin:  							//default:  							//    break;  					}
Missing Default,Dexer.Metadata,TypeDescriptor,C:\repos\sailro_Dexer\Dexer\Metadata\TypeDescriptor.cs,Allocate,The following switch statement is missing a default case: switch (td)  				{  					case TypeDescriptors.Boolean:  						return PrimitiveType.Boolean;  					case TypeDescriptors.Byte:  						return PrimitiveType.Byte;  					case TypeDescriptors.Char:  						return PrimitiveType.Char;  					case TypeDescriptors.Double:  						return PrimitiveType.Double;  					case TypeDescriptors.Float:  						return PrimitiveType.Float;  					case TypeDescriptors.Int:  						return PrimitiveType.Int;  					case TypeDescriptors.Long:  						return PrimitiveType.Long;  					case TypeDescriptors.Short:  						return PrimitiveType.Short;  					case TypeDescriptors.Void:  						return PrimitiveType.Void;  					case TypeDescriptors.Array:  						return new ArrayType();  					case TypeDescriptors.FullyQualifiedName:  						return new ClassReference();  				}
Missing Default,Dexer.Metadata,TypeDescriptor,C:\repos\sailro_Dexer\Dexer\Metadata\TypeDescriptor.cs,Fill,The following switch statement is missing a default case: switch (td)  				{  					case TypeDescriptors.Array:  						var atype = (ArrayType)item;    						TypeReference elementType = Allocate(tdString.Substring(1));  						Fill(tdString.Substring(1)' elementType' context);    						/* All types are already allocated                           * We want to reuse object reference if already in type repository                           * BUT if not' we don't want to add a new reference to this type:                           * it's a 'transient' type only used in the Dexer object model but                           * not persisted in dex file.                           */  						atype.ElementType = context.Import(elementType' false);    						break;  					case TypeDescriptors.FullyQualifiedName:  						var cref = (ClassReference)item;  						cref.Fullname = tdString.Substring(1' tdString.Length - 2);  						break;  				}
