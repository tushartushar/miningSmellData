Implementation smell,Namespace,Class,File,Method,Description
Long Method,SevenZip.Compression.LZMA,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,Code,The method has 114 lines of code.
Long Method,ExcelDna.Loader,XlObject12Marshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalNativeToManaged,The method has 126 lines of code.
Long Method,ExcelDna.Loader,XlObject12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The method has 192 lines of code.
Long Method,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The method has 389 lines of code.
Long Method,ExcelDna.Loader,XlObjectMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The method has 192 lines of code.
Long Method,ExcelDna.Loader,XlObjectMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The method has 114 lines of code.
Long Method,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The method has 329 lines of code.
Long Method,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The method has 104 lines of code.
Long Method,ExcelDna.Loader,XlMethodInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,SetAttributeInfo,The method has 161 lines of code.
Long Method,ExcelDna.Loader,XlMethodInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodInfo,The method has 126 lines of code.
Long Method,ExcelDna.Loader,XlParameterInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlParameterInfo.cs,SetTypeInfo4,The method has 264 lines of code.
Long Method,ExcelDna.Loader,XlParameterInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlParameterInfo.cs,SetTypeInfo12,The method has 269 lines of code.
Long Method,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The method has 139 lines of code.
Complex Method,ExcelDna.Loader,AssemblyManager,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,AssemblyResolve,Cyclomatic complexity of the method is 9
Complex Method,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,Cyclomatic complexity of the method is 16
Complex Method,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,Cyclomatic complexity of the method is 16
Complex Method,ExcelDna.Loader,XlMethodInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,SetAttributeInfo,Cyclomatic complexity of the method is 8
Complex Method,ExcelDna.Loader,XlMethodInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodInfo,Cyclomatic complexity of the method is 15
Complex Method,ExcelDna.Loader,XlMethodInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,GetMethodAttributes,Cyclomatic complexity of the method is 11
Complex Method,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,Cyclomatic complexity of the method is 19
Long Parameter List,SevenZip,ICoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\ICoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.LZMA,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.RangeCoder,BitTreeEncoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Parameter List,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationMarshalHelpers.cs,CreateExcelReference,The method has 5 parameters. Parameters: rowFirst' rowLast' columnFirst' columnLast' sheetId
Long Parameter List,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,AddCommandMenu,The method has 6 parameters. Parameters: commandName' menuName' menuText' description' shortCut' helpTopic
Long Identifier,SevenZip.Compression.LZMA,Base,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Identifier,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationMarshalHelpers.cs,,The length of the parameter excelReferenceConstructorRects is 30.
Long Identifier,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationMarshalHelpers.cs,,The length of the parameter excelReferenceGetRectangleCount is 31.
Long Identifier,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationMarshalHelpers.cs,,The length of the parameter excelAsyncHandleNativeConstructor is 33.
Long Identifier,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationMarshalHelpers.cs,,The length of the parameter excelAsyncHandleNativeHandleField is 33.
Long Statement,ExcelDna.Loader,AssemblyManager,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,AssemblyResolve,The length of the statement  "                    Logger.Initialization.Verbose("Assembly {0} could not be loaded from resources (ResourceManager probing for satellite assemblies)."' name); " is 139.
Long Statement,ExcelDna.Loader,AssemblyManager,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,GetResourceBytes,The length of the statement  "                throw new ArgumentOutOfRangeException("type"' "Unknown resource type. Only types 0 (Assembly)' 1 (Dna file)' 2 (Image) or 3 (Source) are valid."); " is 146.
Long Statement,ExcelDna.Loader,ResourceHelper,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,LoadResourceBytes,The length of the statement  "                    Debug.Print("ResourceHelper.LoadResourceBytes - Resource not found - resource {0} of type {1}"' resourceName' typeName); " is 120.
Long Statement,ExcelDna.Loader,ResourceHelper,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,LoadResourceBytes,The length of the statement  "                Debug.Print("ResourceHelper.LoadResourceBytes - Unexpected errror loading resource {0} of type {1}"' resourceName' typeName); " is 125.
Long Statement,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationMarshalHelpers.cs,Bind,The length of the statement  "            excelReferenceConstructor = excelReferenceType.GetConstructor(new Type[] { typeof(int)' typeof(int)' typeof(int)' typeof(int)' typeof(IntPtr) }); " is 145.
Long Statement,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationMarshalHelpers.cs,Bind,The length of the statement  "            excelReferenceGetRectangleCount = excelReferenceType.GetMethod("GetRectangleCount"' BindingFlags.NonPublic | BindingFlags.Instance); " is 132.
Long Statement,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationMarshalHelpers.cs,Bind,The length of the statement  "            excelReferenceGetRectangles = excelReferenceType.GetMethod("GetRectangles"' BindingFlags.NonPublic | BindingFlags.Instance); " is 124.
Long Statement,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationMarshalHelpers.cs,Bind,The length of the statement  "            excelAsyncHandleNativeConstructor = excelAsyncHandleNativeType.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic' null' new Type[] { typeof(IntPtr) }' null); " is 169.
Long Statement,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationMarshalHelpers.cs,Bind,The length of the statement  "            excelAsyncHandleNativeHandleField = excelAsyncHandleNativeType.GetField("_handle"' BindingFlags.Instance | BindingFlags.NonPublic); " is 131.
Long Statement,ExcelDna.Loader,XlDoubleArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,AllocateFP12AndCopy,The length of the statement  "                // CONSIDER: https://connect.microsoft.com/VisualStudio/feedback/details/766977/il-bytecode-method-cpblk-badly-implemented-by-x86-clr " is 133.
Long Statement,ExcelDna.Loader,XlObject12Marshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalNativeToManaged,The length of the statement  "                        // XlOper12.XlRectangle12* pAreas = (XlOper12.XlRectangle12*)((uint)pOper->refValue.pMultiRef + 4 /* FieldOffset for XlRectangles */); " is 134.
Long Statement,ExcelDna.Loader,XlObject12Marshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalNativeToManaged,The length of the statement  "                        XlOper12.XlRectangle12* pAreas = (XlOper12.XlRectangle12*)((byte*)(pOper->refValue.pMultiRef) + 4 /* FieldOffset for XlRectangles */); " is 134.
Long Statement,ExcelDna.Loader,XlObject12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The length of the statement  "				// Debug.Print("Getting XlObject12Marshaler instance for thread: " + System.Threading.Thread.CurrentThread.ManagedThreadId); " is 124.
Long Statement,ExcelDna.Loader,XlObject12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The length of the statement  "				// Debug.Print("Returning XlObject12Marshaler instance with Id {0} for thread {1}"' instance.instanceId' System.Threading.Thread.CurrentThread.ManagedThreadId); " is 160.
Long Statement,ExcelDna.Loader,XlObject12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The length of the statement  "				// Debug.Print("XlObject12Marshaler {0} - Marshaling for thread {1} "' instanceId' System.Threading.Thread.CurrentThread.ManagedThreadId); " is 138.
Long Statement,ExcelDna.Loader,XlObject12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The length of the statement  "                    // To avoid extra memory management in this class' wrap in an array and let the array marshaler deal with the reference. " is 120.
Long Statement,ExcelDna.Loader,XlObjectArray12Marshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,Dispose,The length of the statement  "			// Debug.Print("Disposing XlObjectArray12Marshaler with id {0} for thread {1}"' id' System.Threading.Thread.CurrentThread.ManagedThreadId); " is 139.
Long Statement,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The length of the statement  "						cbNativeStrings += (Marshal.SizeOf(typeof(XlString12)) + ((Math.Min(str.Length' XlString12.MaxLength) - 1) /* 1 char already in XlString */) * 2 /* 2 bytes per char */); " is 169.
Long Statement,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The length of the statement  "						numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount(obj); // ((ExcelReference)obj).InnerReferences.Count; " is 128.
Long Statement,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,Dispose,The length of the statement  "			    // Debug.Print("Disposing XlObjectArray12MarshalerImpl with id {0} for thread {1}"' id' System.Threading.Thread.CurrentThread.ManagedThreadId); " is 143.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,CreateUnhandledExceptionHandlerWrapper,The length of the statement  "			MethodInfo unhandledExceptionHandler = integrationType.GetMethod("HandleUnhandledException"' BindingFlags.Static | BindingFlags.NonPublic); " is 139.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,CreateUnhandledExceptionHandlerWrapper,The length of the statement  "            DynamicMethod ueh = new DynamicMethod("UnhandledExceptionHandler"' typeof(object)' new Type[] { typeof(object) }' true); " is 120.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DnaLibraryAutoOpen,The length of the statement  "            integrationType.InvokeMember("DnaLibraryAutoOpen"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 143.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DnaLibraryAutoClose,The length of the statement  "            integrationType.InvokeMember("DnaLibraryAutoClose"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 144.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DnaLibraryGetName,The length of the statement  "            return (string)integrationType.InvokeMember("DnaLibraryGetName"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 157.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllRegisterServer,The length of the statement  "            return (HRESULT)integrationType.InvokeMember("DllRegisterServer"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 158.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllUnregisterServer,The length of the statement  "            return (HRESULT)integrationType.InvokeMember("DllUnregisterServer"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 160.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllGetClassObject,The length of the statement  "            result = (HRESULT)integrationType.InvokeMember("DllGetClassObject"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' args); " is 160.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllCanUnloadNow,The length of the statement  "            return (HRESULT)integrationType.InvokeMember("DllCanUnloadNow"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 156.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,InitializeIntegration,The length of the statement  "            integrationType.InvokeMember("Initialize"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] {xllPath});         " is 153.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DeInitializeIntegration,The length of the statement  "            integrationType.InvokeMember("DeInitialize"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 137.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,SyncMacro,The length of the statement  "            integrationType.InvokeMember("SyncMacro"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] {dValue}); " is 151.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,CalculationCanceled,The length of the statement  "            integrationType.InvokeMember("CalculationCanceled"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 144.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,CalculationEnded,The length of the statement  "            integrationType.InvokeMember("CalculationEnded"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 141.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,GetIntegrationTraceSource,The length of the statement  "            return (System.Diagnostics.TraceSource)integrationType.InvokeMember("GetIntegrationTraceSource"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 189.
Long Statement,ExcelDna.Loader,XlCallImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCallImpl.cs,GetCurrentSheetId12,The length of the statement  "                // CONSIDER: As a small optimisation' we could combine the two calls the xlFree. But then we'd have to manage an array here. " is 124.
Long Statement,ExcelDna.Loader,XlObjectMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The length of the statement  "                // To avoid extra memory management in this class' wrap in an array and let the array marshaler deal with the reference. " is 120.
Long Statement,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The length of the statement  "                    numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount(obj); // ((ExcelReference)obj).InnerReferences.Count; " is 128.
Long Statement,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The length of the statement  "                int cbNativeReferences = numReferenceOpers * sizeof(ushort) + numReferences * Marshal.SizeOf(typeof(XlOper.XlRectangle)); " is 121.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The length of the statement  "            Debug.Print("In sandbox AppDomain with Id: {0}' running on thread: {1}"' AppDomain.CurrentDomain.Id' Thread.CurrentThread.ManagedThreadId); " is 139.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The length of the statement  "            // File.AppendAllText(Path.ChangeExtension(pathXll' ".log")' string.Format("{0:u} XlAddIn.Initialize OK\r\n"' DateTime.Now)); " is 125.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            // Get the assembly and ExcelIntegration type - will be loaded from file or from packed resources via AssemblyManager.AssemblyResolve. " is 134.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            int integrationVersion = (int)integrationType.InvokeMember("GetExcelIntegrationVersion"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 181.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            MethodInfo tryExcelImplMethod = typeof(XlCallImpl).GetMethod("TryExcelImpl"' BindingFlags.Static | BindingFlags.Public); " is 120.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            integrationType.InvokeMember("SetTryExcelImpl"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] { tryExcelImplDelegate }); " is 173.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            MethodInfo registerMethodsMethod = typeof(XlRegistration).GetMethod("RegisterMethods"' BindingFlags.Static | BindingFlags.Public); " is 130.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            integrationType.InvokeMember("SetRegisterMethods"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] { registerMethodsDelegate }); " is 179.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            MethodInfo registerWithAttMethod = typeof(XlRegistration).GetMethod("RegisterMethodsWithAttributes"' BindingFlags.Static | BindingFlags.Public); " is 144.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            Type registerWithAttDelegateType = integrationAssembly.GetType("ExcelDna.Integration.RegisterMethodsWithAttributesDelegate"); " is 125.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            integrationType.InvokeMember("SetRegisterMethodsWithAttributes"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] { registerWithAttDelegate }); " is 193.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            MethodInfo registerDelAttMethod = typeof(XlRegistration).GetMethod("RegisterDelegatesWithAttributes"' BindingFlags.Static | BindingFlags.Public); " is 145.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            Type registerDelAttDelegateType = integrationAssembly.GetType("ExcelDna.Integration.RegisterDelegatesWithAttributesDelegate"); " is 126.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            integrationType.InvokeMember("SetRegisterDelegatesWithAttributes"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] { registerDelAttDelegate }); " is 194.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            MethodInfo getResourceBytesMethod = typeof(AssemblyManager).GetMethod("GetResourceBytes"' BindingFlags.Static | BindingFlags.NonPublic); " is 136.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            integrationType.InvokeMember("SetGetResourceBytesDelegate"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] { getResourceBytesDelegate }); " is 189.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,XlAutoOpen,The length of the statement  "            Debug.Print("XlAddIn.XlAutoOpen - AppDomain Id: " + AppDomain.CurrentDomain.Id + " (Default: " + AppDomain.CurrentDomain.IsDefaultAppDomain() + ")"); " is 149.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,XlAutoOpen,The length of the statement  "                string alertMessage = string.Format("A problem occurred while an add-in was being initialized (InitializeIntegration failed - {1}).\r\nThe add-in is built with ExcelDna and is being loaded from {0}"' pathXll' e.Message); " is 220.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,XlAutoOpen,The length of the statement  "				XlCallImpl.TryExcelImpl(XlCallImpl.xlcAlert' out xlCallResult /*Ignored*/' alertMessage ' 3 /* Only OK Button' Warning Icon*/); " is 127.
Long Statement,ExcelDna.Loader,XlMethodInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateDelegateTypeAndMethodInfo,The length of the statement  "            //           Future version might do straight-forward marshaling' so we can get rid of these types (just use generic methods) " is 125.
Long Statement,ExcelDna.Loader,XlMethodInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,ConvertToXlMethodInfos,The length of the statement  "                        Logger.Registration.Info("Suppressing due to ExplictRegistration attribute: '{0}.{1}'"' mi.DeclaringType.Name' mi.Name); " is 120.
Long Statement,ExcelDna.Loader,XlMethodInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,ConvertToXlMethodInfos,The length of the statement  "                    Logger.Registration.Error(e' "Method not registered due to unsupported signature: '{0}.{1}'"' mi.DeclaringType.Name' mi.Name); " is 126.
Long Statement,ExcelDna.Loader,XlParameterInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlParameterInfo.cs,GetMarshalAsAttribute,The length of the statement  "								new FieldInfo[] { typeof(MarshalAsAttribute).GetField("MarshalTypeRef")' typeof(MarshalAsAttribute).GetField("MarshalCookie") }' " is 128.
Long Statement,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,Register,The length of the statement  "            List<XlMethodInfo> xlMethods = XlMethodInfo.ConvertToXlMethodInfos(methods' targets' methodAttributes' argumentAttributes); " is 123.
Long Statement,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,Register,The length of the statement  "            // Sort by name in reverse order before registering - this is inspired by the article http://www.benf.org/excel/regcost/ " is 120.
Long Statement,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,Register,The length of the statement  "            xlMethods.Sort(delegate (XlMethodInfo mi1' XlMethodInfo mi2) { return -string.Compare(mi1.Name' mi2.Name' StringComparison.OrdinalIgnoreCase); }); " is 146.
Long Statement,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,RegisterXlMethod,The length of the statement  "            if (registrationInfo.Exists(ri => ((string)ri[3]).Equals((string)registerParameters[3]' StringComparison.OrdinalIgnoreCase))) " is 125.
Long Statement,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,RegisterXlMethod,The length of the statement  "                    Logger.Registration.Info("Repeated function name: '{0}' - previous registration will be overwritten. "' registerParameters[3]); " is 127.
Long Statement,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,RegisterXlMethod,The length of the statement  "                    // This logged as an error' but the registration continues - the last function with the name wins' for backward compatibility. " is 126.
Long Statement,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,RegisterXlMethod,The length of the statement  "                    Logger.Registration.Error("Repeated function name: '{0}' - previous registration will be overwritten. "' registerParameters[3]); " is 128.
Long Statement,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,UnregisterMethods,The length of the statement  "                    XlCallImpl.TryExcelImpl(XlCallImpl.xlfRegister' out xlCallResult' XlAddIn.PathXll' "xlAutoRemove"' "I"' mi.Name' IntegrationMarshalHelpers.GetExcelMissingValue()' 2); " is 166.
Long Statement,ExcelDna.Loader.Logging,Logger,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\LoaderLogging.cs,Log,The length of the statement  "                //       The problem only happened when ExcelDna.Integration had to be resolved from resources (in which case the calls here would come from AssemblyResolve. " is 157.
Long Statement,ExcelDna.Loader.Logging,Logger,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\LoaderLogging.cs,Log,The length of the statement  "                //       Under the debugger' the problem was inconsistent (sometimes the load worked fine)' but outside the debugger it always failed. " is 134.
Complex Conditional,ExcelDna.Loader,AssemblyManager,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,GetAssemblyIfLoaded,The conditional expression  "(loadedName.CultureInfo == null) && (assemblyName.CultureInfo != null) ||                              (loadedName.CultureInfo != null) && (assemblyName.CultureInfo == null) ||                              !string.Equals(loadedName.CultureInfo.Name' assemblyName.CultureInfo.Name)"  is complex.
Complex Conditional,ExcelDna.Loader,XlMethodInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodInfo,The conditional expression  "IsExceptionSafe                  && Array.TrueForAll(Parameters'                                      delegate(XlParameterInfo pi) { return pi.BoxedValueType == null; })                  && (!HasReturnType || ReturnType.BoxedValueType == null)"  is complex.
Empty Catch Block,ExcelDna.Loader,XlCallImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCallImpl.cs,FetchExcel12EntryPt,The method has an empty catch block.
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize)  			{  				m_DictionarySize = dictionarySize;  				m_DictionarySizeCheck = Math.Max(m_DictionarySize' 1);  				uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));  				m_OutWindow.Create(blockSize);  			}
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64)  			{  				// UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);  					// while(nowPos64 < next)  				{  					uint posState = (uint)nowPos64 & m_PosStateMask;  					if (m_IsMatchDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)  					{  						byte b;  						byte prevByte = m_OutWindow.GetByte(0);  						if (!state.IsCharState())  							b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder'  								(uint)nowPos64' prevByte' m_OutWindow.GetByte(rep0));  						else  							b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder' (uint)nowPos64' prevByte);  						m_OutWindow.PutByte(b);  						state.UpdateChar();  						nowPos64++;  					}  					else  					{  						uint len;  						if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1)  						{  							if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0)  							{  								if (m_IsRep0LongDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)  								{  									state.UpdateShortRep();  									m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));  									nowPos64++;  									continue;  								}  							}  							else  							{  								UInt32 distance;  								if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0)  								{  									distance = rep1;  								}  								else  								{  									if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)  										distance = rep2;  									else  									{  										distance = rep3;  										rep3 = rep2;  									}  									rep2 = rep1;  								}  								rep1 = rep0;  								rep0 = distance;  							}  							len = m_RepLenDecoder.Decode(m_RangeDecoder' posState) + Base.kMatchMinLen;  							state.UpdateRep();  						}  						else  						{  							rep3 = rep2;  							rep2 = rep1;  							rep1 = rep0;  							len = Base.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder' posState);  							state.UpdateMatch();  							uint posSlot = m_PosSlotDecoder[Base.GetLenToPosState(len)].Decode(m_RangeDecoder);  							if (posSlot >= Base.kStartPosModelIndex)  							{  								int numDirectBits = (int)((posSlot >> 1) - 1);  								rep0 = ((2 | (posSlot & 1)) << numDirectBits);  								if (posSlot < Base.kEndPosModelIndex)  									rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders'  											rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  								else  								{  									rep0 += (m_RangeDecoder.DecodeDirectBits(  										numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  									rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);  								}  							}  							else  								rep0 = posSlot;  						}  						if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck)  						{  							if (rep0 == 0xFFFFFFFF)  								break;  							throw new DataErrorException();  						}  						m_OutWindow.CopyBlock(rep0' len);  						nowPos64 += len;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,SevenZip.Compression.LZMA,LiteralDecoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,SevenZip.Compression.LZMA,Decoder2,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do  					{  						uint matchBit = (uint)(matchByte >> 7) & 1;  						matchByte <<= 1;  						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);  						symbol = (symbol << 1) | bit;  						if (matchBit != bit)  						{  							while (symbol < 0x100)  								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);  							break;  						}  					}  					while (symbol < 0x100);
Magic Number,SevenZip.Compression.LZMA,Decoder2,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do  					{  						uint matchBit = (uint)(matchByte >> 7) & 1;  						matchByte <<= 1;  						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);  						symbol = (symbol << 1) | bit;  						if (matchBit != bit)  						{  							while (symbol < 0x100)  								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);  							break;  						}  					}  					while (symbol < 0x100);
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				ShiftLow();
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,Encode,The following statement contains a magic number: while (Range < kTopValue)  			{  				Range <<= 8;  				ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits - 1; i >= 0; i--)  			{  				Range >>= 1;  				if (((v >> i) & 1) == 1)  					Low += Range;  				if (Range < kTopValue)  				{  					Range <<= 8;  					ShiftLow();  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,EncodeBit,The following statement contains a magic number: while (Range < kTopValue)  			{  				Range <<= 8;  				ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize +  				Stream.Position - StartPosition + 4;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoderBit.cs,Encode,The following statement contains a magic number: if (encoder.Range < Encoder.kTopValue)  			{  				encoder.Range <<= 8;  				encoder.ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,ExcelDna.Loader,AssemblyManager,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,GetResourceBytes,The following statement contains a magic number: if (type == 0)  			{  				typeName = "ASSEMBLY";  			}  			else if (type == 1)  			{  				typeName = "DNA";  			}              else if (type == 2)              {                  typeName = "IMAGE";              }              else if (type == 3)              {                  typeName = "SOURCE";              }              else              {                  throw new ArgumentOutOfRangeException("type"' "Unknown resource type. Only types 0 (Assembly)' 1 (Dna file)' 2 (Image) or 3 (Source) are valid.");              }
Magic Number,ExcelDna.Loader,AssemblyManager,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,GetResourceBytes,The following statement contains a magic number: if (type == 0)  			{  				typeName = "ASSEMBLY";  			}  			else if (type == 1)  			{  				typeName = "DNA";  			}              else if (type == 2)              {                  typeName = "IMAGE";              }              else if (type == 3)              {                  typeName = "SOURCE";              }              else              {                  throw new ArgumentOutOfRangeException("type"' "Unknown resource type. Only types 0 (Assembly)' 1 (Dna file)' 2 (Image) or 3 (Source) are valid.");              }
Magic Number,ExcelDna.Loader,ResourceHelper,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: byte[] properties2 = new byte[5];
Magic Number,ExcelDna.Loader,ResourceHelper,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: if (newInStream.Read(properties2' 0' 5) != 5)  				throw (new Exception("input .lzma is too short"));
Magic Number,ExcelDna.Loader,ResourceHelper,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: if (newInStream.Read(properties2' 0' 5) != 5)  				throw (new Exception("input .lzma is too short"));
Magic Number,ExcelDna.Loader,ResourceHelper,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				int v = newInStream.ReadByte();  				if (v < 0)  					throw (new Exception("Can't Read 1"));  				outSize |= ((long)(byte)v) << (8 * i);  			}
Magic Number,ExcelDna.Loader,ResourceHelper,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				int v = newInStream.ReadByte();  				if (v < 0)  					throw (new Exception("Can't Read 1"));  				outSize |= ((long)(byte)v) << (8 * i);  			}
Magic Number,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationMarshalHelpers.cs,SetExcelReference,The following statement contains a magic number: for (int i = 0; i < rectCount; i++)              {                  pRectangles[i].RowFirst = (ushort)rects[i][0];                  pRectangles[i].RowLast = (ushort)rects[i][1];                  pRectangles[i].ColumnFirst = (byte)rects[i][2];                  pRectangles[i].ColumnLast = (byte)rects[i][3];              }
Magic Number,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationMarshalHelpers.cs,SetExcelReference,The following statement contains a magic number: for (int i = 0; i < rectCount; i++)              {                  pRectangles[i].RowFirst = (ushort)rects[i][0];                  pRectangles[i].RowLast = (ushort)rects[i][1];                  pRectangles[i].ColumnFirst = (byte)rects[i][2];                  pRectangles[i].ColumnLast = (byte)rects[i][3];              }
Magic Number,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationMarshalHelpers.cs,SetExcelReference12,The following statement contains a magic number: for (int i = 0; i < rectCount; i++)              {                  pRectangles[i].RowFirst = rects[i][0];                  pRectangles[i].RowLast = rects[i][1];                  pRectangles[i].ColumnFirst = rects[i][2];                  pRectangles[i].ColumnLast = rects[i][3];              }
Magic Number,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationMarshalHelpers.cs,SetExcelReference12,The following statement contains a magic number: for (int i = 0; i < rectCount; i++)              {                  pRectangles[i].RowFirst = rects[i][0];                  pRectangles[i].RowLast = rects[i][1];                  pRectangles[i].ColumnFirst = rects[i][2];                  pRectangles[i].ColumnLast = rects[i][3];              }
Magic Number,ExcelDna.Loader,XlString12ReturnMarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,XlString12ReturnMarshalerImpl,The following statement contains a magic number: int size = Marshal.SizeOf(typeof(XlString12)) + ((XlString12.MaxLength - 1) /* 1 char is in Data[1] */ * 2 /* 2 bytes per char */);
Magic Number,ExcelDna.Loader,XlDoubleArray12Marshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The following statement contains a magic number: if (marshalCookie == "1")  			{  				if (instance1 == null)  				{  					instance1 = new XlDoubleArray12Marshaler(1);  				}  				return instance1;  			}  			else if (marshalCookie == "2")  			{  				if (instance2 == null)  					instance2 = new XlDoubleArray12Marshaler(2);  				return instance2;  			}
Magic Number,ExcelDna.Loader,XlDoubleArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The following statement contains a magic number: if (rank == 1)  				{  					if (instance1 == null)  						instance1 = new XlDoubleArray12MarshalerImpl(1);  					return instance1;  				}  				else if (rank == 2)  				{  					if (instance2 == null)  						instance2 = new XlDoubleArray12MarshalerImpl(2);  					return instance2;  				}
Magic Number,ExcelDna.Loader,XlDoubleArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The following statement contains a magic number: if (rank == 1)  				{  					if (instance1 == null)  						instance1 = new XlDoubleArray12MarshalerImpl(1);  					return instance1;  				}  				else if (rank == 2)  				{  					if (instance2 == null)  						instance2 = new XlDoubleArray12MarshalerImpl(2);  					return instance2;  				}
Magic Number,ExcelDna.Loader,XlDoubleArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: if (rank == 1)  				{  					double[] doubles = (double[])ManagedObj;    					rows = 1;  					columns = doubles.Length;                        // Guard against invalid arrays - with no columns.                      // Just return null' which Excel will turn into #NUM                      if (columns == 0)                          return IntPtr.Zero;    					fixed (double* src = doubles)  					{  						AllocateFP12AndCopy(src' rows' columns);  					}  				}  				else if (rank == 2)  				{  					double['] doubles = (double['])ManagedObj;    					rows = doubles.GetLength(0);  					columns = doubles.GetLength(1);                        // Guard against invalid arrays - with no rows or no columns.                      // Just return null' which Excel will turn into #NUM                      if (rows == 0 || columns == 0)                          return IntPtr.Zero;    					fixed (double* src = doubles)  					{  						AllocateFP12AndCopy(src' rows' columns);  					}  				}  				else  				{  					throw new InvalidOperationException("Damaged XlDoubleArrayMarshaler rank");  				}
Magic Number,ExcelDna.Loader,XlDoubleArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalNativeToManaged,The following statement contains a magic number: if (rank == 1)  				{  					double[] array;  					if (pFP->Columns == 1)  					{  						// Take the one and only column as the array  						array = new double[pFP->Rows];  					}  					else  					{  						// Take only the first row of the array.  						array = new double[pFP->Columns];  					}  					// Copy works for either case' due to in-memory layout!  					fixed (double* dest = array)  					{  						CopyDoubles(pFP->Values' dest' array.Length);  					}  					result = array;  				}  				else if (rank == 2)  				{  					double['] array = new double[pFP->Rows' pFP->Columns];  					fixed (double* dest = array)  					{  						CopyDoubles(pFP->Values' dest' array.Length);  					}  					result = array;  				}  				else  				{  					Debug.Fail("Damaged XlDoubleArray12Marshaler rank");  					throw new InvalidOperationException("Damaged XlDoubleArray12Marshaler rank");  				}
Magic Number,ExcelDna.Loader,XlObject12Marshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalNativeToManaged,The following statement contains a magic number: switch (type)              {                  case XlType12.XlTypeNumber:                      double val = pOper->numValue;                      if (val == 0.0)                          managed = boxedZero;                      else if (val == 1.0)                          managed = boxedOne;                      else                          managed = val;                      break;                  case XlType12.XlTypeString:                      XlString12* pString = pOper->pstrValue;                      managed = new string(pString->Data' 0' pString->Length);                      break;                  case XlType12.XlTypeBoolean:                      managed = pOper->boolValue == 1;                      break;                  case XlType12.XlTypeError:                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(pOper->errValue);                      break;                  case XlType12.XlTypeMissing:                      // DOCUMENT: Changed in version 0.17.                      // managed = System.Reflection.Missing.Value;                      managed = IntegrationMarshalHelpers.GetExcelMissingValue();                      break;                  case XlType12.XlTypeEmpty:                      // DOCUMENT: Changed in version 0.17.                      // managed = null;                      managed = excelEmpty; // IntegrationMarshalHelpers.GetExcelEmptyValue();                      break;                  case XlType12.XlTypeArray:                      int rows = pOper->arrayValue.Rows;                      int columns = pOper->arrayValue.Columns;                      object['] array = new object[rows' columns];                      // TODO: Initialize as ExcelEmpty                      XlOper12* opers = (XlOper12*)pOper->arrayValue.pOpers;                      for (int i = 0; i < rows; i++)                      {                          int rowStart = i * columns;                          for (int j = 0; j < columns; j++)                          {                              int pos = rowStart + j;                              XlOper12* oper = opers + pos;                              // Fast-path for some cases                              if (oper->xlType == XlType12.XlTypeEmpty)                              {                                  array[i' j] = excelEmpty;                              }                              else if (oper->xlType == XlType12.XlTypeNumber)                              {                                  double dval = oper->numValue;                                  if (dval == 0.0)                                      array[i' j] = boxedZero;                                  else if (dval == 1.0)                                      array[i' j] = boxedOne;                                  else                                      array[i' j] = dval;                              }                              else                              {                                  array[i' j] = MarshalNativeToManaged((IntPtr)oper);                              }                          }                      }                      managed = array;                      break;                  case XlType12.XlTypeReference:                      object /*ExcelReference*/ r;                      if (pOper->refValue.pMultiRef == (XlOper12.XlMultiRef12*)IntPtr.Zero)                      {                          r = IntegrationMarshalHelpers.CreateExcelReference(0' 0' 0' 0' pOper->refValue.SheetId);                      }                      else                      {                          ushort numAreas = *(ushort*)pOper->refValue.pMultiRef;                          // XlOper12.XlRectangle12* pAreas = (XlOper12.XlRectangle12*)((uint)pOper->refValue.pMultiRef + 4 /* FieldOffset for XlRectangles */);                          XlOper12.XlRectangle12* pAreas = (XlOper12.XlRectangle12*)((byte*)(pOper->refValue.pMultiRef) + 4 /* FieldOffset for XlRectangles */);                          if (numAreas == 1)                          {                                r = IntegrationMarshalHelpers.CreateExcelReference(                                  pAreas[0].RowFirst' pAreas[0].RowLast'                                  pAreas[0].ColumnFirst' pAreas[0].ColumnLast' pOper->refValue.SheetId);                          }                          else                          {                              int[][] areas = new int[numAreas][];                              for (int i = 0; i < numAreas; i++)                              {                                  XlOper12.XlRectangle12 rect = pAreas[i];                                  int[] area = new int[4] { rect.RowFirst' rect.RowLast'                                                            rect.ColumnFirst' rect.ColumnLast };                                  areas[i] = area;                              }                              r = IntegrationMarshalHelpers.CreateExcelReference(areas' pOper->refValue.SheetId);                          }                      }                      managed = r;                      break;                  case XlType12.XlTypeSReference:                      IntPtr sheetId = XlCallImpl.GetCurrentSheetId12();                      object /*ExcelReference*/ sref;                      sref = IntegrationMarshalHelpers.CreateExcelReference(                                              pOper->srefValue.Reference.RowFirst'                                              pOper->srefValue.Reference.RowLast'                                              pOper->srefValue.Reference.ColumnFirst'                                              pOper->srefValue.Reference.ColumnLast'                                              sheetId /*Current sheet (not active sheet)*/);                      managed = sref;                      break;                  case XlType12.XlTypeInt: // Never passed from Excel to a UDF! int32 in XlOper12                      managed = (double)pOper->intValue;                      break;                  default:                      // unheard of !!                      managed = null;                      break;              }
Magic Number,ExcelDna.Loader,XlObject12Marshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalNativeToManaged,The following statement contains a magic number: switch (type)              {                  case XlType12.XlTypeNumber:                      double val = pOper->numValue;                      if (val == 0.0)                          managed = boxedZero;                      else if (val == 1.0)                          managed = boxedOne;                      else                          managed = val;                      break;                  case XlType12.XlTypeString:                      XlString12* pString = pOper->pstrValue;                      managed = new string(pString->Data' 0' pString->Length);                      break;                  case XlType12.XlTypeBoolean:                      managed = pOper->boolValue == 1;                      break;                  case XlType12.XlTypeError:                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(pOper->errValue);                      break;                  case XlType12.XlTypeMissing:                      // DOCUMENT: Changed in version 0.17.                      // managed = System.Reflection.Missing.Value;                      managed = IntegrationMarshalHelpers.GetExcelMissingValue();                      break;                  case XlType12.XlTypeEmpty:                      // DOCUMENT: Changed in version 0.17.                      // managed = null;                      managed = excelEmpty; // IntegrationMarshalHelpers.GetExcelEmptyValue();                      break;                  case XlType12.XlTypeArray:                      int rows = pOper->arrayValue.Rows;                      int columns = pOper->arrayValue.Columns;                      object['] array = new object[rows' columns];                      // TODO: Initialize as ExcelEmpty                      XlOper12* opers = (XlOper12*)pOper->arrayValue.pOpers;                      for (int i = 0; i < rows; i++)                      {                          int rowStart = i * columns;                          for (int j = 0; j < columns; j++)                          {                              int pos = rowStart + j;                              XlOper12* oper = opers + pos;                              // Fast-path for some cases                              if (oper->xlType == XlType12.XlTypeEmpty)                              {                                  array[i' j] = excelEmpty;                              }                              else if (oper->xlType == XlType12.XlTypeNumber)                              {                                  double dval = oper->numValue;                                  if (dval == 0.0)                                      array[i' j] = boxedZero;                                  else if (dval == 1.0)                                      array[i' j] = boxedOne;                                  else                                      array[i' j] = dval;                              }                              else                              {                                  array[i' j] = MarshalNativeToManaged((IntPtr)oper);                              }                          }                      }                      managed = array;                      break;                  case XlType12.XlTypeReference:                      object /*ExcelReference*/ r;                      if (pOper->refValue.pMultiRef == (XlOper12.XlMultiRef12*)IntPtr.Zero)                      {                          r = IntegrationMarshalHelpers.CreateExcelReference(0' 0' 0' 0' pOper->refValue.SheetId);                      }                      else                      {                          ushort numAreas = *(ushort*)pOper->refValue.pMultiRef;                          // XlOper12.XlRectangle12* pAreas = (XlOper12.XlRectangle12*)((uint)pOper->refValue.pMultiRef + 4 /* FieldOffset for XlRectangles */);                          XlOper12.XlRectangle12* pAreas = (XlOper12.XlRectangle12*)((byte*)(pOper->refValue.pMultiRef) + 4 /* FieldOffset for XlRectangles */);                          if (numAreas == 1)                          {                                r = IntegrationMarshalHelpers.CreateExcelReference(                                  pAreas[0].RowFirst' pAreas[0].RowLast'                                  pAreas[0].ColumnFirst' pAreas[0].ColumnLast' pOper->refValue.SheetId);                          }                          else                          {                              int[][] areas = new int[numAreas][];                              for (int i = 0; i < numAreas; i++)                              {                                  XlOper12.XlRectangle12 rect = pAreas[i];                                  int[] area = new int[4] { rect.RowFirst' rect.RowLast'                                                            rect.ColumnFirst' rect.ColumnLast };                                  areas[i] = area;                              }                              r = IntegrationMarshalHelpers.CreateExcelReference(areas' pOper->refValue.SheetId);                          }                      }                      managed = r;                      break;                  case XlType12.XlTypeSReference:                      IntPtr sheetId = XlCallImpl.GetCurrentSheetId12();                      object /*ExcelReference*/ sref;                      sref = IntegrationMarshalHelpers.CreateExcelReference(                                              pOper->srefValue.Reference.RowFirst'                                              pOper->srefValue.Reference.RowLast'                                              pOper->srefValue.Reference.ColumnFirst'                                              pOper->srefValue.Reference.ColumnLast'                                              sheetId /*Current sheet (not active sheet)*/);                      managed = sref;                      break;                  case XlType12.XlTypeInt: // Never passed from Excel to a UDF! int32 in XlOper12                      managed = (double)pOper->intValue;                      break;                  default:                      // unheard of !!                      managed = null;                      break;              }
Magic Number,ExcelDna.Loader,XlObjectArray12Marshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The following statement contains a magic number: if (marshalCookie == "1")  			{  				if (instance1 == null)  				{  					instance1 = new XlObjectArray12Marshaler(1);  				}  				return instance1;  			}  			else if (marshalCookie == "2")  			{  				if (instance2 == null)  					instance2 = new XlObjectArray12Marshaler(2);  				return instance2;  			}
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The following statement contains a magic number: if (rank == 1)  				{  					if (instance1 == null)  						instance1 = new XlObjectArray12MarshalerImpl(1);  					return instance1;  				}  				else if (rank == 2)  				{  					if (instance2 == null)  						instance2 = new XlObjectArray12MarshalerImpl(2);  					return instance2;  				}
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The following statement contains a magic number: if (rank == 1)  				{  					if (instance1 == null)  						instance1 = new XlObjectArray12MarshalerImpl(1);  					return instance1;  				}  				else if (rank == 2)  				{  					if (instance2 == null)  						instance2 = new XlObjectArray12MarshalerImpl(2);  					return instance2;  				}
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: if (rank == 1)  				{  					object[] objects = (object[])ManagedObj;    					rows = 1;                      rowBase = 0;  					columns = objects.Length;                      columnBase = objects.GetLowerBound(0);  				}  				else if (rank == 2)  				{  					object['] objects = (object['])ManagedObj;    					rows = objects.GetLength(0);                      rowBase = objects.GetLowerBound(0);  					columns = objects.GetLength(1);                      columnBase = objects.GetLowerBound(0);  				}  				else  				{  					throw new InvalidOperationException("Damaged XlObjectArrayMarshaler rank");  				}
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: for (int i = 0; i < rows * columns; i++)  				{  					// Get the right object out of the array  					object obj;  					if (rank == 1)  					{  						obj = ((object[])ManagedObj)[columnBase + i];  					}  					else  					{  						int row = i / columns;  						int column = i % columns;  						obj = ((object['])ManagedObj)[rowBase + row' columnBase + column];  					}    					// Get the right pOper  					pOper = (XlOper12*)pNative + i + 1;    					// Set up the oper from the object  					if (obj is double)  					{  						pOper->numValue = (double)obj;  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is string)  					{  						// We count all of the string lengths'   						string str = (string)obj;  						cbNativeStrings += (Marshal.SizeOf(typeof(XlString12)) + ((Math.Min(str.Length' XlString12.MaxLength) - 1) /* 1 char already in XlString */) * 2 /* 2 bytes per char */);  						// mark the Oper as a string' and  						// later allocate memory and return to fix pointers  						pOper->xlType = XlType12.XlTypeString;  					}  					else if (obj is DateTime)  					{  						pOper->numValue = ((DateTime)obj).ToOADate();  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (IntegrationMarshalHelpers.IsExcelErrorObject(obj))  					{  						pOper->errValue = IntegrationMarshalHelpers.ExcelErrorGetValue(obj);  						pOper->xlType = XlType12.XlTypeError;  					}  					else if (IntegrationMarshalHelpers.IsExcelMissingObject(obj))  					{  						pOper->xlType = XlType12.XlTypeMissing;  					}  					else if (IntegrationMarshalHelpers.IsExcelEmptyObject(obj))  					{  						pOper->xlType = XlType12.XlTypeEmpty;  					}                      else if (IntegrationMarshalHelpers.IsExcelAsyncHandleNativeObject(obj))                      {                          IntPtr handle = IntegrationMarshalHelpers.GetExcelAsyncHandleNativeHandle(obj);                          pOper->bigData.hData = handle;                          pOper->bigData.cbData = IntPtr.Size;                          pOper->xlType = XlType12.XlTypeBigData;                      }  					else if (obj is bool)  					{  						pOper->boolValue = (bool)obj ? 1 : 0;  						pOper->xlType = XlType12.XlTypeBoolean;  					}  					else if (obj is byte)  					{  						pOper->numValue = (double)((byte)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is sbyte)  					{  						pOper->numValue = (double)((sbyte)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is short)  					{  						pOper->numValue = (double)((short)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is ushort)  					{  						pOper->numValue = (double)((ushort)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is int)  					{  						pOper->numValue = (double)((int)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is uint)  					{  						pOper->numValue = (double)((uint)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is long)  					{  						pOper->numValue = (double)((long)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is ulong)  					{  						pOper->numValue = (double)((ulong)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is decimal)  					{  						pOper->numValue = (double)((decimal)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is float)  					{  						pOper->numValue = (double)((float)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (IntegrationMarshalHelpers.IsExcelReferenceObject(obj))  					{  						pOper->xlType = XlType12.XlTypeReference;  						// First we count all of these'   						// later allocate memory and return to fix pointers  						numReferenceOpers++;  						numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount(obj); // ((ExcelReference)obj).InnerReferences.Count;  					}  					else if (obj is object[])  					{  						XlObjectArray12MarshalerImpl m = new XlObjectArray12MarshalerImpl(1);  						nestedInstances.Add(m);  						XlOper12* pNested = (XlOper12*)m.MarshalManagedToNative(obj);                          if (pNested->xlType == XlType12.XlTypeArray)                          {                              pOper->xlType = XlType12.XlTypeArray;                              pOper->arrayValue.Rows = pNested->arrayValue.Rows;                              pOper->arrayValue.Columns = pNested->arrayValue.Columns;                              pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                          }                          else                          {                              // This is the case where the array passed in has 0 length.                              // We set to an error to at least have a valid XLOPER                              pOper->xlType = XlType12.XlTypeError;                              pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                          }  					}  					else if (obj is object['])  					{  						XlObjectArray12MarshalerImpl m = new XlObjectArray12MarshalerImpl(2);  						nestedInstances.Add(m);  						XlOper12* pNested = (XlOper12*)m.MarshalManagedToNative(obj);                          if (pNested->xlType == XlType12.XlTypeArray)                          {  						    pOper->xlType = XlType12.XlTypeArray;  						    pOper->arrayValue.Rows = pNested->arrayValue.Rows;  						    pOper->arrayValue.Columns = pNested->arrayValue.Columns;  						    pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                          }                          else                          {                              // This is the case where the array passed in has 0'0 length.                              // We set to an error to at least have a valid XLOPER                              pOper->xlType = XlType12.XlTypeError;                              pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                          }  					}                      else if (obj is double[])                      {                          double[] doubles = (double[])obj;                          object[] objects = new object[doubles.Length];                          Array.Copy(doubles' objects' doubles.Length);    						XlObjectArray12MarshalerImpl m = new XlObjectArray12MarshalerImpl(1);  						nestedInstances.Add(m);  						XlOper12* pNested = (XlOper12*)m.MarshalManagedToNative(objects);                          if (pNested->xlType == XlType12.XlTypeArray)                          {                              pOper->xlType = XlType12.XlTypeArray;                              pOper->arrayValue.Rows = pNested->arrayValue.Rows;                              pOper->arrayValue.Columns = pNested->arrayValue.Columns;                              pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                          }                          else                          {                              // This is the case where the array passed in has 0 length.                              // We set to an error to at least have a valid XLOPER                              pOper->xlType = XlType12.XlTypeError;                              pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                          }                      }                      else if (obj is double['])                      {                          double['] doubles = (double['])obj;                          object['] objects = new object[doubles.GetLength(0)' doubles.GetLength(1)];                          Array.Copy(doubles' objects' doubles.GetLength(0) * doubles.GetLength(1));                            XlObjectArray12MarshalerImpl m = new XlObjectArray12MarshalerImpl(2);                          nestedInstances.Add(m);                          XlOper12* pNested = (XlOper12*)m.MarshalManagedToNative(objects);                          if (pNested->xlType == XlType12.XlTypeArray)                          {                              pOper->xlType = XlType12.XlTypeArray;                              pOper->arrayValue.Rows = pNested->arrayValue.Rows;                              pOper->arrayValue.Columns = pNested->arrayValue.Columns;                              pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                          }                          else                          {                              // This is the case where the array passed in has 0'0 length.                              // We set to an error to at least have a valid XLOPER                              pOper->xlType = XlType12.XlTypeError;                              pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                          }                      }                      else if (obj is Missing)  					{  						pOper->xlType = XlType12.XlTypeMissing;  					}  					else if (obj == null)  					{  						// DOCUMENT: I return Empty for nulls inside the Array'   						// which is not consistent with what happens in other settings.  						// In particular not consistent with the results of the XlObjectMarshaler  						// (which is not called when a null is returned'  						// and interpreted as ExcelErrorNum in Excel)  						// This works well for xlSet though.  						pOper->xlType = XlType12.XlTypeEmpty;  					}  					else  					{  						// Default error return  						pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  						pOper->xlType = XlType12.XlTypeError;  					}  				}
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: for (int i = 0; i < rows * columns; i++)  				{  					// Get the right object out of the array  					object obj;  					if (rank == 1)  					{  						obj = ((object[])ManagedObj)[columnBase + i];  					}  					else  					{  						int row = i / columns;  						int column = i % columns;  						obj = ((object['])ManagedObj)[rowBase + row' columnBase + column];  					}    					// Get the right pOper  					pOper = (XlOper12*)pNative + i + 1;    					// Set up the oper from the object  					if (obj is double)  					{  						pOper->numValue = (double)obj;  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is string)  					{  						// We count all of the string lengths'   						string str = (string)obj;  						cbNativeStrings += (Marshal.SizeOf(typeof(XlString12)) + ((Math.Min(str.Length' XlString12.MaxLength) - 1) /* 1 char already in XlString */) * 2 /* 2 bytes per char */);  						// mark the Oper as a string' and  						// later allocate memory and return to fix pointers  						pOper->xlType = XlType12.XlTypeString;  					}  					else if (obj is DateTime)  					{  						pOper->numValue = ((DateTime)obj).ToOADate();  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (IntegrationMarshalHelpers.IsExcelErrorObject(obj))  					{  						pOper->errValue = IntegrationMarshalHelpers.ExcelErrorGetValue(obj);  						pOper->xlType = XlType12.XlTypeError;  					}  					else if (IntegrationMarshalHelpers.IsExcelMissingObject(obj))  					{  						pOper->xlType = XlType12.XlTypeMissing;  					}  					else if (IntegrationMarshalHelpers.IsExcelEmptyObject(obj))  					{  						pOper->xlType = XlType12.XlTypeEmpty;  					}                      else if (IntegrationMarshalHelpers.IsExcelAsyncHandleNativeObject(obj))                      {                          IntPtr handle = IntegrationMarshalHelpers.GetExcelAsyncHandleNativeHandle(obj);                          pOper->bigData.hData = handle;                          pOper->bigData.cbData = IntPtr.Size;                          pOper->xlType = XlType12.XlTypeBigData;                      }  					else if (obj is bool)  					{  						pOper->boolValue = (bool)obj ? 1 : 0;  						pOper->xlType = XlType12.XlTypeBoolean;  					}  					else if (obj is byte)  					{  						pOper->numValue = (double)((byte)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is sbyte)  					{  						pOper->numValue = (double)((sbyte)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is short)  					{  						pOper->numValue = (double)((short)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is ushort)  					{  						pOper->numValue = (double)((ushort)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is int)  					{  						pOper->numValue = (double)((int)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is uint)  					{  						pOper->numValue = (double)((uint)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is long)  					{  						pOper->numValue = (double)((long)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is ulong)  					{  						pOper->numValue = (double)((ulong)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is decimal)  					{  						pOper->numValue = (double)((decimal)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is float)  					{  						pOper->numValue = (double)((float)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (IntegrationMarshalHelpers.IsExcelReferenceObject(obj))  					{  						pOper->xlType = XlType12.XlTypeReference;  						// First we count all of these'   						// later allocate memory and return to fix pointers  						numReferenceOpers++;  						numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount(obj); // ((ExcelReference)obj).InnerReferences.Count;  					}  					else if (obj is object[])  					{  						XlObjectArray12MarshalerImpl m = new XlObjectArray12MarshalerImpl(1);  						nestedInstances.Add(m);  						XlOper12* pNested = (XlOper12*)m.MarshalManagedToNative(obj);                          if (pNested->xlType == XlType12.XlTypeArray)                          {                              pOper->xlType = XlType12.XlTypeArray;                              pOper->arrayValue.Rows = pNested->arrayValue.Rows;                              pOper->arrayValue.Columns = pNested->arrayValue.Columns;                              pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                          }                          else                          {                              // This is the case where the array passed in has 0 length.                              // We set to an error to at least have a valid XLOPER                              pOper->xlType = XlType12.XlTypeError;                              pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                          }  					}  					else if (obj is object['])  					{  						XlObjectArray12MarshalerImpl m = new XlObjectArray12MarshalerImpl(2);  						nestedInstances.Add(m);  						XlOper12* pNested = (XlOper12*)m.MarshalManagedToNative(obj);                          if (pNested->xlType == XlType12.XlTypeArray)                          {  						    pOper->xlType = XlType12.XlTypeArray;  						    pOper->arrayValue.Rows = pNested->arrayValue.Rows;  						    pOper->arrayValue.Columns = pNested->arrayValue.Columns;  						    pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                          }                          else                          {                              // This is the case where the array passed in has 0'0 length.                              // We set to an error to at least have a valid XLOPER                              pOper->xlType = XlType12.XlTypeError;                              pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                          }  					}                      else if (obj is double[])                      {                          double[] doubles = (double[])obj;                          object[] objects = new object[doubles.Length];                          Array.Copy(doubles' objects' doubles.Length);    						XlObjectArray12MarshalerImpl m = new XlObjectArray12MarshalerImpl(1);  						nestedInstances.Add(m);  						XlOper12* pNested = (XlOper12*)m.MarshalManagedToNative(objects);                          if (pNested->xlType == XlType12.XlTypeArray)                          {                              pOper->xlType = XlType12.XlTypeArray;                              pOper->arrayValue.Rows = pNested->arrayValue.Rows;                              pOper->arrayValue.Columns = pNested->arrayValue.Columns;                              pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                          }                          else                          {                              // This is the case where the array passed in has 0 length.                              // We set to an error to at least have a valid XLOPER                              pOper->xlType = XlType12.XlTypeError;                              pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                          }                      }                      else if (obj is double['])                      {                          double['] doubles = (double['])obj;                          object['] objects = new object[doubles.GetLength(0)' doubles.GetLength(1)];                          Array.Copy(doubles' objects' doubles.GetLength(0) * doubles.GetLength(1));                            XlObjectArray12MarshalerImpl m = new XlObjectArray12MarshalerImpl(2);                          nestedInstances.Add(m);                          XlOper12* pNested = (XlOper12*)m.MarshalManagedToNative(objects);                          if (pNested->xlType == XlType12.XlTypeArray)                          {                              pOper->xlType = XlType12.XlTypeArray;                              pOper->arrayValue.Rows = pNested->arrayValue.Rows;                              pOper->arrayValue.Columns = pNested->arrayValue.Columns;                              pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                          }                          else                          {                              // This is the case where the array passed in has 0'0 length.                              // We set to an error to at least have a valid XLOPER                              pOper->xlType = XlType12.XlTypeError;                              pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                          }                      }                      else if (obj is Missing)  					{  						pOper->xlType = XlType12.XlTypeMissing;  					}  					else if (obj == null)  					{  						// DOCUMENT: I return Empty for nulls inside the Array'   						// which is not consistent with what happens in other settings.  						// In particular not consistent with the results of the XlObjectMarshaler  						// (which is not called when a null is returned'  						// and interpreted as ExcelErrorNum in Excel)  						// This works well for xlSet though.  						pOper->xlType = XlType12.XlTypeEmpty;  					}  					else  					{  						// Default error return  						pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  						pOper->xlType = XlType12.XlTypeError;  					}  				}
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: for (int i = 0; i < rows * columns; i++)  				{  					// Get the right object out of the array  					object obj;  					if (rank == 1)  					{  						obj = ((object[])ManagedObj)[columnBase + i];  					}  					else  					{  						int row = i / columns;  						int column = i % columns;  						obj = ((object['])ManagedObj)[rowBase + row' columnBase + column];  					}    					// Get the right pOper  					pOper = (XlOper12*)pNative + i + 1;    					// Set up the oper from the object  					if (obj is double)  					{  						pOper->numValue = (double)obj;  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is string)  					{  						// We count all of the string lengths'   						string str = (string)obj;  						cbNativeStrings += (Marshal.SizeOf(typeof(XlString12)) + ((Math.Min(str.Length' XlString12.MaxLength) - 1) /* 1 char already in XlString */) * 2 /* 2 bytes per char */);  						// mark the Oper as a string' and  						// later allocate memory and return to fix pointers  						pOper->xlType = XlType12.XlTypeString;  					}  					else if (obj is DateTime)  					{  						pOper->numValue = ((DateTime)obj).ToOADate();  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (IntegrationMarshalHelpers.IsExcelErrorObject(obj))  					{  						pOper->errValue = IntegrationMarshalHelpers.ExcelErrorGetValue(obj);  						pOper->xlType = XlType12.XlTypeError;  					}  					else if (IntegrationMarshalHelpers.IsExcelMissingObject(obj))  					{  						pOper->xlType = XlType12.XlTypeMissing;  					}  					else if (IntegrationMarshalHelpers.IsExcelEmptyObject(obj))  					{  						pOper->xlType = XlType12.XlTypeEmpty;  					}                      else if (IntegrationMarshalHelpers.IsExcelAsyncHandleNativeObject(obj))                      {                          IntPtr handle = IntegrationMarshalHelpers.GetExcelAsyncHandleNativeHandle(obj);                          pOper->bigData.hData = handle;                          pOper->bigData.cbData = IntPtr.Size;                          pOper->xlType = XlType12.XlTypeBigData;                      }  					else if (obj is bool)  					{  						pOper->boolValue = (bool)obj ? 1 : 0;  						pOper->xlType = XlType12.XlTypeBoolean;  					}  					else if (obj is byte)  					{  						pOper->numValue = (double)((byte)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is sbyte)  					{  						pOper->numValue = (double)((sbyte)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is short)  					{  						pOper->numValue = (double)((short)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is ushort)  					{  						pOper->numValue = (double)((ushort)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is int)  					{  						pOper->numValue = (double)((int)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is uint)  					{  						pOper->numValue = (double)((uint)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is long)  					{  						pOper->numValue = (double)((long)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is ulong)  					{  						pOper->numValue = (double)((ulong)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is decimal)  					{  						pOper->numValue = (double)((decimal)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (obj is float)  					{  						pOper->numValue = (double)((float)obj);  						pOper->xlType = XlType12.XlTypeNumber;  					}  					else if (IntegrationMarshalHelpers.IsExcelReferenceObject(obj))  					{  						pOper->xlType = XlType12.XlTypeReference;  						// First we count all of these'   						// later allocate memory and return to fix pointers  						numReferenceOpers++;  						numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount(obj); // ((ExcelReference)obj).InnerReferences.Count;  					}  					else if (obj is object[])  					{  						XlObjectArray12MarshalerImpl m = new XlObjectArray12MarshalerImpl(1);  						nestedInstances.Add(m);  						XlOper12* pNested = (XlOper12*)m.MarshalManagedToNative(obj);                          if (pNested->xlType == XlType12.XlTypeArray)                          {                              pOper->xlType = XlType12.XlTypeArray;                              pOper->arrayValue.Rows = pNested->arrayValue.Rows;                              pOper->arrayValue.Columns = pNested->arrayValue.Columns;                              pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                          }                          else                          {                              // This is the case where the array passed in has 0 length.                              // We set to an error to at least have a valid XLOPER                              pOper->xlType = XlType12.XlTypeError;                              pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                          }  					}  					else if (obj is object['])  					{  						XlObjectArray12MarshalerImpl m = new XlObjectArray12MarshalerImpl(2);  						nestedInstances.Add(m);  						XlOper12* pNested = (XlOper12*)m.MarshalManagedToNative(obj);                          if (pNested->xlType == XlType12.XlTypeArray)                          {  						    pOper->xlType = XlType12.XlTypeArray;  						    pOper->arrayValue.Rows = pNested->arrayValue.Rows;  						    pOper->arrayValue.Columns = pNested->arrayValue.Columns;  						    pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                          }                          else                          {                              // This is the case where the array passed in has 0'0 length.                              // We set to an error to at least have a valid XLOPER                              pOper->xlType = XlType12.XlTypeError;                              pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                          }  					}                      else if (obj is double[])                      {                          double[] doubles = (double[])obj;                          object[] objects = new object[doubles.Length];                          Array.Copy(doubles' objects' doubles.Length);    						XlObjectArray12MarshalerImpl m = new XlObjectArray12MarshalerImpl(1);  						nestedInstances.Add(m);  						XlOper12* pNested = (XlOper12*)m.MarshalManagedToNative(objects);                          if (pNested->xlType == XlType12.XlTypeArray)                          {                              pOper->xlType = XlType12.XlTypeArray;                              pOper->arrayValue.Rows = pNested->arrayValue.Rows;                              pOper->arrayValue.Columns = pNested->arrayValue.Columns;                              pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                          }                          else                          {                              // This is the case where the array passed in has 0 length.                              // We set to an error to at least have a valid XLOPER                              pOper->xlType = XlType12.XlTypeError;                              pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                          }                      }                      else if (obj is double['])                      {                          double['] doubles = (double['])obj;                          object['] objects = new object[doubles.GetLength(0)' doubles.GetLength(1)];                          Array.Copy(doubles' objects' doubles.GetLength(0) * doubles.GetLength(1));                            XlObjectArray12MarshalerImpl m = new XlObjectArray12MarshalerImpl(2);                          nestedInstances.Add(m);                          XlOper12* pNested = (XlOper12*)m.MarshalManagedToNative(objects);                          if (pNested->xlType == XlType12.XlTypeArray)                          {                              pOper->xlType = XlType12.XlTypeArray;                              pOper->arrayValue.Rows = pNested->arrayValue.Rows;                              pOper->arrayValue.Columns = pNested->arrayValue.Columns;                              pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                          }                          else                          {                              // This is the case where the array passed in has 0'0 length.                              // We set to an error to at least have a valid XLOPER                              pOper->xlType = XlType12.XlTypeError;                              pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                          }                      }                      else if (obj is Missing)  					{  						pOper->xlType = XlType12.XlTypeMissing;  					}  					else if (obj == null)  					{  						// DOCUMENT: I return Empty for nulls inside the Array'   						// which is not consistent with what happens in other settings.  						// In particular not consistent with the results of the XlObjectMarshaler  						// (which is not called when a null is returned'  						// and interpreted as ExcelErrorNum in Excel)  						// This works well for xlSet though.  						pOper->xlType = XlType12.XlTypeEmpty;  					}  					else  					{  						// Default error return  						pOper->errValue = IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  						pOper->xlType = XlType12.XlTypeError;  					}  				}
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: if (numReferenceOpers > 0)  				{  					// Allocate room for all the references  					int cbNativeReferences = numReferenceOpers * 4 /* sizeof ushort + packing to get to field offset */  											 + numReferences * Marshal.SizeOf(typeof(XlOper12.XlRectangle12));  					pNativeReferences = Marshal.AllocCoTaskMem(cbNativeReferences);  					IntPtr pCurrent = pNativeReferences;  					// Go through the Opers and set each reference  					int refOperIndex = 0;  					for (int i = 0; i < rows * columns && refOperIndex < numReferenceOpers; i++)  					{  						// Get the corresponding oper  						pOper = (XlOper12*)pNative + i + 1;  						if (pOper->xlType == XlType12.XlTypeReference)  						{  							// Get the reference from the managed array  							object /*ExcelReference*/ r;  							if (rank == 1)  							{  								r = /*(ExcelReference)*/((object[])ManagedObj)[i];  							}  							else  							{  								int row = i / columns;  								int column = i % columns;  								r = /*(ExcelReference)*/((object['])ManagedObj)[rowBase + row' columnBase + column];  							}    							int refCount = IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount(r); // r.InnerReferences.Count  							int numBytes = 4 /* sizeof ushort + packing to get to field offset */  										   + refCount * Marshal.SizeOf(typeof(XlOper12.XlRectangle12));    							IntegrationMarshalHelpers.SetExcelReference12(pOper' (XlOper12.XlMultiRef12*)pCurrent' r);                                // Unchecked keyword here is redundant (it's the default for C#)'                               // but makes clear that we rely on the overflow.                              // Also - numBytes must be int and not long' else we get numeric promotion and a mess again!                              pCurrent = IntPtr.Size == 4 ?                                   new IntPtr(unchecked(pCurrent.ToInt32() + (int)numBytes)) :                                   new IntPtr(unchecked(pCurrent.ToInt64() + numBytes));  							refOperIndex++;  						}  					}  				}
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: if (numReferenceOpers > 0)  				{  					// Allocate room for all the references  					int cbNativeReferences = numReferenceOpers * 4 /* sizeof ushort + packing to get to field offset */  											 + numReferences * Marshal.SizeOf(typeof(XlOper12.XlRectangle12));  					pNativeReferences = Marshal.AllocCoTaskMem(cbNativeReferences);  					IntPtr pCurrent = pNativeReferences;  					// Go through the Opers and set each reference  					int refOperIndex = 0;  					for (int i = 0; i < rows * columns && refOperIndex < numReferenceOpers; i++)  					{  						// Get the corresponding oper  						pOper = (XlOper12*)pNative + i + 1;  						if (pOper->xlType == XlType12.XlTypeReference)  						{  							// Get the reference from the managed array  							object /*ExcelReference*/ r;  							if (rank == 1)  							{  								r = /*(ExcelReference)*/((object[])ManagedObj)[i];  							}  							else  							{  								int row = i / columns;  								int column = i % columns;  								r = /*(ExcelReference)*/((object['])ManagedObj)[rowBase + row' columnBase + column];  							}    							int refCount = IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount(r); // r.InnerReferences.Count  							int numBytes = 4 /* sizeof ushort + packing to get to field offset */  										   + refCount * Marshal.SizeOf(typeof(XlOper12.XlRectangle12));    							IntegrationMarshalHelpers.SetExcelReference12(pOper' (XlOper12.XlMultiRef12*)pCurrent' r);                                // Unchecked keyword here is redundant (it's the default for C#)'                               // but makes clear that we rely on the overflow.                              // Also - numBytes must be int and not long' else we get numeric promotion and a mess again!                              pCurrent = IntPtr.Size == 4 ?                                   new IntPtr(unchecked(pCurrent.ToInt32() + (int)numBytes)) :                                   new IntPtr(unchecked(pCurrent.ToInt64() + numBytes));  							refOperIndex++;  						}  					}  				}
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: if (numReferenceOpers > 0)  				{  					// Allocate room for all the references  					int cbNativeReferences = numReferenceOpers * 4 /* sizeof ushort + packing to get to field offset */  											 + numReferences * Marshal.SizeOf(typeof(XlOper12.XlRectangle12));  					pNativeReferences = Marshal.AllocCoTaskMem(cbNativeReferences);  					IntPtr pCurrent = pNativeReferences;  					// Go through the Opers and set each reference  					int refOperIndex = 0;  					for (int i = 0; i < rows * columns && refOperIndex < numReferenceOpers; i++)  					{  						// Get the corresponding oper  						pOper = (XlOper12*)pNative + i + 1;  						if (pOper->xlType == XlType12.XlTypeReference)  						{  							// Get the reference from the managed array  							object /*ExcelReference*/ r;  							if (rank == 1)  							{  								r = /*(ExcelReference)*/((object[])ManagedObj)[i];  							}  							else  							{  								int row = i / columns;  								int column = i % columns;  								r = /*(ExcelReference)*/((object['])ManagedObj)[rowBase + row' columnBase + column];  							}    							int refCount = IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount(r); // r.InnerReferences.Count  							int numBytes = 4 /* sizeof ushort + packing to get to field offset */  										   + refCount * Marshal.SizeOf(typeof(XlOper12.XlRectangle12));    							IntegrationMarshalHelpers.SetExcelReference12(pOper' (XlOper12.XlMultiRef12*)pCurrent' r);                                // Unchecked keyword here is redundant (it's the default for C#)'                               // but makes clear that we rely on the overflow.                              // Also - numBytes must be int and not long' else we get numeric promotion and a mess again!                              pCurrent = IntPtr.Size == 4 ?                                   new IntPtr(unchecked(pCurrent.ToInt32() + (int)numBytes)) :                                   new IntPtr(unchecked(pCurrent.ToInt64() + numBytes));  							refOperIndex++;  						}  					}  				}
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: if (!isExcel12v)  				{  					// For big allocations' ensure that Excel allows us to free the memory  					if (rows * columns * 16 + cbNativeStrings + numReferences * 16 > 65535)  						pOper->xlType |= XlType12.XlBitDLLFree;    					// We are done  					return pNative;  				}  				else  				{  					// For the Excel12v call' we need to return an array  					// which will contain the pointers to the Opers.  					int cbOperPointers = columns * Marshal.SizeOf(typeof(XlOper12*));  					pOperPointers = Marshal.AllocCoTaskMem(cbOperPointers);  					XlOper12** pOpers = (XlOper12**)pOperPointers;  					for (int i = 0; i < columns; i++)  					{  						pOpers[i] = (XlOper12*)pNative + i + 1;  					}  					return pOperPointers;  				}
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: if (!isExcel12v)  				{  					// For big allocations' ensure that Excel allows us to free the memory  					if (rows * columns * 16 + cbNativeStrings + numReferences * 16 > 65535)  						pOper->xlType |= XlType12.XlBitDLLFree;    					// We are done  					return pNative;  				}  				else  				{  					// For the Excel12v call' we need to return an array  					// which will contain the pointers to the Opers.  					int cbOperPointers = columns * Marshal.SizeOf(typeof(XlOper12*));  					pOperPointers = Marshal.AllocCoTaskMem(cbOperPointers);  					XlOper12** pOpers = (XlOper12**)pOperPointers;  					for (int i = 0; i < columns; i++)  					{  						pOpers[i] = (XlOper12*)pNative + i + 1;  					}  					return pOperPointers;  				}
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: if (!isExcel12v)  				{  					// For big allocations' ensure that Excel allows us to free the memory  					if (rows * columns * 16 + cbNativeStrings + numReferences * 16 > 65535)  						pOper->xlType |= XlType12.XlBitDLLFree;    					// We are done  					return pNative;  				}  				else  				{  					// For the Excel12v call' we need to return an array  					// which will contain the pointers to the Opers.  					int cbOperPointers = columns * Marshal.SizeOf(typeof(XlOper12*));  					pOperPointers = Marshal.AllocCoTaskMem(cbOperPointers);  					XlOper12** pOpers = (XlOper12**)pOperPointers;  					for (int i = 0; i < columns; i++)  					{  						pOpers[i] = (XlOper12*)pNative + i + 1;  					}  					return pOperPointers;  				}
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalNativeToManaged,The following statement contains a magic number: if (rank == 1)  				{  					if (managed == null || !(managed is object[']))  					{  						return new object[1] { managed };  					}  					else // managed is object[']: turn first row (or column) into object[]  					{  						object[] array;  						object['] all = (object['])managed;  						int rows = all.GetLength(0);  						int columns = all.GetLength(1);    						if (columns == 1)  						{  							// Take the one and only column as the array  							array = new object[rows];  							for (int i = 0; i < rows; i++)  							{  								array[i] = all[i' 0];  							}  						}  						else  						{  							// Take first row only  							array = new object[columns];  							for (int j = 0; j < columns; j++)  							{  								array[j] = all[0' j];  							}  						}  						return array;  					}  				}  				else if (rank == 2)  				{  					if (managed == null || !(managed is object[']))  					{  						return new object['] { { managed } };  					}  					else // managed is object[']  					{  						return managed;  					}  				}  				else  				{  					Debug.Fail("Damaged XlObjectArray12Marshaler rank");  					throw new InvalidOperationException("Damaged XlObjectArray12Marshaler rank");  				}
Magic Number,ExcelDna.Loader,IntegrationHelpers,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllGetClassObject,The following statement contains a magic number: ppunk = (IntPtr)args[2];
Magic Number,ExcelDna.Loader,XlCallImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCallImpl.cs,TryExcelImpl,The following statement contains a magic number: if (XlAddIn.XlCallVersion < 12)              {                  return TryExcelImpl4(xlFunction' out result' parameters);              }
Magic Number,ExcelDna.Loader,XlCallImpl,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCallImpl.cs,TryExcelImpl,The following statement contains a magic number: if (Excel12v == null )              {                  FetchExcel12EntryPt();                  if (Excel12v == null)                  {                      result = null;                      return 32; /*XlCall.XlReturn.XlReturnFailed*/                  }              }
Magic Number,ExcelDna.Loader,XlStringReturnMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: int charCount = Math.Min(str.Length' 255);
Magic Number,ExcelDna.Loader,XlStringReturnMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: fixed (char* psrc = str )  			{                  // Support for system codepage by hmd  				//int written = Encoding.ASCII.GetBytes(psrc' charCount' pdest->Data' 255);                  Encoding enc = Encoding.GetEncoding(ASCIIEncoding.Default.CodePage'                                                      EncoderFallback.ReplacementFallback'                                                          DecoderFallback.ReplacementFallback);                  int written = enc.GetBytes(psrc' charCount' pdest->Data' 255);  				pdest->Length = (byte)written;  			}
Magic Number,ExcelDna.Loader,XlDoubleArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,GetInstance,The following statement contains a magic number: if (marshalCookie == "1")  			{  				if (instance1 == null)  					instance1 = new XlDoubleArrayMarshaler(1);  				return instance1;  			}  			else if (marshalCookie == "2")  			{  				if (instance2 == null)  					instance2 = new XlDoubleArrayMarshaler(2);  				return instance2;  			}
Magic Number,ExcelDna.Loader,XlDoubleArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (rank == 1)  			{  				double[] doubles = (double[])ManagedObj;    				rows = 1;  				allColumns = doubles.Length;  				columns = (ushort)Math.Min(allColumns' ushort.MaxValue);                    // Guard against invalid arrays - with no columns.                  // Just return null' which Excel will turn into #NUM                  if (columns == 0)                      return IntPtr.Zero;    				fixed(double* src = doubles)  				{  					AllocateFPAndCopy(src' rows' columns' allColumns);	  				}  			}  			else if (rank == 2)  			{  				double['] doubles = (double['])ManagedObj;    				rows = (ushort)Math.Min(doubles.GetLength(0)' ushort.MaxValue);  				allColumns = doubles.GetLength(1);  				columns = (ushort)Math.Min(allColumns' ushort.MaxValue);                    // Guard against invalid arrays - with no rows or no columns.                  // Just return null' which Excel will turn into #NUM                  if (rows == 0 || columns == 0)                      return IntPtr.Zero;    				fixed (double* src = doubles)  				{  					AllocateFPAndCopy(src' rows' columns' allColumns);  				}  			}  			else  			{  				throw new InvalidOperationException("Damaged XlDoubleArrayMarshaler rank");  			}
Magic Number,ExcelDna.Loader,XlDoubleArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: if (rank == 1)  			{  				double[] array;                  if (pFP->Columns == 1)                  {                      // Take the one and only column as the array                      array = new double[pFP->Rows];                  }                  else                  {                      // Take only the first row of the array.                      array = new double[pFP->Columns];                  }                  // Copy works for either case' due to in-memory layout!                  fixed (double* dest = array)                  {                      CopyDoubles(pFP->Values' dest' array.Length);                  }  				result = array;  			}  			else if (rank == 2)  			{  				double['] array = new double[pFP->Rows' pFP->Columns];  				fixed (double* dest = array)  				{  					CopyDoubles(pFP->Values' dest' array.Length);  				}  				result = array;  			}  			else  			{  				Debug.Fail("Damaged XlDoubleArrayMarshaler rank");  				throw new InvalidOperationException("Damaged XlDoubleArrayMarshaler rank");  			}
Magic Number,ExcelDna.Loader,XlObjectMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: switch (type)  			{  				case XlType.XlTypeNumber:  					managed = pOper->numValue;  					break;  				case XlType.XlTypeString:                      XlString* pString = pOper->pstrValue;                      // Support for system codepage by hmd                      // managed = new string((sbyte*)pString->Data' 0' pString->Length' Encoding.ASCII);                      Encoding enc = Encoding.GetEncoding(ASCIIEncoding.Default.CodePage'                                                          EncoderFallback.ReplacementFallback'                                                          DecoderFallback.ReplacementFallback);                      managed = new string((sbyte*)pString->Data' 0' pString->Length' enc);  					break;  				case XlType.XlTypeBoolean:  					managed = pOper->boolValue == 1;  					break;  				case XlType.XlTypeError:  					managed = IntegrationMarshalHelpers.GetExcelErrorObject(pOper->errValue);  					break;  				case XlType.XlTypeMissing:                      // DOCUMENT: Changed in version 0.17.  					// managed = System.Reflection.Missing.Value;                      managed = IntegrationMarshalHelpers.GetExcelMissingValue();  					break;  				case XlType.XlTypeEmpty:                      // DOCUMENT: Changed in version 0.17.                      // managed = null;                      managed = IntegrationMarshalHelpers.GetExcelEmptyValue();  					break;  				case XlType.XlTypeArray:  					int rows = pOper->arrayValue.Rows;  					int columns = pOper->arrayValue.Columns;  					object['] array = new object[rows' columns];  					XlOper* opers = (XlOper*)pOper->arrayValue.pOpers;  					for (int i = 0; i < rows; i++)  					{  						for (int j = 0; j < columns; j++)  						{  							int pos = i * columns + j;  							array[i' j] = MarshalNativeToManaged((IntPtr)(opers + pos));  						}  					}  					managed = array;  					break;  				case XlType.XlTypeInt:  					managed = (double)pOper->intValue; // int16 in XlOper // always return double  					break;  				case XlType.XlTypeReference:  					object /*ExcelReference*/ r;  					if (pOper->refValue.pMultiRef == (XlOper.XlMultiRef*)IntPtr.Zero)  					{  						r = IntegrationMarshalHelpers.CreateExcelReference(0' 0' 0' 0' pOper->refValue.SheetId);  					}  					else  					{  						ushort numAreas = *(ushort*)pOper->refValue.pMultiRef;  						XlOper.XlRectangle* pAreas = (XlOper.XlRectangle*)((uint)pOper->refValue.pMultiRef + sizeof(ushort));                          if (numAreas == 1)                          {                              r = IntegrationMarshalHelpers.CreateExcelReference(                                  pAreas[0].RowFirst' pAreas[0].RowLast'                                  pAreas[0].ColumnFirst' pAreas[0].ColumnLast' pOper->refValue.SheetId);                          }                          else                          {                              int[][] areas = new int[numAreas][];                              for (int i = 0; i < numAreas; i++)                              {                                  XlOper.XlRectangle rect = pAreas[i];                                  int[] area = new int[4] { rect.RowFirst' rect.RowLast'                                                            rect.ColumnFirst' rect.ColumnLast };                                  areas[i] = area;                              }                              r = IntegrationMarshalHelpers.CreateExcelReference(areas' pOper->refValue.SheetId);                          }  					}  					managed = r;  					break;  				case XlType.XlTypeSReference:                      IntPtr sheetId = XlCallImpl.GetCurrentSheetId4();  					object /*ExcelReference*/ sref;  					sref = IntegrationMarshalHelpers.CreateExcelReference(                                              pOper->srefValue.Reference.RowFirst'  											pOper->srefValue.Reference.RowLast'  											pOper->srefValue.Reference.ColumnFirst'  											pOper->srefValue.Reference.ColumnLast'   											sheetId /*Current sheet (not Active sheet!)*/);  					managed = sref;  					break;                  case 0:                      // We get type == 0 when a long (>255 char) string is embedded in an array.                      // To be consistent with the string handling' we set the value to #VALUE                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(15 /* ExcelErrorValue */);                      break;  				default:                      // Unexpected !? (BigData perhaps - How did it get here?)                      // We do #VALUE here too' rather than set to null.                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(15 /* ExcelErrorValue */);  					break;  			}
Magic Number,ExcelDna.Loader,XlObjectMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: switch (type)  			{  				case XlType.XlTypeNumber:  					managed = pOper->numValue;  					break;  				case XlType.XlTypeString:                      XlString* pString = pOper->pstrValue;                      // Support for system codepage by hmd                      // managed = new string((sbyte*)pString->Data' 0' pString->Length' Encoding.ASCII);                      Encoding enc = Encoding.GetEncoding(ASCIIEncoding.Default.CodePage'                                                          EncoderFallback.ReplacementFallback'                                                          DecoderFallback.ReplacementFallback);                      managed = new string((sbyte*)pString->Data' 0' pString->Length' enc);  					break;  				case XlType.XlTypeBoolean:  					managed = pOper->boolValue == 1;  					break;  				case XlType.XlTypeError:  					managed = IntegrationMarshalHelpers.GetExcelErrorObject(pOper->errValue);  					break;  				case XlType.XlTypeMissing:                      // DOCUMENT: Changed in version 0.17.  					// managed = System.Reflection.Missing.Value;                      managed = IntegrationMarshalHelpers.GetExcelMissingValue();  					break;  				case XlType.XlTypeEmpty:                      // DOCUMENT: Changed in version 0.17.                      // managed = null;                      managed = IntegrationMarshalHelpers.GetExcelEmptyValue();  					break;  				case XlType.XlTypeArray:  					int rows = pOper->arrayValue.Rows;  					int columns = pOper->arrayValue.Columns;  					object['] array = new object[rows' columns];  					XlOper* opers = (XlOper*)pOper->arrayValue.pOpers;  					for (int i = 0; i < rows; i++)  					{  						for (int j = 0; j < columns; j++)  						{  							int pos = i * columns + j;  							array[i' j] = MarshalNativeToManaged((IntPtr)(opers + pos));  						}  					}  					managed = array;  					break;  				case XlType.XlTypeInt:  					managed = (double)pOper->intValue; // int16 in XlOper // always return double  					break;  				case XlType.XlTypeReference:  					object /*ExcelReference*/ r;  					if (pOper->refValue.pMultiRef == (XlOper.XlMultiRef*)IntPtr.Zero)  					{  						r = IntegrationMarshalHelpers.CreateExcelReference(0' 0' 0' 0' pOper->refValue.SheetId);  					}  					else  					{  						ushort numAreas = *(ushort*)pOper->refValue.pMultiRef;  						XlOper.XlRectangle* pAreas = (XlOper.XlRectangle*)((uint)pOper->refValue.pMultiRef + sizeof(ushort));                          if (numAreas == 1)                          {                              r = IntegrationMarshalHelpers.CreateExcelReference(                                  pAreas[0].RowFirst' pAreas[0].RowLast'                                  pAreas[0].ColumnFirst' pAreas[0].ColumnLast' pOper->refValue.SheetId);                          }                          else                          {                              int[][] areas = new int[numAreas][];                              for (int i = 0; i < numAreas; i++)                              {                                  XlOper.XlRectangle rect = pAreas[i];                                  int[] area = new int[4] { rect.RowFirst' rect.RowLast'                                                            rect.ColumnFirst' rect.ColumnLast };                                  areas[i] = area;                              }                              r = IntegrationMarshalHelpers.CreateExcelReference(areas' pOper->refValue.SheetId);                          }  					}  					managed = r;  					break;  				case XlType.XlTypeSReference:                      IntPtr sheetId = XlCallImpl.GetCurrentSheetId4();  					object /*ExcelReference*/ sref;  					sref = IntegrationMarshalHelpers.CreateExcelReference(                                              pOper->srefValue.Reference.RowFirst'  											pOper->srefValue.Reference.RowLast'  											pOper->srefValue.Reference.ColumnFirst'  											pOper->srefValue.Reference.ColumnLast'   											sheetId /*Current sheet (not Active sheet!)*/);  					managed = sref;  					break;                  case 0:                      // We get type == 0 when a long (>255 char) string is embedded in an array.                      // To be consistent with the string handling' we set the value to #VALUE                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(15 /* ExcelErrorValue */);                      break;  				default:                      // Unexpected !? (BigData perhaps - How did it get here?)                      // We do #VALUE here too' rather than set to null.                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(15 /* ExcelErrorValue */);  					break;  			}
Magic Number,ExcelDna.Loader,XlObjectMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: switch (type)  			{  				case XlType.XlTypeNumber:  					managed = pOper->numValue;  					break;  				case XlType.XlTypeString:                      XlString* pString = pOper->pstrValue;                      // Support for system codepage by hmd                      // managed = new string((sbyte*)pString->Data' 0' pString->Length' Encoding.ASCII);                      Encoding enc = Encoding.GetEncoding(ASCIIEncoding.Default.CodePage'                                                          EncoderFallback.ReplacementFallback'                                                          DecoderFallback.ReplacementFallback);                      managed = new string((sbyte*)pString->Data' 0' pString->Length' enc);  					break;  				case XlType.XlTypeBoolean:  					managed = pOper->boolValue == 1;  					break;  				case XlType.XlTypeError:  					managed = IntegrationMarshalHelpers.GetExcelErrorObject(pOper->errValue);  					break;  				case XlType.XlTypeMissing:                      // DOCUMENT: Changed in version 0.17.  					// managed = System.Reflection.Missing.Value;                      managed = IntegrationMarshalHelpers.GetExcelMissingValue();  					break;  				case XlType.XlTypeEmpty:                      // DOCUMENT: Changed in version 0.17.                      // managed = null;                      managed = IntegrationMarshalHelpers.GetExcelEmptyValue();  					break;  				case XlType.XlTypeArray:  					int rows = pOper->arrayValue.Rows;  					int columns = pOper->arrayValue.Columns;  					object['] array = new object[rows' columns];  					XlOper* opers = (XlOper*)pOper->arrayValue.pOpers;  					for (int i = 0; i < rows; i++)  					{  						for (int j = 0; j < columns; j++)  						{  							int pos = i * columns + j;  							array[i' j] = MarshalNativeToManaged((IntPtr)(opers + pos));  						}  					}  					managed = array;  					break;  				case XlType.XlTypeInt:  					managed = (double)pOper->intValue; // int16 in XlOper // always return double  					break;  				case XlType.XlTypeReference:  					object /*ExcelReference*/ r;  					if (pOper->refValue.pMultiRef == (XlOper.XlMultiRef*)IntPtr.Zero)  					{  						r = IntegrationMarshalHelpers.CreateExcelReference(0' 0' 0' 0' pOper->refValue.SheetId);  					}  					else  					{  						ushort numAreas = *(ushort*)pOper->refValue.pMultiRef;  						XlOper.XlRectangle* pAreas = (XlOper.XlRectangle*)((uint)pOper->refValue.pMultiRef + sizeof(ushort));                          if (numAreas == 1)                          {                              r = IntegrationMarshalHelpers.CreateExcelReference(                                  pAreas[0].RowFirst' pAreas[0].RowLast'                                  pAreas[0].ColumnFirst' pAreas[0].ColumnLast' pOper->refValue.SheetId);                          }                          else                          {                              int[][] areas = new int[numAreas][];                              for (int i = 0; i < numAreas; i++)                              {                                  XlOper.XlRectangle rect = pAreas[i];                                  int[] area = new int[4] { rect.RowFirst' rect.RowLast'                                                            rect.ColumnFirst' rect.ColumnLast };                                  areas[i] = area;                              }                              r = IntegrationMarshalHelpers.CreateExcelReference(areas' pOper->refValue.SheetId);                          }  					}  					managed = r;  					break;  				case XlType.XlTypeSReference:                      IntPtr sheetId = XlCallImpl.GetCurrentSheetId4();  					object /*ExcelReference*/ sref;  					sref = IntegrationMarshalHelpers.CreateExcelReference(                                              pOper->srefValue.Reference.RowFirst'  											pOper->srefValue.Reference.RowLast'  											pOper->srefValue.Reference.ColumnFirst'  											pOper->srefValue.Reference.ColumnLast'   											sheetId /*Current sheet (not Active sheet!)*/);  					managed = sref;  					break;                  case 0:                      // We get type == 0 when a long (>255 char) string is embedded in an array.                      // To be consistent with the string handling' we set the value to #VALUE                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(15 /* ExcelErrorValue */);                      break;  				default:                      // Unexpected !? (BigData perhaps - How did it get here?)                      // We do #VALUE here too' rather than set to null.                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(15 /* ExcelErrorValue */);  					break;  			}
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,GetInstance,The following statement contains a magic number: if (marshalCookie == "1")              {                  if (instance1 == null)                      instance1 = new XlObjectArrayMarshaler(1);                  return instance1;              }              else if (marshalCookie == "2")              {                  if (instance2 == null)                      instance2 = new XlObjectArrayMarshaler(2);                  return instance2;              }
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (rank == 1)  			{  				object[] objects = (object[])ManagedObj;    				rows = 1;                  rowBase = 0;  				allColumns = objects.Length;  				columns = (ushort)Math.Min(objects.Length' ushort.MaxValue);                  columnBase = objects.GetLowerBound(0);  			}  			else if (rank == 2)  			{  				object['] objects = (object['])ManagedObj;    				rows = (ushort)Math.Min(objects.GetLength(0)' ushort.MaxValue);                  rowBase = objects.GetLowerBound(0);  				allColumns = objects.GetLength(1);  				columns = (ushort)Math.Min(objects.GetLength(1)' ushort.MaxValue);                  columnBase = objects.GetLowerBound(1);  			}  			else  			{  				throw new InvalidOperationException("Damaged XlObjectArrayMarshaler rank");  			}
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: for (int i = 0; i < rows * columns; i++)              {                  // Get the right object out of the array                  object obj;                  if (rank == 1)                  {                      obj = ((object[])ManagedObj)[columnBase + i];                  }                  else                  {                      int row = i / allColumns;                      int column = i % allColumns;                      obj = ((object['])ManagedObj)[rowBase + row' columnBase + column];                  }                    // Get the right pOper                  pOper = (XlOper*)pNative + i + 1;                    // Set up the oper from the object                  if (obj is double)                  {                      pOper->numValue = (double)obj;                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is string)                  {                      // We count all of the string lengths'                       string str = (string)obj;                      cbNativeStrings += Math.Min(str.Length' 255) + 1;                      // mark the Oper as a string' and                      // later allocate memory and return to fix pointers                      pOper->xlType = XlType.XlTypeString;                  }                  else if (obj is DateTime)                  {                      pOper->numValue = ((DateTime)obj).ToOADate();                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (IntegrationMarshalHelpers.IsExcelErrorObject(obj))                  {                      pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelErrorGetValue(obj);                      pOper->xlType = XlType.XlTypeError;                  }                  else if (IntegrationMarshalHelpers.IsExcelMissingObject(obj))                  {                      pOper->xlType = XlType.XlTypeMissing;                  }                  else if (IntegrationMarshalHelpers.IsExcelEmptyObject(obj))                  {                      pOper->xlType = XlType.XlTypeEmpty;                  }                  else if (obj is bool)                  {                      pOper->boolValue = (bool)obj ? (ushort)1 : (ushort)0;                      pOper->xlType = XlType.XlTypeBoolean;                  }                  else if (obj is short)                  {                      pOper->numValue = (double)((short)obj); // int16 in XlOper                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is ushort)                  {                      pOper->numValue = (double)((ushort)obj);                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is int)                  {                      pOper->numValue = (double)((int)obj);                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is uint)                  {                      pOper->numValue = (double)((uint)obj);                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is long)                  {                      pOper->numValue = (double)((long)obj);                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is ulong)                  {                      pOper->numValue = (double)((ulong)obj);                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is decimal)                  {                      pOper->numValue = (double)((decimal)obj);                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is float)                  {                      pOper->numValue = (double)((float)obj);                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (IntegrationMarshalHelpers.IsExcelReferenceObject(obj))                  {                      pOper->xlType = XlType.XlTypeReference;                      // First we count all of these'                       // later allocate memory and return to fix pointers                      numReferenceOpers++;                      numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount(obj); // ((ExcelReference)obj).InnerReferences.Count;                  }                  else if (obj is object[])                  {                      XlObjectArrayMarshaler m = new XlObjectArrayMarshaler(1);                      nestedInstances.Add(m);                      XlOper* pNested = (XlOper*)m.MarshalManagedToNative(obj);                      if (pNested->xlType == XlType.XlTypeArray)                      {                          pOper->xlType = XlType.XlTypeArray;                          pOper->arrayValue.Rows = pNested->arrayValue.Rows;                          pOper->arrayValue.Columns = pNested->arrayValue.Columns;                          pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                      }                      else                      {                          // This is the case where the array passed in has 0 length.                          // We set to an error to at least have a valid XLOPER                          pOper->xlType = XlType.XlTypeError;                          pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                      }                  }                  else if (obj is object['])                  {                      XlObjectArrayMarshaler m = new XlObjectArrayMarshaler(2);                      nestedInstances.Add(m);                      XlOper* pNested = (XlOper*)m.MarshalManagedToNative(obj);                      if (pNested->xlType == XlType.XlTypeArray)                      {                          pOper->xlType = XlType.XlTypeArray;                          pOper->arrayValue.Rows = pNested->arrayValue.Rows;                          pOper->arrayValue.Columns = pNested->arrayValue.Columns;                          pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                      }                      else                      {                          // This is the case where the array passed in has 0 length.                          // We set to an error to at least have a valid XLOPER                          pOper->xlType = XlType.XlTypeError;                          pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                      }                  }                  else if (obj is System.Reflection.Missing)                  {                      pOper->xlType = XlType.XlTypeMissing;                  }                  else if (obj == null)                  {                      // DOCUMENT: I return Empty for nulls inside the Array'                       // which is not consistent with what happens in other settings.                      // In particular not consistent with the results of the XlObjectMarshaler                      // (which is not called when a null is returned'                      // and interpreted as ExcelErrorNum in Excel)                      // This works well for xlSet though.                      // CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'                      // and return ErrNum here                      pOper->xlType = XlType.XlTypeEmpty;                  }                  else                  {                      // Default error return                      pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                      pOper->xlType = XlType.XlTypeError;                  }              }
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: for (int i = 0; i < rows * columns; i++)              {                  // Get the right object out of the array                  object obj;                  if (rank == 1)                  {                      obj = ((object[])ManagedObj)[columnBase + i];                  }                  else                  {                      int row = i / allColumns;                      int column = i % allColumns;                      obj = ((object['])ManagedObj)[rowBase + row' columnBase + column];                  }                    // Get the right pOper                  pOper = (XlOper*)pNative + i + 1;                    // Set up the oper from the object                  if (obj is double)                  {                      pOper->numValue = (double)obj;                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is string)                  {                      // We count all of the string lengths'                       string str = (string)obj;                      cbNativeStrings += Math.Min(str.Length' 255) + 1;                      // mark the Oper as a string' and                      // later allocate memory and return to fix pointers                      pOper->xlType = XlType.XlTypeString;                  }                  else if (obj is DateTime)                  {                      pOper->numValue = ((DateTime)obj).ToOADate();                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (IntegrationMarshalHelpers.IsExcelErrorObject(obj))                  {                      pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelErrorGetValue(obj);                      pOper->xlType = XlType.XlTypeError;                  }                  else if (IntegrationMarshalHelpers.IsExcelMissingObject(obj))                  {                      pOper->xlType = XlType.XlTypeMissing;                  }                  else if (IntegrationMarshalHelpers.IsExcelEmptyObject(obj))                  {                      pOper->xlType = XlType.XlTypeEmpty;                  }                  else if (obj is bool)                  {                      pOper->boolValue = (bool)obj ? (ushort)1 : (ushort)0;                      pOper->xlType = XlType.XlTypeBoolean;                  }                  else if (obj is short)                  {                      pOper->numValue = (double)((short)obj); // int16 in XlOper                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is ushort)                  {                      pOper->numValue = (double)((ushort)obj);                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is int)                  {                      pOper->numValue = (double)((int)obj);                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is uint)                  {                      pOper->numValue = (double)((uint)obj);                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is long)                  {                      pOper->numValue = (double)((long)obj);                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is ulong)                  {                      pOper->numValue = (double)((ulong)obj);                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is decimal)                  {                      pOper->numValue = (double)((decimal)obj);                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (obj is float)                  {                      pOper->numValue = (double)((float)obj);                      pOper->xlType = XlType.XlTypeNumber;                  }                  else if (IntegrationMarshalHelpers.IsExcelReferenceObject(obj))                  {                      pOper->xlType = XlType.XlTypeReference;                      // First we count all of these'                       // later allocate memory and return to fix pointers                      numReferenceOpers++;                      numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount(obj); // ((ExcelReference)obj).InnerReferences.Count;                  }                  else if (obj is object[])                  {                      XlObjectArrayMarshaler m = new XlObjectArrayMarshaler(1);                      nestedInstances.Add(m);                      XlOper* pNested = (XlOper*)m.MarshalManagedToNative(obj);                      if (pNested->xlType == XlType.XlTypeArray)                      {                          pOper->xlType = XlType.XlTypeArray;                          pOper->arrayValue.Rows = pNested->arrayValue.Rows;                          pOper->arrayValue.Columns = pNested->arrayValue.Columns;                          pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                      }                      else                      {                          // This is the case where the array passed in has 0 length.                          // We set to an error to at least have a valid XLOPER                          pOper->xlType = XlType.XlTypeError;                          pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                      }                  }                  else if (obj is object['])                  {                      XlObjectArrayMarshaler m = new XlObjectArrayMarshaler(2);                      nestedInstances.Add(m);                      XlOper* pNested = (XlOper*)m.MarshalManagedToNative(obj);                      if (pNested->xlType == XlType.XlTypeArray)                      {                          pOper->xlType = XlType.XlTypeArray;                          pOper->arrayValue.Rows = pNested->arrayValue.Rows;                          pOper->arrayValue.Columns = pNested->arrayValue.Columns;                          pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;                      }                      else                      {                          // This is the case where the array passed in has 0 length.                          // We set to an error to at least have a valid XLOPER                          pOper->xlType = XlType.XlTypeError;                          pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                      }                  }                  else if (obj is System.Reflection.Missing)                  {                      pOper->xlType = XlType.XlTypeMissing;                  }                  else if (obj == null)                  {                      // DOCUMENT: I return Empty for nulls inside the Array'                       // which is not consistent with what happens in other settings.                      // In particular not consistent with the results of the XlObjectMarshaler                      // (which is not called when a null is returned'                      // and interpreted as ExcelErrorNum in Excel)                      // This works well for xlSet though.                      // CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'                      // and return ErrNum here                      pOper->xlType = XlType.XlTypeEmpty;                  }                  else                  {                      // Default error return                      pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;                      pOper->xlType = XlType.XlTypeError;                  }              }
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (cbNativeStrings > 0)  			{  				// Allocate room for all the strings                  pNativeStrings = Marshal.AllocCoTaskMem(cbNativeStrings);                  // Go through the Opers and set each string                  byte* pCurrent = (byte*)pNativeStrings;  				for (int i = 0; i < rows * columns; i++)  				{  					// Get the corresponding oper  					pOper = (XlOper*)pNative + i + 1;  					if (pOper->xlType == XlType.XlTypeString)  					{  						// Get the string from the managed array  						string str;  						if (rank == 1)  						{  							str = (string)((object[])ManagedObj)[i];  						}  						else  						{  							int row = i / allColumns;  							int column = i % allColumns;  							str = (string)((object['])ManagedObj)[rowBase + row' columnBase + column];  						}                            XlString* pXlString = (XlString*)pCurrent;  						pOper->pstrValue = pXlString;  						int charCount = Math.Min(str.Length' 255);  						fixed (char* psrc = str)  						{                              // Write the data and length to the XlString                              // Support for system codepage by hmd  							// int written = Encoding.ASCII.GetBytes(psrc' charCount' pXlString->Data' 255);  							Encoding enc = Encoding.GetEncoding(ASCIIEncoding.Default.CodePage'                                                                  EncoderFallback.ReplacementFallback'                                                                  DecoderFallback.ReplacementFallback);                              int written = enc.GetBytes(psrc' charCount' pXlString->Data' 255);                              pXlString->Length = (byte)written;                              // Increment pointer within allocated memory                              pCurrent += written + 1;                          }  					}  				}  			}
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (cbNativeStrings > 0)  			{  				// Allocate room for all the strings                  pNativeStrings = Marshal.AllocCoTaskMem(cbNativeStrings);                  // Go through the Opers and set each string                  byte* pCurrent = (byte*)pNativeStrings;  				for (int i = 0; i < rows * columns; i++)  				{  					// Get the corresponding oper  					pOper = (XlOper*)pNative + i + 1;  					if (pOper->xlType == XlType.XlTypeString)  					{  						// Get the string from the managed array  						string str;  						if (rank == 1)  						{  							str = (string)((object[])ManagedObj)[i];  						}  						else  						{  							int row = i / allColumns;  							int column = i % allColumns;  							str = (string)((object['])ManagedObj)[rowBase + row' columnBase + column];  						}                            XlString* pXlString = (XlString*)pCurrent;  						pOper->pstrValue = pXlString;  						int charCount = Math.Min(str.Length' 255);  						fixed (char* psrc = str)  						{                              // Write the data and length to the XlString                              // Support for system codepage by hmd  							// int written = Encoding.ASCII.GetBytes(psrc' charCount' pXlString->Data' 255);  							Encoding enc = Encoding.GetEncoding(ASCIIEncoding.Default.CodePage'                                                                  EncoderFallback.ReplacementFallback'                                                                  DecoderFallback.ReplacementFallback);                              int written = enc.GetBytes(psrc' charCount' pXlString->Data' 255);                              pXlString->Length = (byte)written;                              // Increment pointer within allocated memory                              pCurrent += written + 1;                          }  					}  				}  			}
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (!isExcel4v)  			{  				// For big allocations' ensure that Excel allows us to free the memory                  if (rows * columns * 16 + cbNativeStrings + numReferences * 8 > 65535)  					pOper->xlType |= XlType.XlBitDLLFree;    				// We are done  				return pNative;  			}  			else  			{  				// For the Excel4v call' we need to return an array  				// which will contain the pointers to the Opers.                  int cbOperPointers = columns * Marshal.SizeOf(typeof(XlOper*));  				pOperPointers = Marshal.AllocCoTaskMem(cbOperPointers);  				XlOper** pOpers = (XlOper**)pOperPointers;  				for (int i = 0; i < columns; i++)  				{  					pOpers[i] = (XlOper*)pNative + i + 1;  				}  				return pOperPointers;  			}
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (!isExcel4v)  			{  				// For big allocations' ensure that Excel allows us to free the memory                  if (rows * columns * 16 + cbNativeStrings + numReferences * 8 > 65535)  					pOper->xlType |= XlType.XlBitDLLFree;    				// We are done  				return pNative;  			}  			else  			{  				// For the Excel4v call' we need to return an array  				// which will contain the pointers to the Opers.                  int cbOperPointers = columns * Marshal.SizeOf(typeof(XlOper*));  				pOperPointers = Marshal.AllocCoTaskMem(cbOperPointers);  				XlOper** pOpers = (XlOper**)pOperPointers;  				for (int i = 0; i < columns; i++)  				{  					pOpers[i] = (XlOper*)pNative + i + 1;  				}  				return pOperPointers;  			}
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (!isExcel4v)  			{  				// For big allocations' ensure that Excel allows us to free the memory                  if (rows * columns * 16 + cbNativeStrings + numReferences * 8 > 65535)  					pOper->xlType |= XlType.XlBitDLLFree;    				// We are done  				return pNative;  			}  			else  			{  				// For the Excel4v call' we need to return an array  				// which will contain the pointers to the Opers.                  int cbOperPointers = columns * Marshal.SizeOf(typeof(XlOper*));  				pOperPointers = Marshal.AllocCoTaskMem(cbOperPointers);  				XlOper** pOpers = (XlOper**)pOperPointers;  				for (int i = 0; i < columns; i++)  				{  					pOpers[i] = (XlOper*)pNative + i + 1;  				}  				return pOperPointers;  			}
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: if (rank == 1)  			{  				if (managed == null || !(managed is object[']))  				{  					return new object[1] { managed };  				}  				else // managed is object[']: turn first row (or column) into object[]  				{                      object[] array;  					object['] all = (object['])managed;                      int rows = all.GetLength(0);                      int columns = all.GetLength(1);                        if (columns == 1)                      {                          // Take the one and only column as the array                          array = new object[rows];                          for (int i = 0; i < rows; i++)                          {                              array[i] = all[i' 0];                          }                      }                      else                      {                          // Take first row only                          array = new object[columns];                          for (int j = 0; j < columns; j++)                          {                              array[j] = all[0' j];                          }                      }  					return array;  				}  			}  			else if (rank == 2)  			{  				if (managed == null || !(managed is object[']))  				{  					return new object['] { { managed } };  				}  				else // managed is object[']  				{  					return managed;  				}  			}  			else  			{  				Debug.Fail("Damaged XlObjectArrayMarshaler rank");  				throw new InvalidOperationException("Damaged XlObjectArrayMarshaler rank");  			}
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The following statement contains a magic number: if (exportInfoVersion != 8)              {                  Debug.Print("ExportInfoVersion '{0}' not supported"' exportInfoVersion);                  return false;              }
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The following statement contains a magic number: try              {                  XlAddIn.xlCallVersion = XlCallImpl.XLCallVer() / 256;              }              catch (DllNotFoundException)              {                  // This is expected if we are running under HPC or Regsvr32.                  Debug.Print("XlCall library not found - probably running in HPC host or Regsvr32.exe");                                    // For the HPC support' I ignore error here and just assume we are under new Excel.                  // This will cause the common error here to get pushed to later ...                  XlAddIn.xlCallVersion = 12;                  // return false;              }              catch (Exception e)              {                  Debug.Print("XlAddIn: XLCallVer Error: {0}"' e);                    // CONSIDER: Is this right / needed - I'm not actually sure what happens under HPC host'                   // so I'll leave this case in here too.?                  XlAddIn.xlCallVersion = 12;                  // return false;              }
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The following statement contains a magic number: try              {                  XlAddIn.xlCallVersion = XlCallImpl.XLCallVer() / 256;              }              catch (DllNotFoundException)              {                  // This is expected if we are running under HPC or Regsvr32.                  Debug.Print("XlCall library not found - probably running in HPC host or Regsvr32.exe");                                    // For the HPC support' I ignore error here and just assume we are under new Excel.                  // This will cause the common error here to get pushed to later ...                  XlAddIn.xlCallVersion = 12;                  // return false;              }              catch (Exception e)              {                  Debug.Print("XlAddIn: XLCallVer Error: {0}"' e);                    // CONSIDER: Is this right / needed - I'm not actually sure what happens under HPC host'                   // so I'll leave this case in here too.?                  XlAddIn.xlCallVersion = 12;                  // return false;              }
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The following statement contains a magic number: try              {                  XlAddIn.xlCallVersion = XlCallImpl.XLCallVer() / 256;              }              catch (DllNotFoundException)              {                  // This is expected if we are running under HPC or Regsvr32.                  Debug.Print("XlCall library not found - probably running in HPC host or Regsvr32.exe");                                    // For the HPC support' I ignore error here and just assume we are under new Excel.                  // This will cause the common error here to get pushed to later ...                  XlAddIn.xlCallVersion = 12;                  // return false;              }              catch (Exception e)              {                  Debug.Print("XlAddIn: XLCallVer Error: {0}"' e);                    // CONSIDER: Is this right / needed - I'm not actually sure what happens under HPC host'                   // so I'll leave this case in here too.?                  XlAddIn.xlCallVersion = 12;                  // return false;              }
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,XlAutoOpen,The following statement contains a magic number: try              {                  if (_opened)                  {                      DeInitializeIntegration();                  }                  object xlCallResult;                  XlCallImpl.TryExcelImpl(XlCallImpl.xlcMessage' out xlCallResult /*Ignore*/ ' true' "Registering library " + pathXll);  				InitializeIntegration();                  Logger.Initialization.Verbose("In XlAddIn.XlAutoOpen");                                    // v. 30 - moved the setting of _opened before calling AutoOpen'                   // so that checking in DeInitializeIntegration does not prevent AutoOpen - unloading via xlAutoRemove from working.                  _opened = true;                    // InitializeIntegration has loaded the DnaLibrary                  IntegrationHelpers.DnaLibraryAutoOpen();                    result = 1; // All is OK              }              catch (Exception e)              {                  // Can't use logging here                  string alertMessage = string.Format("A problem occurred while an add-in was being initialized (InitializeIntegration failed - {1}).\r\nThe add-in is built with ExcelDna and is being loaded from {0}"' pathXll' e.Message);  				object xlCallResult;  				XlCallImpl.TryExcelImpl(XlCallImpl.xlcAlert' out xlCallResult /*Ignored*/' alertMessage ' 3 /* Only OK Button' Warning Icon*/);                  result = 0;              }              finally              {                  // Clear the status bar message                  object xlCallResult;                  XlCallImpl.TryExcelImpl(XlCallImpl.xlcMessage' out xlCallResult /*Ignored*/ ' false);                  // Debug.Print("Clear status bar message result: " + xlCallResult);              }
Magic Number,ExcelDna.Loader,XlMethodInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodInfo,The following statement contains a magic number: if (Environment.Version.Major >= 4 && emitExceptionHandler)              {                  Type hcpeType = Type.GetType("System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute");                  ConstructorInfo hcpeCtorInfo = hcpeType.GetConstructor(Type.EmptyTypes);                  CustomAttributeBuilder hcpeBuilder = new CustomAttributeBuilder(hcpeCtorInfo' Type.EmptyTypes);                  wrapper.SetCustomAttribute(hcpeBuilder);              }
Magic Number,ExcelDna.Loader,XlMethodInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodInfo,The following statement contains a magic number: for (byte i = 0; i < Parameters.Length; i++)              {                  if (i < 255)                  {                      byte argIndex = isInstanceMethod ? (byte)(i + 1) : i;                      wrapIL.Emit(OpCodes.Ldarg_S' argIndex);                  }                  else                  {                      short argIndex = isInstanceMethod ? (short)(i + 1) : i;                      wrapIL.Emit(OpCodes.Ldarg' argIndex);                  }                  XlParameterInfo pi = Parameters[i];                  if (pi.BoxedValueType != null)                  {                      wrapIL.Emit(OpCodes.Unbox_Any' pi.BoxedValueType);                  }              }
Magic Number,ExcelDna.Loader,XlParameterInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlParameterInfo.cs,SetTypeInfo,The following statement contains a magic number: if ((XlAddIn.XlCallVersion < 12)  #if DEBUG // on debug-32bit we want to keep exercising the Excel4 APIs                  || (IntPtr.Size == 4)  #endif              )              {                  SetTypeInfo4(type' isReturnType' isExceptionSafe);              }              else              {                  SetTypeInfo12(type' isReturnType' isExceptionSafe);              }
Magic Number,ExcelDna.Loader,XlParameterInfo,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlParameterInfo.cs,SetTypeInfo,The following statement contains a magic number: if ((XlAddIn.XlCallVersion < 12)  #if DEBUG // on debug-32bit we want to keep exercising the Excel4 APIs                  || (IntPtr.Size == 4)  #endif              )              {                  SetTypeInfo4(type' isReturnType' isExceptionSafe);              }              else              {                  SetTypeInfo12(type' isReturnType' isExceptionSafe);              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegistrationInfo,The following statement contains a magic number: object['] result = new object[registrationInfo.Count + 1' 255];
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegistrationInfo,The following statement contains a magic number: for (int i = 0; i < registrationInfo.Count; i++)              {                  int resultRow = i + 1;                  object[] info = registrationInfo[i];                  for (int j = 0; j < 255; j++)                  {                      if (j >= info.Length)                      {                          // Done with this row                          break;                      }                      result[resultRow' j] = info[j];                  }              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,RegisterXlMethod,The following statement contains a magic number: if (registrationInfo.Exists(ri => ((string)ri[3]).Equals((string)registerParameters[3]' StringComparison.OrdinalIgnoreCase)))              {                  // This function will be registered with a name that has already been used (by this add-in)                  if (mi.SuppressOverwriteError)                  {                      // Logged at Info level - to allow re-registration without error popup                      Logger.Registration.Info("Repeated function name: '{0}' - previous registration will be overwritten. "' registerParameters[3]);                  }                  else                  {                      // This logged as an error' but the registration continues - the last function with the name wins' for backward compatibility.                      Logger.Registration.Error("Repeated function name: '{0}' - previous registration will be overwritten. "' registerParameters[3]);                  }              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,RegisterXlMethod,The following statement contains a magic number: if (registrationInfo.Exists(ri => ((string)ri[3]).Equals((string)registerParameters[3]' StringComparison.OrdinalIgnoreCase)))              {                  // This function will be registered with a name that has already been used (by this add-in)                  if (mi.SuppressOverwriteError)                  {                      // Logged at Info level - to allow re-registration without error popup                      Logger.Registration.Info("Repeated function name: '{0}' - previous registration will be overwritten. "' registerParameters[3]);                  }                  else                  {                      // This logged as an error' but the registration continues - the last function with the name wins' for backward compatibility.                      Logger.Registration.Error("Repeated function name: '{0}' - previous registration will be overwritten. "' registerParameters[3]);                  }              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,RegisterXlMethod,The following statement contains a magic number: if (registrationInfo.Exists(ri => ((string)ri[3]).Equals((string)registerParameters[3]' StringComparison.OrdinalIgnoreCase)))              {                  // This function will be registered with a name that has already been used (by this add-in)                  if (mi.SuppressOverwriteError)                  {                      // Logged at Info level - to allow re-registration without error popup                      Logger.Registration.Info("Repeated function name: '{0}' - previous registration will be overwritten. "' registerParameters[3]);                  }                  else                  {                      // This logged as an error' but the registration continues - the last function with the name wins' for backward compatibility.                      Logger.Registration.Error("Repeated function name: '{0}' - previous registration will be overwritten. "' registerParameters[3]);                  }              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,RegisterXlMethod,The following statement contains a magic number: if (registrationInfo.Exists(ri => ((string)ri[3]).Equals((string)registerParameters[3]' StringComparison.OrdinalIgnoreCase)))              {                  // This function will be registered with a name that has already been used (by this add-in)                  if (mi.SuppressOverwriteError)                  {                      // Logged at Info level - to allow re-registration without error popup                      Logger.Registration.Info("Repeated function name: '{0}' - previous registration will be overwritten. "' registerParameters[3]);                  }                  else                  {                      // This logged as an error' but the registration continues - the last function with the name wins' for backward compatibility.                      Logger.Registration.Error("Repeated function name: '{0}' - previous registration will be overwritten. "' registerParameters[3]);                  }              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,RegisterXlMethod,The following statement contains a magic number: try              {                  object xlCallResult;                  XlCallImpl.TryExcelImpl(XlCallImpl.xlfRegister' out xlCallResult' registerParameters);                  Logger.Registration.Info("Register - XllPath={0}' ProcName={1}' FunctionType={2}' Name={3} - Result={4}"'                              registerParameters[0]' registerParameters[1]' registerParameters[2]' registerParameters[3]'                              xlCallResult);                  if (xlCallResult is double)                  {                      mi.RegisterId = (double) xlCallResult;                      registeredMethods.Add(mi);                      if (mi.IsCommand)                      {                          RegisterMenu(mi);                          RegisterShortCut(mi);                      }                  }                  else                  {                      Logger.Registration.Error("xlfRegister call failed for function or command: '{0}'"' mi.Name);                  }                  // Now clear out the xll path and store the parameters to support RegistrationInfo access.                  registerParameters[0] = null;                  registrationInfo.Add(registerParameters);              }              catch (Exception e)              {                  Logger.Registration.Error(e' "Registration failed for function or command: '{0}'"' mi.Name);              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,RegisterXlMethod,The following statement contains a magic number: try              {                  object xlCallResult;                  XlCallImpl.TryExcelImpl(XlCallImpl.xlfRegister' out xlCallResult' registerParameters);                  Logger.Registration.Info("Register - XllPath={0}' ProcName={1}' FunctionType={2}' Name={3} - Result={4}"'                              registerParameters[0]' registerParameters[1]' registerParameters[2]' registerParameters[3]'                              xlCallResult);                  if (xlCallResult is double)                  {                      mi.RegisterId = (double) xlCallResult;                      registeredMethods.Add(mi);                      if (mi.IsCommand)                      {                          RegisterMenu(mi);                          RegisterShortCut(mi);                      }                  }                  else                  {                      Logger.Registration.Error("xlfRegister call failed for function or command: '{0}'"' mi.Name);                  }                  // Now clear out the xll path and store the parameters to support RegistrationInfo access.                  registerParameters[0] = null;                  registrationInfo.Add(registerParameters);              }              catch (Exception e)              {                  Logger.Registration.Error(e' "Registration failed for function or command: '{0}'"' mi.Name);              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,UnregisterMethods,The following statement contains a magic number: foreach (XlMethodInfo mi in registeredMethods)              {                  if (mi.IsCommand)                  {                      // Clear the name and unregister                      XlCallImpl.TryExcelImpl(XlCallImpl.xlfSetName' out xlCallResult' mi.Name);                      XlCallImpl.TryExcelImpl(XlCallImpl.xlfUnregister' out xlCallResult' mi.RegisterId);                  }                  else                  {                      // And Unregister the real function                      XlCallImpl.TryExcelImpl(XlCallImpl.xlfUnregister' out xlCallResult' mi.RegisterId);                      // I follow the advice from X-Cell website to get function out of Wizard (with fix from kh)                      XlCallImpl.TryExcelImpl(XlCallImpl.xlfRegister' out xlCallResult' XlAddIn.PathXll' "xlAutoRemove"' "I"' mi.Name' IntegrationMarshalHelpers.GetExcelMissingValue()' 2);                      if (xlCallResult is double)                      {                          double fakeRegisterId = (double)xlCallResult;                          XlCallImpl.TryExcelImpl(XlCallImpl.xlfSetName' out xlCallResult' mi.Name);                          XlCallImpl.TryExcelImpl(XlCallImpl.xlfUnregister' out xlCallResult' fakeRegisterId);                      }                  }              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: for (int j = 0; j < numArgumentDescriptions; j++)              {                  XlParameterInfo pi = mi.Parameters[j];                    functionType += pi.XlType;                    if (j > 0)                      argumentNames += "'";   // TODO: Should this be a comma' or the Excel list separator?                  argumentNames += pi.Name;                  argumentDescriptions[j] = pi.Description;                    if (pi.Description != "")                      showDescriptions = true;                    // DOCUMENT: Truncate the argument description if it exceeds the Excel limit of 255 characters                  if (j < mi.Parameters.Length - 1)                  {                      if (!string.IsNullOrEmpty(argumentDescriptions[j]) &&                          argumentDescriptions[j].Length > 255)                      {                          argumentDescriptions[j] = argumentDescriptions[j].Substring(0' 255);                          Logger.Registration.Warn("Truncated argument description of '{0}' in function '{1}'"' pi.Name' mi.Name);                      }                  }                  else                  {                      // Last argument - need to deal with extra ". "                      if (!string.IsNullOrEmpty(argumentDescriptions[j]))                      {                          if (argumentDescriptions[j].Length > 253)                          {                              argumentDescriptions[j] = argumentDescriptions[j].Substring(0' 253);                              Logger.Registration.Warn("Truncated final argument description of function '{0}'"' mi.Name);                          }                            // DOCUMENT: Here is the patch for the Excel Function Description bug.                          // DOCUMENT: Ensure the ". " suffix exists on the last parameter.                          if (!argumentDescriptions[j].EndsWith(". "))                              argumentDescriptions[j] += argumentDescriptions[j].EndsWith(".") ? " " : ". ";                      }                  }              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: for (int j = 0; j < numArgumentDescriptions; j++)              {                  XlParameterInfo pi = mi.Parameters[j];                    functionType += pi.XlType;                    if (j > 0)                      argumentNames += "'";   // TODO: Should this be a comma' or the Excel list separator?                  argumentNames += pi.Name;                  argumentDescriptions[j] = pi.Description;                    if (pi.Description != "")                      showDescriptions = true;                    // DOCUMENT: Truncate the argument description if it exceeds the Excel limit of 255 characters                  if (j < mi.Parameters.Length - 1)                  {                      if (!string.IsNullOrEmpty(argumentDescriptions[j]) &&                          argumentDescriptions[j].Length > 255)                      {                          argumentDescriptions[j] = argumentDescriptions[j].Substring(0' 255);                          Logger.Registration.Warn("Truncated argument description of '{0}' in function '{1}'"' pi.Name' mi.Name);                      }                  }                  else                  {                      // Last argument - need to deal with extra ". "                      if (!string.IsNullOrEmpty(argumentDescriptions[j]))                      {                          if (argumentDescriptions[j].Length > 253)                          {                              argumentDescriptions[j] = argumentDescriptions[j].Substring(0' 253);                              Logger.Registration.Warn("Truncated final argument description of function '{0}'"' mi.Name);                          }                            // DOCUMENT: Here is the patch for the Excel Function Description bug.                          // DOCUMENT: Ensure the ". " suffix exists on the last parameter.                          if (!argumentDescriptions[j].EndsWith(". "))                              argumentDescriptions[j] += argumentDescriptions[j].EndsWith(".") ? " " : ". ";                      }                  }              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: for (int j = 0; j < numArgumentDescriptions; j++)              {                  XlParameterInfo pi = mi.Parameters[j];                    functionType += pi.XlType;                    if (j > 0)                      argumentNames += "'";   // TODO: Should this be a comma' or the Excel list separator?                  argumentNames += pi.Name;                  argumentDescriptions[j] = pi.Description;                    if (pi.Description != "")                      showDescriptions = true;                    // DOCUMENT: Truncate the argument description if it exceeds the Excel limit of 255 characters                  if (j < mi.Parameters.Length - 1)                  {                      if (!string.IsNullOrEmpty(argumentDescriptions[j]) &&                          argumentDescriptions[j].Length > 255)                      {                          argumentDescriptions[j] = argumentDescriptions[j].Substring(0' 255);                          Logger.Registration.Warn("Truncated argument description of '{0}' in function '{1}'"' pi.Name' mi.Name);                      }                  }                  else                  {                      // Last argument - need to deal with extra ". "                      if (!string.IsNullOrEmpty(argumentDescriptions[j]))                      {                          if (argumentDescriptions[j].Length > 253)                          {                              argumentDescriptions[j] = argumentDescriptions[j].Substring(0' 253);                              Logger.Registration.Warn("Truncated final argument description of function '{0}'"' mi.Name);                          }                            // DOCUMENT: Here is the patch for the Excel Function Description bug.                          // DOCUMENT: Ensure the ". " suffix exists on the last parameter.                          if (!argumentDescriptions[j].EndsWith(". "))                              argumentDescriptions[j] += argumentDescriptions[j].EndsWith(".") ? " " : ". ";                      }                  }              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: for (int j = 0; j < numArgumentDescriptions; j++)              {                  XlParameterInfo pi = mi.Parameters[j];                    functionType += pi.XlType;                    if (j > 0)                      argumentNames += "'";   // TODO: Should this be a comma' or the Excel list separator?                  argumentNames += pi.Name;                  argumentDescriptions[j] = pi.Description;                    if (pi.Description != "")                      showDescriptions = true;                    // DOCUMENT: Truncate the argument description if it exceeds the Excel limit of 255 characters                  if (j < mi.Parameters.Length - 1)                  {                      if (!string.IsNullOrEmpty(argumentDescriptions[j]) &&                          argumentDescriptions[j].Length > 255)                      {                          argumentDescriptions[j] = argumentDescriptions[j].Substring(0' 255);                          Logger.Registration.Warn("Truncated argument description of '{0}' in function '{1}'"' pi.Name' mi.Name);                      }                  }                  else                  {                      // Last argument - need to deal with extra ". "                      if (!string.IsNullOrEmpty(argumentDescriptions[j]))                      {                          if (argumentDescriptions[j].Length > 253)                          {                              argumentDescriptions[j] = argumentDescriptions[j].Substring(0' 253);                              Logger.Registration.Warn("Truncated final argument description of function '{0}'"' mi.Name);                          }                            // DOCUMENT: Here is the patch for the Excel Function Description bug.                          // DOCUMENT: Ensure the ". " suffix exists on the last parameter.                          if (!argumentDescriptions[j].EndsWith(". "))                              argumentDescriptions[j] += argumentDescriptions[j].EndsWith(".") ? " " : ". ";                      }                  }              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: if (!mi.IsMacroType && mi.IsThreadSafe && XlAddIn.XlCallVersion >= 12)                  functionType += "$";
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: string functionDescription = Truncate(mi.Description' 253' "function description"' mi);
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: int maxDescriptions = (XlAddIn.XlCallVersion < 12) ? 20 : 245;
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: int maxDescriptions = (XlAddIn.XlCallVersion < 12) ? 20 : 245;
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: int maxDescriptions = (XlAddIn.XlCallVersion < 12) ? 20 : 245;
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: if (showDescriptions)              {                  numArgumentDescriptions = Math.Min(numArgumentDescriptions' maxDescriptions);                  numRegisterParameters = 10 + numArgumentDescriptions;    // function description + arg descriptions              }              else              {                  // Won't be showing any descriptions.                  numArgumentDescriptions = 0;                  numRegisterParameters = 9;              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: if (showDescriptions)              {                  numArgumentDescriptions = Math.Min(numArgumentDescriptions' maxDescriptions);                  numRegisterParameters = 10 + numArgumentDescriptions;    // function description + arg descriptions              }              else              {                  // Won't be showing any descriptions.                  numArgumentDescriptions = 0;                  numRegisterParameters = 9;              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: argumentNames = Truncate(argumentNames' 255' "argument names"' mi);
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: string category = Truncate(mi.Category' 255' "Category name"' mi);
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: string name = Truncate(mi.Name' 255' "Name"' mi);
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: if (mi.HelpTopic != null)              {                  if (mi.HelpTopic.Length > 255)                  {                      // Can't safely truncate the help link                      Logger.Registration.Warn("Ignoring HelpTopic of function '{0}' - too long"' mi.Name);                  }                  else                  {                      // It's OK                      helpTopic = mi.HelpTopic;                  }              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: registerParameters[2] = functionType;
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: registerParameters[3] = name;
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: registerParameters[4] = argumentNames;
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: registerParameters[5] = mi.IsCommand ? 2 /*macro*/                                                   : (mi.IsHidden ? 0 : 1);
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: registerParameters[5] = mi.IsCommand ? 2 /*macro*/                                                   : (mi.IsHidden ? 0 : 1);
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: registerParameters[6] = category;
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: registerParameters[7] = mi.ShortCut;
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: registerParameters[8] = helpTopic;
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: if (showDescriptions)              {                  registerParameters[9] = functionDescription;                    for (int k = 0; k < numArgumentDescriptions; k++)                  {                      registerParameters[10 + k] = argumentDescriptions[k];                  }              }
Magic Number,ExcelDna.Loader,XlRegistration,C:\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlRegistration.cs,GetRegisterParameters,The following statement contains a magic number: if (showDescriptions)              {                  registerParameters[9] = functionDescription;                    for (int k = 0; k < numArgumentDescriptions; k++)                  {                      registerParameters[10 + k] = argumentDescriptions[k];                  }              }
