Implementation smell,Namespace,Class,File,Method,Description
Long Method,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,Code,The method has 114 lines of code.
Long Method,ExcelDna.Loader,XlObject12Marshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalNativeToManaged,The method has 126 lines of code.
Long Method,ExcelDna.Loader,XlObject12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The method has 203 lines of code.
Long Method,ExcelDna.Loader,XlObjectArray12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The method has 400 lines of code.
Long Method,ExcelDna.Loader,XlObjectMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The method has 203 lines of code.
Long Method,ExcelDna.Loader,XlObjectMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The method has 114 lines of code.
Long Method,ExcelDna.Loader,XlObjectArrayMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The method has 340 lines of code.
Long Method,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The method has 104 lines of code.
Long Method,ExcelDna.Loader,XlMethodInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,SetAttributeInfo,The method has 161 lines of code.
Long Method,ExcelDna.Loader,XlMethodInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodInfo,The method has 150 lines of code.
Long Method,ExcelDna.Loader,XlParameterInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlParameterInfo.cs,SetTypeInfo4,The method has 264 lines of code.
Long Method,ExcelDna.Loader,XlParameterInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlParameterInfo.cs,SetTypeInfo12,The method has 267 lines of code.
Complex Method,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,Code,Cyclomatic complexity of the method is 15
Complex Method,ExcelDna.Loader,AssemblyManager,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,AssemblyResolve,Cyclomatic complexity of the method is 10
Complex Method,ExcelDna.Loader,XlObject12Marshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalNativeToManaged,Cyclomatic complexity of the method is 22
Complex Method,ExcelDna.Loader,XlObject12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,Cyclomatic complexity of the method is 24
Complex Method,ExcelDna.Loader,XlObjectArray12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,Cyclomatic complexity of the method is 46
Complex Method,ExcelDna.Loader,XlObjectArray12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalNativeToManaged,Cyclomatic complexity of the method is 8
Complex Method,ExcelDna.Loader,XlObjectMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,Cyclomatic complexity of the method is 23
Complex Method,ExcelDna.Loader,XlObjectMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,Cyclomatic complexity of the method is 18
Complex Method,ExcelDna.Loader,XlObjectArrayMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,Cyclomatic complexity of the method is 39
Complex Method,ExcelDna.Loader,XlObjectArrayMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,Cyclomatic complexity of the method is 8
Complex Method,ExcelDna.Loader,XlMethodInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,SetAttributeInfo,Cyclomatic complexity of the method is 15
Complex Method,ExcelDna.Loader,XlMethodInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodInfo,Cyclomatic complexity of the method is 19
Complex Method,ExcelDna.Loader,XlMethodInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,GetMethodAttributes,Cyclomatic complexity of the method is 11
Complex Method,ExcelDna.Loader,XlParameterInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlParameterInfo.cs,SetTypeInfo4,Cyclomatic complexity of the method is 29
Complex Method,ExcelDna.Loader,XlParameterInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlParameterInfo.cs,SetTypeInfo12,Cyclomatic complexity of the method is 30
Long Parameter List,SevenZip,ICoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\ICoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.RangeCoder,BitTreeEncoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Parameter List,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,AddCommandMenu,The method has 6 parameters. Parameters: commandName' menuName' menuText' description' shortCut' helpTopic
Long Identifier,SevenZip.Compression.LZMA,Base,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Statement,ExcelDna.Loader,AssemblyManager,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,AssemblyResolve,The length of the statement  "                    Logger.Initialization.Verbose("Assembly {0} could not be loaded from resources (ResourceManager probing for satellite assemblies)."' name); " is 139.
Long Statement,ExcelDna.Loader,AssemblyManager,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,AssemblyResolve,The length of the statement  "                Logger.Initialization.Info("Trying Assembly.Load for {0} (from {1} bytes' with {2} bytes of pdb)."' name' assemblyBytes.Length' pdbBytes.Length); " is 145.
Long Statement,ExcelDna.Loader,AssemblyManager,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,GetResourceBytes,The length of the statement  "                throw new ArgumentOutOfRangeException("type"' "Unknown resource type. Only types 0 (Assembly)' 1 (Dna file)' 2 (Image) or 3 (Source) are valid."); " is 146.
Long Statement,ExcelDna.Loader,ResourceHelper,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,LoadResourceBytes,The length of the statement  "                    Debug.Print("ResourceHelper.LoadResourceBytes - Resource not found - resource {0} of type {1}"' resourceName' typeName); " is 120.
Long Statement,ExcelDna.Loader,ResourceHelper,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,LoadResourceBytes,The length of the statement  "                Debug.Print("ResourceHelper.LoadResourceBytes - Unexpected errror loading resource {0} of type {1}"' resourceName' typeName); " is 125.
Long Statement,ExcelDna.Loader,XlDoubleArray12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,AllocateFP12AndCopy,The length of the statement  "                // CONSIDER: https://connect.microsoft.com/VisualStudio/feedback/details/766977/il-bytecode-method-cpblk-badly-implemented-by-x86-clr " is 133.
Long Statement,ExcelDna.Loader,XlObject12Marshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalNativeToManaged,The length of the statement  "                        // XlOper12.XlRectangle12* pAreas = (XlOper12.XlRectangle12*)((uint)pOper->refValue.pMultiRef + 4 /* FieldOffset for XlRectangles */); " is 134.
Long Statement,ExcelDna.Loader,XlObject12Marshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalNativeToManaged,The length of the statement  "                        XlOper12.XlRectangle12* pAreas = (XlOper12.XlRectangle12*)((byte*)(pOper->refValue.pMultiRef) + 4 /* FieldOffset for XlRectangles */); " is 134.
Long Statement,ExcelDna.Loader,XlObject12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The length of the statement  "				// Debug.Print("Getting XlObject12Marshaler instance for thread: " + System.Threading.Thread.CurrentThread.ManagedThreadId); " is 124.
Long Statement,ExcelDna.Loader,XlObject12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The length of the statement  "				// Debug.Print("Returning XlObject12Marshaler instance with Id {0} for thread {1}"' instance.instanceId' System.Threading.Thread.CurrentThread.ManagedThreadId); " is 160.
Long Statement,ExcelDna.Loader,XlObject12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The length of the statement  "				// Debug.Print("XlObject12Marshaler {0} - Marshaling for thread {1} "' instanceId' System.Threading.Thread.CurrentThread.ManagedThreadId); " is 138.
Long Statement,ExcelDna.Loader,XlObject12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The length of the statement  "                    // To avoid extra memory management in this class' wrap in an array and let the array marshaler deal with the reference. " is 120.
Long Statement,ExcelDna.Loader,XlObjectArray12Marshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,Dispose,The length of the statement  "			// Debug.Print("Disposing XlObjectArray12Marshaler with id {0} for thread {1}"' id' System.Threading.Thread.CurrentThread.ManagedThreadId); " is 139.
Long Statement,ExcelDna.Loader,XlObjectArray12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The length of the statement  "						cbNativeStrings += (Marshal.SizeOf(typeof(XlString12)) + ((Math.Min(str.Length' XlString12.MaxLength) - 1) /* 1 char already in XlString */) * 2 /* 2 bytes per char */); " is 169.
Long Statement,ExcelDna.Loader,XlObjectArray12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The length of the statement  "						numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount(obj); // ((ExcelReference)obj).InnerReferences.Count; " is 128.
Long Statement,ExcelDna.Loader,XlObjectArray12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,Dispose,The length of the statement  "			    // Debug.Print("Disposing XlObjectArray12MarshalerImpl with id {0} for thread {1}"' id' System.Threading.Thread.CurrentThread.ManagedThreadId); " is 143.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,CreateUnhandledExceptionHandlerWrapper,The length of the statement  "			MethodInfo unhandledExceptionHandler = integrationType.GetMethod("HandleUnhandledException"' BindingFlags.Static | BindingFlags.NonPublic); " is 139.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,CreateUnhandledExceptionHandlerWrapper,The length of the statement  "            DynamicMethod ueh = new DynamicMethod("UnhandledExceptionHandler"' typeof(object)' new Type[] { typeof(object) }' true); " is 120.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DnaLibraryAutoOpen,The length of the statement  "            integrationType.InvokeMember("DnaLibraryAutoOpen"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 143.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DnaLibraryAutoClose,The length of the statement  "            integrationType.InvokeMember("DnaLibraryAutoClose"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 144.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DnaLibraryGetName,The length of the statement  "            return (string)integrationType.InvokeMember("DnaLibraryGetName"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 157.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllRegisterServer,The length of the statement  "            return (HRESULT)integrationType.InvokeMember("DllRegisterServer"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 158.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllUnregisterServer,The length of the statement  "            return (HRESULT)integrationType.InvokeMember("DllUnregisterServer"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 160.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllGetClassObject,The length of the statement  "            result = (HRESULT)integrationType.InvokeMember("DllGetClassObject"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' args); " is 160.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllCanUnloadNow,The length of the statement  "            return (HRESULT)integrationType.InvokeMember("DllCanUnloadNow"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 156.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,InitializeIntegration,The length of the statement  "            integrationType.InvokeMember("Initialize"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] {xllPath});         " is 153.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DeInitializeIntegration,The length of the statement  "            integrationType.InvokeMember("DeInitialize"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 137.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,SyncMacro,The length of the statement  "            integrationType.InvokeMember("SyncMacro"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] {dValue}); " is 151.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,CalculationCanceled,The length of the statement  "            integrationType.InvokeMember("CalculationCanceled"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 144.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,CalculationEnded,The length of the statement  "            integrationType.InvokeMember("CalculationEnded"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 141.
Long Statement,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,GetIntegrationTraceSource,The length of the statement  "            return (System.Diagnostics.TraceSource)integrationType.InvokeMember("GetIntegrationTraceSource"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 189.
Long Statement,ExcelDna.Loader,XlCallImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCallImpl.cs,GetCurrentSheetId12,The length of the statement  "                // CONSIDER: As a small optimisation' we could combine the two calls the xlFree. But then we'd have to manage an array here. " is 124.
Long Statement,ExcelDna.Loader,XlObjectMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The length of the statement  "                // To avoid extra memory management in this class' wrap in an array and let the array marshaler deal with the reference. " is 120.
Long Statement,ExcelDna.Loader,XlObjectArrayMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The length of the statement  "                    numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount(obj); // ((ExcelReference)obj).InnerReferences.Count; " is 128.
Long Statement,ExcelDna.Loader,XlObjectArrayMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The length of the statement  "                int cbNativeReferences = numReferenceOpers * sizeof(ushort) + numReferences * Marshal.SizeOf(typeof(XlOper.XlRectangle)); " is 121.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The length of the statement  "            Debug.Print("In sandbox AppDomain with Id: {0}' running on thread: {1}"' AppDomain.CurrentDomain.Id' Thread.CurrentThread.ManagedThreadId); " is 139.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The length of the statement  "            // File.AppendAllText(Path.ChangeExtension(pathXll' ".log")' string.Format("{0:u} XlAddIn.Initialize OK\r\n"' DateTime.Now)); " is 125.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            // Get the assembly and ExcelIntegration type - will be loaded from file or from packed resources via AssemblyManager.AssemblyResolve. " is 134.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "                throw new InvalidOperationException("ExcelDna.Integration was loaded from Global Assembly Cache' and that's not allowed."); " is 123.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            int integrationVersion = (int)integrationType.InvokeMember("GetExcelIntegrationVersion"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 181.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            MethodInfo tryExcelImplMethod = typeof(XlCallImpl).GetMethod("TryExcelImpl"' BindingFlags.Static | BindingFlags.Public); " is 120.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            integrationType.InvokeMember("SetTryExcelImpl"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] { tryExcelImplDelegate }); " is 173.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            MethodInfo registerMethodsMethod = typeof(XlRegistration).GetMethod("RegisterMethods"' BindingFlags.Static | BindingFlags.Public); " is 130.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            integrationType.InvokeMember("SetRegisterMethods"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] { registerMethodsDelegate }); " is 179.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            MethodInfo registerWithAttMethod = typeof(XlRegistration).GetMethod("RegisterMethodsWithAttributes"' BindingFlags.Static | BindingFlags.Public); " is 144.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            Type registerWithAttDelegateType = integrationAssembly.GetType("ExcelDna.Integration.RegisterMethodsWithAttributesDelegate"); " is 125.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            integrationType.InvokeMember("SetRegisterMethodsWithAttributes"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] { registerWithAttDelegate }); " is 193.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            MethodInfo registerDelAttMethod = typeof(XlRegistration).GetMethod("RegisterDelegatesWithAttributes"' BindingFlags.Static | BindingFlags.Public); " is 145.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            Type registerDelAttDelegateType = integrationAssembly.GetType("ExcelDna.Integration.RegisterDelegatesWithAttributesDelegate"); " is 126.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            integrationType.InvokeMember("SetRegisterDelegatesWithAttributes"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] { registerDelAttDelegate }); " is 194.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            MethodInfo getResourceBytesMethod = typeof(AssemblyManager).GetMethod("GetResourceBytes"' BindingFlags.Static | BindingFlags.NonPublic); " is 136.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "            integrationType.InvokeMember("SetGetResourceBytesDelegate"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] { getResourceBytesDelegate }); " is 189.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,XlAutoOpen,The length of the statement  "            Debug.Print("XlAddIn.XlAutoOpen - AppDomain Id: " + AppDomain.CurrentDomain.Id + " (Default: " + AppDomain.CurrentDomain.IsDefaultAppDomain() + ")"); " is 149.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,XlAutoOpen,The length of the statement  "                string alertMessage = string.Format("A problem occurred while an add-in was being initialized (InitializeIntegration failed - {1}).\r\nThe add-in is built with ExcelDna and is being loaded from {0}"' pathXll' e.Message); " is 220.
Long Statement,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,XlAutoOpen,The length of the statement  "				XlCallImpl.TryExcelImpl(XlCallImpl.xlcAlert' out xlCallResult /*Ignored*/' alertMessage ' 3 /* Only OK Button' Warning Icon*/); " is 127.
Long Statement,ExcelDna.Loader,XlMethodInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodInfo,The length of the statement  "                throw new DnaMarshalException("DateTime and bool input parameters are incompatible with IsExceptionSafe attribute if return type is not object"); " is 145.
Long Statement,ExcelDna.Loader,XlMethodInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateDelegateTypeAndMethodInfo,The length of the statement  "            //           Future version might do straight-forward marshaling' so we can get rid of these types (just use generic methods) " is 125.
Long Statement,ExcelDna.Loader,XlMethodInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,ConvertToXlMethodInfos,The length of the statement  "                        Logger.Registration.Info("Suppressing due to ExplictRegistration attribute: '{0}.{1}'"' mi.DeclaringType.Name' mi.Name); " is 120.
Long Statement,ExcelDna.Loader,XlMethodInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,ConvertToXlMethodInfos,The length of the statement  "                    Logger.Registration.Error(e' "Method not registered due to unsupported signature: '{0}.{1}'"' mi.DeclaringType.Name' mi.Name); " is 126.
Long Statement,ExcelDna.Loader,XlParameterInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlParameterInfo.cs,GetMarshalAsAttribute,The length of the statement  "								new FieldInfo[] { typeof(MarshalAsAttribute).GetField("MarshalTypeRef")' typeof(MarshalAsAttribute).GetField("MarshalCookie") }' " is 128.
Complex Conditional,ExcelDna.Loader,AssemblyManager,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,GetAssemblyIfLoaded,The conditional expression  "(loadedName.CultureInfo == null) && (assemblyName.CultureInfo != null) ||                              (loadedName.CultureInfo != null) && (assemblyName.CultureInfo == null) ||                              !string.Equals(loadedName.CultureInfo.Name' assemblyName.CultureInfo.Name)"  is complex.
Complex Conditional,ExcelDna.Loader,XlMethodInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodInfo,The conditional expression  "IsExceptionSafe                  && Array.TrueForAll(Parameters'                                      delegate(XlParameterInfo pi) { return pi.BoxedValueType == null; })                  && (!HasReturnType || ReturnType.BoxedValueType == null)"  is complex.
Complex Conditional,ExcelDna.Loader,XlMethodInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodInfo,The conditional expression  "emitExceptionHandler && IsExceptionSafe && HasReturnType && ReturnType.DelegateParamType != typeof(object)"  is complex.
Empty Catch Block,ExcelDna.Loader,XlCallImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCallImpl.cs,FetchExcel12EntryPt,The method has an empty catch block.
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateChar,The following statement contains a magic number: Index < 4
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaBase.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDictionarySize,The following statement contains a magic number: uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: lp > 8
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: lc > 8
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: properties.Length < 5
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: i < 4
Magic Number,SevenZip.Compression.LZMA,LiteralDecoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,SevenZip.Compression.LZMA,Decoder2,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: uint matchBit = (uint)(matchByte >> 7) & 1;
Magic Number,SevenZip.Compression.LZMA,Decoder2,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,FlushData,The following statement contains a magic number: i < 5
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,Encode,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Stream.WriteByte((byte)(temp + (Low >> 32)));
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: _cache = (byte)(((uint)Low) >> 24);
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: (uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,EncodeBit,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize +  				Stream.Position - StartPosition + 4;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,Init,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,Init,The following statement contains a magic number: i < 5
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,Normalize,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,Normalize,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,Normalize2,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,Normalize2,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: uint t = (code - range) >> 31;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: code = (code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoderBit.cs,Encode,The following statement contains a magic number: encoder.Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;
Magic Number,ExcelDna.Loader,AssemblyManager,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,AssemblyResolve,The following statement contains a magic number: byte[] pdbBytes = GetResourceBytes(name' 4);
Magic Number,ExcelDna.Loader,ResourceHelper,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: byte[] properties2 = new byte[5];
Magic Number,ExcelDna.Loader,ResourceHelper,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: newInStream.Read(properties2' 0' 5) != 5
Magic Number,ExcelDna.Loader,ResourceHelper,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: newInStream.Read(properties2' 0' 5) != 5
Magic Number,ExcelDna.Loader,ResourceHelper,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: outSize |= ((long)(byte)v) << (8 * i);
Magic Number,ExcelDna.Loader,ResourceHelper,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: i < 8
Magic Number,ExcelDna.Loader,XlString12ReturnMarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,XlString12ReturnMarshalerImpl,The following statement contains a magic number: int size = Marshal.SizeOf(typeof(XlString12)) + ((XlString12.MaxLength - 1) /* 1 char is in Data[1] */ * 2 /* 2 bytes per char */);
Magic Number,ExcelDna.Loader,XlObject12Marshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalNativeToManaged,The following statement contains a magic number: switch (type)              {                  case XlType12.XlTypeNumber:                      double val = pOper->numValue;                      if (val == 0.0)                          managed = boxedZero;                      else if (val == 1.0)                          managed = boxedOne;                      else                          managed = val;                      break;                  case XlType12.XlTypeString:                      XlString12* pString = pOper->pstrValue;                      managed = new string(pString->Data' 0' pString->Length);                      break;                  case XlType12.XlTypeBoolean:                      managed = pOper->boolValue == 1;                      break;                  case XlType12.XlTypeError:                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(pOper->errValue);                      break;                  case XlType12.XlTypeMissing:                      // DOCUMENT: Changed in version 0.17.                      // managed = System.Reflection.Missing.Value;                      managed = IntegrationMarshalHelpers.GetExcelMissingValue();                      break;                  case XlType12.XlTypeEmpty:                      // DOCUMENT: Changed in version 0.17.                      // managed = null;                      managed = excelEmpty; // IntegrationMarshalHelpers.GetExcelEmptyValue();                      break;                  case XlType12.XlTypeArray:                      int rows = pOper->arrayValue.Rows;                      int columns = pOper->arrayValue.Columns;                      object['] array = new object[rows' columns];                      // TODO: Initialize as ExcelEmpty                      XlOper12* opers = (XlOper12*)pOper->arrayValue.pOpers;                      for (int i = 0; i < rows; i++)                      {                          int rowStart = i * columns;                          for (int j = 0; j < columns; j++)                          {                              int pos = rowStart + j;                              XlOper12* oper = opers + pos;                              // Fast-path for some cases                              if (oper->xlType == XlType12.XlTypeEmpty)                              {                                  array[i' j] = excelEmpty;                              }                              else if (oper->xlType == XlType12.XlTypeNumber)                              {                                  double dval = oper->numValue;                                  if (dval == 0.0)                                      array[i' j] = boxedZero;                                  else if (dval == 1.0)                                      array[i' j] = boxedOne;                                  else                                      array[i' j] = dval;                              }                              else                              {                                  array[i' j] = MarshalNativeToManaged((IntPtr)oper);                              }                          }                      }                      managed = array;                      break;                  case XlType12.XlTypeReference:                      object /*ExcelReference*/ r;                      if (pOper->refValue.pMultiRef == (XlOper12.XlMultiRef12*)IntPtr.Zero)                      {                          r = IntegrationMarshalHelpers.CreateExcelReference(0' 0' 0' 0' pOper->refValue.SheetId);                      }                      else                      {                          ushort numAreas = *(ushort*)pOper->refValue.pMultiRef;                          // XlOper12.XlRectangle12* pAreas = (XlOper12.XlRectangle12*)((uint)pOper->refValue.pMultiRef + 4 /* FieldOffset for XlRectangles */);                          XlOper12.XlRectangle12* pAreas = (XlOper12.XlRectangle12*)((byte*)(pOper->refValue.pMultiRef) + 4 /* FieldOffset for XlRectangles */);                          if (numAreas == 1)                          {                                r = IntegrationMarshalHelpers.CreateExcelReference(                                  pAreas[0].RowFirst' pAreas[0].RowLast'                                  pAreas[0].ColumnFirst' pAreas[0].ColumnLast' pOper->refValue.SheetId);                          }                          else                          {                              int[][] areas = new int[numAreas][];                              for (int i = 0; i < numAreas; i++)                              {                                  XlOper12.XlRectangle12 rect = pAreas[i];                                  int[] area = new int[4] { rect.RowFirst' rect.RowLast'                                                            rect.ColumnFirst' rect.ColumnLast };                                  areas[i] = area;                              }                              r = IntegrationMarshalHelpers.CreateExcelReference(areas' pOper->refValue.SheetId);                          }                      }                      managed = r;                      break;                  case XlType12.XlTypeSReference:                      IntPtr sheetId = XlCallImpl.GetCurrentSheetId12();                      object /*ExcelReference*/ sref;                      sref = IntegrationMarshalHelpers.CreateExcelReference(                                              pOper->srefValue.Reference.RowFirst'                                              pOper->srefValue.Reference.RowLast'                                              pOper->srefValue.Reference.ColumnFirst'                                              pOper->srefValue.Reference.ColumnLast'                                              sheetId /*Current sheet (not active sheet)*/);                      managed = sref;                      break;                  case XlType12.XlTypeInt: // Never passed from Excel to a UDF! int32 in XlOper12                      managed = (double)pOper->intValue;                      break;                  default:                      // unheard of !!                      managed = null;                      break;              }
Magic Number,ExcelDna.Loader,XlObject12Marshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalNativeToManaged,The following statement contains a magic number: switch (type)              {                  case XlType12.XlTypeNumber:                      double val = pOper->numValue;                      if (val == 0.0)                          managed = boxedZero;                      else if (val == 1.0)                          managed = boxedOne;                      else                          managed = val;                      break;                  case XlType12.XlTypeString:                      XlString12* pString = pOper->pstrValue;                      managed = new string(pString->Data' 0' pString->Length);                      break;                  case XlType12.XlTypeBoolean:                      managed = pOper->boolValue == 1;                      break;                  case XlType12.XlTypeError:                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(pOper->errValue);                      break;                  case XlType12.XlTypeMissing:                      // DOCUMENT: Changed in version 0.17.                      // managed = System.Reflection.Missing.Value;                      managed = IntegrationMarshalHelpers.GetExcelMissingValue();                      break;                  case XlType12.XlTypeEmpty:                      // DOCUMENT: Changed in version 0.17.                      // managed = null;                      managed = excelEmpty; // IntegrationMarshalHelpers.GetExcelEmptyValue();                      break;                  case XlType12.XlTypeArray:                      int rows = pOper->arrayValue.Rows;                      int columns = pOper->arrayValue.Columns;                      object['] array = new object[rows' columns];                      // TODO: Initialize as ExcelEmpty                      XlOper12* opers = (XlOper12*)pOper->arrayValue.pOpers;                      for (int i = 0; i < rows; i++)                      {                          int rowStart = i * columns;                          for (int j = 0; j < columns; j++)                          {                              int pos = rowStart + j;                              XlOper12* oper = opers + pos;                              // Fast-path for some cases                              if (oper->xlType == XlType12.XlTypeEmpty)                              {                                  array[i' j] = excelEmpty;                              }                              else if (oper->xlType == XlType12.XlTypeNumber)                              {                                  double dval = oper->numValue;                                  if (dval == 0.0)                                      array[i' j] = boxedZero;                                  else if (dval == 1.0)                                      array[i' j] = boxedOne;                                  else                                      array[i' j] = dval;                              }                              else                              {                                  array[i' j] = MarshalNativeToManaged((IntPtr)oper);                              }                          }                      }                      managed = array;                      break;                  case XlType12.XlTypeReference:                      object /*ExcelReference*/ r;                      if (pOper->refValue.pMultiRef == (XlOper12.XlMultiRef12*)IntPtr.Zero)                      {                          r = IntegrationMarshalHelpers.CreateExcelReference(0' 0' 0' 0' pOper->refValue.SheetId);                      }                      else                      {                          ushort numAreas = *(ushort*)pOper->refValue.pMultiRef;                          // XlOper12.XlRectangle12* pAreas = (XlOper12.XlRectangle12*)((uint)pOper->refValue.pMultiRef + 4 /* FieldOffset for XlRectangles */);                          XlOper12.XlRectangle12* pAreas = (XlOper12.XlRectangle12*)((byte*)(pOper->refValue.pMultiRef) + 4 /* FieldOffset for XlRectangles */);                          if (numAreas == 1)                          {                                r = IntegrationMarshalHelpers.CreateExcelReference(                                  pAreas[0].RowFirst' pAreas[0].RowLast'                                  pAreas[0].ColumnFirst' pAreas[0].ColumnLast' pOper->refValue.SheetId);                          }                          else                          {                              int[][] areas = new int[numAreas][];                              for (int i = 0; i < numAreas; i++)                              {                                  XlOper12.XlRectangle12 rect = pAreas[i];                                  int[] area = new int[4] { rect.RowFirst' rect.RowLast'                                                            rect.ColumnFirst' rect.ColumnLast };                                  areas[i] = area;                              }                              r = IntegrationMarshalHelpers.CreateExcelReference(areas' pOper->refValue.SheetId);                          }                      }                      managed = r;                      break;                  case XlType12.XlTypeSReference:                      IntPtr sheetId = XlCallImpl.GetCurrentSheetId12();                      object /*ExcelReference*/ sref;                      sref = IntegrationMarshalHelpers.CreateExcelReference(                                              pOper->srefValue.Reference.RowFirst'                                              pOper->srefValue.Reference.RowLast'                                              pOper->srefValue.Reference.ColumnFirst'                                              pOper->srefValue.Reference.ColumnLast'                                              sheetId /*Current sheet (not active sheet)*/);                      managed = sref;                      break;                  case XlType12.XlTypeInt: // Never passed from Excel to a UDF! int32 in XlOper12                      managed = (double)pOper->intValue;                      break;                  default:                      // unheard of !!                      managed = null;                      break;              }
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: int cbNativeReferences = numReferenceOpers * 4 /* sizeof ushort + packing to get to field offset */  											 + numReferences * Marshal.SizeOf(typeof(XlOper12.XlRectangle12));
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: int numBytes = 4 /* sizeof ushort + packing to get to field offset */  										   + refCount * Marshal.SizeOf(typeof(XlOper12.XlRectangle12));
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: pCurrent = IntPtr.Size == 4 ?                                   new IntPtr(unchecked(pCurrent.ToInt32() + (int)numBytes)) :                                   new IntPtr(unchecked(pCurrent.ToInt64() + numBytes));
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: rows * columns * 16 + cbNativeStrings + numReferences * 16 > 65535
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: rows * columns * 16 + cbNativeStrings + numReferences * 16 > 65535
Magic Number,ExcelDna.Loader,XlObjectArray12MarshalerImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal12.cs,MarshalManagedToNative,The following statement contains a magic number: rows * columns * 16 + cbNativeStrings + numReferences * 16 > 65535
Magic Number,ExcelDna.Loader,IntegrationHelpers,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllGetClassObject,The following statement contains a magic number: ppunk = (IntPtr)args[2];
Magic Number,ExcelDna.Loader,XlCallImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCallImpl.cs,TryExcelImpl,The following statement contains a magic number: XlAddIn.XlCallVersion < 12
Magic Number,ExcelDna.Loader,XlCallImpl,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCallImpl.cs,TryExcelImpl,The following statement contains a magic number: return 32;
Magic Number,ExcelDna.Loader,XlStringReturnMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: int charCount = Math.Min(str.Length' 255);
Magic Number,ExcelDna.Loader,XlStringReturnMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: int written = enc.GetBytes(psrc' charCount' pdest->Data' 255);
Magic Number,ExcelDna.Loader,XlObjectMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: switch (type)  			{  				case XlType.XlTypeNumber:  					managed = pOper->numValue;  					break;  				case XlType.XlTypeString:                      XlString* pString = pOper->pstrValue;                      // Support for system codepage by hmd                      // managed = new string((sbyte*)pString->Data' 0' pString->Length' Encoding.ASCII);                      Encoding enc = Encoding.GetEncoding(ASCIIEncoding.Default.CodePage'                                                          EncoderFallback.ReplacementFallback'                                                          DecoderFallback.ReplacementFallback);                      managed = new string((sbyte*)pString->Data' 0' pString->Length' enc);  					break;  				case XlType.XlTypeBoolean:  					managed = pOper->boolValue == 1;  					break;  				case XlType.XlTypeError:  					managed = IntegrationMarshalHelpers.GetExcelErrorObject(pOper->errValue);  					break;  				case XlType.XlTypeMissing:                      // DOCUMENT: Changed in version 0.17.  					// managed = System.Reflection.Missing.Value;                      managed = IntegrationMarshalHelpers.GetExcelMissingValue();  					break;  				case XlType.XlTypeEmpty:                      // DOCUMENT: Changed in version 0.17.                      // managed = null;                      managed = IntegrationMarshalHelpers.GetExcelEmptyValue();  					break;  				case XlType.XlTypeArray:  					int rows = pOper->arrayValue.Rows;  					int columns = pOper->arrayValue.Columns;  					object['] array = new object[rows' columns];  					XlOper* opers = (XlOper*)pOper->arrayValue.pOpers;  					for (int i = 0; i < rows; i++)  					{  						for (int j = 0; j < columns; j++)  						{  							int pos = i * columns + j;  							array[i' j] = MarshalNativeToManaged((IntPtr)(opers + pos));  						}  					}  					managed = array;  					break;  				case XlType.XlTypeInt:  					managed = (double)pOper->intValue; // int16 in XlOper // always return double  					break;  				case XlType.XlTypeReference:  					object /*ExcelReference*/ r;  					if (pOper->refValue.pMultiRef == (XlOper.XlMultiRef*)IntPtr.Zero)  					{  						r = IntegrationMarshalHelpers.CreateExcelReference(0' 0' 0' 0' pOper->refValue.SheetId);  					}  					else  					{  						ushort numAreas = *(ushort*)pOper->refValue.pMultiRef;  						XlOper.XlRectangle* pAreas = (XlOper.XlRectangle*)((uint)pOper->refValue.pMultiRef + sizeof(ushort));                          if (numAreas == 1)                          {                              r = IntegrationMarshalHelpers.CreateExcelReference(                                  pAreas[0].RowFirst' pAreas[0].RowLast'                                  pAreas[0].ColumnFirst' pAreas[0].ColumnLast' pOper->refValue.SheetId);                          }                          else                          {                              int[][] areas = new int[numAreas][];                              for (int i = 0; i < numAreas; i++)                              {                                  XlOper.XlRectangle rect = pAreas[i];                                  int[] area = new int[4] { rect.RowFirst' rect.RowLast'                                                            rect.ColumnFirst' rect.ColumnLast };                                  areas[i] = area;                              }                              r = IntegrationMarshalHelpers.CreateExcelReference(areas' pOper->refValue.SheetId);                          }  					}  					managed = r;  					break;  				case XlType.XlTypeSReference:                      IntPtr sheetId = XlCallImpl.GetCurrentSheetId4();  					object /*ExcelReference*/ sref;  					sref = IntegrationMarshalHelpers.CreateExcelReference(                                              pOper->srefValue.Reference.RowFirst'  											pOper->srefValue.Reference.RowLast'  											pOper->srefValue.Reference.ColumnFirst'  											pOper->srefValue.Reference.ColumnLast'   											sheetId /*Current sheet (not Active sheet!)*/);  					managed = sref;  					break;                  case 0:                      // We get type == 0 when a long (>255 char) string is embedded in an array.                      // To be consistent with the string handling' we set the value to #VALUE                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(15 /* ExcelErrorValue */);                      break;  				default:                      // Unexpected !? (BigData perhaps - How did it get here?)                      // We do #VALUE here too' rather than set to null.                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(15 /* ExcelErrorValue */);  					break;  			}
Magic Number,ExcelDna.Loader,XlObjectMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: switch (type)  			{  				case XlType.XlTypeNumber:  					managed = pOper->numValue;  					break;  				case XlType.XlTypeString:                      XlString* pString = pOper->pstrValue;                      // Support for system codepage by hmd                      // managed = new string((sbyte*)pString->Data' 0' pString->Length' Encoding.ASCII);                      Encoding enc = Encoding.GetEncoding(ASCIIEncoding.Default.CodePage'                                                          EncoderFallback.ReplacementFallback'                                                          DecoderFallback.ReplacementFallback);                      managed = new string((sbyte*)pString->Data' 0' pString->Length' enc);  					break;  				case XlType.XlTypeBoolean:  					managed = pOper->boolValue == 1;  					break;  				case XlType.XlTypeError:  					managed = IntegrationMarshalHelpers.GetExcelErrorObject(pOper->errValue);  					break;  				case XlType.XlTypeMissing:                      // DOCUMENT: Changed in version 0.17.  					// managed = System.Reflection.Missing.Value;                      managed = IntegrationMarshalHelpers.GetExcelMissingValue();  					break;  				case XlType.XlTypeEmpty:                      // DOCUMENT: Changed in version 0.17.                      // managed = null;                      managed = IntegrationMarshalHelpers.GetExcelEmptyValue();  					break;  				case XlType.XlTypeArray:  					int rows = pOper->arrayValue.Rows;  					int columns = pOper->arrayValue.Columns;  					object['] array = new object[rows' columns];  					XlOper* opers = (XlOper*)pOper->arrayValue.pOpers;  					for (int i = 0; i < rows; i++)  					{  						for (int j = 0; j < columns; j++)  						{  							int pos = i * columns + j;  							array[i' j] = MarshalNativeToManaged((IntPtr)(opers + pos));  						}  					}  					managed = array;  					break;  				case XlType.XlTypeInt:  					managed = (double)pOper->intValue; // int16 in XlOper // always return double  					break;  				case XlType.XlTypeReference:  					object /*ExcelReference*/ r;  					if (pOper->refValue.pMultiRef == (XlOper.XlMultiRef*)IntPtr.Zero)  					{  						r = IntegrationMarshalHelpers.CreateExcelReference(0' 0' 0' 0' pOper->refValue.SheetId);  					}  					else  					{  						ushort numAreas = *(ushort*)pOper->refValue.pMultiRef;  						XlOper.XlRectangle* pAreas = (XlOper.XlRectangle*)((uint)pOper->refValue.pMultiRef + sizeof(ushort));                          if (numAreas == 1)                          {                              r = IntegrationMarshalHelpers.CreateExcelReference(                                  pAreas[0].RowFirst' pAreas[0].RowLast'                                  pAreas[0].ColumnFirst' pAreas[0].ColumnLast' pOper->refValue.SheetId);                          }                          else                          {                              int[][] areas = new int[numAreas][];                              for (int i = 0; i < numAreas; i++)                              {                                  XlOper.XlRectangle rect = pAreas[i];                                  int[] area = new int[4] { rect.RowFirst' rect.RowLast'                                                            rect.ColumnFirst' rect.ColumnLast };                                  areas[i] = area;                              }                              r = IntegrationMarshalHelpers.CreateExcelReference(areas' pOper->refValue.SheetId);                          }  					}  					managed = r;  					break;  				case XlType.XlTypeSReference:                      IntPtr sheetId = XlCallImpl.GetCurrentSheetId4();  					object /*ExcelReference*/ sref;  					sref = IntegrationMarshalHelpers.CreateExcelReference(                                              pOper->srefValue.Reference.RowFirst'  											pOper->srefValue.Reference.RowLast'  											pOper->srefValue.Reference.ColumnFirst'  											pOper->srefValue.Reference.ColumnLast'   											sheetId /*Current sheet (not Active sheet!)*/);  					managed = sref;  					break;                  case 0:                      // We get type == 0 when a long (>255 char) string is embedded in an array.                      // To be consistent with the string handling' we set the value to #VALUE                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(15 /* ExcelErrorValue */);                      break;  				default:                      // Unexpected !? (BigData perhaps - How did it get here?)                      // We do #VALUE here too' rather than set to null.                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(15 /* ExcelErrorValue */);  					break;  			}
Magic Number,ExcelDna.Loader,XlObjectMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: switch (type)  			{  				case XlType.XlTypeNumber:  					managed = pOper->numValue;  					break;  				case XlType.XlTypeString:                      XlString* pString = pOper->pstrValue;                      // Support for system codepage by hmd                      // managed = new string((sbyte*)pString->Data' 0' pString->Length' Encoding.ASCII);                      Encoding enc = Encoding.GetEncoding(ASCIIEncoding.Default.CodePage'                                                          EncoderFallback.ReplacementFallback'                                                          DecoderFallback.ReplacementFallback);                      managed = new string((sbyte*)pString->Data' 0' pString->Length' enc);  					break;  				case XlType.XlTypeBoolean:  					managed = pOper->boolValue == 1;  					break;  				case XlType.XlTypeError:  					managed = IntegrationMarshalHelpers.GetExcelErrorObject(pOper->errValue);  					break;  				case XlType.XlTypeMissing:                      // DOCUMENT: Changed in version 0.17.  					// managed = System.Reflection.Missing.Value;                      managed = IntegrationMarshalHelpers.GetExcelMissingValue();  					break;  				case XlType.XlTypeEmpty:                      // DOCUMENT: Changed in version 0.17.                      // managed = null;                      managed = IntegrationMarshalHelpers.GetExcelEmptyValue();  					break;  				case XlType.XlTypeArray:  					int rows = pOper->arrayValue.Rows;  					int columns = pOper->arrayValue.Columns;  					object['] array = new object[rows' columns];  					XlOper* opers = (XlOper*)pOper->arrayValue.pOpers;  					for (int i = 0; i < rows; i++)  					{  						for (int j = 0; j < columns; j++)  						{  							int pos = i * columns + j;  							array[i' j] = MarshalNativeToManaged((IntPtr)(opers + pos));  						}  					}  					managed = array;  					break;  				case XlType.XlTypeInt:  					managed = (double)pOper->intValue; // int16 in XlOper // always return double  					break;  				case XlType.XlTypeReference:  					object /*ExcelReference*/ r;  					if (pOper->refValue.pMultiRef == (XlOper.XlMultiRef*)IntPtr.Zero)  					{  						r = IntegrationMarshalHelpers.CreateExcelReference(0' 0' 0' 0' pOper->refValue.SheetId);  					}  					else  					{  						ushort numAreas = *(ushort*)pOper->refValue.pMultiRef;  						XlOper.XlRectangle* pAreas = (XlOper.XlRectangle*)((uint)pOper->refValue.pMultiRef + sizeof(ushort));                          if (numAreas == 1)                          {                              r = IntegrationMarshalHelpers.CreateExcelReference(                                  pAreas[0].RowFirst' pAreas[0].RowLast'                                  pAreas[0].ColumnFirst' pAreas[0].ColumnLast' pOper->refValue.SheetId);                          }                          else                          {                              int[][] areas = new int[numAreas][];                              for (int i = 0; i < numAreas; i++)                              {                                  XlOper.XlRectangle rect = pAreas[i];                                  int[] area = new int[4] { rect.RowFirst' rect.RowLast'                                                            rect.ColumnFirst' rect.ColumnLast };                                  areas[i] = area;                              }                              r = IntegrationMarshalHelpers.CreateExcelReference(areas' pOper->refValue.SheetId);                          }  					}  					managed = r;  					break;  				case XlType.XlTypeSReference:                      IntPtr sheetId = XlCallImpl.GetCurrentSheetId4();  					object /*ExcelReference*/ sref;  					sref = IntegrationMarshalHelpers.CreateExcelReference(                                              pOper->srefValue.Reference.RowFirst'  											pOper->srefValue.Reference.RowLast'  											pOper->srefValue.Reference.ColumnFirst'  											pOper->srefValue.Reference.ColumnLast'   											sheetId /*Current sheet (not Active sheet!)*/);  					managed = sref;  					break;                  case 0:                      // We get type == 0 when a long (>255 char) string is embedded in an array.                      // To be consistent with the string handling' we set the value to #VALUE                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(15 /* ExcelErrorValue */);                      break;  				default:                      // Unexpected !? (BigData perhaps - How did it get here?)                      // We do #VALUE here too' rather than set to null.                      managed = IntegrationMarshalHelpers.GetExcelErrorObject(15 /* ExcelErrorValue */);  					break;  			}
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: int charCount = Math.Min(str.Length' 255);
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: int written = enc.GetBytes(psrc' charCount' pXlString->Data' 255);
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: rows * columns * 16 + cbNativeStrings + numReferences * 8 > 65535
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: rows * columns * 16 + cbNativeStrings + numReferences * 8 > 65535
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: rows * columns * 16 + cbNativeStrings + numReferences * 8 > 65535
Magic Number,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The following statement contains a magic number: exportInfoVersion != 8
Magic Number,ExcelDna.Loader,XlAddIn,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The following statement contains a magic number: XlAddIn.xlCallVersion = XlCallImpl.XLCallVer() / 256;
Magic Number,ExcelDna.Loader,XlMethodInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodInfo,The following statement contains a magic number: Environment.Version.Major >= 4 && emitExceptionHandler
Magic Number,ExcelDna.Loader,XlMethodInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodInfo,The following statement contains a magic number: i < 255
Magic Number,ExcelDna.Loader,XlMethodInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodInfo,The following statement contains a magic number: idx < 256
Magic Number,ExcelDna.Loader,XlParameterInfo,D:\research\architectureSmells\repos\Excel-DNA_Excel-DNA\Source\ExcelDna.Loader\XlParameterInfo.cs,SetTypeInfo,The following statement contains a magic number: (XlAddIn.XlCallVersion < 12)
