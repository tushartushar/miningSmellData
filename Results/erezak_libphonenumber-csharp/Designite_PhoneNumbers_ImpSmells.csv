Implementation smell,Namespace,Class,File,Method,Description
Long Method,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,PhoneNumberUtil,The method has 128 lines of code.
Complex Method,PhoneNumbers,AreaCodeMap,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\AreaCodeMap.cs,Lookup,Cyclomatic complexity of the method is 8
Complex Method,PhoneNumbers,AsYouTypeFormatter,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\AsYouTypeFormatter.cs,InputDigitWithOptionToRememberPosition,Cyclomatic complexity of the method is 22
Complex Method,PhoneNumbers,BuildMetadataFromXml,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\BuildMetadataFromXml.cs,LoadTerritoryTagMetadata,Cyclomatic complexity of the method is 10
Complex Method,PhoneNumbers,BuildMetadataFromXml,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\BuildMetadataFromXml.cs,LoadAvailableFormats,Cyclomatic complexity of the method is 8
Complex Method,PhoneNumbers,BuildMetadataFromXml,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\BuildMetadataFromXml.cs,ProcessPhoneNumberDescElement,Cyclomatic complexity of the method is 8
Complex Method,PhoneNumbers,MappingFileProvider,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\MappingFileProvider.cs,FindBestMatchingLanguageCode,Cyclomatic complexity of the method is 10
Complex Method,PhoneNumbers,NumberFormat,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,GetHashCode,Cyclomatic complexity of the method is 8
Complex Method,PhoneNumbers,PhoneMetadata,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,GetHashCode,Cyclomatic complexity of the method is 30
Complex Method,PhoneNumbers,PhoneNumberMatcher,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberMatcher.cs,ParseAndVerify,Cyclomatic complexity of the method is 8
Complex Method,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,PhoneNumberUtil,Cyclomatic complexity of the method is 8
Complex Method,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,Verify,Cyclomatic complexity of the method is 10
Complex Method,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatOutOfCountryCallingNumber,Cyclomatic complexity of the method is 8
Complex Method,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatInOriginalFormat,Cyclomatic complexity of the method is 35
Complex Method,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,PrefixNumberWithCountryCallingCode,Cyclomatic complexity of the method is 8
Complex Method,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,GetNumberDescByType,Cyclomatic complexity of the method is 12
Complex Method,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,MaybeExtractCountryCode,Cyclomatic complexity of the method is 10
Complex Method,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,ParseHelper,Cyclomatic complexity of the method is 18
Long Parameter List,PhoneNumbers,BuildMetadataFromXml,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\BuildMetadataFromXml.cs,LoadAvailableFormats,The method has 5 parameters.
Long Parameter List,PhoneNumbers,PhoneNumberMatcher,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberMatcher.cs,PhoneNumberMatcher,The method has 5 parameters.
Long Parameter List,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,MaybeExtractCountryCode,The method has 5 parameters.
Long Parameter List,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,ParseHelper,The method has 5 parameters.
Long Identifier,PhoneNumbers,AsYouTypeFormatter,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\AsYouTypeFormatter.cs,AttemptToExtractCountryCallingCode,The length of the parameter numberWithoutCountryCallingCode is 31.
Long Identifier,PhoneNumbers,BuildMetadataFromXml,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\BuildMetadataFromXml.cs,LoadAvailableFormats,The length of the parameter nationalPrefixOptionalWhenFormatting is 36.
Long Identifier,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,GetInstance,The length of the parameter countryCallingCodeToRegionCodeMap is 33.
Long Identifier,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatOutOfCountryCallingNumber,The length of the parameter internationalPrefixForFormatting is 32.
Long Identifier,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatOutOfCountryKeepingAlphaChars,The length of the parameter internationalPrefixForFormatting is 32.
Long Identifier,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,IsNumberMatch,The length of the parameter secondNumberWithFirstNumberRegion is 33.
Long Statement,PhoneNumbers,AsYouTypeFormatter,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\AsYouTypeFormatter.cs,GetAvailableFormats,The length of the statement  "	IList<NumberFormat> formatList = (isInternationalFormatting && currentMetaData.IntlNumberFormatCount > 0) ? currentMetaData.IntlNumberFormatList : currentMetaData.NumberFormatList; " is 180.
Long Statement,PhoneNumbers,AsYouTypeFormatter,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\AsYouTypeFormatter.cs,NarrowDownPossibleFormats,The length of the statement  "			var leadingDigitsPattern = regexCache.GetPatternForRegex (format.LeadingDigitsPatternList [indexOfLeadingDigitsPattern]); " is 121.
Long Statement,PhoneNumbers,AsYouTypeFormatter,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\AsYouTypeFormatter.cs,IsDigitOrLeadingPlusSign,The length of the statement  "	return char.IsDigit (nextChar) || (accruedInput.Length == 1 && PhoneNumberUtil.PLUS_CHARS_PATTERN.MatchAll (char.ToString (nextChar)).Success); " is 143.
Long Statement,PhoneNumbers,AsYouTypeFormatter,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\AsYouTypeFormatter.cs,RemoveNationalPrefixFromNationalNumber,The length of the statement  "		var m = regexCache.GetPatternForRegex (currentMetaData.NationalPrefixForParsing).MatchBeginning (nationalNumber.ToString ()); " is 125.
Long Statement,PhoneNumbers,AsYouTypeFormatter,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\AsYouTypeFormatter.cs,AttemptToExtractIdd,The length of the statement  "	var internationalPrefix = regexCache.GetPatternForRegex ("\\" + PhoneNumberUtil.PLUS_SIGN + "|" + currentMetaData.InternationalPrefix); " is 135.
Long Statement,PhoneNumbers,BuildMetadataFromXml,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\BuildMetadataFromXml.cs,LoadAvailableFormats,The length of the statement  "				format.SetNationalPrefixFormattingRule (GetNationalPrefixFormattingRuleFromElement (numberFormatElement' nationalPrefix)); " is 122.
Long Statement,PhoneNumbers,BuildMetadataFromXml,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\BuildMetadataFromXml.cs,LoadAvailableFormats,The length of the statement  "				format.SetNationalPrefixOptionalWhenFormatting (numberFormatElement.HasAttribute (NATIONAL_PREFIX_OPTIONAL_WHEN_FORMATTING)); " is 125.
Long Statement,PhoneNumbers,BuildMetadataFromXml,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\BuildMetadataFromXml.cs,LoadAvailableFormats,The length of the statement  "				format.SetDomesticCarrierCodeFormattingRule (ValidateRE (GetDomesticCarrierCodeFormattingRuleFromElement (numberFormatElement' nationalPrefix))); " is 145.
Long Statement,PhoneNumbers,BuildMetadataFromXml,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\BuildMetadataFromXml.cs,LoadGeneralDesc,The length of the statement  "	metadata.SetNoInternationalDialling (ProcessPhoneNumberDescElement (generalDesc' element' NO_INTERNATIONAL_DIALLING' liteBuild)); " is 129.
Long Statement,PhoneNumbers,BuildMetadataFromXml,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\BuildMetadataFromXml.cs,LoadGeneralDesc,The length of the statement  "	metadata.SetSameMobileAndFixedLinePattern (metadata.Mobile.NationalNumberPattern.Equals (metadata.FixedLine.NationalNumberPattern)); " is 132.
Long Statement,PhoneNumbers,BuildMetadataFromXml,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\BuildMetadataFromXml.cs,LoadCountryMetadata,The length of the statement  "	LoadAvailableFormats (metadata' element' nationalPrefix.ToString ()' nationalPrefixFormattingRule.ToString ()' element.HasAttribute (NATIONAL_PREFIX_OPTIONAL_WHEN_FORMATTING)); " is 176.
Long Statement,PhoneNumbers,MetadataManager,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\MetadataManager.cs,GetAlternateFormatsForCountry,The length of the statement  "		return callingCodeToAlternateFormatsMap.ContainsKey (countryCallingCode) ? callingCodeToAlternateFormatsMap [countryCallingCode] : null; " is 136.
Long Statement,PhoneNumbers,NumberFormat,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasNationalPrefixFormattingRule != other.hasNationalPrefixFormattingRule || (hasNationalPrefixFormattingRule && !nationalPrefixFormattingRule_.Equals (other.nationalPrefixFormattingRule_))) " is 193.
Long Statement,PhoneNumbers,NumberFormat,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasNationalPrefixOptionalWhenFormatting != other.hasNationalPrefixOptionalWhenFormatting || (hasNationalPrefixOptionalWhenFormatting && !nationalPrefixOptionalWhenFormatting_.Equals (other.nationalPrefixOptionalWhenFormatting_))) " is 233.
Long Statement,PhoneNumbers,NumberFormat,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasDomesticCarrierCodeFormattingRule != other.hasDomesticCarrierCodeFormattingRule || (hasDomesticCarrierCodeFormattingRule && !domesticCarrierCodeFormattingRule_.Equals (other.domesticCarrierCodeFormattingRule_))) " is 218.
Long Statement,PhoneNumbers,PhoneNumberDesc,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasNationalNumberPattern != other.hasNationalNumberPattern || (hasNationalNumberPattern && !nationalNumberPattern_.Equals (other.nationalNumberPattern_))) " is 158.
Long Statement,PhoneNumbers,PhoneNumberDesc,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasPossibleNumberPattern != other.hasPossibleNumberPattern || (hasPossibleNumberPattern && !possibleNumberPattern_.Equals (other.possibleNumberPattern_))) " is 158.
Long Statement,PhoneNumbers,PhoneMetadata,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasPersonalNumber != other.hasPersonalNumber || (hasPersonalNumber && !personalNumber_.Equals (other.personalNumber_))) " is 123.
Long Statement,PhoneNumbers,PhoneMetadata,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasNoInternationalDialling != other.hasNoInternationalDialling || (hasNoInternationalDialling && !noInternationalDialling_.Equals (other.noInternationalDialling_))) " is 168.
Long Statement,PhoneNumbers,PhoneMetadata,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasInternationalPrefix != other.hasInternationalPrefix || (hasInternationalPrefix && !internationalPrefix_.Equals (other.internationalPrefix_))) " is 148.
Long Statement,PhoneNumbers,PhoneMetadata,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasPreferredInternationalPrefix != other.hasPreferredInternationalPrefix || (hasPreferredInternationalPrefix && !preferredInternationalPrefix_.Equals (other.preferredInternationalPrefix_))) " is 193.
Long Statement,PhoneNumbers,PhoneMetadata,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasNationalPrefix != other.hasNationalPrefix || (hasNationalPrefix && !nationalPrefix_.Equals (other.nationalPrefix_))) " is 123.
Long Statement,PhoneNumbers,PhoneMetadata,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasPreferredExtnPrefix != other.hasPreferredExtnPrefix || (hasPreferredExtnPrefix && !preferredExtnPrefix_.Equals (other.preferredExtnPrefix_))) " is 148.
Long Statement,PhoneNumbers,PhoneMetadata,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasNationalPrefixForParsing != other.hasNationalPrefixForParsing || (hasNationalPrefixForParsing && !nationalPrefixForParsing_.Equals (other.nationalPrefixForParsing_))) " is 173.
Long Statement,PhoneNumbers,PhoneMetadata,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasNationalPrefixTransformRule != other.hasNationalPrefixTransformRule || (hasNationalPrefixTransformRule && !nationalPrefixTransformRule_.Equals (other.nationalPrefixTransformRule_))) " is 188.
Long Statement,PhoneNumbers,PhoneMetadata,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasSameMobileAndFixedLinePattern != other.hasSameMobileAndFixedLinePattern || (hasSameMobileAndFixedLinePattern && !sameMobileAndFixedLinePattern_.Equals (other.sameMobileAndFixedLinePattern_))) " is 198.
Long Statement,PhoneNumbers,PhoneMetadata,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasMainCountryForCode != other.hasMainCountryForCode || (hasMainCountryForCode && !mainCountryForCode_.Equals (other.mainCountryForCode_))) " is 143.
Long Statement,PhoneNumbers,PhoneMetadata,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonemetadata.cs,Equals,The length of the statement  "	if (hasLeadingZeroPossible != other.hasLeadingZeroPossible || (hasLeadingZeroPossible && !leadingZeroPossible_.Equals (other.leadingZeroPossible_))) " is 148.
Long Statement,PhoneNumbers,PhoneNumber,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonenumber.cs,Equals,The length of the statement  "	if (hasNationalNumber != other.hasNationalNumber || (hasNationalNumber && !nationalNumber_.Equals (other.nationalNumber_))) " is 123.
Long Statement,PhoneNumbers,PhoneNumber,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonenumber.cs,Equals,The length of the statement  "	if (hasCountryCodeSource != other.hasCountryCodeSource || (hasCountryCodeSource && !countryCodeSource_.Equals (other.countryCodeSource_))) " is 138.
Long Statement,PhoneNumbers,PhoneNumber,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\Phonenumber.cs,Equals,The length of the statement  "	if (hasPreferredDomesticCarrierCode != other.hasPreferredDomesticCarrierCode || (hasPreferredDomesticCarrierCode && !preferredDomesticCarrierCode_.Equals (other.preferredDomesticCarrierCode_))) " is 193.
Long Statement,PhoneNumbers,PhoneNumberMatcher,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberMatcher.cs,TrimAfterUnwantedChars,The length of the statement  "		if (c != '#' && (uc != UnicodeCategory.UppercaseLetter && uc != UnicodeCategory.LowercaseLetter && uc != UnicodeCategory.TitlecaseLetter && uc != UnicodeCategory.ModifierLetter && uc != UnicodeCategory.OtherLetter && uc != UnicodeCategory.DecimalDigitNumber && uc != UnicodeCategory.LetterNumber && uc != UnicodeCategory.OtherNumber)) { " is 336.
Long Statement,PhoneNumbers,PhoneNumberMatcher,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberMatcher.cs,AllNumberGroupsRemainGrouped,The length of the statement  "				return normalizedCandidate.ToString ().Substring (fromIndex - formattedNumberGroups [i].Length).StartsWith (nationalSignificantNumber); " is 135.
Long Statement,PhoneNumbers,PhoneNumberMatcher,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberMatcher.cs,AllNumberGroupsAreExactlyPresent,The length of the statement  "	if (candidateGroups.Length == 1 || candidateGroups [candidateNumberGroupIndex].Contains (util.GetNationalSignificantNumber (number))) { " is 135.
Long Statement,PhoneNumbers,PhoneNumberMatcher,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberMatcher.cs,AllNumberGroupsAreExactlyPresent,The length of the statement  "	for (int formattedNumberGroupIndex = (formattedNumberGroups.Length - 1); formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0; formattedNumberGroupIndex--' candidateNumberGroupIndex--) { " is 197.
Long Statement,PhoneNumbers,PhoneNumberMatcher,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberMatcher.cs,AllNumberGroupsAreExactlyPresent,The length of the statement  "	return (candidateNumberGroupIndex >= 0 && candidateGroups [candidateNumberGroupIndex].EndsWith (formattedNumberGroups [0])); " is 124.
Long Statement,PhoneNumbers,PhoneNumberMatcher,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberMatcher.cs,GetNationalNumberGroups,The length of the statement  "		return util.FormatNsnUsingPattern (nationalSignificantNumber' formattingPattern' PhoneNumberFormat.RFC3966).Split (new[] { " is 122.
Long Statement,PhoneNumbers,PhoneNumberOfflineGeocoder,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberOfflineGeocoder.cs,GetRegionDisplayName,The length of the statement  "	return (regionCode == null || regionCode.Equals ("ZZ") || regionCode.Equals (PhoneNumberUtil.REGION_CODE_FOR_NON_GEO_ENTITY)) ? "" : new Locale (""' regionCode).GetDisplayCountry (language.Language); " is 199.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,CreateExtnPattern,The length of the statement  "	return (RFC3966_EXTN_PREFIX + CAPTURING_EXTN_DIGITS + "|" + "[ \u00A0\\t']*" + "(?:e?xt(?:ensi(?:o\u0301?|\u00F3))?n?|\uFF45?\uFF58\uFF54\uFF4E?|" + "[" + singleExtnSymbols + "]|int|anexo|\uFF49\uFF4E\uFF54)" + "[:\\.\uFF0E]?[ \u00A0\\t'-]*" + CAPTURING_EXTN_DIGITS + "#?|" + "[- ]+(" + DIGITS + "{1'5})#"); " is 307.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,Verify,The length of the statement  "		if (!util.IsValidNumber (number) || !PhoneNumberMatcher.ContainsOnlyValidXChars (number' candidate' util) || PhoneNumberMatcher.ContainsMoreThanOneSlash (candidate) || !PhoneNumberMatcher.IsNationalPrefixPresentIfRequired (number' util)) { " is 239.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,Verify,The length of the statement  "		return PhoneNumberMatcher.CheckNumberGroupingIsValid (number' candidate' util' (PhoneNumberUtil u' PhoneNumber n' StringBuilder nc' String[] eg) => { " is 149.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,Verify,The length of the statement  "		if (!util.IsValidNumber (number) || !PhoneNumberMatcher.ContainsOnlyValidXChars (number' candidate' util) || PhoneNumberMatcher.ContainsMoreThanOneSlash (candidate) || !PhoneNumberMatcher.IsNationalPrefixPresentIfRequired (number' util)) { " is 239.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,Verify,The length of the statement  "		return PhoneNumberMatcher.CheckNumberGroupingIsValid (number' candidate' util' (PhoneNumberUtil u' PhoneNumber n' StringBuilder normalizedCandidate' String[] expectedNumberGroups) => { " is 184.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,GetMetadataForRegionOrCallingCode,The length of the statement  "	return REGION_CODE_FOR_NON_GEO_ENTITY.Equals (regionCode) ? GetMetadataForNonGeographicalRegion (countryCallingCode) : GetMetadataForRegion (regionCode); " is 153.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatNationalNumberWithPreferredCarrierCode,The length of the statement  "	return FormatNationalNumberWithCarrierCode (number' number.HasPreferredDomesticCarrierCode ? number.PreferredDomesticCarrierCode : fallbackCarrierCode); " is 152.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatNumberForMobileDialing,The length of the statement  "	} else if (regionCode.Equals ("BR") && regionCallingFrom.Equals ("BR") && ((numberType == PhoneNumberType.FIXED_LINE) || (numberType == PhoneNumberType.MOBILE) || (numberType == PhoneNumberType.FIXED_LINE_OR_MOBILE))) { " is 219.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatNumberForMobileDialing,The length of the statement  "		formattedNumber = numberNoExt.HasPreferredDomesticCarrierCode ? FormatNationalNumberWithPreferredCarrierCode (numberNoExt' "") // Brazilian fixed line and mobile numbers need to be dialed with a carrier code when " is 212.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatNumberForMobileDialing,The length of the statement  "		return withFormatting ? Format (numberNoExt' PhoneNumberFormat.INTERNATIONAL) : Format (numberNoExt' PhoneNumberFormat.E164); " is 125.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatNumberForMobileDialing,The length of the statement  "	return withFormatting ? formattedNumber : NormalizeHelper (formattedNumber' DIALLABLE_CHAR_MAPPINGS' true/* remove non matches */); " is 131.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatOutOfCountryCallingNumber,The length of the statement  "	String formattedNationalNumber = FormatNsn (nationalSignificantNumber' metadataForRegion' PhoneNumberFormat.INTERNATIONAL); " is 123.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatOutOfCountryCallingNumber,The length of the statement  "		formattedNumber.Insert (0' " ").Insert (0' countryCallingCode).Insert (0' " ").Insert (0' internationalPrefixForFormatting); " is 124.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatInOriginalFormat,The length of the statement  "	return (formattedNumber != null && NormalizeHelper (formattedNumber' DIALLABLE_CHAR_MAPPINGS' true/* remove non matches */).Equals (NormalizeHelper (rawInput' DIALLABLE_CHAR_MAPPINGS' true/* remove non matches */))) ? formattedNumber : rawInput; " is 245.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatOutOfCountryKeepingAlphaChars,The length of the statement  "		NumberFormat formattingPattern = ChooseFormattingPatternForNumber (metadataForRegionCallingFrom.NumberFormatList' nationalNumber); " is 130.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatOutOfCountryKeepingAlphaChars,The length of the statement  "		internationalPrefixForFormatting = UNIQUE_INTERNATIONAL_PREFIX.MatchAll (internationalPrefix).Success ? internationalPrefix : metadataForRegionCallingFrom.PreferredInternationalPrefix; " is 184.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatNsn,The length of the statement  "	var availableFormats = (intlNumberFormats.Count == 0 || numberFormat == PhoneNumberFormat.NATIONAL) ? metadata.NumberFormatList : metadata.IntlNumberFormatList; " is 160.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatNsn,The length of the statement  "	return (formattingPattern == null) ? number : FormatNsnUsingPattern (number' formattingPattern' numberFormat' carrierCode); " is 123.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,ChooseFormattingPatternForNumber,The length of the statement  "		if (size == 0 || regexCache.GetPatternForRegex (// We always use the last leading_digits_pattern' as it is the most detailed. " is 125.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatNsnUsingPattern,The length of the statement  "	if (numberFormat == PhoneNumberFormat.NATIONAL && carrierCode != null && carrierCode.Length > 0 && formattingPattern.DomesticCarrierCodeFormattingRule.Length > 0) { " is 164.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatNsnUsingPattern,The length of the statement  "		if (numberFormat == PhoneNumberFormat.NATIONAL && nationalPrefixFormattingRule != null && nationalPrefixFormattingRule.Length > 0) { " is 132.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,IsNumberMatchingDesc,The length of the statement  "	var possibleNumberPatternMatch = regexCache.GetPatternForRegex (numberDesc.PossibleNumberPattern).MatchAll (nationalNumber); " is 124.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,IsNumberMatchingDesc,The length of the statement  "	var nationalNumberPatternMatch = regexCache.GetPatternForRegex (numberDesc.NationalNumberPattern).MatchAll (nationalNumber); " is 124.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,IsValidNumberForRegion,The length of the statement  "	if ((metadata == null) || (!REGION_CODE_FOR_NON_GEO_ENTITY.Equals (regionCode) && countryCode != GetCountryCodeForValidRegion (regionCode))) { " is 142.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,GetRegionCodeForCountryCode,The length of the statement  "	return countryCallingCodeToRegionCodeMap_.TryGetValue (countryCallingCode' out regionCodes) ? regionCodes [0] : UNKNOWN_REGION; " is 127.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,MaybeExtractCountryCode,The length of the statement  "			throw new NumberParseException (ErrorType.TOO_SHORT_AFTER_IDD' "Phone number had an IDD' but after this was not " + "long enough to be a viable phone number."); " is 160.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,MaybeExtractCountryCode,The length of the statement  "			StringBuilder potentialNationalNumber = new StringBuilder (normalizedNumber.Substring (defaultCountryCodeString.Length)); " is 121.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,MaybeExtractCountryCode,The length of the statement  "			MaybeStripNationalPrefixAndCarrierCode (potentialNationalNumber' defaultRegionMetadata' null/* Don't need the carrier code */); " is 127.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,MaybeStripInternationalPrefixAndNormalize,The length of the statement  "	return ParsePrefixAsIdd (iddPattern' number) ? CountryCodeSource.FROM_NUMBER_WITH_IDD : CountryCodeSource.FROM_DEFAULT_COUNTRY; " is 127.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,MaybeStripNationalPrefixAndCarrierCode,The length of the statement  "			if (isViableOriginalNumber && !nationalNumberRule.MatchAll (number.ToString ().Substring (prefixMatch.Index + prefixMatch.Length)).Success) " is 139.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,ParseHelper,The length of the statement  "		countryCode = MaybeExtractCountryCode (nationalNumber.ToString ()' regionMetadata' normalizedNationalNumber' keepRawInput' phoneNumber); " is 136.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,ParseHelper,The length of the statement  "			countryCode = MaybeExtractCountryCode (nationalNumber.ToString ().Substring (m.Index + m.Length)' regionMetadata' normalizedNationalNumber' keepRawInput' phoneNumber); " is 167.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,IsNumberMatch,The length of the statement  "		else if (firstNumberCountryCode == secondNumberCountryCode && IsNationalNumberSuffixOfTheOther (firstNumber' secondNumber)) { " is 125.
Long Statement,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,IsNationalNumberSuffixOfTheOther,The length of the statement  "	return firstNumberNationalNumber.EndsWith (secondNumberNationalNumber) || secondNumberNationalNumber.EndsWith (firstNumberNationalNumber); " is 138.
Long Statement,PhoneNumbers,ShortNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\ShortNumberUtil.cs,MatchesEmergencyNumberHelper,The length of the statement  "	return (!allowPrefixMatch || regionCode.Equals ("BR")) ? emergencyNumberPattern.MatchAll (normalizedNumber).Success : emergencyNumberPattern.MatchBeginning (normalizedNumber).Success; " is 183.
Complex Conditional,PhoneNumbers,PhoneNumberMatcher,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberMatcher.cs,TrimAfterUnwantedChars,The conditional expression  "c != '#' && (uc != UnicodeCategory.UppercaseLetter && uc != UnicodeCategory.LowercaseLetter && uc != UnicodeCategory.TitlecaseLetter && uc != UnicodeCategory.ModifierLetter && uc != UnicodeCategory.OtherLetter && uc != UnicodeCategory.DecimalDigitNumber && uc != UnicodeCategory.LetterNumber && uc != UnicodeCategory.OtherNumber)"  is complex.
Complex Conditional,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,Verify,The conditional expression  "!util.IsValidNumber (number) || !PhoneNumberMatcher.ContainsOnlyValidXChars (number' candidate' util) || PhoneNumberMatcher.ContainsMoreThanOneSlash (candidate) || !PhoneNumberMatcher.IsNationalPrefixPresentIfRequired (number' util)"  is complex.
Complex Conditional,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,Verify,The conditional expression  "!util.IsValidNumber (number) || !PhoneNumberMatcher.ContainsOnlyValidXChars (number' candidate' util) || PhoneNumberMatcher.ContainsMoreThanOneSlash (candidate) || !PhoneNumberMatcher.IsNationalPrefixPresentIfRequired (number' util)"  is complex.
Complex Conditional,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatNumberForMobileDialing,The conditional expression  "regionCode.Equals ("BR") && regionCallingFrom.Equals ("BR") && ((numberType == PhoneNumberType.FIXED_LINE) || (numberType == PhoneNumberType.MOBILE) || (numberType == PhoneNumberType.FIXED_LINE_OR_MOBILE))"  is complex.
Complex Conditional,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatNsnUsingPattern,The conditional expression  "numberFormat == PhoneNumberFormat.NATIONAL && carrierCode != null && carrierCode.Length > 0 && formattingPattern.DomesticCarrierCodeFormattingRule.Length > 0"  is complex.
Empty Catch Block,PhoneNumbers,PhoneNumberMatcher,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberMatcher.cs,ParseAndVerify,The method has an empty catch block.
Empty Catch Block,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,LoadMetadataFromFile,The method has an empty catch block.
Empty Catch Block,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,GetExampleNumberForType,The method has an empty catch block.
Empty Catch Block,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,GetExampleNumberForNonGeoEntity,The method has an empty catch block.
Empty Catch Block,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,IsNumberMatch,The method has an empty catch block.
Empty Catch Block,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,IsNumberMatch,The method has an empty catch block.
Magic Number,PhoneNumbers,AreaCodeMap,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\AreaCodeMap.cs,binarySearch,The following statement contains a magic number: while (start <= end) {  	current = (start + end) / 2;  	int currentValue = areaCodeMapStorage.getPrefix (current);  	if (currentValue == value) {  		return current;  	} else if (currentValue > value) {  		current--;  		end = current;  	} else {  		start = current + 1;  	}  }  
Magic Number,PhoneNumbers,AreaCodeMap,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\AreaCodeMap.cs,binarySearch,The following statement contains a magic number: current = (start + end) / 2;  
Magic Number,PhoneNumbers,AsYouTypeFormatter,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\AsYouTypeFormatter.cs,InputDigitWithOptionToRememberPosition,The following statement contains a magic number: switch (accruedInputWithoutFormatting.Length) {  case 0:  case 1:  case 2:  	return accruedInput.ToString ();  case 3:  	if (AttemptToExtractIdd ()) {  		isExpectingCountryCallingCode = true;  	} else {  		// No IDD or plus sign is found' might be entering in national format.  		nationalPrefixExtracted = RemoveNationalPrefixFromNationalNumber ();  		return AttemptToChooseFormattingPattern ();  	}  	goto default;  default:  	if (isExpectingCountryCallingCode) {  		if (AttemptToExtractCountryCallingCode ()) {  			isExpectingCountryCallingCode = false;  		}  		return prefixBeforeNationalNumber + nationalNumber.ToString ();  	}  	if (possibleFormats.Count > 0) {  		// The formatting pattern is already chosen.  		String tempNationalNumber = InputDigitHelper (nextChar);  		// See if the accrued digits can be formatted properly already. If not' use the results  		// from inputDigitHelper' which does formatting based on the formatting pattern chosen.  		String formattedNumber = AttemptToFormatAccruedDigits ();  		if (formattedNumber.Length > 0) {  			return formattedNumber;  		}  		NarrowDownPossibleFormats (nationalNumber.ToString ());  		if (MaybeCreateNewTemplate ()) {  			return InputAccruedNationalNumber ();  		}  		return ableToFormat ? prefixBeforeNationalNumber + tempNationalNumber : accruedInput.ToString ();  	} else {  		return AttemptToChooseFormattingPattern ();  	}  }  
Magic Number,PhoneNumbers,AsYouTypeFormatter,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\AsYouTypeFormatter.cs,InputDigitWithOptionToRememberPosition,The following statement contains a magic number: switch (accruedInputWithoutFormatting.Length) {  case 0:  case 1:  case 2:  	return accruedInput.ToString ();  case 3:  	if (AttemptToExtractIdd ()) {  		isExpectingCountryCallingCode = true;  	} else {  		// No IDD or plus sign is found' might be entering in national format.  		nationalPrefixExtracted = RemoveNationalPrefixFromNationalNumber ();  		return AttemptToChooseFormattingPattern ();  	}  	goto default;  default:  	if (isExpectingCountryCallingCode) {  		if (AttemptToExtractCountryCallingCode ()) {  			isExpectingCountryCallingCode = false;  		}  		return prefixBeforeNationalNumber + nationalNumber.ToString ();  	}  	if (possibleFormats.Count > 0) {  		// The formatting pattern is already chosen.  		String tempNationalNumber = InputDigitHelper (nextChar);  		// See if the accrued digits can be formatted properly already. If not' use the results  		// from inputDigitHelper' which does formatting based on the formatting pattern chosen.  		String formattedNumber = AttemptToFormatAccruedDigits ();  		if (formattedNumber.Length > 0) {  			return formattedNumber;  		}  		NarrowDownPossibleFormats (nationalNumber.ToString ());  		if (MaybeCreateNewTemplate ()) {  			return InputAccruedNationalNumber ();  		}  		return ableToFormat ? prefixBeforeNationalNumber + tempNationalNumber : accruedInput.ToString ();  	} else {  		return AttemptToChooseFormattingPattern ();  	}  }  
Magic Number,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,GetLengthOfNationalDestinationCode,The following statement contains a magic number: if (numberGroups.Length <= 3)  	return 0;  
Magic Number,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,GetLengthOfNationalDestinationCode,The following statement contains a magic number: if (GetRegionCodeForCountryCode (number.CountryCode) == "AR" && GetNumberType (number) == PhoneNumberType.MOBILE)  	// Argentinian mobile numbers' when formatted in the international format' are in the form of  	// +54 9 NDC XXXX.... As a result' we take the length of the third group (NDC) and add 1 for  	// the digit 9' which also forms part of the national significant number.  	//  	// TODO: Investigate the possibility of better modeling the metadata to make it  	// easier to obtain the NDC.  	return numberGroups [3].Length + 1;  
Magic Number,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,GetLengthOfNationalDestinationCode,The following statement contains a magic number: return numberGroups [3].Length + 1;  
Magic Number,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,GetLengthOfNationalDestinationCode,The following statement contains a magic number: return numberGroups [2].Length;  
Magic Number,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatOutOfCountryKeepingAlphaChars,The following statement contains a magic number: if (nationalNumber.Length > 3) {  	int firstNationalNumberDigit = rawInput.IndexOf (nationalNumber.Substring (0' 3));  	if (firstNationalNumberDigit != -1)  		rawInput = rawInput.Substring (firstNationalNumberDigit);  }  
Magic Number,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,FormatOutOfCountryKeepingAlphaChars,The following statement contains a magic number: if (nationalNumber.Length > 3) {  	int firstNationalNumberDigit = rawInput.IndexOf (nationalNumber.Substring (0' 3));  	if (firstNationalNumberDigit != -1)  		rawInput = rawInput.Substring (firstNationalNumberDigit);  }  
Magic Number,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,TruncateTooLongNumber,The following statement contains a magic number: do {  	nationalNumber /= 10;  	PhoneNumber.Builder numberCopy = number.Clone ();  	numberCopy.SetNationalNumber (nationalNumber);  	copy = numberCopy.Build ();  	if (IsPossibleNumberWithReason (copy) == ValidationResult.TOO_SHORT || nationalNumber == 0)  		return false;  } while (!IsValidNumber (copy));  
Magic Number,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,TruncateTooLongNumber,The following statement contains a magic number: nationalNumber /= 10;  
Magic Number,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,MaybeStripNationalPrefixAndCarrierCode,The following statement contains a magic number: if (prefixMatch.Success) {  	var nationalNumberRule = regexCache.GetPatternForRegex (metadata.GeneralDesc.NationalNumberPattern);  	// Check if the original number is viable.  	bool isViableOriginalNumber = nationalNumberRule.MatchAll (number.ToString ()).Success;  	// prefixMatcher.group(numOfGroups) == null implies nothing was captured by the capturing  	// groups in possibleNationalPrefix; therefore' no transformation is necessary' and we just  	// remove the national prefix.  	int numOfGroups = prefixMatch.Groups.Count;  	String transformRule = metadata.NationalPrefixTransformRule;  	if (transformRule == null || transformRule.Length == 0 || !prefixMatch.Groups [numOfGroups - 1].Success) {  		// If the original number was viable' and the resultant number is not' we return.  		if (isViableOriginalNumber && !nationalNumberRule.MatchAll (number.ToString ().Substring (prefixMatch.Index + prefixMatch.Length)).Success)  			return false;  		if (carrierCode != null && numOfGroups > 1 && prefixMatch.Groups [numOfGroups - 1].Success)  			carrierCode.Append (prefixMatch.Groups [1].Value);  		number.Remove (0' prefixMatch.Index + prefixMatch.Length);  		return true;  	} else {  		// Check that the resultant number is still viable. If not' return. Check this by copying  		// the string buffer and making the transformation on the copy first.  		StringBuilder transformedNumber = new StringBuilder (prefixMatcher.Replace (number.ToString ()' transformRule' 1));  		//XXX: ToString  		if (isViableOriginalNumber && !nationalNumberRule.MatchAll (transformedNumber.ToString ()).Success)  			return false;  		if (carrierCode != null && numOfGroups > 2)  			carrierCode.Append (prefixMatcher.Match (number.ToString ()).Groups [1].Value);  		number.Length = 0;  		number.Append (transformedNumber.ToString ());  		return true;  	}  }  
Magic Number,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,MaybeStripNationalPrefixAndCarrierCode,The following statement contains a magic number: if (transformRule == null || transformRule.Length == 0 || !prefixMatch.Groups [numOfGroups - 1].Success) {  	// If the original number was viable' and the resultant number is not' we return.  	if (isViableOriginalNumber && !nationalNumberRule.MatchAll (number.ToString ().Substring (prefixMatch.Index + prefixMatch.Length)).Success)  		return false;  	if (carrierCode != null && numOfGroups > 1 && prefixMatch.Groups [numOfGroups - 1].Success)  		carrierCode.Append (prefixMatch.Groups [1].Value);  	number.Remove (0' prefixMatch.Index + prefixMatch.Length);  	return true;  } else {  	// Check that the resultant number is still viable. If not' return. Check this by copying  	// the string buffer and making the transformation on the copy first.  	StringBuilder transformedNumber = new StringBuilder (prefixMatcher.Replace (number.ToString ()' transformRule' 1));  	//XXX: ToString  	if (isViableOriginalNumber && !nationalNumberRule.MatchAll (transformedNumber.ToString ()).Success)  		return false;  	if (carrierCode != null && numOfGroups > 2)  		carrierCode.Append (prefixMatcher.Match (number.ToString ()).Groups [1].Value);  	number.Length = 0;  	number.Append (transformedNumber.ToString ());  	return true;  }  
Magic Number,PhoneNumbers,PhoneNumberUtil,F:\newReposMay17\erezak_libphonenumber-csharp\csharp\PhoneNumbers\PhoneNumberUtil.cs,MaybeStripNationalPrefixAndCarrierCode,The following statement contains a magic number: if (carrierCode != null && numOfGroups > 2)  	carrierCode.Append (prefixMatcher.Match (number.ToString ()).Groups [1].Value);  
