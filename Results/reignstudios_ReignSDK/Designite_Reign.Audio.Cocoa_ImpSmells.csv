Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Reign.Audio.Cocoa,SoundWAV,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,New,The method has 5 parameters. Parameters: parent' fileName' instanceCount' looped' loadedCallback
Long Parameter List,Reign.Audio.Cocoa,SoundWAV,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,SoundWAV,The method has 5 parameters. Parameters: parent' fileName' instanceCount' looped' loadedCallback
Long Parameter List,Reign.Audio.Cocoa,SoundWAV,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,init,The method has 5 parameters. Parameters: parent' stream' instanceCount' looped' loadedCallback
Long Statement,Reign.Audio.Cocoa,SoundWAV,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,init,The length of the statement  "				desc.FormatFlags = (AudioFormatFlags)((int)AudioFormatFlags.IsSignedInteger | (int)AudioFormatFlags.IsPacked | (int)AudioFormatFlags.IsNonInterleaved); " is 151.
Magic Number,Reign.Audio.Cocoa,SoundWAVInstance,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,SoundWAVInstance,The following statement contains a magic number: if (sound.channels == 2)  			{  				switch (sound.bitDepth)  				{  					case 8: instance.RenderCallback += render2Channel8BitCallback; break;  					case 16: instance.RenderCallback += render2Channel16BitCallback; break;  					default: Debug.ThrowError("SoundWAVInstance"' "Unsuported WAV bit depth"); break;  				}  			}  			else  			{  				switch (sound.bitDepth)  				{  					case 8: instance.RenderCallback += render1Channel8BitCallback; break;  					case 16: instance.RenderCallback += render1Channel16BitCallback; break;  					default: Debug.ThrowError("SoundWAVInstance"' "Unsuported WAV bit depth"); break;  				}  			}
Magic Number,Reign.Audio.Cocoa,SoundWAVInstance,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,SoundWAVInstance,The following statement contains a magic number: if (sound.channels == 2)  			{  				switch (sound.bitDepth)  				{  					case 8: instance.RenderCallback += render2Channel8BitCallback; break;  					case 16: instance.RenderCallback += render2Channel16BitCallback; break;  					default: Debug.ThrowError("SoundWAVInstance"' "Unsuported WAV bit depth"); break;  				}  			}  			else  			{  				switch (sound.bitDepth)  				{  					case 8: instance.RenderCallback += render1Channel8BitCallback; break;  					case 16: instance.RenderCallback += render1Channel16BitCallback; break;  					default: Debug.ThrowError("SoundWAVInstance"' "Unsuported WAV bit depth"); break;  				}  			}
Magic Number,Reign.Audio.Cocoa,SoundWAVInstance,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,SoundWAVInstance,The following statement contains a magic number: if (sound.channels == 2)  			{  				switch (sound.bitDepth)  				{  					case 8: instance.RenderCallback += render2Channel8BitCallback; break;  					case 16: instance.RenderCallback += render2Channel16BitCallback; break;  					default: Debug.ThrowError("SoundWAVInstance"' "Unsuported WAV bit depth"); break;  				}  			}  			else  			{  				switch (sound.bitDepth)  				{  					case 8: instance.RenderCallback += render1Channel8BitCallback; break;  					case 16: instance.RenderCallback += render1Channel16BitCallback; break;  					default: Debug.ThrowError("SoundWAVInstance"' "Unsuported WAV bit depth"); break;  				}  			}
Magic Number,Reign.Audio.Cocoa,SoundWAVInstance,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,SoundWAVInstance,The following statement contains a magic number: if (sound.channels == 2)  			{  				switch (sound.bitDepth)  				{  					case 8: instance.RenderCallback += render2Channel8BitCallback; break;  					case 16: instance.RenderCallback += render2Channel16BitCallback; break;  					default: Debug.ThrowError("SoundWAVInstance"' "Unsuported WAV bit depth"); break;  				}  			}  			else  			{  				switch (sound.bitDepth)  				{  					case 8: instance.RenderCallback += render1Channel8BitCallback; break;  					case 16: instance.RenderCallback += render1Channel16BitCallback; break;  					default: Debug.ThrowError("SoundWAVInstance"' "Unsuported WAV bit depth"); break;  				}  			}
Magic Number,Reign.Audio.Cocoa,SoundWAVInstance,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,SoundWAVInstance,The following statement contains a magic number: if (sound.channels == 2)  			{  				switch (sound.bitDepth)  				{  					case 8: instance.RenderCallback += render2Channel8BitCallback; break;  					case 16: instance.RenderCallback += render2Channel16BitCallback; break;  					default: Debug.ThrowError("SoundWAVInstance"' "Unsuported WAV bit depth"); break;  				}  			}  			else  			{  				switch (sound.bitDepth)  				{  					case 8: instance.RenderCallback += render1Channel8BitCallback; break;  					case 16: instance.RenderCallback += render1Channel16BitCallback; break;  					default: Debug.ThrowError("SoundWAVInstance"' "Unsuported WAV bit depth"); break;  				}  			}
Magic Number,Reign.Audio.Cocoa,SoundWAVInstance,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,render1Channel16BitCallback,The following statement contains a magic number: unsafe  			{  				float* channel1 = (float*)e.Data.Buffers[0].Data.ToPointer();  				fixed (byte* data = sound.data)  				{  					short* dataS = (short*)data;  					int i2 = dataOffset;  					e.Data.Buffers[0].DataByteSize = readSize * 2;  					for (int i = 0; i != readSize; ++i)  					{  						float value = 0;  						short* valueData = (short*)&value;  						valueData[1] = (short)(dataS[i2] * volume);  						#if iOS  						channel1[i] = value;// / 128;  						#else  						channel1[i] = value;  						#endif  						  						++i2;  					}  				}  			}
Magic Number,Reign.Audio.Cocoa,SoundWAVInstance,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,render2Channel8BitCallback,The following statement contains a magic number: int dataFrameSize = e.NumberFrames * 2;
Magic Number,Reign.Audio.Cocoa,SoundWAVInstance,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,render2Channel8BitCallback,The following statement contains a magic number: unsafe  			{  				int* channel1 = (int*)e.Data.Buffers[0].Data.ToPointer();  				int* channel2 = (int*)e.Data.Buffers[1].Data.ToPointer();  				fixed (byte* data = sound.data)  				{  					int i2 = dataOffset' readSizeLoop = readSize / 2;  					e.Data.Buffers[0].DataByteSize = readSizeLoop;  					e.Data.Buffers[1].DataByteSize = readSizeLoop;  					for (int i = 0; i != readSizeLoop; ++i)  					{  						int valueL = 0' valueR = 0;  						short* valueDataL = (short*)&valueL;  						short* valueDataR = (short*)&valueR;  						valueDataL[1] = (short)((data[i2] * 0.00392156862745f) * short.MaxValue * volume);// '* 0.00392156862745f' = '/ 255f'  						valueDataR[1] = (short)((data[i2+1] * 0.00392156862745f) * short.MaxValue * volume);  						#if iOS  						channel1[i] = valueL;// / 128;  						channel2[i] = valueR;// / 128;  						#else  						channel1[i] = valueL;  						channel2[i] = valueR;  						#endif  						  						i2 += 2;  					}  				}  			}
Magic Number,Reign.Audio.Cocoa,SoundWAVInstance,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,render2Channel8BitCallback,The following statement contains a magic number: unsafe  			{  				int* channel1 = (int*)e.Data.Buffers[0].Data.ToPointer();  				int* channel2 = (int*)e.Data.Buffers[1].Data.ToPointer();  				fixed (byte* data = sound.data)  				{  					int i2 = dataOffset' readSizeLoop = readSize / 2;  					e.Data.Buffers[0].DataByteSize = readSizeLoop;  					e.Data.Buffers[1].DataByteSize = readSizeLoop;  					for (int i = 0; i != readSizeLoop; ++i)  					{  						int valueL = 0' valueR = 0;  						short* valueDataL = (short*)&valueL;  						short* valueDataR = (short*)&valueR;  						valueDataL[1] = (short)((data[i2] * 0.00392156862745f) * short.MaxValue * volume);// '* 0.00392156862745f' = '/ 255f'  						valueDataR[1] = (short)((data[i2+1] * 0.00392156862745f) * short.MaxValue * volume);  						#if iOS  						channel1[i] = valueL;// / 128;  						channel2[i] = valueR;// / 128;  						#else  						channel1[i] = valueL;  						channel2[i] = valueR;  						#endif  						  						i2 += 2;  					}  				}  			}
Magic Number,Reign.Audio.Cocoa,SoundWAVInstance,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,render2Channel16BitCallback,The following statement contains a magic number: int dataFrameSize = e.NumberFrames * 2;
Magic Number,Reign.Audio.Cocoa,SoundWAVInstance,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,render2Channel16BitCallback,The following statement contains a magic number: unsafe  			{  				int* channel1 = (int*)e.Data.Buffers[0].Data.ToPointer();  				int* channel2 = (int*)e.Data.Buffers[1].Data.ToPointer();  				fixed (byte* data = sound.data)  				{  					short* dataS = (short*)data;  					int i2 = dataOffset' readSizeLoop = readSize / 2;  					e.Data.Buffers[0].DataByteSize = readSize;  					e.Data.Buffers[1].DataByteSize = readSize;  					for (int i = 0; i != readSizeLoop; ++i)  					{  						int valueL = 0' valueR = 0;  						short* valueDataL = (short*)&valueL;  						short* valueDataR = (short*)&valueR;  						valueDataL[1] = (short)(dataS[i2] * volume);  						valueDataR[1] = (short)(dataS[i2+1] * volume);  						#if iOS  						channel1[i] = valueL;// / 128;  						channel2[i] = valueR;// / 128;  						#else  						channel1[i] = valueL;  						channel2[i] = valueR;  						#endif  						  						i2 += 2;  					}  				}  			}
Magic Number,Reign.Audio.Cocoa,SoundWAVInstance,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Audio.Cocoa\SoundWAV.cs,render2Channel16BitCallback,The following statement contains a magic number: unsafe  			{  				int* channel1 = (int*)e.Data.Buffers[0].Data.ToPointer();  				int* channel2 = (int*)e.Data.Buffers[1].Data.ToPointer();  				fixed (byte* data = sound.data)  				{  					short* dataS = (short*)data;  					int i2 = dataOffset' readSizeLoop = readSize / 2;  					e.Data.Buffers[0].DataByteSize = readSize;  					e.Data.Buffers[1].DataByteSize = readSize;  					for (int i = 0; i != readSizeLoop; ++i)  					{  						int valueL = 0' valueR = 0;  						short* valueDataL = (short*)&valueL;  						short* valueDataR = (short*)&valueR;  						valueDataL[1] = (short)(dataS[i2] * volume);  						valueDataR[1] = (short)(dataS[i2+1] * volume);  						#if iOS  						channel1[i] = valueL;// / 128;  						channel2[i] = valueR;// / 128;  						#else  						channel1[i] = valueL;  						channel2[i] = valueR;  						#endif  						  						i2 += 2;  					}  				}  			}
