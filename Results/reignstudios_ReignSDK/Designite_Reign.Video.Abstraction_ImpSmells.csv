Implementation smell,Namespace,Class,File,Method,Description
Long Method,Reign.Video.Abstraction,HardwareMeshProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,HardwareMeshProcessor,The method has 132 lines of code.
Long Method,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The method has 119 lines of code.
Long Method,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,init,The method has 130 lines of code.
Long Method,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The method has 179 lines of code.
Complex Method,Reign.Video.Abstraction,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Font.cs,draw,Cyclomatic complexity of the method is 8
Complex Method,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,Cyclomatic complexity of the method is 10
Complex Method,Reign.Video.Abstraction,HardwareMeshProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,HardwareMeshProcessor,Cyclomatic complexity of the method is 27
Complex Method,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,Mesh,Cyclomatic complexity of the method is 12
Complex Method,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,Cyclomatic complexity of the method is 10
Complex Method,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,init,Cyclomatic complexity of the method is 20
Complex Method,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,Save,Cyclomatic complexity of the method is 11
Complex Method,Reign.Video.Abstraction,Object,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Object.cs,linkObjects,Cyclomatic complexity of the method is 10
Complex Method,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,Cyclomatic complexity of the method is 27
Complex Method,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,RotateGeometry,Cyclomatic complexity of the method is 8
Complex Method,Reign.Video.Abstraction,SoftwareModel,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareModel.cs,init,Cyclomatic complexity of the method is 15
Complex Method,Reign.Video.Abstraction,SoftwareObject,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareObject.cs,SoftwareObject,Cyclomatic complexity of the method is 9
Complex Method,Reign.Video.Abstraction,SoftwareObject,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareObject.cs,linkObjects,Cyclomatic complexity of the method is 9
Long Parameter List,Reign.Video.Abstraction,VertexBufferAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Buffers\VertexBuffer.cs,New,The method has 5 parameters. Parameters: parent' bufferLayoutDesc' usage' topology' vertices
Long Parameter List,Reign.Video.Abstraction,VertexBufferAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Buffers\VertexBuffer.cs,New,The method has 6 parameters. Parameters: parent' bufferLayoutDesc' usage' topology' vertices' indices
Long Parameter List,Reign.Video.Abstraction,VertexBufferAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Buffers\VertexBuffer.cs,New,The method has 7 parameters. Parameters: videoType' parent' bufferLayoutDesc' usage' topology' vertices' indices
Long Parameter List,Reign.Video.Abstraction,DepthStencilAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\DepthStencil.cs,New,The method has 5 parameters. Parameters: videoType' parent' width' height' format
Long Parameter List,Reign.Video.Abstraction,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Font.cs,Font,The method has 5 parameters. Parameters: parent' shader' texture' metricsFileName' loadedCallback
Long Parameter List,Reign.Video.Abstraction,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Font.cs,init,The method has 5 parameters. Parameters: shader' texture' stream' metricsFileName' loadedCallback
Long Parameter List,Reign.Video.Abstraction,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Font.cs,Draw,The method has 6 parameters. Parameters: text' position' color' size' centeredX' centeredY
Long Parameter List,Reign.Video.Abstraction,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Font.cs,draw,The method has 7 parameters. Parameters: text' textureSize' position' color' size' centeredX' centeredY
Long Parameter List,Reign.Video.Abstraction,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Font.cs,drawCharacter,The method has 5 parameters. Parameters: position' size' positionUV' sizeUV' color
Long Parameter List,Reign.Video.Abstraction,VertexProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,VertexProcessor,The method has 5 parameters. Parameters: vertex' colors' normals' uvs' mesh
Long Parameter List,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The method has 5 parameters. Parameters: triangle' mesh' loadColors' loadUVs' loadNormals
Long Parameter List,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The method has 7 parameters. Parameters: softwareMesh' loadColors' loadUVs' loadNormals' elements' vertices' indices
Long Parameter List,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,Write,The method has 6 parameters. Parameters: writer' softwareModel' softwareMesh' loadColors' loadUVs' loadNormals
Long Parameter List,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,Model,The method has 12 parameters. Parameters: parent' filename' contentDirectory' materialTypes' value1BinderTypes' value2BinderTypes' value3BinderTypes' value4BinderTypes' textureBinderTypes' fileExtOverrides' classicInstanceCount' loadedCallback
Long Parameter List,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,Model,The method has 15 parameters. Parameters: parent' softwareModel' loadColors' loadUVs' loadNormals' contentDirectory' materialTypes' value1BinderTypes' value2BinderTypes' value3BinderTypes' value4BinderTypes' textureBinderTypes' fileExtOverrides' classicInstanceCount' loadedCallback
Long Parameter List,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,init,The method has 12 parameters. Parameters: filename' stream' contentDirectory' materialTypes' value1BinderTypes' value2BinderTypes' value3BinderTypes' value4BinderTypes' textureBinderTypes' fileExtOverrides' classicInstanceCount' loadedCallback
Long Parameter List,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,bindTypes,The method has 6 parameters. Parameters: material' values' binders' contentDirectory' fileExtOverrides' handleFoundBinder
Long Parameter List,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,handleFoundValueBinder,The method has 6 parameters. Parameters: material' materialField' values' binder' contentDirectory' fileExtOverrides
Long Parameter List,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,handleFoundTextureBinder,The method has 6 parameters. Parameters: material' materialField' values' binder' contentDirectory' fileExtOverrides
Long Parameter List,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,Save,The method has 6 parameters. Parameters: filename' compress' softwareModel' loadColors' loadUVs' loadNormals
Long Parameter List,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,Save,The method has 6 parameters. Parameters: stream' compress' softwareModel' loadColors' loadUVs' loadNormals
Long Parameter List,Reign.Video.Abstraction,ShaderAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Shader.cs,New,The method has 6 parameters. Parameters: parent' filename' shaderVersion' vsQuality' psQuality' loadedCallback
Long Parameter List,Reign.Video.Abstraction,ShaderAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Shader.cs,New,The method has 7 parameters. Parameters: videoType' parent' filename' shaderVersion' vsQuality' psQuality' loadedCallback
Long Parameter List,Reign.Video.Abstraction,RenderTargetAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\RenderTarget.cs,New,The method has 12 parameters. Parameters: videoType' parent' filename' width' height' generateMipmaps' multiSampleType' surfaceFormat' depthStencilFormat' renderTargetUsage' usage' loadedCallback
Long Parameter List,Reign.Video.Abstraction,RenderTargetAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\RenderTarget.cs,New,The method has 9 parameters. Parameters: parent' width' height' multiSampleType' surfaceFormat' depthStencilFormat' renderTargetUsage' usage' loadedCallback
Long Parameter List,Reign.Video.Abstraction,RenderTargetAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\RenderTarget.cs,New,The method has 12 parameters. Parameters: videoType' parent' image' width' height' generateMipmaps' multiSampleType' surfaceFormat' depthStencilFormat' renderTargetUsage' usage' loadedCallback
Long Parameter List,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The method has 5 parameters. Parameters: parent' filename' generateMipmaps' usage' loadedCallback
Long Parameter List,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The method has 11 parameters. Parameters: videoType' parent' filename' width' height' generateMipmaps' multiSampleType' surfaceFormat' renderTargetUsage' usage' loadedCallback
Long Parameter List,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The method has 10 parameters. Parameters: parent' image' width' height' generateMipmaps' multiSampleType' surfaceFormat' renderTargetUsage' usage' loadedCallback
Long Parameter List,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The method has 11 parameters. Parameters: videoType' parent' image' width' height' generateMipmaps' multiSampleType' surfaceFormat' renderTargetUsage' usage' loadedCallback
Long Parameter List,Reign.Video.Abstraction,VideoAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Video.cs,New,The method has 6 parameters. Parameters: videoTypeFlags' videoType' parent' application' depthStencilFormats' vSync
Long Parameter List,Reign.Video.Abstraction,ViewPortAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\ViewPort.cs,New,The method has 5 parameters. Parameters: parent' x' y' width' height
Long Parameter List,Reign.Video.Abstraction,ViewPortAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\ViewPort.cs,New,The method has 6 parameters. Parameters: videoType' parent' x' y' width' height
Long Statement,Reign.Video.Abstraction,VertexBufferAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Buffers\VertexBuffer.cs,New,The length of the statement  "			if (videoType == VideoTypes.D3D9) api = new D3D9.VertexBuffer(parent' bufferLayoutDesc' usage' topology' vertices' indices); " is 124.
Long Statement,Reign.Video.Abstraction,VertexBufferAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Buffers\VertexBuffer.cs,New,The length of the statement  "			if (videoType == VideoTypes.D3D11) api = new D3D11.VertexBuffer(parent' bufferLayoutDesc' usage' topology' vertices' indices); " is 126.
Long Statement,Reign.Video.Abstraction,VertexBufferAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Buffers\VertexBuffer.cs,New,The length of the statement  "			if (videoType == VideoTypes.OpenGL) api = new OpenGL.VertexBuffer(parent' bufferLayoutDesc' usage' topology' vertices' indices); " is 128.
Long Statement,Reign.Video.Abstraction,VertexBufferAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Buffers\VertexBuffer.cs,New,The length of the statement  "			if (videoType == VideoTypes.XNA) api = new XNA.VertexBuffer(parent' bufferLayoutDesc' usage' topology' vertices' indices); " is 122.
Long Statement,Reign.Video.Abstraction,VertexBufferAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Buffers\VertexBuffer.cs,New,The length of the statement  "			if (videoType == VideoTypes.Vita) api = new Vita.VertexBuffer(parent' bufferLayoutDesc' usage' topology' vertices' indices); " is 124.
Long Statement,Reign.Video.Abstraction,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Font.cs,init,The length of the statement  "					Characters[i] = new Character(character.Key' new Vector2(character.X' character.Y)' new Vector2(character.Width' character.Height)); " is 132.
Long Statement,Reign.Video.Abstraction,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Font.cs,init,The length of the statement  "				vertexBuffer = VertexBufferAPI.New(this' layoutDesc' BufferUsages.Default' VertexBufferTopologys.Triangle' Vertices' Indices); " is 126.
Long Statement,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The length of the statement  "							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector4' BufferLayoutElementUsages.Color' 0' colorCount' vertFloatCount)); " is 136.
Long Statement,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The length of the statement  "							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' normalCount' vertFloatCount)); " is 138.
Long Statement,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The length of the statement  "							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' uvCount' vertFloatCount)); " is 130.
Long Statement,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,init,The length of the statement  "				if (reader.ReadInt32() != Streams.MakeFourCC('R'' 'M'' 'F'' 'T')) Debug.ThrowError("Error"' "Not a ReignModel file: " + filename); " is 130.
Long Statement,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,bindTypes,The length of the statement  "					if (materialField == null) Debug.ThrowError("Model"' "Shader material field name does not exist: " + binder.ShaderMaterialFieldName); " is 133.
Long Statement,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,bindTypes,The length of the statement  "					if (handleFoundBinder != null) handleFoundBinder(material' materialField' values' binder' contentDirectory' fileExtOverrides); " is 126.
Long Statement,Reign.Video.Abstraction,Model,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Model.cs,handleFoundTextureBinder,The length of the statement  "				if (fileExtOverrides.ContainsKey(ext)) textureFileName = Streams.GetFileNameWithoutExt(textureFileName) + fileExtOverrides[ext]; " is 128.
Long Statement,Reign.Video.Abstraction,SoftwareObject,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareObject.cs,linkObjects,The length of the statement  "				if (ArmatureObject == null) Debug.ThrowError("SoftwareObject"' "Failed to find ArmatureObject: " + o.ArmatureObject.Name); " is 122.
Long Statement,Reign.Video.Abstraction,ShaderAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Shader.cs,New,The length of the statement  "			return New(VideoAPI.DefaultAPI' parent' filename' shaderVersion' ShaderFloatingPointQuality.High' ShaderFloatingPointQuality.Low' loadedCallback); " is 146.
Long Statement,Reign.Video.Abstraction,ShaderAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Shader.cs,New,The length of the statement  "			if (videoType == VideoTypes.D3D9) api = new D3D9.Shader(parent' filename' shaderVersion' vsQuality' psQuality' loadedCallback); " is 127.
Long Statement,Reign.Video.Abstraction,ShaderAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Shader.cs,New,The length of the statement  "			if (videoType == VideoTypes.D3D11) api = new D3D11.Shader(parent' filename' shaderVersion' vsQuality' psQuality' loadedCallback); " is 129.
Long Statement,Reign.Video.Abstraction,ShaderAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Shader.cs,New,The length of the statement  "			if (videoType == VideoTypes.OpenGL) api = new OpenGL.Shader(parent' filename' shaderVersion' vsQuality' psQuality' loadedCallback); " is 131.
Long Statement,Reign.Video.Abstraction,ShaderAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Shader.cs,New,The length of the statement  "			if (videoType == VideoTypes.XNA) api = new XNA.Shader(parent' filename' shaderVersion' vsQuality' psQuality' loadedCallback); " is 125.
Long Statement,Reign.Video.Abstraction,ShaderAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Shader.cs,New,The length of the statement  "			if (videoType == VideoTypes.Vita) api = new Vita.Shader(parent' filename' shaderVersion' vsQuality' psQuality' loadedCallback); " is 127.
Long Statement,Reign.Video.Abstraction,RenderTargetAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\RenderTarget.cs,New,The length of the statement  "			if (videoType == VideoTypes.D3D9) api = new D3D9.RenderTarget(parent' filename' width' height' generateMipmaps' multiSampleType' surfaceFormat' depthStencilFormat' renderTargetUsage' usage' loadedCallback); " is 206.
Long Statement,Reign.Video.Abstraction,RenderTargetAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\RenderTarget.cs,New,The length of the statement  "			if (videoType == VideoTypes.D3D11) api = new D3D11.RenderTarget(parent' filename' width' height' generateMipmaps' multiSampleType' surfaceFormat' depthStencilFormat' renderTargetUsage' usage' loadedCallback); " is 208.
Long Statement,Reign.Video.Abstraction,RenderTargetAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\RenderTarget.cs,New,The length of the statement  "			if (videoType == VideoTypes.OpenGL) api = new OpenGL.RenderTarget(parent' filename' width' height' generateMipmaps' multiSampleType' surfaceFormat' depthStencilFormat' renderTargetUsage' usage' loadedCallback); " is 210.
Long Statement,Reign.Video.Abstraction,RenderTargetAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\RenderTarget.cs,New,The length of the statement  "			if (videoType == VideoTypes.XNA) api = new XNA.RenderTarget(parent' filename' width' height' generateMipmaps' multiSampleType' surfaceFormat' depthStencilFormat' renderTargetUsage' usage' loadedCallback); " is 204.
Long Statement,Reign.Video.Abstraction,RenderTargetAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\RenderTarget.cs,New,The length of the statement  "			if (videoType == VideoTypes.Vita) api = new Vita.RenderTarget(parent' filename' width' height' generateMipmaps' multiSampleType' surfaceFormat' depthStencilFormat' renderTargetUsage' usage' loadedCallback); " is 206.
Long Statement,Reign.Video.Abstraction,RenderTargetAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\RenderTarget.cs,New,The length of the statement  "			return New(VideoAPI.DefaultAPI' parent' (Image)null' width' height' false' multiSampleType' surfaceFormat' depthStencilFormat' renderTargetUsage' usage' loadedCallback); " is 169.
Long Statement,Reign.Video.Abstraction,RenderTargetAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\RenderTarget.cs,New,The length of the statement  "			if (videoType == VideoTypes.D3D9) api = new D3D9.RenderTarget(parent' image' width' height' generateMipmaps' multiSampleType' surfaceFormat' depthStencilFormat' renderTargetUsage' usage' loadedCallback); " is 203.
Long Statement,Reign.Video.Abstraction,RenderTargetAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\RenderTarget.cs,New,The length of the statement  "			if (videoType == VideoTypes.D3D11) api = new D3D11.RenderTarget(parent' image' width' height' generateMipmaps' multiSampleType' surfaceFormat' depthStencilFormat' renderTargetUsage' usage' loadedCallback); " is 205.
Long Statement,Reign.Video.Abstraction,RenderTargetAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\RenderTarget.cs,New,The length of the statement  "			if (videoType == VideoTypes.OpenGL) api = new OpenGL.RenderTarget(parent' image' width' height' generateMipmaps' multiSampleType' surfaceFormat' depthStencilFormat' renderTargetUsage' usage' loadedCallback); " is 207.
Long Statement,Reign.Video.Abstraction,RenderTargetAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\RenderTarget.cs,New,The length of the statement  "			if (videoType == VideoTypes.XNA) api = new XNA.RenderTarget(parent' image' width' height' generateMipmaps' multiSampleType' surfaceFormat' depthStencilFormat' renderTargetUsage' usage' loadedCallback); " is 201.
Long Statement,Reign.Video.Abstraction,RenderTargetAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\RenderTarget.cs,New,The length of the statement  "			if (videoType == VideoTypes.Vita) api = new Vita.RenderTarget(parent' image' width' height' generateMipmaps' multiSampleType' surfaceFormat' depthStencilFormat' renderTargetUsage' usage' loadedCallback); " is 203.
Long Statement,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The length of the statement  "			return New(VideoAPI.DefaultAPI' parent' filename' 0' 0' false' MultiSampleTypes.None' SurfaceFormats.Defualt' RenderTargetUsage.PlatformDefault' BufferUsages.Default' loadedCallback); " is 183.
Long Statement,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The length of the statement  "			return New(VideoAPI.DefaultAPI' parent' filename' 0' 0' generateMipmaps' MultiSampleTypes.None' SurfaceFormats.Defualt' RenderTargetUsage.PlatformDefault' usage' loadedCallback); " is 178.
Long Statement,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The length of the statement  "			if (videoType == VideoTypes.D3D9) api = new D3D9.Texture2D(parent' filename' width' height' generateMipmaps' multiSampleType' surfaceFormat' renderTargetUsage' usage' loadedCallback); " is 183.
Long Statement,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The length of the statement  "			if (videoType == VideoTypes.D3D11) api = new D3D11.Texture2D(parent' filename' width' height' generateMipmaps' multiSampleType' surfaceFormat' renderTargetUsage' usage' loadedCallback); " is 185.
Long Statement,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The length of the statement  "			if (videoType == VideoTypes.OpenGL) api = new OpenGL.Texture2D(parent' filename' width' height' generateMipmaps' multiSampleType' surfaceFormat' renderTargetUsage' usage' loadedCallback); " is 187.
Long Statement,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The length of the statement  "			if (videoType == VideoTypes.XNA) api = new XNA.Texture2D(parent' filename' width' height' generateMipmaps' multiSampleType' surfaceFormat' renderTargetUsage' usage' loadedCallback); " is 181.
Long Statement,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The length of the statement  "			if (videoType == VideoTypes.Vita) api = new Vita.Texture2D(parent' filename' width' height' generateMipmaps' multiSampleType' surfaceFormat' renderTargetUsage' usage' loadedCallback); " is 183.
Long Statement,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The length of the statement  "			return New(VideoAPI.DefaultAPI' parent' image' width' height' generateMipmaps' multiSampleType' surfaceFormat' renderTargetUsage' usage' loadedCallback); " is 153.
Long Statement,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The length of the statement  "			if (videoType == VideoTypes.D3D9) api = new D3D9.Texture2D(parent' image' width' height' generateMipmaps' multiSampleType' surfaceFormat' renderTargetUsage' usage' loadedCallback); " is 180.
Long Statement,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The length of the statement  "			if (videoType == VideoTypes.D3D11) api = new D3D11.Texture2D(parent' image' width' height' generateMipmaps' multiSampleType' surfaceFormat' renderTargetUsage' usage' loadedCallback); " is 182.
Long Statement,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The length of the statement  "			if (videoType == VideoTypes.OpenGL) api = new OpenGL.Texture2D(parent' image' width' height' generateMipmaps' multiSampleType' surfaceFormat' renderTargetUsage' usage' loadedCallback); " is 184.
Long Statement,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The length of the statement  "			if (videoType == VideoTypes.XNA) api = new XNA.Texture2D(parent' image' width' height' generateMipmaps' multiSampleType' surfaceFormat' renderTargetUsage' usage' loadedCallback); " is 178.
Long Statement,Reign.Video.Abstraction,Texture2DAPI,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Textures\Texture2D.cs,New,The length of the statement  "			if (videoType == VideoTypes.Vita) api = new Vita.Texture2D(parent' image' width' height' generateMipmaps' multiSampleType' surfaceFormat' renderTargetUsage' usage' loadedCallback); " is 180.
Virtual Method Call from Constructor,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,Mesh,The constructor "Mesh" calls a virtual method "Dispose".
Magic Number,Reign.Video.Abstraction,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Font.cs,init,The following statement contains a magic number: try  			{  				// load characters  				var metrics = new FontMetrics();  				metrics.Load(stream);    				Characters = new Character[metrics.Characters.Length];  				for (int i = 0; i != metrics.Characters.Length; ++i)  				{  					var character = metrics.Characters[i];  					Characters[i] = new Character(character.Key' new Vector2(character.X' character.Y)' new Vector2(character.Width' character.Height));  				}    				// get shader variables  				this.texture = texture;  				this.shader = shader;  				shaderCamera = shader.Variable("Camera");  				shaderPosition = shader.Variable("Position");  				shaderSize = shader.Variable("Size");  				shaderPositionUV = shader.Variable("PositionUV");  				shaderSizeUV = shader.Variable("SizeUV");  				texelOffset = shader.Variable("TexelOffset");  				shaderColor = shader.Variable("Color");  				shaderTexture = shader.Resource("DiffuseTexture");    				// create buffers  				var layoutDesc = BufferLayoutDescAPI.New(BufferLayoutTypes.Position2);  				layout = BufferLayoutAPI.New(this' shader' layoutDesc);    				var Indices = new int[6]  				{  					0' 1' 2'  					0' 2' 3  				};    				var Vertices = new float[8]  				{  					0' 0'  					0' 1'  					1' 1'  					1' 0'  				};  				  				vertexBuffer = VertexBufferAPI.New(this' layoutDesc' BufferUsages.Default' VertexBufferTopologys.Triangle' Vertices' Indices);  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				Dispose();  				if (loadedCallback != null) loadedCallback(this' false);  			}
Magic Number,Reign.Video.Abstraction,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Font.cs,init,The following statement contains a magic number: try  			{  				// load characters  				var metrics = new FontMetrics();  				metrics.Load(stream);    				Characters = new Character[metrics.Characters.Length];  				for (int i = 0; i != metrics.Characters.Length; ++i)  				{  					var character = metrics.Characters[i];  					Characters[i] = new Character(character.Key' new Vector2(character.X' character.Y)' new Vector2(character.Width' character.Height));  				}    				// get shader variables  				this.texture = texture;  				this.shader = shader;  				shaderCamera = shader.Variable("Camera");  				shaderPosition = shader.Variable("Position");  				shaderSize = shader.Variable("Size");  				shaderPositionUV = shader.Variable("PositionUV");  				shaderSizeUV = shader.Variable("SizeUV");  				texelOffset = shader.Variable("TexelOffset");  				shaderColor = shader.Variable("Color");  				shaderTexture = shader.Resource("DiffuseTexture");    				// create buffers  				var layoutDesc = BufferLayoutDescAPI.New(BufferLayoutTypes.Position2);  				layout = BufferLayoutAPI.New(this' shader' layoutDesc);    				var Indices = new int[6]  				{  					0' 1' 2'  					0' 2' 3  				};    				var Vertices = new float[8]  				{  					0' 0'  					0' 1'  					1' 1'  					1' 0'  				};  				  				vertexBuffer = VertexBufferAPI.New(this' layoutDesc' BufferUsages.Default' VertexBufferTopologys.Triangle' Vertices' Indices);  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				Dispose();  				if (loadedCallback != null) loadedCallback(this' false);  			}
Magic Number,Reign.Video.Abstraction,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Font.cs,init,The following statement contains a magic number: try  			{  				// load characters  				var metrics = new FontMetrics();  				metrics.Load(stream);    				Characters = new Character[metrics.Characters.Length];  				for (int i = 0; i != metrics.Characters.Length; ++i)  				{  					var character = metrics.Characters[i];  					Characters[i] = new Character(character.Key' new Vector2(character.X' character.Y)' new Vector2(character.Width' character.Height));  				}    				// get shader variables  				this.texture = texture;  				this.shader = shader;  				shaderCamera = shader.Variable("Camera");  				shaderPosition = shader.Variable("Position");  				shaderSize = shader.Variable("Size");  				shaderPositionUV = shader.Variable("PositionUV");  				shaderSizeUV = shader.Variable("SizeUV");  				texelOffset = shader.Variable("TexelOffset");  				shaderColor = shader.Variable("Color");  				shaderTexture = shader.Resource("DiffuseTexture");    				// create buffers  				var layoutDesc = BufferLayoutDescAPI.New(BufferLayoutTypes.Position2);  				layout = BufferLayoutAPI.New(this' shader' layoutDesc);    				var Indices = new int[6]  				{  					0' 1' 2'  					0' 2' 3  				};    				var Vertices = new float[8]  				{  					0' 0'  					0' 1'  					1' 1'  					1' 0'  				};  				  				vertexBuffer = VertexBufferAPI.New(this' layoutDesc' BufferUsages.Default' VertexBufferTopologys.Triangle' Vertices' Indices);  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				Dispose();  				if (loadedCallback != null) loadedCallback(this' false);  			}
Magic Number,Reign.Video.Abstraction,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Font.cs,init,The following statement contains a magic number: try  			{  				// load characters  				var metrics = new FontMetrics();  				metrics.Load(stream);    				Characters = new Character[metrics.Characters.Length];  				for (int i = 0; i != metrics.Characters.Length; ++i)  				{  					var character = metrics.Characters[i];  					Characters[i] = new Character(character.Key' new Vector2(character.X' character.Y)' new Vector2(character.Width' character.Height));  				}    				// get shader variables  				this.texture = texture;  				this.shader = shader;  				shaderCamera = shader.Variable("Camera");  				shaderPosition = shader.Variable("Position");  				shaderSize = shader.Variable("Size");  				shaderPositionUV = shader.Variable("PositionUV");  				shaderSizeUV = shader.Variable("SizeUV");  				texelOffset = shader.Variable("TexelOffset");  				shaderColor = shader.Variable("Color");  				shaderTexture = shader.Resource("DiffuseTexture");    				// create buffers  				var layoutDesc = BufferLayoutDescAPI.New(BufferLayoutTypes.Position2);  				layout = BufferLayoutAPI.New(this' shader' layoutDesc);    				var Indices = new int[6]  				{  					0' 1' 2'  					0' 2' 3  				};    				var Vertices = new float[8]  				{  					0' 0'  					0' 1'  					1' 1'  					1' 0'  				};  				  				vertexBuffer = VertexBufferAPI.New(this' layoutDesc' BufferUsages.Default' VertexBufferTopologys.Triangle' Vertices' Indices);  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				Dispose();  				if (loadedCallback != null) loadedCallback(this' false);  			}
Magic Number,Reign.Video.Abstraction,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Font.cs,init,The following statement contains a magic number: try  			{  				// load characters  				var metrics = new FontMetrics();  				metrics.Load(stream);    				Characters = new Character[metrics.Characters.Length];  				for (int i = 0; i != metrics.Characters.Length; ++i)  				{  					var character = metrics.Characters[i];  					Characters[i] = new Character(character.Key' new Vector2(character.X' character.Y)' new Vector2(character.Width' character.Height));  				}    				// get shader variables  				this.texture = texture;  				this.shader = shader;  				shaderCamera = shader.Variable("Camera");  				shaderPosition = shader.Variable("Position");  				shaderSize = shader.Variable("Size");  				shaderPositionUV = shader.Variable("PositionUV");  				shaderSizeUV = shader.Variable("SizeUV");  				texelOffset = shader.Variable("TexelOffset");  				shaderColor = shader.Variable("Color");  				shaderTexture = shader.Resource("DiffuseTexture");    				// create buffers  				var layoutDesc = BufferLayoutDescAPI.New(BufferLayoutTypes.Position2);  				layout = BufferLayoutAPI.New(this' shader' layoutDesc);    				var Indices = new int[6]  				{  					0' 1' 2'  					0' 2' 3  				};    				var Vertices = new float[8]  				{  					0' 0'  					0' 1'  					1' 1'  					1' 0'  				};  				  				vertexBuffer = VertexBufferAPI.New(this' layoutDesc' BufferUsages.Default' VertexBufferTopologys.Triangle' Vertices' Indices);  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				Dispose();  				if (loadedCallback != null) loadedCallback(this' false);  			}
Magic Number,Reign.Video.Abstraction,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Font.cs,CharacterIndex,The following statement contains a magic number: int i = ((int)@char) - 32;
Magic Number,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The following statement contains a magic number: var colors = new Vector4[3][];
Magic Number,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The following statement contains a magic number: if (loadColors)  			{  				int componentCount = mesh.colorComponents.Count;  				for (int i = 0; i != colors.Length; ++i)  				{  					colors[i] = new Vector4[componentCount];  				}    				for (int i = 0; i != componentCount; ++i)  				{  					var colorComponent = mesh.colorComponents[i][triangle.Index].Colors;  					colors[0][i] = colorComponent[0];  					colors[1][i] = colorComponent[1];  					colors[2][i] = colorComponent[2];  				}  			}
Magic Number,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The following statement contains a magic number: if (loadColors)  			{  				int componentCount = mesh.colorComponents.Count;  				for (int i = 0; i != colors.Length; ++i)  				{  					colors[i] = new Vector4[componentCount];  				}    				for (int i = 0; i != componentCount; ++i)  				{  					var colorComponent = mesh.colorComponents[i][triangle.Index].Colors;  					colors[0][i] = colorComponent[0];  					colors[1][i] = colorComponent[1];  					colors[2][i] = colorComponent[2];  				}  			}
Magic Number,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The following statement contains a magic number: var normals = new Vector3[3][];
Magic Number,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The following statement contains a magic number: if (loadNormals)  			{  				int componentCount = mesh.normalComponents.Count;  				for (int i = 0; i != normals.Length; ++i)  				{  					normals[i] = new Vector3[componentCount];  				}    				for (int i = 0; i != componentCount; ++i)  				{  					var normalComponent = mesh.normalComponents[i][triangle.Index].Normals;  					normals[0][i] = normalComponent[0];  					normals[1][i] = normalComponent[1];  					normals[2][i] = normalComponent[2];  				}  			}
Magic Number,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The following statement contains a magic number: if (loadNormals)  			{  				int componentCount = mesh.normalComponents.Count;  				for (int i = 0; i != normals.Length; ++i)  				{  					normals[i] = new Vector3[componentCount];  				}    				for (int i = 0; i != componentCount; ++i)  				{  					var normalComponent = mesh.normalComponents[i][triangle.Index].Normals;  					normals[0][i] = normalComponent[0];  					normals[1][i] = normalComponent[1];  					normals[2][i] = normalComponent[2];  				}  			}
Magic Number,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The following statement contains a magic number: var uvs = new Vector2[3][];
Magic Number,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The following statement contains a magic number: if (loadUVs)  			{  				int componentCount = mesh.uvComponents.Count;  				for (int i = 0; i != uvs.Length; ++i)  				{  					uvs[i] = new Vector2[componentCount];  				}    				for (int i = 0; i != componentCount; ++i)  				{  					var normalComponent = mesh.uvComponents[i][triangle.Index].UVs;  					uvs[0][i] = normalComponent[0];  					uvs[1][i] = normalComponent[1];  					uvs[2][i] = normalComponent[2];  				}  			}
Magic Number,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The following statement contains a magic number: if (loadUVs)  			{  				int componentCount = mesh.uvComponents.Count;  				for (int i = 0; i != uvs.Length; ++i)  				{  					uvs[i] = new Vector2[componentCount];  				}    				for (int i = 0; i != componentCount; ++i)  				{  					var normalComponent = mesh.uvComponents[i][triangle.Index].UVs;  					uvs[0][i] = normalComponent[0];  					uvs[1][i] = normalComponent[1];  					uvs[2][i] = normalComponent[2];  				}  			}
Magic Number,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The following statement contains a magic number: var vertex3 = new VertexProcessor(triangle.Verticies[2]' colors[2]' normals[2]' uvs[2]' mesh);
Magic Number,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The following statement contains a magic number: var vertex3 = new VertexProcessor(triangle.Verticies[2]' colors[2]' normals[2]' uvs[2]' mesh);
Magic Number,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The following statement contains a magic number: var vertex3 = new VertexProcessor(triangle.Verticies[2]' colors[2]' normals[2]' uvs[2]' mesh);
Magic Number,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The following statement contains a magic number: var vertex3 = new VertexProcessor(triangle.Verticies[2]' colors[2]' normals[2]' uvs[2]' mesh);
Magic Number,Reign.Video.Abstraction,TriangleProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,TriangleProcessor,The following statement contains a magic number: Verticies = new VertexProcessor[3] {vertex1' vertex2' vertex3};
Magic Number,Reign.Video.Abstraction,HardwareMeshProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,HardwareMeshProcessor,The following statement contains a magic number: for (int i = 0; i != count; ++i)  			{  				for (int vi = 0; vi != 3; ++vi)  				{  					var vertex = Triangles[i].Verticies[vi];  					for (int i2 = i+1; i2 != count2; ++i2)  					{  						for (int vi2 = 0; vi2 != 3; ++vi2)  						{  							var vertex2 = Triangles[i2].Verticies[vi2];  							if (vertex == vertex2) continue;    							// position tolerance  							bool canRemoveVertex = true;  							for (int pi = 0; pi != vertex.Positions.Length; ++pi)  							{  								if (!vertex.Positions[pi].AproxEqualsBox(vertex2.Positions[pi]' tolerance))  								{  									canRemoveVertex = false;  									break;  								}  							}    							// color tolerance  							if (canRemoveVertex && loadColors)  							{  								for (int pi = 0; pi != vertex.Colors.Length; ++pi)  								{  									if (!vertex.Colors[pi].AproxEqualsBox(vertex2.Colors[pi]' tolerance))  									{  										canRemoveVertex = false;  										break;  									}  								}  							}    							// normal tolerance  							if (canRemoveVertex && loadNormals)  							{  								for (int pi = 0; pi != vertex.Normals.Length; ++pi)  								{  									if (!vertex.Normals[pi].AproxEqualsBox(vertex2.Normals[pi]' tolerance))  									{  										canRemoveVertex = false;  										break;  									}  								}  							}    							// uv tolerance  							if (canRemoveVertex && loadUVs)  							{  								for (int pi = 0; pi != vertex.UVs.Length; ++pi)  								{  									if (!vertex.UVs[pi].AproxEqualsBox(vertex2.UVs[pi]' tolerance))  									{  										canRemoveVertex = false;  										break;  									}  								}  							}    							// remove vertex  							if (canRemoveVertex)  							{  								Verticies.Remove(vertex2);  								Triangles[i2].Verticies[vi2] = vertex;  							}  						}  					}  				}  			}
Magic Number,Reign.Video.Abstraction,HardwareMeshProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,HardwareMeshProcessor,The following statement contains a magic number: for (int i = 0; i != count; ++i)  			{  				for (int vi = 0; vi != 3; ++vi)  				{  					var vertex = Triangles[i].Verticies[vi];  					for (int i2 = i+1; i2 != count2; ++i2)  					{  						for (int vi2 = 0; vi2 != 3; ++vi2)  						{  							var vertex2 = Triangles[i2].Verticies[vi2];  							if (vertex == vertex2) continue;    							// position tolerance  							bool canRemoveVertex = true;  							for (int pi = 0; pi != vertex.Positions.Length; ++pi)  							{  								if (!vertex.Positions[pi].AproxEqualsBox(vertex2.Positions[pi]' tolerance))  								{  									canRemoveVertex = false;  									break;  								}  							}    							// color tolerance  							if (canRemoveVertex && loadColors)  							{  								for (int pi = 0; pi != vertex.Colors.Length; ++pi)  								{  									if (!vertex.Colors[pi].AproxEqualsBox(vertex2.Colors[pi]' tolerance))  									{  										canRemoveVertex = false;  										break;  									}  								}  							}    							// normal tolerance  							if (canRemoveVertex && loadNormals)  							{  								for (int pi = 0; pi != vertex.Normals.Length; ++pi)  								{  									if (!vertex.Normals[pi].AproxEqualsBox(vertex2.Normals[pi]' tolerance))  									{  										canRemoveVertex = false;  										break;  									}  								}  							}    							// uv tolerance  							if (canRemoveVertex && loadUVs)  							{  								for (int pi = 0; pi != vertex.UVs.Length; ++pi)  								{  									if (!vertex.UVs[pi].AproxEqualsBox(vertex2.UVs[pi]' tolerance))  									{  										canRemoveVertex = false;  										break;  									}  								}  							}    							// remove vertex  							if (canRemoveVertex)  							{  								Verticies.Remove(vertex2);  								Triangles[i2].Verticies[vi2] = vertex;  							}  						}  					}  				}  			}
Magic Number,Reign.Video.Abstraction,InstanceObjectArmature,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\InstanceModel\InstanceObjectArmature.cs,linkObjects,The following statement contains a magic number: for (int bi = 0; bi != Armature.Bones.Length; ++bi)  			{  				if (dataPath == Armature.Bones[bi].Name)  				{  					boneIndices[i] = bi;    					if (curve.Index == 0) bindActionDatas[i] = bindBoneRotationX;  					else if (curve.Index == 1) bindActionDatas[i] = bindBoneRotationY;  					else if (curve.Index == 2) bindActionDatas[i] = bindBoneRotationZ;  					else if (curve.Index == 3) bindActionDatas[i] = bindBoneRotationW;    					pass = true;  					break;  				}  			}
Magic Number,Reign.Video.Abstraction,InstanceObjectArmature,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\InstanceModel\InstanceObjectArmature.cs,linkObjects,The following statement contains a magic number: for (int bi = 0; bi != Armature.Bones.Length; ++bi)  			{  				if (dataPath == Armature.Bones[bi].Name)  				{  					boneIndices[i] = bi;    					if (curve.Index == 0) bindActionDatas[i] = bindBoneRotationX;  					else if (curve.Index == 1) bindActionDatas[i] = bindBoneRotationY;  					else if (curve.Index == 2) bindActionDatas[i] = bindBoneRotationZ;  					else if (curve.Index == 3) bindActionDatas[i] = bindBoneRotationW;    					pass = true;  					break;  				}  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: switch (softwareMesh.Dimensions)  			{  				case 2:  					posElementType = BufferLayoutElementTypes.Vector2;  					posFloatCount = 2;  					break;    				case 3:  					posElementType = BufferLayoutElementTypes.Vector3;  					posFloatCount = 3;  					break;  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: switch (softwareMesh.Dimensions)  			{  				case 2:  					posElementType = BufferLayoutElementTypes.Vector2;  					posFloatCount = 2;  					break;    				case 3:  					posElementType = BufferLayoutElementTypes.Vector3;  					posFloatCount = 3;  					break;  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: switch (softwareMesh.Dimensions)  			{  				case 2:  					posElementType = BufferLayoutElementTypes.Vector2;  					posFloatCount = 2;  					break;    				case 3:  					posElementType = BufferLayoutElementTypes.Vector3;  					posFloatCount = 3;  					break;  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: switch (softwareMesh.Dimensions)  			{  				case 2:  					posElementType = BufferLayoutElementTypes.Vector2;  					posFloatCount = 2;  					break;    				case 3:  					posElementType = BufferLayoutElementTypes.Vector3;  					posFloatCount = 3;  					break;  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: foreach (var key in softwareMesh.TriangleComponentKeys)  			{  				switch (key.Key)  				{  					case TriangleComponentKeyTypes.ColorComponents:  						if (loadColors)  						{  							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector4' BufferLayoutElementUsages.Color' 0' colorCount' vertFloatCount));  							vertFloatCount += 4;  							++colorCount;  						}  						break;    					case TriangleComponentKeyTypes.NormalComponents:  						if (loadNormals)  						{  							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' normalCount' vertFloatCount));  							vertFloatCount += 3;  							++normalCount;  						}  						break;    					case TriangleComponentKeyTypes.UVComponents:  						if (loadUVs)  						{  							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' uvCount' vertFloatCount));  							vertFloatCount += 2;  							++uvCount;  						}  						break;  				}  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: foreach (var key in softwareMesh.TriangleComponentKeys)  			{  				switch (key.Key)  				{  					case TriangleComponentKeyTypes.ColorComponents:  						if (loadColors)  						{  							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector4' BufferLayoutElementUsages.Color' 0' colorCount' vertFloatCount));  							vertFloatCount += 4;  							++colorCount;  						}  						break;    					case TriangleComponentKeyTypes.NormalComponents:  						if (loadNormals)  						{  							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' normalCount' vertFloatCount));  							vertFloatCount += 3;  							++normalCount;  						}  						break;    					case TriangleComponentKeyTypes.UVComponents:  						if (loadUVs)  						{  							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' uvCount' vertFloatCount));  							vertFloatCount += 2;  							++uvCount;  						}  						break;  				}  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: foreach (var key in softwareMesh.TriangleComponentKeys)  			{  				switch (key.Key)  				{  					case TriangleComponentKeyTypes.ColorComponents:  						if (loadColors)  						{  							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector4' BufferLayoutElementUsages.Color' 0' colorCount' vertFloatCount));  							vertFloatCount += 4;  							++colorCount;  						}  						break;    					case TriangleComponentKeyTypes.NormalComponents:  						if (loadNormals)  						{  							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' normalCount' vertFloatCount));  							vertFloatCount += 3;  							++normalCount;  						}  						break;    					case TriangleComponentKeyTypes.UVComponents:  						if (loadUVs)  						{  							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' uvCount' vertFloatCount));  							vertFloatCount += 2;  							++uvCount;  						}  						break;  				}  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: foreach (var vertex in meshProcessor.Verticies)  			{  				int posIndex = 0' colorIndex = 0' normIndex = 0' uvIndex = 0;  				foreach (var element in elements)  				{  					switch (element.Usage)  					{  						case BufferLayoutElementUsages.Position:  							vertices[vi] = vertex.Positions[posIndex].X;  							vertices[vi+1] = vertex.Positions[posIndex].Y;  							if (posFloatCount == 3) vertices[vi+2] = vertex.Positions[posIndex].Z;  							vi += posFloatCount;  							++posIndex;  							break;    						case BufferLayoutElementUsages.Color:  							if (loadColors)  							{  								vertices[vi] = vertex.Colors[uvIndex].X;  								vertices[vi+1] = vertex.Colors[uvIndex].Y;  								vi += 4;  								++colorIndex;  							}  							break;    						case BufferLayoutElementUsages.Normal:  							if (loadNormals)  							{  								vertices[vi] = vertex.Normals[normIndex].X;  								vertices[vi+1] = vertex.Normals[normIndex].Y;  								vertices[vi+2] = vertex.Normals[normIndex].Z;  								vi += 3;  								++normIndex;  							}  							break;    						case BufferLayoutElementUsages.UV:  							if (loadUVs)  							{  								vertices[vi] = vertex.UVs[uvIndex].X;  								vertices[vi+1] = vertex.UVs[uvIndex].Y;  								vi += 2;  								++uvIndex;  							}  							break;  					}  				}  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: foreach (var vertex in meshProcessor.Verticies)  			{  				int posIndex = 0' colorIndex = 0' normIndex = 0' uvIndex = 0;  				foreach (var element in elements)  				{  					switch (element.Usage)  					{  						case BufferLayoutElementUsages.Position:  							vertices[vi] = vertex.Positions[posIndex].X;  							vertices[vi+1] = vertex.Positions[posIndex].Y;  							if (posFloatCount == 3) vertices[vi+2] = vertex.Positions[posIndex].Z;  							vi += posFloatCount;  							++posIndex;  							break;    						case BufferLayoutElementUsages.Color:  							if (loadColors)  							{  								vertices[vi] = vertex.Colors[uvIndex].X;  								vertices[vi+1] = vertex.Colors[uvIndex].Y;  								vi += 4;  								++colorIndex;  							}  							break;    						case BufferLayoutElementUsages.Normal:  							if (loadNormals)  							{  								vertices[vi] = vertex.Normals[normIndex].X;  								vertices[vi+1] = vertex.Normals[normIndex].Y;  								vertices[vi+2] = vertex.Normals[normIndex].Z;  								vi += 3;  								++normIndex;  							}  							break;    						case BufferLayoutElementUsages.UV:  							if (loadUVs)  							{  								vertices[vi] = vertex.UVs[uvIndex].X;  								vertices[vi+1] = vertex.UVs[uvIndex].Y;  								vi += 2;  								++uvIndex;  							}  							break;  					}  				}  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: foreach (var vertex in meshProcessor.Verticies)  			{  				int posIndex = 0' colorIndex = 0' normIndex = 0' uvIndex = 0;  				foreach (var element in elements)  				{  					switch (element.Usage)  					{  						case BufferLayoutElementUsages.Position:  							vertices[vi] = vertex.Positions[posIndex].X;  							vertices[vi+1] = vertex.Positions[posIndex].Y;  							if (posFloatCount == 3) vertices[vi+2] = vertex.Positions[posIndex].Z;  							vi += posFloatCount;  							++posIndex;  							break;    						case BufferLayoutElementUsages.Color:  							if (loadColors)  							{  								vertices[vi] = vertex.Colors[uvIndex].X;  								vertices[vi+1] = vertex.Colors[uvIndex].Y;  								vi += 4;  								++colorIndex;  							}  							break;    						case BufferLayoutElementUsages.Normal:  							if (loadNormals)  							{  								vertices[vi] = vertex.Normals[normIndex].X;  								vertices[vi+1] = vertex.Normals[normIndex].Y;  								vertices[vi+2] = vertex.Normals[normIndex].Z;  								vi += 3;  								++normIndex;  							}  							break;    						case BufferLayoutElementUsages.UV:  							if (loadUVs)  							{  								vertices[vi] = vertex.UVs[uvIndex].X;  								vertices[vi+1] = vertex.UVs[uvIndex].Y;  								vi += 2;  								++uvIndex;  							}  							break;  					}  				}  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: foreach (var vertex in meshProcessor.Verticies)  			{  				int posIndex = 0' colorIndex = 0' normIndex = 0' uvIndex = 0;  				foreach (var element in elements)  				{  					switch (element.Usage)  					{  						case BufferLayoutElementUsages.Position:  							vertices[vi] = vertex.Positions[posIndex].X;  							vertices[vi+1] = vertex.Positions[posIndex].Y;  							if (posFloatCount == 3) vertices[vi+2] = vertex.Positions[posIndex].Z;  							vi += posFloatCount;  							++posIndex;  							break;    						case BufferLayoutElementUsages.Color:  							if (loadColors)  							{  								vertices[vi] = vertex.Colors[uvIndex].X;  								vertices[vi+1] = vertex.Colors[uvIndex].Y;  								vi += 4;  								++colorIndex;  							}  							break;    						case BufferLayoutElementUsages.Normal:  							if (loadNormals)  							{  								vertices[vi] = vertex.Normals[normIndex].X;  								vertices[vi+1] = vertex.Normals[normIndex].Y;  								vertices[vi+2] = vertex.Normals[normIndex].Z;  								vi += 3;  								++normIndex;  							}  							break;    						case BufferLayoutElementUsages.UV:  							if (loadUVs)  							{  								vertices[vi] = vertex.UVs[uvIndex].X;  								vertices[vi+1] = vertex.UVs[uvIndex].Y;  								vi += 2;  								++uvIndex;  							}  							break;  					}  				}  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: foreach (var vertex in meshProcessor.Verticies)  			{  				int posIndex = 0' colorIndex = 0' normIndex = 0' uvIndex = 0;  				foreach (var element in elements)  				{  					switch (element.Usage)  					{  						case BufferLayoutElementUsages.Position:  							vertices[vi] = vertex.Positions[posIndex].X;  							vertices[vi+1] = vertex.Positions[posIndex].Y;  							if (posFloatCount == 3) vertices[vi+2] = vertex.Positions[posIndex].Z;  							vi += posFloatCount;  							++posIndex;  							break;    						case BufferLayoutElementUsages.Color:  							if (loadColors)  							{  								vertices[vi] = vertex.Colors[uvIndex].X;  								vertices[vi+1] = vertex.Colors[uvIndex].Y;  								vi += 4;  								++colorIndex;  							}  							break;    						case BufferLayoutElementUsages.Normal:  							if (loadNormals)  							{  								vertices[vi] = vertex.Normals[normIndex].X;  								vertices[vi+1] = vertex.Normals[normIndex].Y;  								vertices[vi+2] = vertex.Normals[normIndex].Z;  								vi += 3;  								++normIndex;  							}  							break;    						case BufferLayoutElementUsages.UV:  							if (loadUVs)  							{  								vertices[vi] = vertex.UVs[uvIndex].X;  								vertices[vi+1] = vertex.UVs[uvIndex].Y;  								vi += 2;  								++uvIndex;  							}  							break;  					}  				}  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: foreach (var vertex in meshProcessor.Verticies)  			{  				int posIndex = 0' colorIndex = 0' normIndex = 0' uvIndex = 0;  				foreach (var element in elements)  				{  					switch (element.Usage)  					{  						case BufferLayoutElementUsages.Position:  							vertices[vi] = vertex.Positions[posIndex].X;  							vertices[vi+1] = vertex.Positions[posIndex].Y;  							if (posFloatCount == 3) vertices[vi+2] = vertex.Positions[posIndex].Z;  							vi += posFloatCount;  							++posIndex;  							break;    						case BufferLayoutElementUsages.Color:  							if (loadColors)  							{  								vertices[vi] = vertex.Colors[uvIndex].X;  								vertices[vi+1] = vertex.Colors[uvIndex].Y;  								vi += 4;  								++colorIndex;  							}  							break;    						case BufferLayoutElementUsages.Normal:  							if (loadNormals)  							{  								vertices[vi] = vertex.Normals[normIndex].X;  								vertices[vi+1] = vertex.Normals[normIndex].Y;  								vertices[vi+2] = vertex.Normals[normIndex].Z;  								vi += 3;  								++normIndex;  							}  							break;    						case BufferLayoutElementUsages.UV:  							if (loadUVs)  							{  								vertices[vi] = vertex.UVs[uvIndex].X;  								vertices[vi+1] = vertex.UVs[uvIndex].Y;  								vi += 2;  								++uvIndex;  							}  							break;  					}  				}  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: indices = new int[meshProcessor.Triangles.Count * 3];
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: foreach (var triangle in meshProcessor.Triangles)  			{  				indices[ti] = triangle.Verticies[0].Index;  				indices[ti+1] = triangle.Verticies[1].Index;  				indices[ti+2] = triangle.Verticies[2].Index;  				ti += 3;  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: foreach (var triangle in meshProcessor.Triangles)  			{  				indices[ti] = triangle.Verticies[0].Index;  				indices[ti+1] = triangle.Verticies[1].Index;  				indices[ti+2] = triangle.Verticies[2].Index;  				ti += 3;  			}
Magic Number,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following statement contains a magic number: foreach (var triangle in meshProcessor.Triangles)  			{  				indices[ti] = triangle.Verticies[0].Index;  				indices[ti+1] = triangle.Verticies[1].Index;  				indices[ti+2] = triangle.Verticies[2].Index;  				ti += 3;  			}
Magic Number,Reign.Video.Abstraction,SoftwareFCurve,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareAction.cs,SoftwareFCurve,The following statement contains a magic number: int i2 = 0' loop = values.Length / 2;
Magic Number,Reign.Video.Abstraction,SoftwareFCurve,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareAction.cs,SoftwareFCurve,The following statement contains a magic number: for (int i = 0; i != loop; ++i)  			{  				InterpolationTypes interpolationType = InterpolationTypes.Bezier;  				switch (types[i])  				{  					case 'B': interpolationType = InterpolationTypes.Bezier; break;  					case 'L': interpolationType = InterpolationTypes.Linear; break;  					case 'C': interpolationType = InterpolationTypes.Constant; break;  				}    				KeyFrames.Add(new SoftwareKeyFrame(new Vector2(values[i2]' values[i2+1])' interpolationType));  				i2 += 2;  			}
Magic Number,Reign.Video.Abstraction,SoftwareBone,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareArmature.cs,SoftwareBone,The following statement contains a magic number: Position = new Vector3(bone.Position.Values[0]' bone.Position.Values[1]' bone.Position.Values[2]);
Magic Number,Reign.Video.Abstraction,SoftwareBone,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareArmature.cs,SoftwareBone,The following statement contains a magic number: Rotation = new Matrix3  			(  				new Vector3(bone.Rotation.Values[0]' bone.Rotation.Values[1]' bone.Rotation.Values[2])'  				new Vector3(bone.Rotation.Values[3]' bone.Rotation.Values[4]' bone.Rotation.Values[5])'  				new Vector3(bone.Rotation.Values[6]' bone.Rotation.Values[7]' bone.Rotation.Values[8])  			);
Magic Number,Reign.Video.Abstraction,SoftwareBone,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareArmature.cs,SoftwareBone,The following statement contains a magic number: Rotation = new Matrix3  			(  				new Vector3(bone.Rotation.Values[0]' bone.Rotation.Values[1]' bone.Rotation.Values[2])'  				new Vector3(bone.Rotation.Values[3]' bone.Rotation.Values[4]' bone.Rotation.Values[5])'  				new Vector3(bone.Rotation.Values[6]' bone.Rotation.Values[7]' bone.Rotation.Values[8])  			);
Magic Number,Reign.Video.Abstraction,SoftwareBone,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareArmature.cs,SoftwareBone,The following statement contains a magic number: Rotation = new Matrix3  			(  				new Vector3(bone.Rotation.Values[0]' bone.Rotation.Values[1]' bone.Rotation.Values[2])'  				new Vector3(bone.Rotation.Values[3]' bone.Rotation.Values[4]' bone.Rotation.Values[5])'  				new Vector3(bone.Rotation.Values[6]' bone.Rotation.Values[7]' bone.Rotation.Values[8])  			);
Magic Number,Reign.Video.Abstraction,SoftwareBone,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareArmature.cs,SoftwareBone,The following statement contains a magic number: Rotation = new Matrix3  			(  				new Vector3(bone.Rotation.Values[0]' bone.Rotation.Values[1]' bone.Rotation.Values[2])'  				new Vector3(bone.Rotation.Values[3]' bone.Rotation.Values[4]' bone.Rotation.Values[5])'  				new Vector3(bone.Rotation.Values[6]' bone.Rotation.Values[7]' bone.Rotation.Values[8])  			);
Magic Number,Reign.Video.Abstraction,SoftwareBone,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareArmature.cs,SoftwareBone,The following statement contains a magic number: Rotation = new Matrix3  			(  				new Vector3(bone.Rotation.Values[0]' bone.Rotation.Values[1]' bone.Rotation.Values[2])'  				new Vector3(bone.Rotation.Values[3]' bone.Rotation.Values[4]' bone.Rotation.Values[5])'  				new Vector3(bone.Rotation.Values[6]' bone.Rotation.Values[7]' bone.Rotation.Values[8])  			);
Magic Number,Reign.Video.Abstraction,SoftwareBone,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareArmature.cs,SoftwareBone,The following statement contains a magic number: Rotation = new Matrix3  			(  				new Vector3(bone.Rotation.Values[0]' bone.Rotation.Values[1]' bone.Rotation.Values[2])'  				new Vector3(bone.Rotation.Values[3]' bone.Rotation.Values[4]' bone.Rotation.Values[5])'  				new Vector3(bone.Rotation.Values[6]' bone.Rotation.Values[7]' bone.Rotation.Values[8])  			);
Magic Number,Reign.Video.Abstraction,SoftwareBone,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareArmature.cs,SoftwareBone,The following statement contains a magic number: Rotation = new Matrix3  			(  				new Vector3(bone.Rotation.Values[0]' bone.Rotation.Values[1]' bone.Rotation.Values[2])'  				new Vector3(bone.Rotation.Values[3]' bone.Rotation.Values[4]' bone.Rotation.Values[5])'  				new Vector3(bone.Rotation.Values[6]' bone.Rotation.Values[7]' bone.Rotation.Values[8])  			);
Magic Number,Reign.Video.Abstraction,SoftwareEdge,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareEdge.cs,SoftwareEdge,The following statement contains a magic number: Verticies = new SoftwareVertex[2] {vertex1' vertex2};
Magic Number,Reign.Video.Abstraction,SoftwareMaterial,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMaterial.cs,SoftwareMaterial,The following statement contains a magic number: foreach (var input in material.Inputs)  			{  				if (input.Type == "Value")  				{  					switch (input.Values.Length)  					{  						case 1: Values1.Add(input.ID' input.Values[0]); break;  						case 2: Values2.Add(input.ID' new Vector2(input.Values[0]' input.Values[1])); break;  						case 3: Values3.Add(input.ID' new Vector3(input.Values[0]' input.Values[1]' input.Values[2])); break;  						case 4: Values4.Add(input.ID' new Vector4(input.Values[0]' input.Values[1]' input.Values[2]' input.Values[3])); break;  					}  				}  				else if (input.Type == "Texture")  				{  					Textures.Add(input.ID' input.Content);  				}  			}
Magic Number,Reign.Video.Abstraction,SoftwareMaterial,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMaterial.cs,SoftwareMaterial,The following statement contains a magic number: foreach (var input in material.Inputs)  			{  				if (input.Type == "Value")  				{  					switch (input.Values.Length)  					{  						case 1: Values1.Add(input.ID' input.Values[0]); break;  						case 2: Values2.Add(input.ID' new Vector2(input.Values[0]' input.Values[1])); break;  						case 3: Values3.Add(input.ID' new Vector3(input.Values[0]' input.Values[1]' input.Values[2])); break;  						case 4: Values4.Add(input.ID' new Vector4(input.Values[0]' input.Values[1]' input.Values[2]' input.Values[3])); break;  					}  				}  				else if (input.Type == "Texture")  				{  					Textures.Add(input.ID' input.Content);  				}  			}
Magic Number,Reign.Video.Abstraction,SoftwareMaterial,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMaterial.cs,SoftwareMaterial,The following statement contains a magic number: foreach (var input in material.Inputs)  			{  				if (input.Type == "Value")  				{  					switch (input.Values.Length)  					{  						case 1: Values1.Add(input.ID' input.Values[0]); break;  						case 2: Values2.Add(input.ID' new Vector2(input.Values[0]' input.Values[1])); break;  						case 3: Values3.Add(input.ID' new Vector3(input.Values[0]' input.Values[1]' input.Values[2])); break;  						case 4: Values4.Add(input.ID' new Vector4(input.Values[0]' input.Values[1]' input.Values[2]' input.Values[3])); break;  					}  				}  				else if (input.Type == "Texture")  				{  					Textures.Add(input.ID' input.Content);  				}  			}
Magic Number,Reign.Video.Abstraction,SoftwareMaterial,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMaterial.cs,SoftwareMaterial,The following statement contains a magic number: foreach (var input in material.Inputs)  			{  				if (input.Type == "Value")  				{  					switch (input.Values.Length)  					{  						case 1: Values1.Add(input.ID' input.Values[0]); break;  						case 2: Values2.Add(input.ID' new Vector2(input.Values[0]' input.Values[1])); break;  						case 3: Values3.Add(input.ID' new Vector3(input.Values[0]' input.Values[1]' input.Values[2])); break;  						case 4: Values4.Add(input.ID' new Vector4(input.Values[0]' input.Values[1]' input.Values[2]' input.Values[3])); break;  					}  				}  				else if (input.Type == "Texture")  				{  					Textures.Add(input.ID' input.Content);  				}  			}
Magic Number,Reign.Video.Abstraction,SoftwareMaterial,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMaterial.cs,SoftwareMaterial,The following statement contains a magic number: foreach (var input in material.Inputs)  			{  				if (input.Type == "Value")  				{  					switch (input.Values.Length)  					{  						case 1: Values1.Add(input.ID' input.Values[0]); break;  						case 2: Values2.Add(input.ID' new Vector2(input.Values[0]' input.Values[1])); break;  						case 3: Values3.Add(input.ID' new Vector3(input.Values[0]' input.Values[1]' input.Values[2])); break;  						case 4: Values4.Add(input.ID' new Vector4(input.Values[0]' input.Values[1]' input.Values[2]' input.Values[3])); break;  					}  				}  				else if (input.Type == "Texture")  				{  					Textures.Add(input.ID' input.Content);  				}  			}
Magic Number,Reign.Video.Abstraction,SoftwareMaterial,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMaterial.cs,SoftwareMaterial,The following statement contains a magic number: foreach (var input in material.Inputs)  			{  				if (input.Type == "Value")  				{  					switch (input.Values.Length)  					{  						case 1: Values1.Add(input.ID' input.Values[0]); break;  						case 2: Values2.Add(input.ID' new Vector2(input.Values[0]' input.Values[1])); break;  						case 3: Values3.Add(input.ID' new Vector3(input.Values[0]' input.Values[1]' input.Values[2])); break;  						case 4: Values4.Add(input.ID' new Vector4(input.Values[0]' input.Values[1]' input.Values[2]' input.Values[3])); break;  					}  				}  				else if (input.Type == "Texture")  				{  					Textures.Add(input.ID' input.Content);  				}  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: for (int i = 0; i != channels.Length; ++i)  			{  				var channel = channels[i];  				if (channel.ID != "Position") continue;    				Dimensions = channel.Step;  				positionStep = channel.Step;  				if (channel.Step == 3)  				{  					var vertexPostions = new Vector3[channel.Values.Length / 3];  					var positions = channel.Values;  					int i2 = 0;  					for (int i3 = 0; i3 != vertexPostions.Length; ++i3)  					{  						Verticies.Add(new SoftwareVertex(i3));  						vertexPostions[i3] = new Vector3(positions[i2]' positions[i2+1]' positions[i2+2]);  						i2 += 3;  					}    					VetexComponents.Add(vertexPostions);  				}  				else if (channel.Step == 2)  				{  					var vertexPostions = new Vector2[channel.Values.Length / 2];  					var positions = channel.Values;  					int i2 = 0;  					for (int i3 = 0; i3 != vertexPostions.Length; ++i3)  					{  						Verticies.Add(new SoftwareVertex(i3));  						vertexPostions[i3] = new Vector2(positions[i2]' positions[i2+1]);  						i2 += 2;  					}    					VetexComponents.Add(vertexPostions);  				}  				else  				{  					Debug.ThrowError("SoftwareMesh"' "Unsupotred position step count");  				}    				VertexComponentKeys.Add(VertexComponentKeyTypes.Positions' i);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: for (int i = 0; i != channels.Length; ++i)  			{  				var channel = channels[i];  				if (channel.ID != "Position") continue;    				Dimensions = channel.Step;  				positionStep = channel.Step;  				if (channel.Step == 3)  				{  					var vertexPostions = new Vector3[channel.Values.Length / 3];  					var positions = channel.Values;  					int i2 = 0;  					for (int i3 = 0; i3 != vertexPostions.Length; ++i3)  					{  						Verticies.Add(new SoftwareVertex(i3));  						vertexPostions[i3] = new Vector3(positions[i2]' positions[i2+1]' positions[i2+2]);  						i2 += 3;  					}    					VetexComponents.Add(vertexPostions);  				}  				else if (channel.Step == 2)  				{  					var vertexPostions = new Vector2[channel.Values.Length / 2];  					var positions = channel.Values;  					int i2 = 0;  					for (int i3 = 0; i3 != vertexPostions.Length; ++i3)  					{  						Verticies.Add(new SoftwareVertex(i3));  						vertexPostions[i3] = new Vector2(positions[i2]' positions[i2+1]);  						i2 += 2;  					}    					VetexComponents.Add(vertexPostions);  				}  				else  				{  					Debug.ThrowError("SoftwareMesh"' "Unsupotred position step count");  				}    				VertexComponentKeys.Add(VertexComponentKeyTypes.Positions' i);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: for (int i = 0; i != channels.Length; ++i)  			{  				var channel = channels[i];  				if (channel.ID != "Position") continue;    				Dimensions = channel.Step;  				positionStep = channel.Step;  				if (channel.Step == 3)  				{  					var vertexPostions = new Vector3[channel.Values.Length / 3];  					var positions = channel.Values;  					int i2 = 0;  					for (int i3 = 0; i3 != vertexPostions.Length; ++i3)  					{  						Verticies.Add(new SoftwareVertex(i3));  						vertexPostions[i3] = new Vector3(positions[i2]' positions[i2+1]' positions[i2+2]);  						i2 += 3;  					}    					VetexComponents.Add(vertexPostions);  				}  				else if (channel.Step == 2)  				{  					var vertexPostions = new Vector2[channel.Values.Length / 2];  					var positions = channel.Values;  					int i2 = 0;  					for (int i3 = 0; i3 != vertexPostions.Length; ++i3)  					{  						Verticies.Add(new SoftwareVertex(i3));  						vertexPostions[i3] = new Vector2(positions[i2]' positions[i2+1]);  						i2 += 2;  					}    					VetexComponents.Add(vertexPostions);  				}  				else  				{  					Debug.ThrowError("SoftwareMesh"' "Unsupotred position step count");  				}    				VertexComponentKeys.Add(VertexComponentKeyTypes.Positions' i);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: for (int i = 0; i != channels.Length; ++i)  			{  				var channel = channels[i];  				if (channel.ID != "Position") continue;    				Dimensions = channel.Step;  				positionStep = channel.Step;  				if (channel.Step == 3)  				{  					var vertexPostions = new Vector3[channel.Values.Length / 3];  					var positions = channel.Values;  					int i2 = 0;  					for (int i3 = 0; i3 != vertexPostions.Length; ++i3)  					{  						Verticies.Add(new SoftwareVertex(i3));  						vertexPostions[i3] = new Vector3(positions[i2]' positions[i2+1]' positions[i2+2]);  						i2 += 3;  					}    					VetexComponents.Add(vertexPostions);  				}  				else if (channel.Step == 2)  				{  					var vertexPostions = new Vector2[channel.Values.Length / 2];  					var positions = channel.Values;  					int i2 = 0;  					for (int i3 = 0; i3 != vertexPostions.Length; ++i3)  					{  						Verticies.Add(new SoftwareVertex(i3));  						vertexPostions[i3] = new Vector2(positions[i2]' positions[i2+1]);  						i2 += 2;  					}    					VetexComponents.Add(vertexPostions);  				}  				else  				{  					Debug.ThrowError("SoftwareMesh"' "Unsupotred position step count");  				}    				VertexComponentKeys.Add(VertexComponentKeyTypes.Positions' i);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: for (int i = 0; i != channels.Length; ++i)  			{  				var channel = channels[i];  				if (channel.ID != "Position") continue;    				Dimensions = channel.Step;  				positionStep = channel.Step;  				if (channel.Step == 3)  				{  					var vertexPostions = new Vector3[channel.Values.Length / 3];  					var positions = channel.Values;  					int i2 = 0;  					for (int i3 = 0; i3 != vertexPostions.Length; ++i3)  					{  						Verticies.Add(new SoftwareVertex(i3));  						vertexPostions[i3] = new Vector3(positions[i2]' positions[i2+1]' positions[i2+2]);  						i2 += 3;  					}    					VetexComponents.Add(vertexPostions);  				}  				else if (channel.Step == 2)  				{  					var vertexPostions = new Vector2[channel.Values.Length / 2];  					var positions = channel.Values;  					int i2 = 0;  					for (int i3 = 0; i3 != vertexPostions.Length; ++i3)  					{  						Verticies.Add(new SoftwareVertex(i3));  						vertexPostions[i3] = new Vector2(positions[i2]' positions[i2+1]);  						i2 += 2;  					}    					VetexComponents.Add(vertexPostions);  				}  				else  				{  					Debug.ThrowError("SoftwareMesh"' "Unsupotred position step count");  				}    				VertexComponentKeys.Add(VertexComponentKeyTypes.Positions' i);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: for (int i = 0; i != channels.Length; ++i)  			{  				var channel = channels[i];  				if (channel.ID != "Position") continue;    				Dimensions = channel.Step;  				positionStep = channel.Step;  				if (channel.Step == 3)  				{  					var vertexPostions = new Vector3[channel.Values.Length / 3];  					var positions = channel.Values;  					int i2 = 0;  					for (int i3 = 0; i3 != vertexPostions.Length; ++i3)  					{  						Verticies.Add(new SoftwareVertex(i3));  						vertexPostions[i3] = new Vector3(positions[i2]' positions[i2+1]' positions[i2+2]);  						i2 += 3;  					}    					VetexComponents.Add(vertexPostions);  				}  				else if (channel.Step == 2)  				{  					var vertexPostions = new Vector2[channel.Values.Length / 2];  					var positions = channel.Values;  					int i2 = 0;  					for (int i3 = 0; i3 != vertexPostions.Length; ++i3)  					{  						Verticies.Add(new SoftwareVertex(i3));  						vertexPostions[i3] = new Vector2(positions[i2]' positions[i2+1]);  						i2 += 2;  					}    					VetexComponents.Add(vertexPostions);  				}  				else  				{  					Debug.ThrowError("SoftwareMesh"' "Unsupotred position step count");  				}    				VertexComponentKeys.Add(VertexComponentKeyTypes.Positions' i);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: for (int i = 0; i != channels.Length; ++i)  			{  				var channel = channels[i];  				if (channel.ID != "Position") continue;    				Dimensions = channel.Step;  				positionStep = channel.Step;  				if (channel.Step == 3)  				{  					var vertexPostions = new Vector3[channel.Values.Length / 3];  					var positions = channel.Values;  					int i2 = 0;  					for (int i3 = 0; i3 != vertexPostions.Length; ++i3)  					{  						Verticies.Add(new SoftwareVertex(i3));  						vertexPostions[i3] = new Vector3(positions[i2]' positions[i2+1]' positions[i2+2]);  						i2 += 3;  					}    					VetexComponents.Add(vertexPostions);  				}  				else if (channel.Step == 2)  				{  					var vertexPostions = new Vector2[channel.Values.Length / 2];  					var positions = channel.Values;  					int i2 = 0;  					for (int i3 = 0; i3 != vertexPostions.Length; ++i3)  					{  						Verticies.Add(new SoftwareVertex(i3));  						vertexPostions[i3] = new Vector2(positions[i2]' positions[i2+1]);  						i2 += 2;  					}    					VetexComponents.Add(vertexPostions);  				}  				else  				{  					Debug.ThrowError("SoftwareMesh"' "Unsupotred position step count");  				}    				VertexComponentKeys.Add(VertexComponentKeyTypes.Positions' i);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following statement contains a magic number: if (positionStep == 3)  			{  				foreach (int step in mesh.Faces.Steps.Values)  				{  					int loop = step - 2;  					int vi2 = vi + 1' vi3 = vi + 2;  					for (int i2 = 0; i2 != loop; ++i2)  					{  						var triangle = new SoftwareTriangle(ti' Verticies[positionIndices[vi]]' Verticies[positionIndices[vi2]]' Verticies[positionIndices[vi3]]);  						Triangles.Add(triangle);    						if (colorIndices != null)  						{  							int cii = colorIndices[vi] * 3' cii2 = colorIndices[vi2] * 3' cii3 = colorIndices[vi3] * 3;  							triangleColors.Add(new TriangleColorComponent  							(  								new Vector4(colors[cii]' colors[cii+1]' colors[cii+2]' colors[cii+3])'  								new Vector4(colors[cii2]' colors[cii2+1]' colors[cii2+2]' colors[cii2+3])'  								new Vector4(colors[cii3]' colors[cii3+1]' colors[cii3+2]' colors[cii3+3]))  							);  						}    						if (normalIndices != null)  						{  							int nii = normalIndices[vi] * 3' nii2 = normalIndices[vi2] * 3' nii3 = normalIndices[vi3] * 3;  							triangleNormals.Add(new TriangleNormalComponent  							(  								new Vector3(normals[nii]' normals[nii+1]' normals[nii+2])'  								new Vector3(normals[nii2]' normals[nii2+1]' normals[nii2+2])'  								new Vector3(normals[nii3]' normals[nii3+1]' normals[nii3+2]))  							);  						}    						if (uvIndices != null)  						{  							int uii = uvIndices[vi] * 2' uii2 = uvIndices[vi2] * 2' uii3 = uvIndices[vi3] * 2;  							triangleUVs.Add(new TriangleUVComponent  							(  								new Vector2(uvs[uii]' uvs[uii+1])'  								new Vector2(uvs[uii2]' uvs[uii2+1])'  								new Vector2(uvs[uii3]' uvs[uii3+1]))  							);  						}    						++ti;  						++vi2;  						++vi3;  					}    					vi += step;  				}  			}  			else  			{  				Debug.ThrowError("SoftwareMesh"' "Position step not implemented yet: Step value = " + positionStep);  			}
Magic Number,Reign.Video.Abstraction,SoftwareObject,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareObject.cs,SoftwareObject,The following statement contains a magic number: foreach (var input in o.Transform.Inputs)  			{  				switch (input.Type)  				{  					case "EulerRotation": Rotation = new Vector3(input.Values[0]' input.Values[1]' input.Values[2]); break;  					case "Scale": Scale = new Vector3(input.Values[0]' input.Values[1]' input.Values[2]); break;  					case "Position": Position = new Vector3(input.Values[0]' input.Values[1]' input.Values[2]); break;  					default: Debug.ThrowError("SoftwareMesh"' "Unsuported Transform Type: " + input.Type); break;  				}  			}
Magic Number,Reign.Video.Abstraction,SoftwareObject,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareObject.cs,SoftwareObject,The following statement contains a magic number: foreach (var input in o.Transform.Inputs)  			{  				switch (input.Type)  				{  					case "EulerRotation": Rotation = new Vector3(input.Values[0]' input.Values[1]' input.Values[2]); break;  					case "Scale": Scale = new Vector3(input.Values[0]' input.Values[1]' input.Values[2]); break;  					case "Position": Position = new Vector3(input.Values[0]' input.Values[1]' input.Values[2]); break;  					default: Debug.ThrowError("SoftwareMesh"' "Unsuported Transform Type: " + input.Type); break;  				}  			}
Magic Number,Reign.Video.Abstraction,SoftwareObject,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareObject.cs,SoftwareObject,The following statement contains a magic number: foreach (var input in o.Transform.Inputs)  			{  				switch (input.Type)  				{  					case "EulerRotation": Rotation = new Vector3(input.Values[0]' input.Values[1]' input.Values[2]); break;  					case "Scale": Scale = new Vector3(input.Values[0]' input.Values[1]' input.Values[2]); break;  					case "Position": Position = new Vector3(input.Values[0]' input.Values[1]' input.Values[2]); break;  					default: Debug.ThrowError("SoftwareMesh"' "Unsuported Transform Type: " + input.Type); break;  				}  			}
Magic Number,Reign.Video.Abstraction,TriangleNormalComponent,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareTriangle.cs,TriangleNormalComponent,The following statement contains a magic number: Normals = new Vector3[3] {normal1' normal2' normal3};
Magic Number,Reign.Video.Abstraction,TriangleUVComponent,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareTriangle.cs,TriangleUVComponent,The following statement contains a magic number: UVs = new Vector2[3] {uv1' uv2' uv3};
Magic Number,Reign.Video.Abstraction,TriangleColorComponent,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareTriangle.cs,TriangleColorComponent,The following statement contains a magic number: Colors = new Vector4[3] {color1' color2' color3};
Magic Number,Reign.Video.Abstraction,SoftwareTriangle,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareTriangle.cs,SoftwareTriangle,The following statement contains a magic number: Verticies = new SoftwareVertex[3] {vertex1' vertex2' vertex3};
Magic Number,Reign.Video.Abstraction,SoftwareTriangle,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareTriangle.cs,SoftwareTriangle,The following statement contains a magic number: vertex3.TraingleIndex.Add(2);
Missing Default,Reign.Video.Abstraction,HardwareMeshProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,HardwareMeshProcessor,The following switch statement is missing a default case: switch (key.Key)  				{  					case VertexComponentKeyTypes.Positions:  						var vertexComponents = mesh.VetexComponents[key.Value];  						if (vertexComponents.GetType() == typeof(Vector3[]))  						{  							positions.Add((Vector3[])vertexComponents);  						}  						else if (vertexComponents.GetType() == typeof(Vector2[]))  						{  							var verts = (Vector2[])vertexComponents;  							var newVerts = new Vector3[verts.Length];  							for (int i = 0; i != verts.Length; ++i) newVerts[i] = new Vector3(verts[i].X' verts[i].Y' 0);  							positions.Add(newVerts);  						}  						else  						{  							Debug.ThrowError("HardwareMeshProcessor"' "Unsuported VectorComponent type");  						}  						break;  				}
Missing Default,Reign.Video.Abstraction,HardwareMeshProcessor,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\HardwareMeshProcessor.cs,HardwareMeshProcessor,The following switch statement is missing a default case: switch (key.Key)  				{  					case TriangleComponentKeyTypes.ColorComponents:  						if (loadColors) colorComponents.Add((TriangleColorComponent[])mesh.TriangleComponents[key.Value]);  						break;    					case TriangleComponentKeyTypes.NormalComponents:  						if (loadNormals) normalComponents.Add((TriangleNormalComponent[])mesh.TriangleComponents[key.Value]);  						break;    					case TriangleComponentKeyTypes.UVComponents:  						if (loadUVs) uvComponents.Add((TriangleUVComponent[])mesh.TriangleComponents[key.Value]);  						break;  				}
Missing Default,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following switch statement is missing a default case: switch (softwareMesh.Dimensions)  			{  				case 2:  					posElementType = BufferLayoutElementTypes.Vector2;  					posFloatCount = 2;  					break;    				case 3:  					posElementType = BufferLayoutElementTypes.Vector3;  					posFloatCount = 3;  					break;  			}
Missing Default,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following switch statement is missing a default case: switch (key.Key)  				{  					case VertexComponentKeyTypes.Positions:  						elements.Add(new BufferLayoutElement(posElementType' BufferLayoutElementUsages.Position' 0' posCount' vertFloatCount));  						vertFloatCount += posFloatCount;  						++posCount;  						break;  				}
Missing Default,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following switch statement is missing a default case: switch (key.Key)  				{  					case TriangleComponentKeyTypes.ColorComponents:  						if (loadColors)  						{  							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector4' BufferLayoutElementUsages.Color' 0' colorCount' vertFloatCount));  							vertFloatCount += 4;  							++colorCount;  						}  						break;    					case TriangleComponentKeyTypes.NormalComponents:  						if (loadNormals)  						{  							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' normalCount' vertFloatCount));  							vertFloatCount += 3;  							++normalCount;  						}  						break;    					case TriangleComponentKeyTypes.UVComponents:  						if (loadUVs)  						{  							elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' uvCount' vertFloatCount));  							vertFloatCount += 2;  							++uvCount;  						}  						break;  				}
Missing Default,Reign.Video.Abstraction,Mesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\Mesh.cs,initData,The following switch statement is missing a default case: switch (element.Usage)  					{  						case BufferLayoutElementUsages.Position:  							vertices[vi] = vertex.Positions[posIndex].X;  							vertices[vi+1] = vertex.Positions[posIndex].Y;  							if (posFloatCount == 3) vertices[vi+2] = vertex.Positions[posIndex].Z;  							vi += posFloatCount;  							++posIndex;  							break;    						case BufferLayoutElementUsages.Color:  							if (loadColors)  							{  								vertices[vi] = vertex.Colors[uvIndex].X;  								vertices[vi+1] = vertex.Colors[uvIndex].Y;  								vi += 4;  								++colorIndex;  							}  							break;    						case BufferLayoutElementUsages.Normal:  							if (loadNormals)  							{  								vertices[vi] = vertex.Normals[normIndex].X;  								vertices[vi+1] = vertex.Normals[normIndex].Y;  								vertices[vi+2] = vertex.Normals[normIndex].Z;  								vi += 3;  								++normIndex;  							}  							break;    						case BufferLayoutElementUsages.UV:  							if (loadUVs)  							{  								vertices[vi] = vertex.UVs[uvIndex].X;  								vertices[vi+1] = vertex.UVs[uvIndex].Y;  								vi += 2;  								++uvIndex;  							}  							break;  					}
Missing Default,Reign.Video.Abstraction,SoftwareFCurve,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareAction.cs,SoftwareFCurve,The following switch statement is missing a default case: switch (types[i])  				{  					case 'B': interpolationType = InterpolationTypes.Bezier; break;  					case 'L': interpolationType = InterpolationTypes.Linear; break;  					case 'C': interpolationType = InterpolationTypes.Constant; break;  				}
Missing Default,Reign.Video.Abstraction,SoftwareMaterial,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMaterial.cs,SoftwareMaterial,The following switch statement is missing a default case: switch (input.Values.Length)  					{  						case 1: Values1.Add(input.ID' input.Values[0]); break;  						case 2: Values2.Add(input.ID' new Vector2(input.Values[0]' input.Values[1])); break;  						case 3: Values3.Add(input.ID' new Vector3(input.Values[0]' input.Values[1]' input.Values[2])); break;  						case 4: Values4.Add(input.ID' new Vector4(input.Values[0]' input.Values[1]' input.Values[2]' input.Values[3])); break;  					}
Missing Default,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following switch statement is missing a default case: switch (channel.ID)  				{  					case "Position": hasPositionData = true; break;  					case "Color": colors = channel.Values; break;  					case "Normal": normals = channel.Values; break;  					case "UV": uvs = channel.Values; break;  				}
Missing Default,Reign.Video.Abstraction,SoftwareMesh,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video.API\Model\SoftwareModel\SoftwareMesh.cs,SoftwareMesh,The following switch statement is missing a default case: switch (index.ID)  				{  					case "Position": positionIndices = index.Values; break;  					case "Color": colorIndices = index.Values; break;  					case "Normal": normalIndices = index.Values; break;  					case "UV": uvIndices = index.Values; break;  				}
