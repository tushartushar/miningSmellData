Implementation smell,Namespace,Class,File,Method,Description
Long Method,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileLibrary,The method has 132 lines of code.
Long Method,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The method has 288 lines of code.
Long Method,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileFields,The method has 274 lines of code.
Long Method,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMethodBlock,The method has 235 lines of code.
Complex Method,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,Cyclomatic complexity of the method is 12
Complex Method,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,formatCode,Cyclomatic complexity of the method is 17
Complex Method,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileFields,Cyclomatic complexity of the method is 60
Complex Method,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,getRegisterySize,Cyclomatic complexity of the method is 17
Complex Method,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,processNormalFields,Cyclomatic complexity of the method is 12
Complex Method,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMethodExt,Cyclomatic complexity of the method is 8
Complex Method,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMethodBlock,Cyclomatic complexity of the method is 35
Long Parameter List,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,Compile,The method has 5 parameters. Parameters: outDirectory' outputType' compileMaterial' compileMetroShaders' compileSilverlightShaders
Long Parameter List,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileShader,The method has 5 parameters. Parameters: shader' stream' vsStream' psStream' reflectionStream
Long Parameter List,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,createConstantType,The method has 10 parameters. Parameters: usage' field' methodValue' globalFieldFormat' fieldFormat' constantType' constantTypeProperties' applyGlobalMethodBody' applyInstanceMethodBody' applyInstancingMethodBody
Long Parameter List,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,createConstantArrayType,The method has 10 parameters. Parameters: usage' field' methodValue' globalFieldFormat' fieldFormat' constantType' constantTypeProperties' applyGlobalMethodBody' applyInstanceMethodBody' applyInstancingMethodBody
Long Parameter List,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileFields,The method has 5 parameters. Parameters: shader' stream' vsStream' psStream' reflectionStream
Long Parameter List,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The method has 5 parameters. Parameters: reflectionStream' normalFields' variableByteOffset' resourceIndex' vsConstansts
Long Statement,ShaderCompiler.Core,CodeFile,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\CodeFile.cs,FindMethodBlock,The length of the statement  "					match = Regex.Match(classBlock' Compiler.convertToBasicType(method.ReturnType' outputType' false) + @"\s*" + method.Name + @".*?\{(.*\})"' RegexOptions.Singleline); " is 164.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,Compile,The length of the statement  "			/*var exeDir = Microsoft.Win32.Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MSBuild\ToolsVersions\4.0"' "MSBuildToolsPath"' "") as string; " is 151.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,Compile,The length of the statement  "			compileLibrary(inDirectory + "bin/Debug/" + inFile.Split('.')[0] + ".dll"' compileMaterial' compileMetroShaders' compileSilverlightShaders); " is 140.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileLibrary,The length of the statement  "							if ((outputType == CompilerOutputs.D3D11 && compileMetroShaders) || (outputType == CompilerOutputs.Silverlight && compileSilverlightShaders)) " is 141.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileLibrary,The length of the statement  "								using (var file = new FileStream(outDirectoryRelitive + FileTag + obj.Name + ".vcg"' FileMode.Create' FileAccess.Write)) " is 120.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileLibrary,The length of the statement  "								using (var file = new FileStream(outDirectoryRelitive + FileTag + obj.Name + ".fcg"' FileMode.Create' FileAccess.Write)) " is 120.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileLibrary,The length of the statement  "								using (var file = new FileStream(outDirectoryRelitive + FileTag + obj.Name + fileExt' FileMode.Create' FileAccess.Write)) " is 121.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileLibrary,The length of the statement  "							if ((outputType == CompilerOutputs.D3D11 && compileMetroShaders) || (outputType == CompilerOutputs.Silverlight && compileSilverlightShaders)) " is 141.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileLibrary,The length of the statement  "								using (var reflectionFile = new FileStream(outDirectoryRelitive + FileTag + obj.Name + ".ref"' FileMode.Create' FileAccess.Write)) " is 130.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "			string constantProperties = null' constantTypeProperties = null' applyGlobalMethodBody = null' applyInstanceMethodBody = null' applyInstancingMethodBody = null' elementsBody = null' constantInitBody = null; " is 206.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "float"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 202.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector2"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 204.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector3"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 204.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector4"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 204.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix2"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 204.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix3"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 204.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix4"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 204.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Texture2DI"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 207.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "						globalFieldFormat = "private static WeakReference {2}; [MaterialField(MaterialFieldUsages.{3})] public static {0} {1} {{ get{{return ({0}){2}.Target;}} set{{{2} = new WeakReference(value);}} }}"; " is 195.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "						fieldFormat = "private WeakReference {2}; [MaterialField(MaterialFieldUsages.{3})] public {0} {1} {{ get{{return ({0}){2}.Target;}} set{{{2} = new WeakReference(value);}} }}"; " is 175.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "float[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 209.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector2[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 211.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector3[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 211.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector4[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 211.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix2[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 211.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix3[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 211.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix4[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody); " is 211.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "						if (field.FieldType == typeof(double) || field.FieldType == typeof(uint)) {type = "BufferLayoutElementTypes.Float"; offset = 1;} " is 128.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "						else if (field.FieldType == typeof(Vector4) && input.Type == VSInputTypes.Color) {type = "BufferLayoutElementTypes.RGBAx8"; offset = 1;} " is 136.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "						elementsBody += string.Format("elements.Add(new BufferLayoutElement({0}' {1}' {2}' {3}' {4}));"' type' usage' streamIndex' input.Index' floatOffset); " is 149.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "		public static void Init(DisposableI parent' string contentPath' string tag' ShaderVersions shaderVersion' Loader.LoadedCallbackMethod loadedCallback) " is 149.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "		public static void Init(DisposableI parent' string contentPath' string tag' ShaderVersions shaderVersion' ShaderFloatingPointQuality vsQuality' ShaderFloatingPointQuality psQuality' Loader.LoadedCallbackMethod loadedCallback) " is 225.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The length of the statement  "			return string.Format(shaderFile' shaderLibName' shader.Name' constantProperties' constantTypeProperties' applyGlobalMethodBody' applyInstanceMethodBody' applyInstancingMethodBody' elementsBody' constantInitBody); " is 212.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,createConstantArrayType,The length of the statement  "				constantTypeProperties += string.Format(globalFieldFormat' constantType' field.Name' field.Name.ToLower()' usage.MaterialUsages); " is 129.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,createConstantArrayType,The length of the statement  "				constantTypeProperties += string.Format(fieldFormat' constantType' field.Name' field.Name.ToLower()' usage.MaterialUsages); " is 123.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,createConstantArrayType,The length of the statement  "				constantTypeProperties += string.Format(globalFieldFormat' constantType' field.Name' field.Name.ToLower()' usage.MaterialUsages); " is 129.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileFields,The length of the statement  "						if (a.Type == VSInputTypes.IndexClassic || outputType == CompilerOutputs.D3D9 || outputType == CompilerOutputs.XNA || outputType == CompilerOutputs.Silverlight) " is 160.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileFields,The length of the statement  "						vsStream.Write(string.Format("{0} in {1} : {2}{3}"' fieldType' field.Name' attributeType' (attributeType != "NORMAL" && attributeType != "POSITION") ? a.Index.ToString() : "")); " is 177.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileFields,The length of the statement  "					if (outputType == CompilerOutputs.GL2 || outputType == CompilerOutputs.GLES2) vsStream.WriteLine(string.Format("attribute {0} {1};"' fieldType' fieldName)); " is 156.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileFields,The length of the statement  "						vsStream.Write(string.Format("'{4}{0} out {1} : {2}{3}"' fieldType' field.Name' attributeType' attributeType != "POSITION" ? a.Index.ToString() : ""' Environment.NewLine)); " is 172.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileFields,The length of the statement  "						psStream.Write(string.Format("{0} in {1} : {2}{3}"' fieldType' field.Name' attributeType' attributeType != "POSITION" ? a.Index.ToString() : "")); " is 146.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileFields,The length of the statement  "						psStream.Write(string.Format("{0} out {1} : {2}{3}"' fieldType' field.Name' attributeType' (attributeType != "COLOR" && attributeType != "NORMAL" && attributeType != "POSITION") ? a.Index.ToString() : "")); " is 206.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The length of the statement  "						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||  " is 159.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The length of the statement  "						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4))) " is 150.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,processNormalFields,The length of the statement  "						stream.WriteLine(string.Format("{0} {1} : register(c{2});"' fieldType' field.Name + ((arrayLength == -1) ? "" : "[" + arrayLength.ToString() + "]")' registerIndex)); " is 165.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,processNormalFields,The length of the statement  "					stream.WriteLine(string.Format("{0} {1};"' fieldType' field.Name + ((arrayLength == -1) ? "" : "[" + arrayLength.ToString() + "]"))); " is 133.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMethodExt,The length of the statement  "                        stream.WriteLine(string.Format("{0} {1}({2})"' convertToBasicType(method.ReturnType' true)' method.Name' methodParameters)); " is 124.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMethodBlock,The length of the statement  "								if ((((VSInput)a[0]).Type == VSInputTypes.IndexClassic || outputType == CompilerOutputs.GL2 || outputType == CompilerOutputs.GLES2) && (field.FieldType == typeof(uint) || field.FieldType == typeof(int))) " is 203.
Long Statement,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMethodBlock,The length of the statement  "										methodBlock = Utility.ReplaceKeyword(methodBlock' field.Name' string.Format("{0}[{1}]"' "glFragColorOut"' psOut.Index)); " is 120.
Complex Conditional,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileLibrary,The conditional expression  "(outputType == CompilerOutputs.D3D11 && compileMetroShaders) || (outputType == CompilerOutputs.Silverlight && compileSilverlightShaders)"  is complex.
Complex Conditional,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileLibrary,The conditional expression  "(outputType == CompilerOutputs.D3D11 && compileMetroShaders) || (outputType == CompilerOutputs.Silverlight && compileSilverlightShaders)"  is complex.
Complex Conditional,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The conditional expression  "field.FieldType == typeof(double) ||  							field.FieldType == typeof(Vector2) || field.FieldType == typeof(Vector3) || field.FieldType == typeof(Vector4) ||  							field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4) ||  							field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||  							field.FieldType == typeof(Matrix2[]) || field.FieldType == typeof(Matrix3[]) || field.FieldType == typeof(Matrix4[])"  is complex.
Complex Conditional,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,formatCode,The conditional expression  "(lastChar == '\n' || lastChar == '\r') && (c != '\n' && c != '\r')"  is complex.
Complex Conditional,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileFields,The conditional expression  "!(field.FieldType == typeof(double) ||  							field.FieldType == typeof(Vector2) || field.FieldType == typeof(Vector3) || field.FieldType == typeof(Vector4) ||  							field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||  							field.FieldType == typeof(Matrix4) || field.FieldType == typeof(Matrix4[]) ||  							field.FieldType == typeof(Texture2D))"  is complex.
Complex Conditional,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileFields,The conditional expression  "a.Type == VSInputTypes.IndexClassic || outputType == CompilerOutputs.D3D9 || outputType == CompilerOutputs.XNA || outputType == CompilerOutputs.Silverlight"  is complex.
Complex Conditional,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The conditional expression  "percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4))"  is complex.
Complex Conditional,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMethodBlock,The conditional expression  "(((VSInput)a[0]).Type == VSInputTypes.IndexClassic || outputType == CompilerOutputs.GL2 || outputType == CompilerOutputs.GLES2) && (field.FieldType == typeof(uint) || field.FieldType == typeof(int))"  is complex.
Complex Conditional,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,convertToRegexLine,The conditional expression  "c == '(' || c == ')' || c == '[' || c == ']' ||  					c == '*' || c == '+' || c == '.'"  is complex.
Magic Number,ShaderCompiler.Core,CodeFile,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\CodeFile.cs,IsFileOfShader,The following statement contains a magic number: if (match.Success && match.Groups.Count == 2)  			{  				// find shader class  				var namespaceBlock = match.Groups[1].Value;  				int end = getBlockEnd(namespaceBlock);  				namespaceBlock = namespaceBlock.Remove(end);  				match = Regex.Match(namespaceBlock' @"class\s*" + shader.Name + @".*?\{(.*\})"' RegexOptions.Singleline);  				if (match.Success && match.Groups.Count == 2) return true;  			}
Magic Number,ShaderCompiler.Core,CodeFile,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\CodeFile.cs,IsFileOfShader,The following statement contains a magic number: if (match.Success && match.Groups.Count == 2)  			{  				// find shader class  				var namespaceBlock = match.Groups[1].Value;  				int end = getBlockEnd(namespaceBlock);  				namespaceBlock = namespaceBlock.Remove(end);  				match = Regex.Match(namespaceBlock' @"class\s*" + shader.Name + @".*?\{(.*\})"' RegexOptions.Singleline);  				if (match.Success && match.Groups.Count == 2) return true;  			}
Magic Number,ShaderCompiler.Core,CodeFile,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\CodeFile.cs,FindMethodBlock,The following statement contains a magic number: if (match.Success && match.Groups.Count == 2)  			{  				// find shader class  				var namespaceBlock = match.Groups[1].Value;  				int end = getBlockEnd(namespaceBlock);  				namespaceBlock = namespaceBlock.Remove(end);  				match = Regex.Match(namespaceBlock' @"class\s*" + shader.Name + @".*?\{(.*\})"' RegexOptions.Singleline);  				if (match.Success && match.Groups.Count == 2)  				{  					// find method  					var classBlock = match.Groups[1].Value;  					end = getBlockEnd(classBlock);  					classBlock = classBlock.Remove(end);  					match = Regex.Match(classBlock' Compiler.convertToBasicType(method.ReturnType' outputType' false) + @"\s*" + method.Name + @".*?\{(.*\})"' RegexOptions.Singleline);  					if (match.Success && match.Groups.Count == 2)  					{  						var methodBlock = match.Groups[1].Value;  						end = getBlockEnd(methodBlock);  						methodBlock = methodBlock.Remove(end);  						return '{' + methodBlock + '}';  					}  				}  			}
Magic Number,ShaderCompiler.Core,CodeFile,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\CodeFile.cs,FindMethodBlock,The following statement contains a magic number: if (match.Success && match.Groups.Count == 2)  			{  				// find shader class  				var namespaceBlock = match.Groups[1].Value;  				int end = getBlockEnd(namespaceBlock);  				namespaceBlock = namespaceBlock.Remove(end);  				match = Regex.Match(namespaceBlock' @"class\s*" + shader.Name + @".*?\{(.*\})"' RegexOptions.Singleline);  				if (match.Success && match.Groups.Count == 2)  				{  					// find method  					var classBlock = match.Groups[1].Value;  					end = getBlockEnd(classBlock);  					classBlock = classBlock.Remove(end);  					match = Regex.Match(classBlock' Compiler.convertToBasicType(method.ReturnType' outputType' false) + @"\s*" + method.Name + @".*?\{(.*\})"' RegexOptions.Singleline);  					if (match.Success && match.Groups.Count == 2)  					{  						var methodBlock = match.Groups[1].Value;  						end = getBlockEnd(methodBlock);  						methodBlock = methodBlock.Remove(end);  						return '{' + methodBlock + '}';  					}  				}  			}
Magic Number,ShaderCompiler.Core,CodeFile,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\CodeFile.cs,FindMethodBlock,The following statement contains a magic number: if (match.Success && match.Groups.Count == 2)  			{  				// find shader class  				var namespaceBlock = match.Groups[1].Value;  				int end = getBlockEnd(namespaceBlock);  				namespaceBlock = namespaceBlock.Remove(end);  				match = Regex.Match(namespaceBlock' @"class\s*" + shader.Name + @".*?\{(.*\})"' RegexOptions.Singleline);  				if (match.Success && match.Groups.Count == 2)  				{  					// find method  					var classBlock = match.Groups[1].Value;  					end = getBlockEnd(classBlock);  					classBlock = classBlock.Remove(end);  					match = Regex.Match(classBlock' Compiler.convertToBasicType(method.ReturnType' outputType' false) + @"\s*" + method.Name + @".*?\{(.*\})"' RegexOptions.Singleline);  					if (match.Success && match.Groups.Count == 2)  					{  						var methodBlock = match.Groups[1].Value;  						end = getBlockEnd(methodBlock);  						methodBlock = methodBlock.Remove(end);  						return '{' + methodBlock + '}';  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileLibrary,The following statement contains a magic number: string name = names[names.Length-2];
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The following statement contains a magic number: foreach (var field in fields)  			{  				var attributes = field.GetCustomAttributes(true);  				foreach (var a in attributes)  				{  					if (a.GetType() == typeof(FieldUsage))  					{  						var usage = (FieldUsage)a;    						if (field.FieldType == typeof(double) ||  							field.FieldType == typeof(Vector2) || field.FieldType == typeof(Vector3) || field.FieldType == typeof(Vector4) ||  							field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4) ||  							field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||  							field.FieldType == typeof(Matrix2[]) || field.FieldType == typeof(Matrix3[]) || field.FieldType == typeof(Matrix4[]))  						{  							constantProperties += string.Format("public static ShaderVariableI {0}Constant {{get; private set;}}"' field.Name);  							constantInitBody += string.Format(@"{0}Constant = shader.Variable(""{0}"");"' field.Name);  						}  						else if (field.FieldType == typeof(Texture2D))  						{  							constantProperties += string.Format("public static ShaderResourceI {0}Constant {{get; private set;}}"' field.Name);  							constantInitBody += string.Format(@"{0}Constant = shader.Resource(""{0}"");"' field.Name);  						}  						else  						{  							throw new Exception("Unsuported field type.");  						}    						string globalFieldFormat = "[MaterialField(MaterialFieldUsages.{2})] public static {0} {1};";  						string fieldFormat = "[MaterialField(MaterialFieldUsages.{2})] public {0} {1};";  						string methodValue = "{0}Constant.Set({0});";  						if (field.FieldType == typeof(double))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "float"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						if (field.FieldType == typeof(Vector2))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector2"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Vector3))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector3"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Vector4))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector4"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix2))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix2"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix3))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix3"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix4))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix4"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Texture2D))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Texture2DI"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}    						globalFieldFormat = "private static WeakReference {2}; [MaterialField(MaterialFieldUsages.{3})] public static {0} {1} {{ get{{return ({0}){2}.Target;}} set{{{2} = new WeakReference(value);}} }}";  						fieldFormat = "private WeakReference {2}; [MaterialField(MaterialFieldUsages.{3})] public {0} {1} {{ get{{return ({0}){2}.Target;}} set{{{2} = new WeakReference(value);}} }}";  						if (field.FieldType == typeof(double[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "float[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						if (field.FieldType == typeof(Vector2[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector2[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Vector3[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector3[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Vector4[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector4[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix2[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix2[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix3[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix3[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix4[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix4[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  					}  					else if (a.GetType() == typeof(VSInput))  					{  						var input = (VSInput)a;  						  						string usage = null;  						int streamIndex = 0;  						switch (input.Type)  						{  							case (VSInputTypes.Position): usage = "BufferLayoutElementUsages.Position"; break;  							case (VSInputTypes.UV): usage = "BufferLayoutElementUsages.UV"; break;  							case (VSInputTypes.Color): usage = "BufferLayoutElementUsages.Color"; break;  							case (VSInputTypes.Normal): usage = "BufferLayoutElementUsages.Normal"; break;  							case (VSInputTypes.Index): usage = "BufferLayoutElementUsages.Index"; streamIndex = 1; break;  							case (VSInputTypes.IndexClassic): usage = "BufferLayoutElementUsages.IndexClassic"; break;  							default: throw new Exception("Unsuported material usage type.");  						}  						  						string type = null;  						int offset = 0;  						if (field.FieldType == typeof(double) || field.FieldType == typeof(uint)) {type = "BufferLayoutElementTypes.Float"; offset = 1;}  						else if (field.FieldType == typeof(Vector4) && input.Type == VSInputTypes.Color) {type = "BufferLayoutElementTypes.RGBAx8"; offset = 1;}  						else if (field.FieldType == typeof(Vector2)) {type = "BufferLayoutElementTypes.Vector2"; offset = 2;}  						else if (field.FieldType == typeof(Vector3)) {type = "BufferLayoutElementTypes.Vector3"; offset = 3;}  						else if (field.FieldType == typeof(Vector4)) {type = "BufferLayoutElementTypes.Vector4"; offset = 4;}  						else throw new Exception("Unsuported material element type.");    						elementsBody += string.Format("elements.Add(new BufferLayoutElement({0}' {1}' {2}' {3}' {4}));"' type' usage' streamIndex' input.Index' floatOffset);  						floatOffset += offset;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The following statement contains a magic number: foreach (var field in fields)  			{  				var attributes = field.GetCustomAttributes(true);  				foreach (var a in attributes)  				{  					if (a.GetType() == typeof(FieldUsage))  					{  						var usage = (FieldUsage)a;    						if (field.FieldType == typeof(double) ||  							field.FieldType == typeof(Vector2) || field.FieldType == typeof(Vector3) || field.FieldType == typeof(Vector4) ||  							field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4) ||  							field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||  							field.FieldType == typeof(Matrix2[]) || field.FieldType == typeof(Matrix3[]) || field.FieldType == typeof(Matrix4[]))  						{  							constantProperties += string.Format("public static ShaderVariableI {0}Constant {{get; private set;}}"' field.Name);  							constantInitBody += string.Format(@"{0}Constant = shader.Variable(""{0}"");"' field.Name);  						}  						else if (field.FieldType == typeof(Texture2D))  						{  							constantProperties += string.Format("public static ShaderResourceI {0}Constant {{get; private set;}}"' field.Name);  							constantInitBody += string.Format(@"{0}Constant = shader.Resource(""{0}"");"' field.Name);  						}  						else  						{  							throw new Exception("Unsuported field type.");  						}    						string globalFieldFormat = "[MaterialField(MaterialFieldUsages.{2})] public static {0} {1};";  						string fieldFormat = "[MaterialField(MaterialFieldUsages.{2})] public {0} {1};";  						string methodValue = "{0}Constant.Set({0});";  						if (field.FieldType == typeof(double))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "float"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						if (field.FieldType == typeof(Vector2))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector2"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Vector3))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector3"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Vector4))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector4"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix2))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix2"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix3))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix3"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix4))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix4"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Texture2D))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Texture2DI"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}    						globalFieldFormat = "private static WeakReference {2}; [MaterialField(MaterialFieldUsages.{3})] public static {0} {1} {{ get{{return ({0}){2}.Target;}} set{{{2} = new WeakReference(value);}} }}";  						fieldFormat = "private WeakReference {2}; [MaterialField(MaterialFieldUsages.{3})] public {0} {1} {{ get{{return ({0}){2}.Target;}} set{{{2} = new WeakReference(value);}} }}";  						if (field.FieldType == typeof(double[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "float[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						if (field.FieldType == typeof(Vector2[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector2[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Vector3[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector3[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Vector4[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector4[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix2[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix2[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix3[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix3[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix4[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix4[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  					}  					else if (a.GetType() == typeof(VSInput))  					{  						var input = (VSInput)a;  						  						string usage = null;  						int streamIndex = 0;  						switch (input.Type)  						{  							case (VSInputTypes.Position): usage = "BufferLayoutElementUsages.Position"; break;  							case (VSInputTypes.UV): usage = "BufferLayoutElementUsages.UV"; break;  							case (VSInputTypes.Color): usage = "BufferLayoutElementUsages.Color"; break;  							case (VSInputTypes.Normal): usage = "BufferLayoutElementUsages.Normal"; break;  							case (VSInputTypes.Index): usage = "BufferLayoutElementUsages.Index"; streamIndex = 1; break;  							case (VSInputTypes.IndexClassic): usage = "BufferLayoutElementUsages.IndexClassic"; break;  							default: throw new Exception("Unsuported material usage type.");  						}  						  						string type = null;  						int offset = 0;  						if (field.FieldType == typeof(double) || field.FieldType == typeof(uint)) {type = "BufferLayoutElementTypes.Float"; offset = 1;}  						else if (field.FieldType == typeof(Vector4) && input.Type == VSInputTypes.Color) {type = "BufferLayoutElementTypes.RGBAx8"; offset = 1;}  						else if (field.FieldType == typeof(Vector2)) {type = "BufferLayoutElementTypes.Vector2"; offset = 2;}  						else if (field.FieldType == typeof(Vector3)) {type = "BufferLayoutElementTypes.Vector3"; offset = 3;}  						else if (field.FieldType == typeof(Vector4)) {type = "BufferLayoutElementTypes.Vector4"; offset = 4;}  						else throw new Exception("Unsuported material element type.");    						elementsBody += string.Format("elements.Add(new BufferLayoutElement({0}' {1}' {2}' {3}' {4}));"' type' usage' streamIndex' input.Index' floatOffset);  						floatOffset += offset;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMaterialFiles,The following statement contains a magic number: foreach (var field in fields)  			{  				var attributes = field.GetCustomAttributes(true);  				foreach (var a in attributes)  				{  					if (a.GetType() == typeof(FieldUsage))  					{  						var usage = (FieldUsage)a;    						if (field.FieldType == typeof(double) ||  							field.FieldType == typeof(Vector2) || field.FieldType == typeof(Vector3) || field.FieldType == typeof(Vector4) ||  							field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4) ||  							field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||  							field.FieldType == typeof(Matrix2[]) || field.FieldType == typeof(Matrix3[]) || field.FieldType == typeof(Matrix4[]))  						{  							constantProperties += string.Format("public static ShaderVariableI {0}Constant {{get; private set;}}"' field.Name);  							constantInitBody += string.Format(@"{0}Constant = shader.Variable(""{0}"");"' field.Name);  						}  						else if (field.FieldType == typeof(Texture2D))  						{  							constantProperties += string.Format("public static ShaderResourceI {0}Constant {{get; private set;}}"' field.Name);  							constantInitBody += string.Format(@"{0}Constant = shader.Resource(""{0}"");"' field.Name);  						}  						else  						{  							throw new Exception("Unsuported field type.");  						}    						string globalFieldFormat = "[MaterialField(MaterialFieldUsages.{2})] public static {0} {1};";  						string fieldFormat = "[MaterialField(MaterialFieldUsages.{2})] public {0} {1};";  						string methodValue = "{0}Constant.Set({0});";  						if (field.FieldType == typeof(double))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "float"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						if (field.FieldType == typeof(Vector2))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector2"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Vector3))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector3"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Vector4))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector4"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix2))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix2"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix3))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix3"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix4))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix4"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Texture2D))  						{  							createConstantType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Texture2DI"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}    						globalFieldFormat = "private static WeakReference {2}; [MaterialField(MaterialFieldUsages.{3})] public static {0} {1} {{ get{{return ({0}){2}.Target;}} set{{{2} = new WeakReference(value);}} }}";  						fieldFormat = "private WeakReference {2}; [MaterialField(MaterialFieldUsages.{3})] public {0} {1} {{ get{{return ({0}){2}.Target;}} set{{{2} = new WeakReference(value);}} }}";  						if (field.FieldType == typeof(double[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "float[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						if (field.FieldType == typeof(Vector2[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector2[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Vector3[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector3[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Vector4[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Vector4[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix2[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix2[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix3[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix3[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  						else if (field.FieldType == typeof(Matrix4[]))  						{  							createConstantArrayType(usage' field' methodValue' globalFieldFormat' fieldFormat' "Matrix4[]"' ref constantTypeProperties' ref applyGlobalMethodBody' ref applyInstanceMethodBody' ref applyInstancingMethodBody);  						}  					}  					else if (a.GetType() == typeof(VSInput))  					{  						var input = (VSInput)a;  						  						string usage = null;  						int streamIndex = 0;  						switch (input.Type)  						{  							case (VSInputTypes.Position): usage = "BufferLayoutElementUsages.Position"; break;  							case (VSInputTypes.UV): usage = "BufferLayoutElementUsages.UV"; break;  							case (VSInputTypes.Color): usage = "BufferLayoutElementUsages.Color"; break;  							case (VSInputTypes.Normal): usage = "BufferLayoutElementUsages.Normal"; break;  							case (VSInputTypes.Index): usage = "BufferLayoutElementUsages.Index"; streamIndex = 1; break;  							case (VSInputTypes.IndexClassic): usage = "BufferLayoutElementUsages.IndexClassic"; break;  							default: throw new Exception("Unsuported material usage type.");  						}  						  						string type = null;  						int offset = 0;  						if (field.FieldType == typeof(double) || field.FieldType == typeof(uint)) {type = "BufferLayoutElementTypes.Float"; offset = 1;}  						else if (field.FieldType == typeof(Vector4) && input.Type == VSInputTypes.Color) {type = "BufferLayoutElementTypes.RGBAx8"; offset = 1;}  						else if (field.FieldType == typeof(Vector2)) {type = "BufferLayoutElementTypes.Vector2"; offset = 2;}  						else if (field.FieldType == typeof(Vector3)) {type = "BufferLayoutElementTypes.Vector3"; offset = 3;}  						else if (field.FieldType == typeof(Vector4)) {type = "BufferLayoutElementTypes.Vector4"; offset = 4;}  						else throw new Exception("Unsuported material element type.");    						elementsBody += string.Format("elements.Add(new BufferLayoutElement({0}' {1}' {2}' {3}' {4}));"' type' usage' streamIndex' input.Index' floatOffset);  						floatOffset += offset;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileFields,The following statement contains a magic number: foreach (var field in fields)  			{  				bool isField = false' isVSField = false' isPSField = false' isVSIn = false' isVSOutPSIn = false' isPSOut = false;  				var attributes = field.GetCustomAttributes(true);  				if (attributes.Length == 0) throw new Exception("All fields must have an attribute.");  				foreach (var a in attributes)  				{  					var t = a.GetType();  					if (t == typeof(ArrayType)) isField = true;  					if (t == typeof(FieldUsage))  					{  						if (!(field.FieldType == typeof(double) ||  							field.FieldType == typeof(Vector2) || field.FieldType == typeof(Vector3) || field.FieldType == typeof(Vector4) ||  							field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||  							field.FieldType == typeof(Matrix4) || field.FieldType == typeof(Matrix4[]) ||  							field.FieldType == typeof(Texture2D)))  						{  							throw new Exception("Field types must be either of a Vector4' Matrix4 or Texture");  						}    						isField = true;  						var aValue = (FieldUsage)a;  						if (aValue.Type == FieldUsageTypes.VS)  						{  							isVSField = true;  						}  						else if (aValue.Type == FieldUsageTypes.VS_PS)  						{  							isVSField = true;  							isPSField = true;  						}  						else if (aValue.Type == FieldUsageTypes.PS)  						{  							isPSField = true;  						}  					}  					if (t == typeof(VSInput)) isVSIn = true;  					if (t == typeof(VSOutputPSInput)) isVSOutPSIn = true;  					if (t == typeof(PSOutput)) isPSOut = true;  				}    				if (isField)  				{  					if (isVSField && isPSField) normalGlobalFields.Add(field);  					else if (isVSField) normalVSFields.Add(field);  					else if (isPSField) normalPSFields.Add(field);  				}  				else  				{  					if (attributes.Length >= 2)  					{  						throw new Exception("VS and PS In/Out Fields can only have one shader attribute.");  					}    					if (isVSIn)  					{  						vsInFields.Add(field);  					}  					else if (isVSOutPSIn)  					{  						vsInPSOutFields.Add(field);  					}  					else if (isPSOut)  					{  						psOutFields.Add(field);  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,writeReflectionFile,The following statement contains a magic number: foreach (var field in normalFields)  			{  				if (field.FieldType == typeof(Texture2D))  				{  					reflectionStream.WriteLine(string.Format("{2}Res {0} {1}"' field.Name' resourceIndex' label));  					++resourceIndex;  				}  				else  				{  					var a = field.GetCustomAttributes(typeof(ArrayType)' true);  					var arrayType = (a != null && a.Length != 0) ? (ArrayType)a[0] : null;    					if (outputType == CompilerOutputs.Silverlight)  					{  						int registerSize = getRegisterySize(field);  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' registerIndex' registerSize' label));  						registerIndex += registerSize;  					}  					else if (outputType == CompilerOutputs.D3D11)  					{  						bool isArrayType = false;  						if (field.FieldType == typeof(double[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector3[]))  						{  							isArrayType = true;;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Vector4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix2[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 2 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix3[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 3 * arrayType.Length;  						}  						  						if (field.FieldType == typeof(Matrix4[]))  						{  							isArrayType = true;  							fieldSize = sizeof(float) * 4 * 4 * arrayType.Length;  						}  						  						if (isArrayType && (a == null || a.Length != 1)) throw new Exception("Arrays must have ArrayType attribute.");  					  						if (field.FieldType == typeof(double)) fieldSize = sizeof(float);  						if (field.FieldType == typeof(Vector2)) fieldSize = sizeof(float) * 2;  						if (field.FieldType == typeof(Vector3)) fieldSize = sizeof(float) * 3;  						if (field.FieldType == typeof(Vector4)) fieldSize = sizeof(float) * 4;  						if (field.FieldType == typeof(Matrix2)) fieldSize = sizeof(float) * 4 * 2;  						if (field.FieldType == typeof(Matrix3)) fieldSize = sizeof(float) * 4 * 3;  						if (field.FieldType == typeof(Matrix4)) fieldSize = sizeof(float) * 4 * 4;  						  						int percent = variableByteOffset % 16;  						int percentOffset = 16 - percent;  						if (field.FieldType == typeof(Vector2) && percent > 8) variableByteOffset += percentOffset;  						if (percent != 0 &&  						 (field.FieldType == typeof(double[]) || field.FieldType == typeof(Vector2[]) || field.FieldType == typeof(Vector3[]) || field.FieldType == typeof(Vector4[]) ||   						 field.FieldType == typeof(Vector4) || field.FieldType == typeof(Matrix2) || field.FieldType == typeof(Matrix3) || field.FieldType == typeof(Matrix4)))  						{  							variableByteOffset += percentOffset;  						}  						  						reflectionStream.WriteLine(string.Format("{3}Var {0} {1} {2}"' field.Name' variableByteOffset' fieldSize' label));  						variableByteOffset += fieldSize;  					}  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,getRegisterySize,The following statement contains a magic number: if (type == typeof(Matrix2)) return 2;
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,getRegisterySize,The following statement contains a magic number: if (type == typeof(Matrix3)) return 3;
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,getRegisterySize,The following statement contains a magic number: if (type == typeof(Matrix4)) return 4;
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,getRegisterySize,The following statement contains a magic number: if (type == typeof(Matrix2[])) arrayLength = arrayType.Length * 2;
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,getRegisterySize,The following statement contains a magic number: if (type == typeof(Matrix3[])) arrayLength = arrayType.Length * 3;
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,getRegisterySize,The following statement contains a magic number: if (type == typeof(Matrix4[])) arrayLength = arrayType.Length * 4;
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,compileMethodBlock,The following statement contains a magic number: if (baseType == BaseCompilerOutputs.GLSL)  			{  				string regStart = @"\s*=\s*new\s*";  				string regEnd = @"\s*\(\s*\)\s*;";  				var findTypes = new string[]  				{  					"Vector2"' "(0' 0);"'  					"Vector3"' "(0' 0' 0);"'  					"Vector4"' "(0' 0' 0' 0);"'  					"Matrix2"' "(0);"'  					"Matrix3"' "(0);"'  					"Matrix4"' "(0);"'  				};  				  				for (int i = 0; i != findTypes.Length; i += 2)  				{  					string find = regStart + findTypes[i] + regEnd;  					var match = Regex.Match(methodBlock' find);  					methodBlock = Regex.Replace(methodBlock' find' " = " + findTypes[i] + findTypes[i+1]);  				}  			}  			else  			{  				methodBlock = Regex.Replace(methodBlock' @"\s*=\s*new.*\(\s*\)\s*;"' " = 0;");  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,replaceMatrixMultiplyTypes,The following statement contains a magic number: if (match.Success && matrixGroups.Count == 2)  			{  				// Find vector parameter  				var line = removeAfterClosingBracket(matrixGroups[0].Value' '('' ')');  				match = Regex.Match(line' @"\((.*)\)"' RegexOptions.Singleline);    				// Replace matrix multiply block  				var vectorGroups = match.Groups;  				if (match.Success && vectorGroups.Count == 2)  				{  					string matrixName = matrixGroups[1].Value;  					string vectorName = vectorGroups[1].Value;  					string formatString = invert ? "mul({1}' {0})" : "mul({0}' {1})";  					if (outputType == CompilerOutputs.D3D9 || outputType == CompilerOutputs.XNA)  					{  						formatString = invert ? "mul({0}' {1})" : "mul({1}' {0})";  					}  					else if (baseType == BaseCompilerOutputs.GLSL)  					{  						formatString = invert ? @"({1} * {0})" : @"({0} * {1})";  					}  					string replace = string.Format(formatString' vectorName' matrixName);  					matrixName = matrixName.Replace("["' @"\[");  					matrixName = matrixName.Replace("]"' @"\]");  					methodBlock = Regex.Replace(methodBlock' convertToRegexLine(line)' replace' RegexOptions.Singleline);    					return true;  				}  			}
Magic Number,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,replaceMatrixMultiplyTypes,The following statement contains a magic number: if (match.Success && matrixGroups.Count == 2)  			{  				// Find vector parameter  				var line = removeAfterClosingBracket(matrixGroups[0].Value' '('' ')');  				match = Regex.Match(line' @"\((.*)\)"' RegexOptions.Singleline);    				// Replace matrix multiply block  				var vectorGroups = match.Groups;  				if (match.Success && vectorGroups.Count == 2)  				{  					string matrixName = matrixGroups[1].Value;  					string vectorName = vectorGroups[1].Value;  					string formatString = invert ? "mul({1}' {0})" : "mul({0}' {1})";  					if (outputType == CompilerOutputs.D3D9 || outputType == CompilerOutputs.XNA)  					{  						formatString = invert ? "mul({0}' {1})" : "mul({1}' {0})";  					}  					else if (baseType == BaseCompilerOutputs.GLSL)  					{  						formatString = invert ? @"({1} * {0})" : @"({0} * {1})";  					}  					string replace = string.Format(formatString' vectorName' matrixName);  					matrixName = matrixName.Replace("["' @"\[");  					matrixName = matrixName.Replace("]"' @"\]");  					methodBlock = Regex.Replace(methodBlock' convertToRegexLine(line)' replace' RegexOptions.Singleline);    					return true;  				}  			}
Missing Default,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,getGLVSInputFieldName,The following switch statement is missing a default case: switch (a.Type)  			{  				case (VSInputTypes.Position):  					fieldName = "Position" + a.Index.ToString();  					break;    				case (VSInputTypes.Color):  					fieldName = "Color" + a.Index.ToString();  					break;    				case (VSInputTypes.UV):  					fieldName = "Texcoord" + a.Index.ToString();  					break;    				case (VSInputTypes.Normal):  					fieldName = "Normal" + a.Index.ToString();  					break;    				case (VSInputTypes.Index):  					if (outputType == CompilerOutputs.GL2) fieldName = "BlendIndex" + a.Index.ToString();  					else fieldName = "gl_InstanceID";  					break;    				case (VSInputTypes.IndexClassic):  					fieldName = "BlendIndex" + a.Index.ToString();  					break;  			}
Missing Default,ShaderCompiler.Core,Compiler,C:\repos\reignstudios_ReignSDK\Tools\ShaderCompiler\ShaderCompiler.Core\Compiler.cs,getMethodType,The following switch statement is missing a default case: switch (attribute.Type)  				{  				    case (ShaderMethodTypes.VS): return MethodTypes.VS;  				    case (ShaderMethodTypes.PS): return MethodTypes.PS;  				}
