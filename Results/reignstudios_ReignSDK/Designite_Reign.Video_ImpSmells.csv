Implementation smell,Namespace,Class,File,Method,Description
Long Method,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The method has 153 lines of code.
Long Method,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The method has 126 lines of code.
Complex Method,Reign.Video,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Font.cs,draw,Cyclomatic complexity of the method is 8
Complex Method,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,Cyclomatic complexity of the method is 8
Long Parameter List,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,Camera,The method has 7 parameters. Parameters: viewPort' position' lookAtPosition' upPosition' near' far' fov
Long Parameter List,Reign.Video,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Font.cs,Font,The method has 5 parameters. Parameters: parent' shader' texture' metricsFileName' loadedCallback
Long Parameter List,Reign.Video,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Font.cs,init,The method has 5 parameters. Parameters: shader' texture' stream' metricsFileName' loadedCallback
Long Parameter List,Reign.Video,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Font.cs,Draw,The method has 6 parameters. Parameters: text' position' color' size' centeredX' centeredY
Long Parameter List,Reign.Video,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Font.cs,draw,The method has 7 parameters. Parameters: text' textureSize' position' color' size' centeredX' centeredY
Long Parameter List,Reign.Video,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Font.cs,drawCharacter,The method has 5 parameters. Parameters: position' size' positionUV' sizeUV' color
Long Parameter List,Reign.Video,BufferLayoutElement,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,BufferLayoutElement,The method has 5 parameters. Parameters: type' usage' streamIndex' usageIndex' floatOffset
Long Parameter List,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,Save,The method has 6 parameters. Parameters: inData' width' height' outStream' imageFormat' imageSavedCallback
Long Parameter List,Reign.Video,Mipmap,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,Mipmap,The method has 5 parameters. Parameters: dataSize' width' height' blockDev' channels
Long Parameter List,Reign.Video,Mipmap,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,Mipmap,The method has 5 parameters. Parameters: data' width' height' blockDev' channels
Long Parameter List,Reign.Video,ImageBMPC,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageBMPC.cs,Save,The method has 5 parameters. Parameters: data' width' height' outStream' imageSavedCallback
Long Parameter List,Reign.Video,ImagePNG,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePNG.cs,Save,The method has 5 parameters. Parameters: inData' width' height' outStream' imageSavedCallback
Long Identifier,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,,The length of the parameter GL_COMPRESSED_RGBA_S3TC_DXT1_EXT is 32.
Long Identifier,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,,The length of the parameter GL_COMPRESSED_RGBA_S3TC_DXT3_EXT is 32.
Long Identifier,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,,The length of the parameter GL_COMPRESSED_RGBA_S3TC_DXT5_EXT is 32.
Long Identifier,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,,The length of the parameter ATC_RGBA_INTERPOLATED_ALPHA_AMD is 31.
Long Identifier,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,,The length of the parameter GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG is 34.
Long Identifier,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,,The length of the parameter GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG is 34.
Long Identifier,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,,The length of the parameter GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG is 35.
Long Identifier,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,,The length of the parameter GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG is 35.
Long Statement,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,Project,The length of the statement  "			return pos.Project(ProjectionMatrix' ViewMatrix' ViewPort.Position.X' ViewPort.Position.Y' ViewPort.Size.Width' ViewPort.Size.Height).ToVector2(); " is 146.
Long Statement,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,Project,The length of the statement  "			return position.Project(ProjectionMatrix' ViewMatrix' ViewPort.Position.X' ViewPort.Position.Y' ViewPort.Size.Width' ViewPort.Size.Height); " is 139.
Long Statement,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,UnProjectNormalized,The length of the statement  "			var near = pos.UnProject(TransformInverseMatrix' ViewPort.Position.X' ViewPort.Position.Y' ViewPort.Size.Width' ViewPort.Size.Height); " is 134.
Long Statement,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,UnProjectNormalized,The length of the statement  "			var far = pos.UnProject(TransformInverseMatrix' ViewPort.Position.X' ViewPort.Position.Y' ViewPort.Size.Width' ViewPort.Size.Height); " is 133.
Long Statement,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,UnProject,The length of the statement  "			return pos.UnProject(TransformInverseMatrix' ViewPort.Position.X' ViewPort.Position.Y' ViewPort.Size.Width' ViewPort.Size.Height); " is 130.
Long Statement,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,UnProject,The length of the statement  "			return screenPosition.UnProject(TransformInverseMatrix' ViewPort.Position.X' ViewPort.Position.Y' ViewPort.Size.Width' ViewPort.Size.Height); " is 141.
Long Statement,Reign.Video,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Font.cs,init,The length of the statement  "					Characters[i] = new Character(character.Key' new Vector2(character.X' character.Y)' new Vector2(character.Width' character.Height)); " is 132.
Long Statement,Reign.Video,IQuickDraw,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\QuickDraw.cs,Color,The length of the statement  "			vertex[colorOffset[0]] = System.BitConverter.ToSingle(new byte[]{(byte)(r*255.0f)' (byte)(g*255.0f)' (byte)(b*255.0f)' (byte)(a*255.0f)}' 0); " is 141.
Long Statement,Reign.Video,ImageIOS,C:\repos\reignstudios_ReignSDK\Platforms\iOS\Reign.Video\Image\ImageIOS.cs,init,The length of the statement  "					using (CGContext imageContext = new CGBitmapContext(data' width' height' 8' width*4' CGColorSpace.CreateDeviceRGB()' CGImageAlphaInfo.PremultipliedLast)) " is 153.
Complex Conditional,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The conditional expression  "flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5)"  is complex.
Magic Number,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,Camera,The following statement contains a magic number: Position = new Vector3(10' 10' 10);
Magic Number,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,Camera,The following statement contains a magic number: Position = new Vector3(10' 10' 10);
Magic Number,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,Camera,The following statement contains a magic number: Position = new Vector3(10' 10' 10);
Magic Number,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,Camera,The following statement contains a magic number: UpPosition = new Vector3(10' 11' 10);
Magic Number,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,Camera,The following statement contains a magic number: UpPosition = new Vector3(10' 11' 10);
Magic Number,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,Camera,The following statement contains a magic number: UpPosition = new Vector3(10' 11' 10);
Magic Number,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,Camera,The following statement contains a magic number: Far = 500;
Magic Number,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,Camera,The following statement contains a magic number: Fov = MathUtilities.DegToRad(45);
Magic Number,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,Camera,The following statement contains a magic number: Far = 500;
Magic Number,Reign.Video,Camera,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Camera.cs,Camera,The following statement contains a magic number: Fov = MathUtilities.DegToRad(45);
Magic Number,Reign.Video,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Font.cs,init,The following statement contains a magic number: try  			{  				// load characters  				var metrics = new FontMetrics();  				metrics.Load(stream);    				Characters = new Character[metrics.Characters.Length];  				for (int i = 0; i != metrics.Characters.Length; ++i)  				{  					var character = metrics.Characters[i];  					Characters[i] = new Character(character.Key' new Vector2(character.X' character.Y)' new Vector2(character.Width' character.Height));  				}    				// get shader variables  				this.texture = texture;  				this.shader = shader;  				shaderCamera = shader.Variable("Camera");  				shaderPosition = shader.Variable("Position");  				shaderSize = shader.Variable("Size");  				shaderPositionUV = shader.Variable("PositionUV");  				shaderSizeUV = shader.Variable("SizeUV");  				texelOffset = shader.Variable("TexelOffset");  				shaderColor = shader.Variable("Color");  				shaderTexture = shader.Resource("DiffuseTexture");    				// create buffers  				var layoutDesc = BufferLayoutDescAPI.New(BufferLayoutTypes.Position2);  				layout = BufferLayoutAPI.New(this' shader' layoutDesc);    				var Indices = new int[6]  				{  					0' 1' 2'  					0' 2' 3  				};    				var Vertices = new float[8]  				{  					0' 0'  					0' 1'  					1' 1'  					1' 0'  				};    				indexBuffer = IndexBufferAPI.New(this' BufferUsages.Default' Indices);  				vertexBuffer = VertexBufferAPI.New(this' layoutDesc' BufferUsages.Default' VertexBufferTopologys.Triangle' Vertices);  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				Dispose();  				if (loadedCallback != null) loadedCallback(this' false);  			}
Magic Number,Reign.Video,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Font.cs,init,The following statement contains a magic number: try  			{  				// load characters  				var metrics = new FontMetrics();  				metrics.Load(stream);    				Characters = new Character[metrics.Characters.Length];  				for (int i = 0; i != metrics.Characters.Length; ++i)  				{  					var character = metrics.Characters[i];  					Characters[i] = new Character(character.Key' new Vector2(character.X' character.Y)' new Vector2(character.Width' character.Height));  				}    				// get shader variables  				this.texture = texture;  				this.shader = shader;  				shaderCamera = shader.Variable("Camera");  				shaderPosition = shader.Variable("Position");  				shaderSize = shader.Variable("Size");  				shaderPositionUV = shader.Variable("PositionUV");  				shaderSizeUV = shader.Variable("SizeUV");  				texelOffset = shader.Variable("TexelOffset");  				shaderColor = shader.Variable("Color");  				shaderTexture = shader.Resource("DiffuseTexture");    				// create buffers  				var layoutDesc = BufferLayoutDescAPI.New(BufferLayoutTypes.Position2);  				layout = BufferLayoutAPI.New(this' shader' layoutDesc);    				var Indices = new int[6]  				{  					0' 1' 2'  					0' 2' 3  				};    				var Vertices = new float[8]  				{  					0' 0'  					0' 1'  					1' 1'  					1' 0'  				};    				indexBuffer = IndexBufferAPI.New(this' BufferUsages.Default' Indices);  				vertexBuffer = VertexBufferAPI.New(this' layoutDesc' BufferUsages.Default' VertexBufferTopologys.Triangle' Vertices);  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				Dispose();  				if (loadedCallback != null) loadedCallback(this' false);  			}
Magic Number,Reign.Video,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Font.cs,init,The following statement contains a magic number: try  			{  				// load characters  				var metrics = new FontMetrics();  				metrics.Load(stream);    				Characters = new Character[metrics.Characters.Length];  				for (int i = 0; i != metrics.Characters.Length; ++i)  				{  					var character = metrics.Characters[i];  					Characters[i] = new Character(character.Key' new Vector2(character.X' character.Y)' new Vector2(character.Width' character.Height));  				}    				// get shader variables  				this.texture = texture;  				this.shader = shader;  				shaderCamera = shader.Variable("Camera");  				shaderPosition = shader.Variable("Position");  				shaderSize = shader.Variable("Size");  				shaderPositionUV = shader.Variable("PositionUV");  				shaderSizeUV = shader.Variable("SizeUV");  				texelOffset = shader.Variable("TexelOffset");  				shaderColor = shader.Variable("Color");  				shaderTexture = shader.Resource("DiffuseTexture");    				// create buffers  				var layoutDesc = BufferLayoutDescAPI.New(BufferLayoutTypes.Position2);  				layout = BufferLayoutAPI.New(this' shader' layoutDesc);    				var Indices = new int[6]  				{  					0' 1' 2'  					0' 2' 3  				};    				var Vertices = new float[8]  				{  					0' 0'  					0' 1'  					1' 1'  					1' 0'  				};    				indexBuffer = IndexBufferAPI.New(this' BufferUsages.Default' Indices);  				vertexBuffer = VertexBufferAPI.New(this' layoutDesc' BufferUsages.Default' VertexBufferTopologys.Triangle' Vertices);  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				Dispose();  				if (loadedCallback != null) loadedCallback(this' false);  			}
Magic Number,Reign.Video,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Font.cs,init,The following statement contains a magic number: try  			{  				// load characters  				var metrics = new FontMetrics();  				metrics.Load(stream);    				Characters = new Character[metrics.Characters.Length];  				for (int i = 0; i != metrics.Characters.Length; ++i)  				{  					var character = metrics.Characters[i];  					Characters[i] = new Character(character.Key' new Vector2(character.X' character.Y)' new Vector2(character.Width' character.Height));  				}    				// get shader variables  				this.texture = texture;  				this.shader = shader;  				shaderCamera = shader.Variable("Camera");  				shaderPosition = shader.Variable("Position");  				shaderSize = shader.Variable("Size");  				shaderPositionUV = shader.Variable("PositionUV");  				shaderSizeUV = shader.Variable("SizeUV");  				texelOffset = shader.Variable("TexelOffset");  				shaderColor = shader.Variable("Color");  				shaderTexture = shader.Resource("DiffuseTexture");    				// create buffers  				var layoutDesc = BufferLayoutDescAPI.New(BufferLayoutTypes.Position2);  				layout = BufferLayoutAPI.New(this' shader' layoutDesc);    				var Indices = new int[6]  				{  					0' 1' 2'  					0' 2' 3  				};    				var Vertices = new float[8]  				{  					0' 0'  					0' 1'  					1' 1'  					1' 0'  				};    				indexBuffer = IndexBufferAPI.New(this' BufferUsages.Default' Indices);  				vertexBuffer = VertexBufferAPI.New(this' layoutDesc' BufferUsages.Default' VertexBufferTopologys.Triangle' Vertices);  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				Dispose();  				if (loadedCallback != null) loadedCallback(this' false);  			}
Magic Number,Reign.Video,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Font.cs,init,The following statement contains a magic number: try  			{  				// load characters  				var metrics = new FontMetrics();  				metrics.Load(stream);    				Characters = new Character[metrics.Characters.Length];  				for (int i = 0; i != metrics.Characters.Length; ++i)  				{  					var character = metrics.Characters[i];  					Characters[i] = new Character(character.Key' new Vector2(character.X' character.Y)' new Vector2(character.Width' character.Height));  				}    				// get shader variables  				this.texture = texture;  				this.shader = shader;  				shaderCamera = shader.Variable("Camera");  				shaderPosition = shader.Variable("Position");  				shaderSize = shader.Variable("Size");  				shaderPositionUV = shader.Variable("PositionUV");  				shaderSizeUV = shader.Variable("SizeUV");  				texelOffset = shader.Variable("TexelOffset");  				shaderColor = shader.Variable("Color");  				shaderTexture = shader.Resource("DiffuseTexture");    				// create buffers  				var layoutDesc = BufferLayoutDescAPI.New(BufferLayoutTypes.Position2);  				layout = BufferLayoutAPI.New(this' shader' layoutDesc);    				var Indices = new int[6]  				{  					0' 1' 2'  					0' 2' 3  				};    				var Vertices = new float[8]  				{  					0' 0'  					0' 1'  					1' 1'  					1' 0'  				};    				indexBuffer = IndexBufferAPI.New(this' BufferUsages.Default' Indices);  				vertexBuffer = VertexBufferAPI.New(this' layoutDesc' BufferUsages.Default' VertexBufferTopologys.Triangle' Vertices);  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				Dispose();  				if (loadedCallback != null) loadedCallback(this' false);  			}
Magic Number,Reign.Video,Font,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Font.cs,CharacterIndex,The following statement contains a magic number: int i = ((int)@char) - 32;
Magic Number,Reign.Video,IQuickDraw,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\QuickDraw.cs,IQuickDraw,The following statement contains a magic number: init(bufferLayoutDesc' 128*2);
Magic Number,Reign.Video,IQuickDraw,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\QuickDraw.cs,IQuickDraw,The following statement contains a magic number: init(bufferLayoutDesc' 128*2);
Magic Number,Reign.Video,IQuickDraw,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\QuickDraw.cs,StartTriangles,The following statement contains a magic number: primitiveVertexCount = 3;
Magic Number,Reign.Video,IQuickDraw,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\QuickDraw.cs,StartLines,The following statement contains a magic number: primitiveVertexCount = 2;
Magic Number,Reign.Video,IQuickDraw,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\QuickDraw.cs,Pos,The following statement contains a magic number: if (positionTypes[0] != BufferLayoutElementTypes.Vector2) vertex[offset+2] = z;
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following statement contains a magic number: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Magic Number,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,finish,The following statement contains a magic number: StreamBytesSizes = new int[2];
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Image,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculatePixelByteSize,The following statement contains a magic number: switch (surfaceFormat)  			{  				case SurfaceFormats.RGBx565: return width * height * 2;  				case SurfaceFormats.RGBAx4: return width * height * 2;  				case SurfaceFormats.RGBx5_Ax1: return width * height * 2;  				case SurfaceFormats.RGBAx8: return width * height * 4;  				case SurfaceFormats.RGBx10_Ax2: return width * height * 4;  				case SurfaceFormats.RGBAx16f: return (width * height * 4) * 2;  				case SurfaceFormats.RGBAx32f: return (width * height * 4) * 4;  				case SurfaceFormats.DXT1: return (width * height) / 2;  				case SurfaceFormats.DXT3: return width * height;  				case SurfaceFormats.DXT5: return width * height;  				case SurfaceFormats.ATC_RGB: return (width * height) / 2;  				case SurfaceFormats.ATC_RGBA_Explicit: return width * height;  				case SurfaceFormats.ATC_RGBA_Interpolated: return width * height;  				case SurfaceFormats.PVR_RGB_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGB_4: return (width * height) / 2;  				case SurfaceFormats.PVR_RGBA_2: return (width * height) / 4;  				case SurfaceFormats.PVR_RGBA_4: return (width * height) / 2;  				default: Debug.ThrowError("Image"' string.Format("Unsuported surface format: {0}"' surfaceFormat)); break;  			}
Magic Number,Reign.Video,Mipmap,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,FlipVertical,The following statement contains a magic number: int loopH = Size.Height / 2' loopW = Size.Width * 4;
Magic Number,Reign.Video,Mipmap,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,FlipVertical,The following statement contains a magic number: int loopH = Size.Height / 2' loopW = Size.Width * 4;
Magic Number,Reign.Video,Mipmap,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,SwapRBColorChannels,The following statement contains a magic number: for (int i = 0; i != data.Length; i += 4)  				{  					data[i] = Data[i+2];  					data[i+1] = Data[i+1];  					data[i+2] = Data[i];  					data[i+3] = Data[i+3];  				}
Magic Number,Reign.Video,Mipmap,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,SwapRBColorChannels,The following statement contains a magic number: for (int i = 0; i != data.Length; i += 4)  				{  					data[i] = Data[i+2];  					data[i+1] = Data[i+1];  					data[i+2] = Data[i];  					data[i+3] = Data[i+3];  				}
Magic Number,Reign.Video,Mipmap,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,SwapRBColorChannels,The following statement contains a magic number: for (int i = 0; i != data.Length; i += 4)  				{  					data[i] = Data[i+2];  					data[i+1] = Data[i+1];  					data[i+2] = Data[i];  					data[i+3] = Data[i+3];  				}
Magic Number,Reign.Video,Mipmap,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,SwapRBColorChannels,The following statement contains a magic number: for (int i = 0; i != data.Length; i += 4)  				{  					data[i] = Data[i+2];  					data[i+1] = Data[i+1];  					data[i+2] = Data[i];  					data[i+3] = Data[i+3];  				}
Magic Number,Reign.Video,Mipmap,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,SwapRBColorChannels,The following statement contains a magic number: for (int i = 0; i != data.Length; i += 4)  				{  					data[i] = Data[i+2];  					data[i+1] = Data[i+1];  					data[i+2] = Data[i];  					data[i+3] = Data[i+3];  				}
Magic Number,Reign.Video,Mipmap,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\Image.cs,CalculateMipmapLvls,The following statement contains a magic number: return (int)System.Math.Log(width > height ? width : height' 2) + 1;
Magic Number,Reign.Video,ImageBMPC,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageBMPC.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.BMPC;  				ImageFormat = ImageFormats.BMPC;  				SurfaceFormat = SurfaceFormats.RGBAx8;    				using (var reader = new BinaryReader(stream))  				{  					// File Type  					int type = reader.ReadInt32();  					if (type != Streams.MakeFourCC('b'' 'm'' 'p'' 'c')) throw new Exception("Not a .bmpc file");    					// Version  					float version = reader.ReadSingle();  					if (version != 1.0f) throw new Exception("Unsuported .bmpc version");    					// Meta Data  					Size = new Size2(reader.ReadInt32()' reader.ReadInt32());  					bool zipCompressed = reader.ReadBoolean();    					// Data  					using (var decompressedDataStream = new MemoryStream())  					{  						int dataLength = reader.ReadInt32();  						int dataRead = 0;  						do  						{  							int read = 1024;  							if ((dataRead + read) > dataLength) read -= (int)((dataRead + read) - dataLength);    							var data = reader.ReadBytes(read);  							decompressedDataStream.Write(data' 0' data.Length);    							dataRead += read;  						} while (dataRead < dataLength);  						decompressedDataStream.Position = 0;    						#if NaCl || SILVERLIGHT  						using (var zip = new GZipInputStream(decompressedDataStream))  						using (var dataStream = new MemoryStream())  						{  							var buffer = new byte[4096];  							int read = 0;  							do  							{  								read = zip.Read(buffer' 0' buffer.Length);  								dataStream.Write(buffer' 0' buffer.Length);  								  							} while (read > 0);  							  							Mipmaps = new Mipmap[1];  							Mipmaps[0] = new Mipmap(dataStream.GetBuffer()' Size.Width' Size.Height' 1' 4);  							if (flip) Mipmaps[0].FlipVertical();  						}  						#else  						using (var decompressedStream = new GZipStream(decompressedDataStream' CompressionMode.Decompress))  						using (var dataStream = new MemoryStream())  						{  							decompressedStream.CopyTo(dataStream);  							Mipmaps = new Mipmap[1];  							Mipmaps[0] = new Mipmap(dataStream.ToArray()' Size.Width' Size.Height' 1' 4);  							if (flip) Mipmaps[0].FlipVertical();  						}  						#endif  					}  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageBMPC,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageBMPC.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.BMPC;  				ImageFormat = ImageFormats.BMPC;  				SurfaceFormat = SurfaceFormats.RGBAx8;    				using (var reader = new BinaryReader(stream))  				{  					// File Type  					int type = reader.ReadInt32();  					if (type != Streams.MakeFourCC('b'' 'm'' 'p'' 'c')) throw new Exception("Not a .bmpc file");    					// Version  					float version = reader.ReadSingle();  					if (version != 1.0f) throw new Exception("Unsuported .bmpc version");    					// Meta Data  					Size = new Size2(reader.ReadInt32()' reader.ReadInt32());  					bool zipCompressed = reader.ReadBoolean();    					// Data  					using (var decompressedDataStream = new MemoryStream())  					{  						int dataLength = reader.ReadInt32();  						int dataRead = 0;  						do  						{  							int read = 1024;  							if ((dataRead + read) > dataLength) read -= (int)((dataRead + read) - dataLength);    							var data = reader.ReadBytes(read);  							decompressedDataStream.Write(data' 0' data.Length);    							dataRead += read;  						} while (dataRead < dataLength);  						decompressedDataStream.Position = 0;    						#if NaCl || SILVERLIGHT  						using (var zip = new GZipInputStream(decompressedDataStream))  						using (var dataStream = new MemoryStream())  						{  							var buffer = new byte[4096];  							int read = 0;  							do  							{  								read = zip.Read(buffer' 0' buffer.Length);  								dataStream.Write(buffer' 0' buffer.Length);  								  							} while (read > 0);  							  							Mipmaps = new Mipmap[1];  							Mipmaps[0] = new Mipmap(dataStream.GetBuffer()' Size.Width' Size.Height' 1' 4);  							if (flip) Mipmaps[0].FlipVertical();  						}  						#else  						using (var decompressedStream = new GZipStream(decompressedDataStream' CompressionMode.Decompress))  						using (var dataStream = new MemoryStream())  						{  							decompressedStream.CopyTo(dataStream);  							Mipmaps = new Mipmap[1];  							Mipmaps[0] = new Mipmap(dataStream.ToArray()' Size.Width' Size.Height' 1' 4);  							if (flip) Mipmaps[0].FlipVertical();  						}  						#endif  					}  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.DDS;    				// Load Desc  				DDSURFACEDESC2 desc = new DDSURFACEDESC2();  				var reader = new BinaryReader(stream);  				desc.MagicNumber = reader.ReadUInt32();  				desc.dwSize = reader.ReadUInt32();  				desc.dwFlags = reader.ReadUInt32();  				desc.dwHeight = reader.ReadUInt32();  				desc.dwWidth = reader.ReadUInt32();    				desc.Union1 = new DDSURFACEDESC2.DUMMYUNIONNAMEN1();  				desc.Union1.lPitch = reader.ReadInt32();    				desc.Union5 = new DDSURFACEDESC2.DUMMYUNIONNAMEN5();  				desc.Union5.dwBackBufferCount = reader.ReadUInt32();    				desc.Union2 = new DDSURFACEDESC2.DUMMYUNIONNAMEN2();  				desc.Union2.dwMipMapCount = reader.ReadUInt32();    				desc.dwAlphaBitDepth = reader.ReadUInt32();  				desc.dwReserved = reader.ReadUInt32();  				desc.lpSurface = reader.ReadInt32();    				desc.Union3 = new DDSURFACEDESC2.DUMMYUNIONNAMEN3();  				desc.Union3.ddckCKDestOverlay = new DDCOLORKEY();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.ddckCKDestBlt = new DDCOLORKEY();  				desc.ddckCKDestBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKDestBlt.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay = new DDCOLORKEY();  				desc.ddckCKSrcOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt = new DDCOLORKEY();  				desc.ddckCKSrcBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.Union4 = new DDSURFACEDESC2.DUMMYUNIONNAMEN4();  				desc.Union4.ddpfPixelFormat = new DDPIXELFORMAT();  				desc.Union4.ddpfPixelFormat.dwSize = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFlags = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFourCC = reader.ReadUInt32();  				{  					desc.Union4.ddpfPixelFormat.Union1 = new DDPIXELFORMAT.DUMMYUNIONNAMEN1();  					desc.Union4.ddpfPixelFormat.Union1.dwRGBBitCount = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union2 = new DDPIXELFORMAT.DUMMYUNIONNAMEN2();  					desc.Union4.ddpfPixelFormat.Union2.dwRBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union3 = new DDPIXELFORMAT.DUMMYUNIONNAMEN3();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps = new DDPIXELFORMAT.DUMMYUNIONNAMEN3.Caps();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wFlipMSTypes = reader.ReadInt16();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wBltMSTypes = reader.ReadInt16();    					desc.Union4.ddpfPixelFormat.Union4 = new DDPIXELFORMAT.DUMMYUNIONNAMEN4();  					desc.Union4.ddpfPixelFormat.Union4.dwBBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union5 = new DDPIXELFORMAT.DUMMYUNIONNAMEN5();  					desc.Union4.ddpfPixelFormat.Union5.dwRGBAlphaBitMask = reader.ReadUInt32();  				}    				desc.ddsCaps = new DDSCAPS2();  				desc.ddsCaps.dwCaps = reader.ReadUInt32();  				desc.ddsCaps.dwCaps2 = reader.ReadUInt32();  				desc.ddsCaps.dwCaps3 = reader.ReadUInt32();  				desc.ddsCaps.Union = new DDSCAPS2.DUMMYUNIONNAMEN();  				desc.ddsCaps.Union.dwCaps4 = reader.ReadUInt32();    				desc.dwTextureStage = reader.ReadUInt32();  			  				// Check file ext  				if (desc.MagicNumber != 0x20534444u)  				{  					Debug.ThrowError("ImageDDS"' "Not a DDS file");  				}    				// Get file caps  				bool isCubemap = ((desc.ddsCaps.dwCaps & DDSCAPS_COMPLEX) != 0) && ((desc.ddsCaps.dwCaps2 & DDSCAPS2_CUBEMAP) != 0);  				bool isVolumeTexture = ((desc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) != 0);  				bool hasAlphaChannel = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) != 0);  				Compressed = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_FOURCC) != 0);    				// Get pixel format  				Size = new Size2((int)desc.dwWidth' (int)desc.dwHeight);  				int blockSize = 0' blockDev = 1;  				if (Compressed)  				{  					FormatD3D = desc.Union4.ddpfPixelFormat.dwFourCC;  					switch (desc.Union4.ddpfPixelFormat.dwFourCC)  					{  						case FOURCC_DXT1:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.DXT1;  							ImageFormat = ImageFormats.DXT1;  							break;    						case FOURCC_DXT3:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT3;  							ImageFormat = ImageFormats.DXT3;  							break;    						case FOURCC_DXT5:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT5;  							ImageFormat = ImageFormats.DXT5;  							break;    						case FOURCC_ATC_RGB:  							FormatGL = ATC_RGB_AMD;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.ATC_RGB;  							ImageFormat = ImageFormats.ATC_RGB;  							break;    						case FOURCC_ATC_RGBA_EXPLICIT:  							FormatGL = ATC_RGBA_EXPLICIT_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Explicit;  							ImageFormat = ImageFormats.ATC_RGBA_Explicit;  							break;    						case FOURCC_ATC_RGBA_INTERPOLATED:  							FormatGL = ATC_RGBA_INTERPOLATED_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Interpolated;  							ImageFormat = ImageFormats.ATC_RGBA_Interpolated;  							break;    						default:  							Debug.ThrowError("ImageDDS"' "Unsuported DDS Format");  							break;  					}  				}  				else  				{  					Debug.ThrowError("ImageDDS"' "Uncompressed textures not supported yet");  				}    				if (isCubemap || isVolumeTexture) Debug.ThrowError("ImageDDS"' "Cubemap and VolumeTextures not supported yet");    				// Create Mipmaps  				Mipmaps = new Mipmap[desc.Union2.dwMipMapCount == 0 ? 1 : desc.Union2.dwMipMapCount];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int dataSize = (((size.Width+3)/4) * ((size.Height+3)/4)) * blockSize;  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					if (flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5))  					{  						data = flipCompressedData(data' size.Width' size.Height' blockSize);  					}  					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.DDS;    				// Load Desc  				DDSURFACEDESC2 desc = new DDSURFACEDESC2();  				var reader = new BinaryReader(stream);  				desc.MagicNumber = reader.ReadUInt32();  				desc.dwSize = reader.ReadUInt32();  				desc.dwFlags = reader.ReadUInt32();  				desc.dwHeight = reader.ReadUInt32();  				desc.dwWidth = reader.ReadUInt32();    				desc.Union1 = new DDSURFACEDESC2.DUMMYUNIONNAMEN1();  				desc.Union1.lPitch = reader.ReadInt32();    				desc.Union5 = new DDSURFACEDESC2.DUMMYUNIONNAMEN5();  				desc.Union5.dwBackBufferCount = reader.ReadUInt32();    				desc.Union2 = new DDSURFACEDESC2.DUMMYUNIONNAMEN2();  				desc.Union2.dwMipMapCount = reader.ReadUInt32();    				desc.dwAlphaBitDepth = reader.ReadUInt32();  				desc.dwReserved = reader.ReadUInt32();  				desc.lpSurface = reader.ReadInt32();    				desc.Union3 = new DDSURFACEDESC2.DUMMYUNIONNAMEN3();  				desc.Union3.ddckCKDestOverlay = new DDCOLORKEY();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.ddckCKDestBlt = new DDCOLORKEY();  				desc.ddckCKDestBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKDestBlt.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay = new DDCOLORKEY();  				desc.ddckCKSrcOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt = new DDCOLORKEY();  				desc.ddckCKSrcBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.Union4 = new DDSURFACEDESC2.DUMMYUNIONNAMEN4();  				desc.Union4.ddpfPixelFormat = new DDPIXELFORMAT();  				desc.Union4.ddpfPixelFormat.dwSize = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFlags = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFourCC = reader.ReadUInt32();  				{  					desc.Union4.ddpfPixelFormat.Union1 = new DDPIXELFORMAT.DUMMYUNIONNAMEN1();  					desc.Union4.ddpfPixelFormat.Union1.dwRGBBitCount = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union2 = new DDPIXELFORMAT.DUMMYUNIONNAMEN2();  					desc.Union4.ddpfPixelFormat.Union2.dwRBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union3 = new DDPIXELFORMAT.DUMMYUNIONNAMEN3();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps = new DDPIXELFORMAT.DUMMYUNIONNAMEN3.Caps();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wFlipMSTypes = reader.ReadInt16();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wBltMSTypes = reader.ReadInt16();    					desc.Union4.ddpfPixelFormat.Union4 = new DDPIXELFORMAT.DUMMYUNIONNAMEN4();  					desc.Union4.ddpfPixelFormat.Union4.dwBBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union5 = new DDPIXELFORMAT.DUMMYUNIONNAMEN5();  					desc.Union4.ddpfPixelFormat.Union5.dwRGBAlphaBitMask = reader.ReadUInt32();  				}    				desc.ddsCaps = new DDSCAPS2();  				desc.ddsCaps.dwCaps = reader.ReadUInt32();  				desc.ddsCaps.dwCaps2 = reader.ReadUInt32();  				desc.ddsCaps.dwCaps3 = reader.ReadUInt32();  				desc.ddsCaps.Union = new DDSCAPS2.DUMMYUNIONNAMEN();  				desc.ddsCaps.Union.dwCaps4 = reader.ReadUInt32();    				desc.dwTextureStage = reader.ReadUInt32();  			  				// Check file ext  				if (desc.MagicNumber != 0x20534444u)  				{  					Debug.ThrowError("ImageDDS"' "Not a DDS file");  				}    				// Get file caps  				bool isCubemap = ((desc.ddsCaps.dwCaps & DDSCAPS_COMPLEX) != 0) && ((desc.ddsCaps.dwCaps2 & DDSCAPS2_CUBEMAP) != 0);  				bool isVolumeTexture = ((desc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) != 0);  				bool hasAlphaChannel = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) != 0);  				Compressed = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_FOURCC) != 0);    				// Get pixel format  				Size = new Size2((int)desc.dwWidth' (int)desc.dwHeight);  				int blockSize = 0' blockDev = 1;  				if (Compressed)  				{  					FormatD3D = desc.Union4.ddpfPixelFormat.dwFourCC;  					switch (desc.Union4.ddpfPixelFormat.dwFourCC)  					{  						case FOURCC_DXT1:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.DXT1;  							ImageFormat = ImageFormats.DXT1;  							break;    						case FOURCC_DXT3:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT3;  							ImageFormat = ImageFormats.DXT3;  							break;    						case FOURCC_DXT5:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT5;  							ImageFormat = ImageFormats.DXT5;  							break;    						case FOURCC_ATC_RGB:  							FormatGL = ATC_RGB_AMD;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.ATC_RGB;  							ImageFormat = ImageFormats.ATC_RGB;  							break;    						case FOURCC_ATC_RGBA_EXPLICIT:  							FormatGL = ATC_RGBA_EXPLICIT_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Explicit;  							ImageFormat = ImageFormats.ATC_RGBA_Explicit;  							break;    						case FOURCC_ATC_RGBA_INTERPOLATED:  							FormatGL = ATC_RGBA_INTERPOLATED_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Interpolated;  							ImageFormat = ImageFormats.ATC_RGBA_Interpolated;  							break;    						default:  							Debug.ThrowError("ImageDDS"' "Unsuported DDS Format");  							break;  					}  				}  				else  				{  					Debug.ThrowError("ImageDDS"' "Uncompressed textures not supported yet");  				}    				if (isCubemap || isVolumeTexture) Debug.ThrowError("ImageDDS"' "Cubemap and VolumeTextures not supported yet");    				// Create Mipmaps  				Mipmaps = new Mipmap[desc.Union2.dwMipMapCount == 0 ? 1 : desc.Union2.dwMipMapCount];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int dataSize = (((size.Width+3)/4) * ((size.Height+3)/4)) * blockSize;  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					if (flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5))  					{  						data = flipCompressedData(data' size.Width' size.Height' blockSize);  					}  					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.DDS;    				// Load Desc  				DDSURFACEDESC2 desc = new DDSURFACEDESC2();  				var reader = new BinaryReader(stream);  				desc.MagicNumber = reader.ReadUInt32();  				desc.dwSize = reader.ReadUInt32();  				desc.dwFlags = reader.ReadUInt32();  				desc.dwHeight = reader.ReadUInt32();  				desc.dwWidth = reader.ReadUInt32();    				desc.Union1 = new DDSURFACEDESC2.DUMMYUNIONNAMEN1();  				desc.Union1.lPitch = reader.ReadInt32();    				desc.Union5 = new DDSURFACEDESC2.DUMMYUNIONNAMEN5();  				desc.Union5.dwBackBufferCount = reader.ReadUInt32();    				desc.Union2 = new DDSURFACEDESC2.DUMMYUNIONNAMEN2();  				desc.Union2.dwMipMapCount = reader.ReadUInt32();    				desc.dwAlphaBitDepth = reader.ReadUInt32();  				desc.dwReserved = reader.ReadUInt32();  				desc.lpSurface = reader.ReadInt32();    				desc.Union3 = new DDSURFACEDESC2.DUMMYUNIONNAMEN3();  				desc.Union3.ddckCKDestOverlay = new DDCOLORKEY();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.ddckCKDestBlt = new DDCOLORKEY();  				desc.ddckCKDestBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKDestBlt.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay = new DDCOLORKEY();  				desc.ddckCKSrcOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt = new DDCOLORKEY();  				desc.ddckCKSrcBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.Union4 = new DDSURFACEDESC2.DUMMYUNIONNAMEN4();  				desc.Union4.ddpfPixelFormat = new DDPIXELFORMAT();  				desc.Union4.ddpfPixelFormat.dwSize = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFlags = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFourCC = reader.ReadUInt32();  				{  					desc.Union4.ddpfPixelFormat.Union1 = new DDPIXELFORMAT.DUMMYUNIONNAMEN1();  					desc.Union4.ddpfPixelFormat.Union1.dwRGBBitCount = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union2 = new DDPIXELFORMAT.DUMMYUNIONNAMEN2();  					desc.Union4.ddpfPixelFormat.Union2.dwRBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union3 = new DDPIXELFORMAT.DUMMYUNIONNAMEN3();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps = new DDPIXELFORMAT.DUMMYUNIONNAMEN3.Caps();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wFlipMSTypes = reader.ReadInt16();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wBltMSTypes = reader.ReadInt16();    					desc.Union4.ddpfPixelFormat.Union4 = new DDPIXELFORMAT.DUMMYUNIONNAMEN4();  					desc.Union4.ddpfPixelFormat.Union4.dwBBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union5 = new DDPIXELFORMAT.DUMMYUNIONNAMEN5();  					desc.Union4.ddpfPixelFormat.Union5.dwRGBAlphaBitMask = reader.ReadUInt32();  				}    				desc.ddsCaps = new DDSCAPS2();  				desc.ddsCaps.dwCaps = reader.ReadUInt32();  				desc.ddsCaps.dwCaps2 = reader.ReadUInt32();  				desc.ddsCaps.dwCaps3 = reader.ReadUInt32();  				desc.ddsCaps.Union = new DDSCAPS2.DUMMYUNIONNAMEN();  				desc.ddsCaps.Union.dwCaps4 = reader.ReadUInt32();    				desc.dwTextureStage = reader.ReadUInt32();  			  				// Check file ext  				if (desc.MagicNumber != 0x20534444u)  				{  					Debug.ThrowError("ImageDDS"' "Not a DDS file");  				}    				// Get file caps  				bool isCubemap = ((desc.ddsCaps.dwCaps & DDSCAPS_COMPLEX) != 0) && ((desc.ddsCaps.dwCaps2 & DDSCAPS2_CUBEMAP) != 0);  				bool isVolumeTexture = ((desc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) != 0);  				bool hasAlphaChannel = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) != 0);  				Compressed = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_FOURCC) != 0);    				// Get pixel format  				Size = new Size2((int)desc.dwWidth' (int)desc.dwHeight);  				int blockSize = 0' blockDev = 1;  				if (Compressed)  				{  					FormatD3D = desc.Union4.ddpfPixelFormat.dwFourCC;  					switch (desc.Union4.ddpfPixelFormat.dwFourCC)  					{  						case FOURCC_DXT1:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.DXT1;  							ImageFormat = ImageFormats.DXT1;  							break;    						case FOURCC_DXT3:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT3;  							ImageFormat = ImageFormats.DXT3;  							break;    						case FOURCC_DXT5:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT5;  							ImageFormat = ImageFormats.DXT5;  							break;    						case FOURCC_ATC_RGB:  							FormatGL = ATC_RGB_AMD;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.ATC_RGB;  							ImageFormat = ImageFormats.ATC_RGB;  							break;    						case FOURCC_ATC_RGBA_EXPLICIT:  							FormatGL = ATC_RGBA_EXPLICIT_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Explicit;  							ImageFormat = ImageFormats.ATC_RGBA_Explicit;  							break;    						case FOURCC_ATC_RGBA_INTERPOLATED:  							FormatGL = ATC_RGBA_INTERPOLATED_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Interpolated;  							ImageFormat = ImageFormats.ATC_RGBA_Interpolated;  							break;    						default:  							Debug.ThrowError("ImageDDS"' "Unsuported DDS Format");  							break;  					}  				}  				else  				{  					Debug.ThrowError("ImageDDS"' "Uncompressed textures not supported yet");  				}    				if (isCubemap || isVolumeTexture) Debug.ThrowError("ImageDDS"' "Cubemap and VolumeTextures not supported yet");    				// Create Mipmaps  				Mipmaps = new Mipmap[desc.Union2.dwMipMapCount == 0 ? 1 : desc.Union2.dwMipMapCount];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int dataSize = (((size.Width+3)/4) * ((size.Height+3)/4)) * blockSize;  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					if (flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5))  					{  						data = flipCompressedData(data' size.Width' size.Height' blockSize);  					}  					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.DDS;    				// Load Desc  				DDSURFACEDESC2 desc = new DDSURFACEDESC2();  				var reader = new BinaryReader(stream);  				desc.MagicNumber = reader.ReadUInt32();  				desc.dwSize = reader.ReadUInt32();  				desc.dwFlags = reader.ReadUInt32();  				desc.dwHeight = reader.ReadUInt32();  				desc.dwWidth = reader.ReadUInt32();    				desc.Union1 = new DDSURFACEDESC2.DUMMYUNIONNAMEN1();  				desc.Union1.lPitch = reader.ReadInt32();    				desc.Union5 = new DDSURFACEDESC2.DUMMYUNIONNAMEN5();  				desc.Union5.dwBackBufferCount = reader.ReadUInt32();    				desc.Union2 = new DDSURFACEDESC2.DUMMYUNIONNAMEN2();  				desc.Union2.dwMipMapCount = reader.ReadUInt32();    				desc.dwAlphaBitDepth = reader.ReadUInt32();  				desc.dwReserved = reader.ReadUInt32();  				desc.lpSurface = reader.ReadInt32();    				desc.Union3 = new DDSURFACEDESC2.DUMMYUNIONNAMEN3();  				desc.Union3.ddckCKDestOverlay = new DDCOLORKEY();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.ddckCKDestBlt = new DDCOLORKEY();  				desc.ddckCKDestBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKDestBlt.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay = new DDCOLORKEY();  				desc.ddckCKSrcOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt = new DDCOLORKEY();  				desc.ddckCKSrcBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.Union4 = new DDSURFACEDESC2.DUMMYUNIONNAMEN4();  				desc.Union4.ddpfPixelFormat = new DDPIXELFORMAT();  				desc.Union4.ddpfPixelFormat.dwSize = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFlags = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFourCC = reader.ReadUInt32();  				{  					desc.Union4.ddpfPixelFormat.Union1 = new DDPIXELFORMAT.DUMMYUNIONNAMEN1();  					desc.Union4.ddpfPixelFormat.Union1.dwRGBBitCount = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union2 = new DDPIXELFORMAT.DUMMYUNIONNAMEN2();  					desc.Union4.ddpfPixelFormat.Union2.dwRBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union3 = new DDPIXELFORMAT.DUMMYUNIONNAMEN3();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps = new DDPIXELFORMAT.DUMMYUNIONNAMEN3.Caps();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wFlipMSTypes = reader.ReadInt16();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wBltMSTypes = reader.ReadInt16();    					desc.Union4.ddpfPixelFormat.Union4 = new DDPIXELFORMAT.DUMMYUNIONNAMEN4();  					desc.Union4.ddpfPixelFormat.Union4.dwBBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union5 = new DDPIXELFORMAT.DUMMYUNIONNAMEN5();  					desc.Union4.ddpfPixelFormat.Union5.dwRGBAlphaBitMask = reader.ReadUInt32();  				}    				desc.ddsCaps = new DDSCAPS2();  				desc.ddsCaps.dwCaps = reader.ReadUInt32();  				desc.ddsCaps.dwCaps2 = reader.ReadUInt32();  				desc.ddsCaps.dwCaps3 = reader.ReadUInt32();  				desc.ddsCaps.Union = new DDSCAPS2.DUMMYUNIONNAMEN();  				desc.ddsCaps.Union.dwCaps4 = reader.ReadUInt32();    				desc.dwTextureStage = reader.ReadUInt32();  			  				// Check file ext  				if (desc.MagicNumber != 0x20534444u)  				{  					Debug.ThrowError("ImageDDS"' "Not a DDS file");  				}    				// Get file caps  				bool isCubemap = ((desc.ddsCaps.dwCaps & DDSCAPS_COMPLEX) != 0) && ((desc.ddsCaps.dwCaps2 & DDSCAPS2_CUBEMAP) != 0);  				bool isVolumeTexture = ((desc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) != 0);  				bool hasAlphaChannel = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) != 0);  				Compressed = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_FOURCC) != 0);    				// Get pixel format  				Size = new Size2((int)desc.dwWidth' (int)desc.dwHeight);  				int blockSize = 0' blockDev = 1;  				if (Compressed)  				{  					FormatD3D = desc.Union4.ddpfPixelFormat.dwFourCC;  					switch (desc.Union4.ddpfPixelFormat.dwFourCC)  					{  						case FOURCC_DXT1:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.DXT1;  							ImageFormat = ImageFormats.DXT1;  							break;    						case FOURCC_DXT3:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT3;  							ImageFormat = ImageFormats.DXT3;  							break;    						case FOURCC_DXT5:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT5;  							ImageFormat = ImageFormats.DXT5;  							break;    						case FOURCC_ATC_RGB:  							FormatGL = ATC_RGB_AMD;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.ATC_RGB;  							ImageFormat = ImageFormats.ATC_RGB;  							break;    						case FOURCC_ATC_RGBA_EXPLICIT:  							FormatGL = ATC_RGBA_EXPLICIT_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Explicit;  							ImageFormat = ImageFormats.ATC_RGBA_Explicit;  							break;    						case FOURCC_ATC_RGBA_INTERPOLATED:  							FormatGL = ATC_RGBA_INTERPOLATED_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Interpolated;  							ImageFormat = ImageFormats.ATC_RGBA_Interpolated;  							break;    						default:  							Debug.ThrowError("ImageDDS"' "Unsuported DDS Format");  							break;  					}  				}  				else  				{  					Debug.ThrowError("ImageDDS"' "Uncompressed textures not supported yet");  				}    				if (isCubemap || isVolumeTexture) Debug.ThrowError("ImageDDS"' "Cubemap and VolumeTextures not supported yet");    				// Create Mipmaps  				Mipmaps = new Mipmap[desc.Union2.dwMipMapCount == 0 ? 1 : desc.Union2.dwMipMapCount];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int dataSize = (((size.Width+3)/4) * ((size.Height+3)/4)) * blockSize;  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					if (flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5))  					{  						data = flipCompressedData(data' size.Width' size.Height' blockSize);  					}  					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.DDS;    				// Load Desc  				DDSURFACEDESC2 desc = new DDSURFACEDESC2();  				var reader = new BinaryReader(stream);  				desc.MagicNumber = reader.ReadUInt32();  				desc.dwSize = reader.ReadUInt32();  				desc.dwFlags = reader.ReadUInt32();  				desc.dwHeight = reader.ReadUInt32();  				desc.dwWidth = reader.ReadUInt32();    				desc.Union1 = new DDSURFACEDESC2.DUMMYUNIONNAMEN1();  				desc.Union1.lPitch = reader.ReadInt32();    				desc.Union5 = new DDSURFACEDESC2.DUMMYUNIONNAMEN5();  				desc.Union5.dwBackBufferCount = reader.ReadUInt32();    				desc.Union2 = new DDSURFACEDESC2.DUMMYUNIONNAMEN2();  				desc.Union2.dwMipMapCount = reader.ReadUInt32();    				desc.dwAlphaBitDepth = reader.ReadUInt32();  				desc.dwReserved = reader.ReadUInt32();  				desc.lpSurface = reader.ReadInt32();    				desc.Union3 = new DDSURFACEDESC2.DUMMYUNIONNAMEN3();  				desc.Union3.ddckCKDestOverlay = new DDCOLORKEY();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.ddckCKDestBlt = new DDCOLORKEY();  				desc.ddckCKDestBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKDestBlt.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay = new DDCOLORKEY();  				desc.ddckCKSrcOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt = new DDCOLORKEY();  				desc.ddckCKSrcBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.Union4 = new DDSURFACEDESC2.DUMMYUNIONNAMEN4();  				desc.Union4.ddpfPixelFormat = new DDPIXELFORMAT();  				desc.Union4.ddpfPixelFormat.dwSize = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFlags = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFourCC = reader.ReadUInt32();  				{  					desc.Union4.ddpfPixelFormat.Union1 = new DDPIXELFORMAT.DUMMYUNIONNAMEN1();  					desc.Union4.ddpfPixelFormat.Union1.dwRGBBitCount = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union2 = new DDPIXELFORMAT.DUMMYUNIONNAMEN2();  					desc.Union4.ddpfPixelFormat.Union2.dwRBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union3 = new DDPIXELFORMAT.DUMMYUNIONNAMEN3();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps = new DDPIXELFORMAT.DUMMYUNIONNAMEN3.Caps();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wFlipMSTypes = reader.ReadInt16();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wBltMSTypes = reader.ReadInt16();    					desc.Union4.ddpfPixelFormat.Union4 = new DDPIXELFORMAT.DUMMYUNIONNAMEN4();  					desc.Union4.ddpfPixelFormat.Union4.dwBBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union5 = new DDPIXELFORMAT.DUMMYUNIONNAMEN5();  					desc.Union4.ddpfPixelFormat.Union5.dwRGBAlphaBitMask = reader.ReadUInt32();  				}    				desc.ddsCaps = new DDSCAPS2();  				desc.ddsCaps.dwCaps = reader.ReadUInt32();  				desc.ddsCaps.dwCaps2 = reader.ReadUInt32();  				desc.ddsCaps.dwCaps3 = reader.ReadUInt32();  				desc.ddsCaps.Union = new DDSCAPS2.DUMMYUNIONNAMEN();  				desc.ddsCaps.Union.dwCaps4 = reader.ReadUInt32();    				desc.dwTextureStage = reader.ReadUInt32();  			  				// Check file ext  				if (desc.MagicNumber != 0x20534444u)  				{  					Debug.ThrowError("ImageDDS"' "Not a DDS file");  				}    				// Get file caps  				bool isCubemap = ((desc.ddsCaps.dwCaps & DDSCAPS_COMPLEX) != 0) && ((desc.ddsCaps.dwCaps2 & DDSCAPS2_CUBEMAP) != 0);  				bool isVolumeTexture = ((desc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) != 0);  				bool hasAlphaChannel = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) != 0);  				Compressed = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_FOURCC) != 0);    				// Get pixel format  				Size = new Size2((int)desc.dwWidth' (int)desc.dwHeight);  				int blockSize = 0' blockDev = 1;  				if (Compressed)  				{  					FormatD3D = desc.Union4.ddpfPixelFormat.dwFourCC;  					switch (desc.Union4.ddpfPixelFormat.dwFourCC)  					{  						case FOURCC_DXT1:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.DXT1;  							ImageFormat = ImageFormats.DXT1;  							break;    						case FOURCC_DXT3:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT3;  							ImageFormat = ImageFormats.DXT3;  							break;    						case FOURCC_DXT5:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT5;  							ImageFormat = ImageFormats.DXT5;  							break;    						case FOURCC_ATC_RGB:  							FormatGL = ATC_RGB_AMD;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.ATC_RGB;  							ImageFormat = ImageFormats.ATC_RGB;  							break;    						case FOURCC_ATC_RGBA_EXPLICIT:  							FormatGL = ATC_RGBA_EXPLICIT_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Explicit;  							ImageFormat = ImageFormats.ATC_RGBA_Explicit;  							break;    						case FOURCC_ATC_RGBA_INTERPOLATED:  							FormatGL = ATC_RGBA_INTERPOLATED_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Interpolated;  							ImageFormat = ImageFormats.ATC_RGBA_Interpolated;  							break;    						default:  							Debug.ThrowError("ImageDDS"' "Unsuported DDS Format");  							break;  					}  				}  				else  				{  					Debug.ThrowError("ImageDDS"' "Uncompressed textures not supported yet");  				}    				if (isCubemap || isVolumeTexture) Debug.ThrowError("ImageDDS"' "Cubemap and VolumeTextures not supported yet");    				// Create Mipmaps  				Mipmaps = new Mipmap[desc.Union2.dwMipMapCount == 0 ? 1 : desc.Union2.dwMipMapCount];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int dataSize = (((size.Width+3)/4) * ((size.Height+3)/4)) * blockSize;  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					if (flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5))  					{  						data = flipCompressedData(data' size.Width' size.Height' blockSize);  					}  					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.DDS;    				// Load Desc  				DDSURFACEDESC2 desc = new DDSURFACEDESC2();  				var reader = new BinaryReader(stream);  				desc.MagicNumber = reader.ReadUInt32();  				desc.dwSize = reader.ReadUInt32();  				desc.dwFlags = reader.ReadUInt32();  				desc.dwHeight = reader.ReadUInt32();  				desc.dwWidth = reader.ReadUInt32();    				desc.Union1 = new DDSURFACEDESC2.DUMMYUNIONNAMEN1();  				desc.Union1.lPitch = reader.ReadInt32();    				desc.Union5 = new DDSURFACEDESC2.DUMMYUNIONNAMEN5();  				desc.Union5.dwBackBufferCount = reader.ReadUInt32();    				desc.Union2 = new DDSURFACEDESC2.DUMMYUNIONNAMEN2();  				desc.Union2.dwMipMapCount = reader.ReadUInt32();    				desc.dwAlphaBitDepth = reader.ReadUInt32();  				desc.dwReserved = reader.ReadUInt32();  				desc.lpSurface = reader.ReadInt32();    				desc.Union3 = new DDSURFACEDESC2.DUMMYUNIONNAMEN3();  				desc.Union3.ddckCKDestOverlay = new DDCOLORKEY();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.ddckCKDestBlt = new DDCOLORKEY();  				desc.ddckCKDestBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKDestBlt.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay = new DDCOLORKEY();  				desc.ddckCKSrcOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt = new DDCOLORKEY();  				desc.ddckCKSrcBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.Union4 = new DDSURFACEDESC2.DUMMYUNIONNAMEN4();  				desc.Union4.ddpfPixelFormat = new DDPIXELFORMAT();  				desc.Union4.ddpfPixelFormat.dwSize = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFlags = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFourCC = reader.ReadUInt32();  				{  					desc.Union4.ddpfPixelFormat.Union1 = new DDPIXELFORMAT.DUMMYUNIONNAMEN1();  					desc.Union4.ddpfPixelFormat.Union1.dwRGBBitCount = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union2 = new DDPIXELFORMAT.DUMMYUNIONNAMEN2();  					desc.Union4.ddpfPixelFormat.Union2.dwRBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union3 = new DDPIXELFORMAT.DUMMYUNIONNAMEN3();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps = new DDPIXELFORMAT.DUMMYUNIONNAMEN3.Caps();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wFlipMSTypes = reader.ReadInt16();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wBltMSTypes = reader.ReadInt16();    					desc.Union4.ddpfPixelFormat.Union4 = new DDPIXELFORMAT.DUMMYUNIONNAMEN4();  					desc.Union4.ddpfPixelFormat.Union4.dwBBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union5 = new DDPIXELFORMAT.DUMMYUNIONNAMEN5();  					desc.Union4.ddpfPixelFormat.Union5.dwRGBAlphaBitMask = reader.ReadUInt32();  				}    				desc.ddsCaps = new DDSCAPS2();  				desc.ddsCaps.dwCaps = reader.ReadUInt32();  				desc.ddsCaps.dwCaps2 = reader.ReadUInt32();  				desc.ddsCaps.dwCaps3 = reader.ReadUInt32();  				desc.ddsCaps.Union = new DDSCAPS2.DUMMYUNIONNAMEN();  				desc.ddsCaps.Union.dwCaps4 = reader.ReadUInt32();    				desc.dwTextureStage = reader.ReadUInt32();  			  				// Check file ext  				if (desc.MagicNumber != 0x20534444u)  				{  					Debug.ThrowError("ImageDDS"' "Not a DDS file");  				}    				// Get file caps  				bool isCubemap = ((desc.ddsCaps.dwCaps & DDSCAPS_COMPLEX) != 0) && ((desc.ddsCaps.dwCaps2 & DDSCAPS2_CUBEMAP) != 0);  				bool isVolumeTexture = ((desc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) != 0);  				bool hasAlphaChannel = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) != 0);  				Compressed = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_FOURCC) != 0);    				// Get pixel format  				Size = new Size2((int)desc.dwWidth' (int)desc.dwHeight);  				int blockSize = 0' blockDev = 1;  				if (Compressed)  				{  					FormatD3D = desc.Union4.ddpfPixelFormat.dwFourCC;  					switch (desc.Union4.ddpfPixelFormat.dwFourCC)  					{  						case FOURCC_DXT1:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.DXT1;  							ImageFormat = ImageFormats.DXT1;  							break;    						case FOURCC_DXT3:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT3;  							ImageFormat = ImageFormats.DXT3;  							break;    						case FOURCC_DXT5:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT5;  							ImageFormat = ImageFormats.DXT5;  							break;    						case FOURCC_ATC_RGB:  							FormatGL = ATC_RGB_AMD;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.ATC_RGB;  							ImageFormat = ImageFormats.ATC_RGB;  							break;    						case FOURCC_ATC_RGBA_EXPLICIT:  							FormatGL = ATC_RGBA_EXPLICIT_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Explicit;  							ImageFormat = ImageFormats.ATC_RGBA_Explicit;  							break;    						case FOURCC_ATC_RGBA_INTERPOLATED:  							FormatGL = ATC_RGBA_INTERPOLATED_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Interpolated;  							ImageFormat = ImageFormats.ATC_RGBA_Interpolated;  							break;    						default:  							Debug.ThrowError("ImageDDS"' "Unsuported DDS Format");  							break;  					}  				}  				else  				{  					Debug.ThrowError("ImageDDS"' "Uncompressed textures not supported yet");  				}    				if (isCubemap || isVolumeTexture) Debug.ThrowError("ImageDDS"' "Cubemap and VolumeTextures not supported yet");    				// Create Mipmaps  				Mipmaps = new Mipmap[desc.Union2.dwMipMapCount == 0 ? 1 : desc.Union2.dwMipMapCount];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int dataSize = (((size.Width+3)/4) * ((size.Height+3)/4)) * blockSize;  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					if (flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5))  					{  						data = flipCompressedData(data' size.Width' size.Height' blockSize);  					}  					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.DDS;    				// Load Desc  				DDSURFACEDESC2 desc = new DDSURFACEDESC2();  				var reader = new BinaryReader(stream);  				desc.MagicNumber = reader.ReadUInt32();  				desc.dwSize = reader.ReadUInt32();  				desc.dwFlags = reader.ReadUInt32();  				desc.dwHeight = reader.ReadUInt32();  				desc.dwWidth = reader.ReadUInt32();    				desc.Union1 = new DDSURFACEDESC2.DUMMYUNIONNAMEN1();  				desc.Union1.lPitch = reader.ReadInt32();    				desc.Union5 = new DDSURFACEDESC2.DUMMYUNIONNAMEN5();  				desc.Union5.dwBackBufferCount = reader.ReadUInt32();    				desc.Union2 = new DDSURFACEDESC2.DUMMYUNIONNAMEN2();  				desc.Union2.dwMipMapCount = reader.ReadUInt32();    				desc.dwAlphaBitDepth = reader.ReadUInt32();  				desc.dwReserved = reader.ReadUInt32();  				desc.lpSurface = reader.ReadInt32();    				desc.Union3 = new DDSURFACEDESC2.DUMMYUNIONNAMEN3();  				desc.Union3.ddckCKDestOverlay = new DDCOLORKEY();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.ddckCKDestBlt = new DDCOLORKEY();  				desc.ddckCKDestBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKDestBlt.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay = new DDCOLORKEY();  				desc.ddckCKSrcOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt = new DDCOLORKEY();  				desc.ddckCKSrcBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.Union4 = new DDSURFACEDESC2.DUMMYUNIONNAMEN4();  				desc.Union4.ddpfPixelFormat = new DDPIXELFORMAT();  				desc.Union4.ddpfPixelFormat.dwSize = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFlags = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFourCC = reader.ReadUInt32();  				{  					desc.Union4.ddpfPixelFormat.Union1 = new DDPIXELFORMAT.DUMMYUNIONNAMEN1();  					desc.Union4.ddpfPixelFormat.Union1.dwRGBBitCount = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union2 = new DDPIXELFORMAT.DUMMYUNIONNAMEN2();  					desc.Union4.ddpfPixelFormat.Union2.dwRBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union3 = new DDPIXELFORMAT.DUMMYUNIONNAMEN3();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps = new DDPIXELFORMAT.DUMMYUNIONNAMEN3.Caps();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wFlipMSTypes = reader.ReadInt16();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wBltMSTypes = reader.ReadInt16();    					desc.Union4.ddpfPixelFormat.Union4 = new DDPIXELFORMAT.DUMMYUNIONNAMEN4();  					desc.Union4.ddpfPixelFormat.Union4.dwBBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union5 = new DDPIXELFORMAT.DUMMYUNIONNAMEN5();  					desc.Union4.ddpfPixelFormat.Union5.dwRGBAlphaBitMask = reader.ReadUInt32();  				}    				desc.ddsCaps = new DDSCAPS2();  				desc.ddsCaps.dwCaps = reader.ReadUInt32();  				desc.ddsCaps.dwCaps2 = reader.ReadUInt32();  				desc.ddsCaps.dwCaps3 = reader.ReadUInt32();  				desc.ddsCaps.Union = new DDSCAPS2.DUMMYUNIONNAMEN();  				desc.ddsCaps.Union.dwCaps4 = reader.ReadUInt32();    				desc.dwTextureStage = reader.ReadUInt32();  			  				// Check file ext  				if (desc.MagicNumber != 0x20534444u)  				{  					Debug.ThrowError("ImageDDS"' "Not a DDS file");  				}    				// Get file caps  				bool isCubemap = ((desc.ddsCaps.dwCaps & DDSCAPS_COMPLEX) != 0) && ((desc.ddsCaps.dwCaps2 & DDSCAPS2_CUBEMAP) != 0);  				bool isVolumeTexture = ((desc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) != 0);  				bool hasAlphaChannel = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) != 0);  				Compressed = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_FOURCC) != 0);    				// Get pixel format  				Size = new Size2((int)desc.dwWidth' (int)desc.dwHeight);  				int blockSize = 0' blockDev = 1;  				if (Compressed)  				{  					FormatD3D = desc.Union4.ddpfPixelFormat.dwFourCC;  					switch (desc.Union4.ddpfPixelFormat.dwFourCC)  					{  						case FOURCC_DXT1:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.DXT1;  							ImageFormat = ImageFormats.DXT1;  							break;    						case FOURCC_DXT3:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT3;  							ImageFormat = ImageFormats.DXT3;  							break;    						case FOURCC_DXT5:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT5;  							ImageFormat = ImageFormats.DXT5;  							break;    						case FOURCC_ATC_RGB:  							FormatGL = ATC_RGB_AMD;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.ATC_RGB;  							ImageFormat = ImageFormats.ATC_RGB;  							break;    						case FOURCC_ATC_RGBA_EXPLICIT:  							FormatGL = ATC_RGBA_EXPLICIT_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Explicit;  							ImageFormat = ImageFormats.ATC_RGBA_Explicit;  							break;    						case FOURCC_ATC_RGBA_INTERPOLATED:  							FormatGL = ATC_RGBA_INTERPOLATED_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Interpolated;  							ImageFormat = ImageFormats.ATC_RGBA_Interpolated;  							break;    						default:  							Debug.ThrowError("ImageDDS"' "Unsuported DDS Format");  							break;  					}  				}  				else  				{  					Debug.ThrowError("ImageDDS"' "Uncompressed textures not supported yet");  				}    				if (isCubemap || isVolumeTexture) Debug.ThrowError("ImageDDS"' "Cubemap and VolumeTextures not supported yet");    				// Create Mipmaps  				Mipmaps = new Mipmap[desc.Union2.dwMipMapCount == 0 ? 1 : desc.Union2.dwMipMapCount];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int dataSize = (((size.Width+3)/4) * ((size.Height+3)/4)) * blockSize;  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					if (flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5))  					{  						data = flipCompressedData(data' size.Width' size.Height' blockSize);  					}  					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.DDS;    				// Load Desc  				DDSURFACEDESC2 desc = new DDSURFACEDESC2();  				var reader = new BinaryReader(stream);  				desc.MagicNumber = reader.ReadUInt32();  				desc.dwSize = reader.ReadUInt32();  				desc.dwFlags = reader.ReadUInt32();  				desc.dwHeight = reader.ReadUInt32();  				desc.dwWidth = reader.ReadUInt32();    				desc.Union1 = new DDSURFACEDESC2.DUMMYUNIONNAMEN1();  				desc.Union1.lPitch = reader.ReadInt32();    				desc.Union5 = new DDSURFACEDESC2.DUMMYUNIONNAMEN5();  				desc.Union5.dwBackBufferCount = reader.ReadUInt32();    				desc.Union2 = new DDSURFACEDESC2.DUMMYUNIONNAMEN2();  				desc.Union2.dwMipMapCount = reader.ReadUInt32();    				desc.dwAlphaBitDepth = reader.ReadUInt32();  				desc.dwReserved = reader.ReadUInt32();  				desc.lpSurface = reader.ReadInt32();    				desc.Union3 = new DDSURFACEDESC2.DUMMYUNIONNAMEN3();  				desc.Union3.ddckCKDestOverlay = new DDCOLORKEY();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.ddckCKDestBlt = new DDCOLORKEY();  				desc.ddckCKDestBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKDestBlt.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay = new DDCOLORKEY();  				desc.ddckCKSrcOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt = new DDCOLORKEY();  				desc.ddckCKSrcBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.Union4 = new DDSURFACEDESC2.DUMMYUNIONNAMEN4();  				desc.Union4.ddpfPixelFormat = new DDPIXELFORMAT();  				desc.Union4.ddpfPixelFormat.dwSize = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFlags = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFourCC = reader.ReadUInt32();  				{  					desc.Union4.ddpfPixelFormat.Union1 = new DDPIXELFORMAT.DUMMYUNIONNAMEN1();  					desc.Union4.ddpfPixelFormat.Union1.dwRGBBitCount = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union2 = new DDPIXELFORMAT.DUMMYUNIONNAMEN2();  					desc.Union4.ddpfPixelFormat.Union2.dwRBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union3 = new DDPIXELFORMAT.DUMMYUNIONNAMEN3();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps = new DDPIXELFORMAT.DUMMYUNIONNAMEN3.Caps();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wFlipMSTypes = reader.ReadInt16();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wBltMSTypes = reader.ReadInt16();    					desc.Union4.ddpfPixelFormat.Union4 = new DDPIXELFORMAT.DUMMYUNIONNAMEN4();  					desc.Union4.ddpfPixelFormat.Union4.dwBBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union5 = new DDPIXELFORMAT.DUMMYUNIONNAMEN5();  					desc.Union4.ddpfPixelFormat.Union5.dwRGBAlphaBitMask = reader.ReadUInt32();  				}    				desc.ddsCaps = new DDSCAPS2();  				desc.ddsCaps.dwCaps = reader.ReadUInt32();  				desc.ddsCaps.dwCaps2 = reader.ReadUInt32();  				desc.ddsCaps.dwCaps3 = reader.ReadUInt32();  				desc.ddsCaps.Union = new DDSCAPS2.DUMMYUNIONNAMEN();  				desc.ddsCaps.Union.dwCaps4 = reader.ReadUInt32();    				desc.dwTextureStage = reader.ReadUInt32();  			  				// Check file ext  				if (desc.MagicNumber != 0x20534444u)  				{  					Debug.ThrowError("ImageDDS"' "Not a DDS file");  				}    				// Get file caps  				bool isCubemap = ((desc.ddsCaps.dwCaps & DDSCAPS_COMPLEX) != 0) && ((desc.ddsCaps.dwCaps2 & DDSCAPS2_CUBEMAP) != 0);  				bool isVolumeTexture = ((desc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) != 0);  				bool hasAlphaChannel = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) != 0);  				Compressed = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_FOURCC) != 0);    				// Get pixel format  				Size = new Size2((int)desc.dwWidth' (int)desc.dwHeight);  				int blockSize = 0' blockDev = 1;  				if (Compressed)  				{  					FormatD3D = desc.Union4.ddpfPixelFormat.dwFourCC;  					switch (desc.Union4.ddpfPixelFormat.dwFourCC)  					{  						case FOURCC_DXT1:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.DXT1;  							ImageFormat = ImageFormats.DXT1;  							break;    						case FOURCC_DXT3:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT3;  							ImageFormat = ImageFormats.DXT3;  							break;    						case FOURCC_DXT5:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT5;  							ImageFormat = ImageFormats.DXT5;  							break;    						case FOURCC_ATC_RGB:  							FormatGL = ATC_RGB_AMD;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.ATC_RGB;  							ImageFormat = ImageFormats.ATC_RGB;  							break;    						case FOURCC_ATC_RGBA_EXPLICIT:  							FormatGL = ATC_RGBA_EXPLICIT_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Explicit;  							ImageFormat = ImageFormats.ATC_RGBA_Explicit;  							break;    						case FOURCC_ATC_RGBA_INTERPOLATED:  							FormatGL = ATC_RGBA_INTERPOLATED_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Interpolated;  							ImageFormat = ImageFormats.ATC_RGBA_Interpolated;  							break;    						default:  							Debug.ThrowError("ImageDDS"' "Unsuported DDS Format");  							break;  					}  				}  				else  				{  					Debug.ThrowError("ImageDDS"' "Uncompressed textures not supported yet");  				}    				if (isCubemap || isVolumeTexture) Debug.ThrowError("ImageDDS"' "Cubemap and VolumeTextures not supported yet");    				// Create Mipmaps  				Mipmaps = new Mipmap[desc.Union2.dwMipMapCount == 0 ? 1 : desc.Union2.dwMipMapCount];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int dataSize = (((size.Width+3)/4) * ((size.Height+3)/4)) * blockSize;  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					if (flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5))  					{  						data = flipCompressedData(data' size.Width' size.Height' blockSize);  					}  					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.DDS;    				// Load Desc  				DDSURFACEDESC2 desc = new DDSURFACEDESC2();  				var reader = new BinaryReader(stream);  				desc.MagicNumber = reader.ReadUInt32();  				desc.dwSize = reader.ReadUInt32();  				desc.dwFlags = reader.ReadUInt32();  				desc.dwHeight = reader.ReadUInt32();  				desc.dwWidth = reader.ReadUInt32();    				desc.Union1 = new DDSURFACEDESC2.DUMMYUNIONNAMEN1();  				desc.Union1.lPitch = reader.ReadInt32();    				desc.Union5 = new DDSURFACEDESC2.DUMMYUNIONNAMEN5();  				desc.Union5.dwBackBufferCount = reader.ReadUInt32();    				desc.Union2 = new DDSURFACEDESC2.DUMMYUNIONNAMEN2();  				desc.Union2.dwMipMapCount = reader.ReadUInt32();    				desc.dwAlphaBitDepth = reader.ReadUInt32();  				desc.dwReserved = reader.ReadUInt32();  				desc.lpSurface = reader.ReadInt32();    				desc.Union3 = new DDSURFACEDESC2.DUMMYUNIONNAMEN3();  				desc.Union3.ddckCKDestOverlay = new DDCOLORKEY();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.ddckCKDestBlt = new DDCOLORKEY();  				desc.ddckCKDestBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKDestBlt.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay = new DDCOLORKEY();  				desc.ddckCKSrcOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt = new DDCOLORKEY();  				desc.ddckCKSrcBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.Union4 = new DDSURFACEDESC2.DUMMYUNIONNAMEN4();  				desc.Union4.ddpfPixelFormat = new DDPIXELFORMAT();  				desc.Union4.ddpfPixelFormat.dwSize = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFlags = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFourCC = reader.ReadUInt32();  				{  					desc.Union4.ddpfPixelFormat.Union1 = new DDPIXELFORMAT.DUMMYUNIONNAMEN1();  					desc.Union4.ddpfPixelFormat.Union1.dwRGBBitCount = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union2 = new DDPIXELFORMAT.DUMMYUNIONNAMEN2();  					desc.Union4.ddpfPixelFormat.Union2.dwRBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union3 = new DDPIXELFORMAT.DUMMYUNIONNAMEN3();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps = new DDPIXELFORMAT.DUMMYUNIONNAMEN3.Caps();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wFlipMSTypes = reader.ReadInt16();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wBltMSTypes = reader.ReadInt16();    					desc.Union4.ddpfPixelFormat.Union4 = new DDPIXELFORMAT.DUMMYUNIONNAMEN4();  					desc.Union4.ddpfPixelFormat.Union4.dwBBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union5 = new DDPIXELFORMAT.DUMMYUNIONNAMEN5();  					desc.Union4.ddpfPixelFormat.Union5.dwRGBAlphaBitMask = reader.ReadUInt32();  				}    				desc.ddsCaps = new DDSCAPS2();  				desc.ddsCaps.dwCaps = reader.ReadUInt32();  				desc.ddsCaps.dwCaps2 = reader.ReadUInt32();  				desc.ddsCaps.dwCaps3 = reader.ReadUInt32();  				desc.ddsCaps.Union = new DDSCAPS2.DUMMYUNIONNAMEN();  				desc.ddsCaps.Union.dwCaps4 = reader.ReadUInt32();    				desc.dwTextureStage = reader.ReadUInt32();  			  				// Check file ext  				if (desc.MagicNumber != 0x20534444u)  				{  					Debug.ThrowError("ImageDDS"' "Not a DDS file");  				}    				// Get file caps  				bool isCubemap = ((desc.ddsCaps.dwCaps & DDSCAPS_COMPLEX) != 0) && ((desc.ddsCaps.dwCaps2 & DDSCAPS2_CUBEMAP) != 0);  				bool isVolumeTexture = ((desc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) != 0);  				bool hasAlphaChannel = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) != 0);  				Compressed = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_FOURCC) != 0);    				// Get pixel format  				Size = new Size2((int)desc.dwWidth' (int)desc.dwHeight);  				int blockSize = 0' blockDev = 1;  				if (Compressed)  				{  					FormatD3D = desc.Union4.ddpfPixelFormat.dwFourCC;  					switch (desc.Union4.ddpfPixelFormat.dwFourCC)  					{  						case FOURCC_DXT1:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.DXT1;  							ImageFormat = ImageFormats.DXT1;  							break;    						case FOURCC_DXT3:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT3;  							ImageFormat = ImageFormats.DXT3;  							break;    						case FOURCC_DXT5:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT5;  							ImageFormat = ImageFormats.DXT5;  							break;    						case FOURCC_ATC_RGB:  							FormatGL = ATC_RGB_AMD;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.ATC_RGB;  							ImageFormat = ImageFormats.ATC_RGB;  							break;    						case FOURCC_ATC_RGBA_EXPLICIT:  							FormatGL = ATC_RGBA_EXPLICIT_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Explicit;  							ImageFormat = ImageFormats.ATC_RGBA_Explicit;  							break;    						case FOURCC_ATC_RGBA_INTERPOLATED:  							FormatGL = ATC_RGBA_INTERPOLATED_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Interpolated;  							ImageFormat = ImageFormats.ATC_RGBA_Interpolated;  							break;    						default:  							Debug.ThrowError("ImageDDS"' "Unsuported DDS Format");  							break;  					}  				}  				else  				{  					Debug.ThrowError("ImageDDS"' "Uncompressed textures not supported yet");  				}    				if (isCubemap || isVolumeTexture) Debug.ThrowError("ImageDDS"' "Cubemap and VolumeTextures not supported yet");    				// Create Mipmaps  				Mipmaps = new Mipmap[desc.Union2.dwMipMapCount == 0 ? 1 : desc.Union2.dwMipMapCount];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int dataSize = (((size.Width+3)/4) * ((size.Height+3)/4)) * blockSize;  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					if (flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5))  					{  						data = flipCompressedData(data' size.Width' size.Height' blockSize);  					}  					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.DDS;    				// Load Desc  				DDSURFACEDESC2 desc = new DDSURFACEDESC2();  				var reader = new BinaryReader(stream);  				desc.MagicNumber = reader.ReadUInt32();  				desc.dwSize = reader.ReadUInt32();  				desc.dwFlags = reader.ReadUInt32();  				desc.dwHeight = reader.ReadUInt32();  				desc.dwWidth = reader.ReadUInt32();    				desc.Union1 = new DDSURFACEDESC2.DUMMYUNIONNAMEN1();  				desc.Union1.lPitch = reader.ReadInt32();    				desc.Union5 = new DDSURFACEDESC2.DUMMYUNIONNAMEN5();  				desc.Union5.dwBackBufferCount = reader.ReadUInt32();    				desc.Union2 = new DDSURFACEDESC2.DUMMYUNIONNAMEN2();  				desc.Union2.dwMipMapCount = reader.ReadUInt32();    				desc.dwAlphaBitDepth = reader.ReadUInt32();  				desc.dwReserved = reader.ReadUInt32();  				desc.lpSurface = reader.ReadInt32();    				desc.Union3 = new DDSURFACEDESC2.DUMMYUNIONNAMEN3();  				desc.Union3.ddckCKDestOverlay = new DDCOLORKEY();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.ddckCKDestBlt = new DDCOLORKEY();  				desc.ddckCKDestBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKDestBlt.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay = new DDCOLORKEY();  				desc.ddckCKSrcOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt = new DDCOLORKEY();  				desc.ddckCKSrcBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.Union4 = new DDSURFACEDESC2.DUMMYUNIONNAMEN4();  				desc.Union4.ddpfPixelFormat = new DDPIXELFORMAT();  				desc.Union4.ddpfPixelFormat.dwSize = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFlags = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFourCC = reader.ReadUInt32();  				{  					desc.Union4.ddpfPixelFormat.Union1 = new DDPIXELFORMAT.DUMMYUNIONNAMEN1();  					desc.Union4.ddpfPixelFormat.Union1.dwRGBBitCount = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union2 = new DDPIXELFORMAT.DUMMYUNIONNAMEN2();  					desc.Union4.ddpfPixelFormat.Union2.dwRBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union3 = new DDPIXELFORMAT.DUMMYUNIONNAMEN3();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps = new DDPIXELFORMAT.DUMMYUNIONNAMEN3.Caps();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wFlipMSTypes = reader.ReadInt16();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wBltMSTypes = reader.ReadInt16();    					desc.Union4.ddpfPixelFormat.Union4 = new DDPIXELFORMAT.DUMMYUNIONNAMEN4();  					desc.Union4.ddpfPixelFormat.Union4.dwBBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union5 = new DDPIXELFORMAT.DUMMYUNIONNAMEN5();  					desc.Union4.ddpfPixelFormat.Union5.dwRGBAlphaBitMask = reader.ReadUInt32();  				}    				desc.ddsCaps = new DDSCAPS2();  				desc.ddsCaps.dwCaps = reader.ReadUInt32();  				desc.ddsCaps.dwCaps2 = reader.ReadUInt32();  				desc.ddsCaps.dwCaps3 = reader.ReadUInt32();  				desc.ddsCaps.Union = new DDSCAPS2.DUMMYUNIONNAMEN();  				desc.ddsCaps.Union.dwCaps4 = reader.ReadUInt32();    				desc.dwTextureStage = reader.ReadUInt32();  			  				// Check file ext  				if (desc.MagicNumber != 0x20534444u)  				{  					Debug.ThrowError("ImageDDS"' "Not a DDS file");  				}    				// Get file caps  				bool isCubemap = ((desc.ddsCaps.dwCaps & DDSCAPS_COMPLEX) != 0) && ((desc.ddsCaps.dwCaps2 & DDSCAPS2_CUBEMAP) != 0);  				bool isVolumeTexture = ((desc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) != 0);  				bool hasAlphaChannel = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) != 0);  				Compressed = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_FOURCC) != 0);    				// Get pixel format  				Size = new Size2((int)desc.dwWidth' (int)desc.dwHeight);  				int blockSize = 0' blockDev = 1;  				if (Compressed)  				{  					FormatD3D = desc.Union4.ddpfPixelFormat.dwFourCC;  					switch (desc.Union4.ddpfPixelFormat.dwFourCC)  					{  						case FOURCC_DXT1:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.DXT1;  							ImageFormat = ImageFormats.DXT1;  							break;    						case FOURCC_DXT3:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT3;  							ImageFormat = ImageFormats.DXT3;  							break;    						case FOURCC_DXT5:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT5;  							ImageFormat = ImageFormats.DXT5;  							break;    						case FOURCC_ATC_RGB:  							FormatGL = ATC_RGB_AMD;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.ATC_RGB;  							ImageFormat = ImageFormats.ATC_RGB;  							break;    						case FOURCC_ATC_RGBA_EXPLICIT:  							FormatGL = ATC_RGBA_EXPLICIT_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Explicit;  							ImageFormat = ImageFormats.ATC_RGBA_Explicit;  							break;    						case FOURCC_ATC_RGBA_INTERPOLATED:  							FormatGL = ATC_RGBA_INTERPOLATED_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Interpolated;  							ImageFormat = ImageFormats.ATC_RGBA_Interpolated;  							break;    						default:  							Debug.ThrowError("ImageDDS"' "Unsuported DDS Format");  							break;  					}  				}  				else  				{  					Debug.ThrowError("ImageDDS"' "Uncompressed textures not supported yet");  				}    				if (isCubemap || isVolumeTexture) Debug.ThrowError("ImageDDS"' "Cubemap and VolumeTextures not supported yet");    				// Create Mipmaps  				Mipmaps = new Mipmap[desc.Union2.dwMipMapCount == 0 ? 1 : desc.Union2.dwMipMapCount];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int dataSize = (((size.Width+3)/4) * ((size.Height+3)/4)) * blockSize;  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					if (flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5))  					{  						data = flipCompressedData(data' size.Width' size.Height' blockSize);  					}  					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.DDS;    				// Load Desc  				DDSURFACEDESC2 desc = new DDSURFACEDESC2();  				var reader = new BinaryReader(stream);  				desc.MagicNumber = reader.ReadUInt32();  				desc.dwSize = reader.ReadUInt32();  				desc.dwFlags = reader.ReadUInt32();  				desc.dwHeight = reader.ReadUInt32();  				desc.dwWidth = reader.ReadUInt32();    				desc.Union1 = new DDSURFACEDESC2.DUMMYUNIONNAMEN1();  				desc.Union1.lPitch = reader.ReadInt32();    				desc.Union5 = new DDSURFACEDESC2.DUMMYUNIONNAMEN5();  				desc.Union5.dwBackBufferCount = reader.ReadUInt32();    				desc.Union2 = new DDSURFACEDESC2.DUMMYUNIONNAMEN2();  				desc.Union2.dwMipMapCount = reader.ReadUInt32();    				desc.dwAlphaBitDepth = reader.ReadUInt32();  				desc.dwReserved = reader.ReadUInt32();  				desc.lpSurface = reader.ReadInt32();    				desc.Union3 = new DDSURFACEDESC2.DUMMYUNIONNAMEN3();  				desc.Union3.ddckCKDestOverlay = new DDCOLORKEY();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.ddckCKDestBlt = new DDCOLORKEY();  				desc.ddckCKDestBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKDestBlt.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay = new DDCOLORKEY();  				desc.ddckCKSrcOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt = new DDCOLORKEY();  				desc.ddckCKSrcBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.Union4 = new DDSURFACEDESC2.DUMMYUNIONNAMEN4();  				desc.Union4.ddpfPixelFormat = new DDPIXELFORMAT();  				desc.Union4.ddpfPixelFormat.dwSize = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFlags = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFourCC = reader.ReadUInt32();  				{  					desc.Union4.ddpfPixelFormat.Union1 = new DDPIXELFORMAT.DUMMYUNIONNAMEN1();  					desc.Union4.ddpfPixelFormat.Union1.dwRGBBitCount = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union2 = new DDPIXELFORMAT.DUMMYUNIONNAMEN2();  					desc.Union4.ddpfPixelFormat.Union2.dwRBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union3 = new DDPIXELFORMAT.DUMMYUNIONNAMEN3();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps = new DDPIXELFORMAT.DUMMYUNIONNAMEN3.Caps();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wFlipMSTypes = reader.ReadInt16();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wBltMSTypes = reader.ReadInt16();    					desc.Union4.ddpfPixelFormat.Union4 = new DDPIXELFORMAT.DUMMYUNIONNAMEN4();  					desc.Union4.ddpfPixelFormat.Union4.dwBBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union5 = new DDPIXELFORMAT.DUMMYUNIONNAMEN5();  					desc.Union4.ddpfPixelFormat.Union5.dwRGBAlphaBitMask = reader.ReadUInt32();  				}    				desc.ddsCaps = new DDSCAPS2();  				desc.ddsCaps.dwCaps = reader.ReadUInt32();  				desc.ddsCaps.dwCaps2 = reader.ReadUInt32();  				desc.ddsCaps.dwCaps3 = reader.ReadUInt32();  				desc.ddsCaps.Union = new DDSCAPS2.DUMMYUNIONNAMEN();  				desc.ddsCaps.Union.dwCaps4 = reader.ReadUInt32();    				desc.dwTextureStage = reader.ReadUInt32();  			  				// Check file ext  				if (desc.MagicNumber != 0x20534444u)  				{  					Debug.ThrowError("ImageDDS"' "Not a DDS file");  				}    				// Get file caps  				bool isCubemap = ((desc.ddsCaps.dwCaps & DDSCAPS_COMPLEX) != 0) && ((desc.ddsCaps.dwCaps2 & DDSCAPS2_CUBEMAP) != 0);  				bool isVolumeTexture = ((desc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) != 0);  				bool hasAlphaChannel = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) != 0);  				Compressed = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_FOURCC) != 0);    				// Get pixel format  				Size = new Size2((int)desc.dwWidth' (int)desc.dwHeight);  				int blockSize = 0' blockDev = 1;  				if (Compressed)  				{  					FormatD3D = desc.Union4.ddpfPixelFormat.dwFourCC;  					switch (desc.Union4.ddpfPixelFormat.dwFourCC)  					{  						case FOURCC_DXT1:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.DXT1;  							ImageFormat = ImageFormats.DXT1;  							break;    						case FOURCC_DXT3:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT3;  							ImageFormat = ImageFormats.DXT3;  							break;    						case FOURCC_DXT5:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT5;  							ImageFormat = ImageFormats.DXT5;  							break;    						case FOURCC_ATC_RGB:  							FormatGL = ATC_RGB_AMD;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.ATC_RGB;  							ImageFormat = ImageFormats.ATC_RGB;  							break;    						case FOURCC_ATC_RGBA_EXPLICIT:  							FormatGL = ATC_RGBA_EXPLICIT_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Explicit;  							ImageFormat = ImageFormats.ATC_RGBA_Explicit;  							break;    						case FOURCC_ATC_RGBA_INTERPOLATED:  							FormatGL = ATC_RGBA_INTERPOLATED_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Interpolated;  							ImageFormat = ImageFormats.ATC_RGBA_Interpolated;  							break;    						default:  							Debug.ThrowError("ImageDDS"' "Unsuported DDS Format");  							break;  					}  				}  				else  				{  					Debug.ThrowError("ImageDDS"' "Uncompressed textures not supported yet");  				}    				if (isCubemap || isVolumeTexture) Debug.ThrowError("ImageDDS"' "Cubemap and VolumeTextures not supported yet");    				// Create Mipmaps  				Mipmaps = new Mipmap[desc.Union2.dwMipMapCount == 0 ? 1 : desc.Union2.dwMipMapCount];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int dataSize = (((size.Width+3)/4) * ((size.Height+3)/4)) * blockSize;  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					if (flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5))  					{  						data = flipCompressedData(data' size.Width' size.Height' blockSize);  					}  					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.DDS;    				// Load Desc  				DDSURFACEDESC2 desc = new DDSURFACEDESC2();  				var reader = new BinaryReader(stream);  				desc.MagicNumber = reader.ReadUInt32();  				desc.dwSize = reader.ReadUInt32();  				desc.dwFlags = reader.ReadUInt32();  				desc.dwHeight = reader.ReadUInt32();  				desc.dwWidth = reader.ReadUInt32();    				desc.Union1 = new DDSURFACEDESC2.DUMMYUNIONNAMEN1();  				desc.Union1.lPitch = reader.ReadInt32();    				desc.Union5 = new DDSURFACEDESC2.DUMMYUNIONNAMEN5();  				desc.Union5.dwBackBufferCount = reader.ReadUInt32();    				desc.Union2 = new DDSURFACEDESC2.DUMMYUNIONNAMEN2();  				desc.Union2.dwMipMapCount = reader.ReadUInt32();    				desc.dwAlphaBitDepth = reader.ReadUInt32();  				desc.dwReserved = reader.ReadUInt32();  				desc.lpSurface = reader.ReadInt32();    				desc.Union3 = new DDSURFACEDESC2.DUMMYUNIONNAMEN3();  				desc.Union3.ddckCKDestOverlay = new DDCOLORKEY();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.ddckCKDestBlt = new DDCOLORKEY();  				desc.ddckCKDestBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKDestBlt.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay = new DDCOLORKEY();  				desc.ddckCKSrcOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt = new DDCOLORKEY();  				desc.ddckCKSrcBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.Union4 = new DDSURFACEDESC2.DUMMYUNIONNAMEN4();  				desc.Union4.ddpfPixelFormat = new DDPIXELFORMAT();  				desc.Union4.ddpfPixelFormat.dwSize = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFlags = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFourCC = reader.ReadUInt32();  				{  					desc.Union4.ddpfPixelFormat.Union1 = new DDPIXELFORMAT.DUMMYUNIONNAMEN1();  					desc.Union4.ddpfPixelFormat.Union1.dwRGBBitCount = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union2 = new DDPIXELFORMAT.DUMMYUNIONNAMEN2();  					desc.Union4.ddpfPixelFormat.Union2.dwRBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union3 = new DDPIXELFORMAT.DUMMYUNIONNAMEN3();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps = new DDPIXELFORMAT.DUMMYUNIONNAMEN3.Caps();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wFlipMSTypes = reader.ReadInt16();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wBltMSTypes = reader.ReadInt16();    					desc.Union4.ddpfPixelFormat.Union4 = new DDPIXELFORMAT.DUMMYUNIONNAMEN4();  					desc.Union4.ddpfPixelFormat.Union4.dwBBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union5 = new DDPIXELFORMAT.DUMMYUNIONNAMEN5();  					desc.Union4.ddpfPixelFormat.Union5.dwRGBAlphaBitMask = reader.ReadUInt32();  				}    				desc.ddsCaps = new DDSCAPS2();  				desc.ddsCaps.dwCaps = reader.ReadUInt32();  				desc.ddsCaps.dwCaps2 = reader.ReadUInt32();  				desc.ddsCaps.dwCaps3 = reader.ReadUInt32();  				desc.ddsCaps.Union = new DDSCAPS2.DUMMYUNIONNAMEN();  				desc.ddsCaps.Union.dwCaps4 = reader.ReadUInt32();    				desc.dwTextureStage = reader.ReadUInt32();  			  				// Check file ext  				if (desc.MagicNumber != 0x20534444u)  				{  					Debug.ThrowError("ImageDDS"' "Not a DDS file");  				}    				// Get file caps  				bool isCubemap = ((desc.ddsCaps.dwCaps & DDSCAPS_COMPLEX) != 0) && ((desc.ddsCaps.dwCaps2 & DDSCAPS2_CUBEMAP) != 0);  				bool isVolumeTexture = ((desc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) != 0);  				bool hasAlphaChannel = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) != 0);  				Compressed = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_FOURCC) != 0);    				// Get pixel format  				Size = new Size2((int)desc.dwWidth' (int)desc.dwHeight);  				int blockSize = 0' blockDev = 1;  				if (Compressed)  				{  					FormatD3D = desc.Union4.ddpfPixelFormat.dwFourCC;  					switch (desc.Union4.ddpfPixelFormat.dwFourCC)  					{  						case FOURCC_DXT1:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.DXT1;  							ImageFormat = ImageFormats.DXT1;  							break;    						case FOURCC_DXT3:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT3;  							ImageFormat = ImageFormats.DXT3;  							break;    						case FOURCC_DXT5:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT5;  							ImageFormat = ImageFormats.DXT5;  							break;    						case FOURCC_ATC_RGB:  							FormatGL = ATC_RGB_AMD;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.ATC_RGB;  							ImageFormat = ImageFormats.ATC_RGB;  							break;    						case FOURCC_ATC_RGBA_EXPLICIT:  							FormatGL = ATC_RGBA_EXPLICIT_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Explicit;  							ImageFormat = ImageFormats.ATC_RGBA_Explicit;  							break;    						case FOURCC_ATC_RGBA_INTERPOLATED:  							FormatGL = ATC_RGBA_INTERPOLATED_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Interpolated;  							ImageFormat = ImageFormats.ATC_RGBA_Interpolated;  							break;    						default:  							Debug.ThrowError("ImageDDS"' "Unsuported DDS Format");  							break;  					}  				}  				else  				{  					Debug.ThrowError("ImageDDS"' "Uncompressed textures not supported yet");  				}    				if (isCubemap || isVolumeTexture) Debug.ThrowError("ImageDDS"' "Cubemap and VolumeTextures not supported yet");    				// Create Mipmaps  				Mipmaps = new Mipmap[desc.Union2.dwMipMapCount == 0 ? 1 : desc.Union2.dwMipMapCount];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int dataSize = (((size.Width+3)/4) * ((size.Height+3)/4)) * blockSize;  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					if (flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5))  					{  						data = flipCompressedData(data' size.Width' size.Height' blockSize);  					}  					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.DDS;    				// Load Desc  				DDSURFACEDESC2 desc = new DDSURFACEDESC2();  				var reader = new BinaryReader(stream);  				desc.MagicNumber = reader.ReadUInt32();  				desc.dwSize = reader.ReadUInt32();  				desc.dwFlags = reader.ReadUInt32();  				desc.dwHeight = reader.ReadUInt32();  				desc.dwWidth = reader.ReadUInt32();    				desc.Union1 = new DDSURFACEDESC2.DUMMYUNIONNAMEN1();  				desc.Union1.lPitch = reader.ReadInt32();    				desc.Union5 = new DDSURFACEDESC2.DUMMYUNIONNAMEN5();  				desc.Union5.dwBackBufferCount = reader.ReadUInt32();    				desc.Union2 = new DDSURFACEDESC2.DUMMYUNIONNAMEN2();  				desc.Union2.dwMipMapCount = reader.ReadUInt32();    				desc.dwAlphaBitDepth = reader.ReadUInt32();  				desc.dwReserved = reader.ReadUInt32();  				desc.lpSurface = reader.ReadInt32();    				desc.Union3 = new DDSURFACEDESC2.DUMMYUNIONNAMEN3();  				desc.Union3.ddckCKDestOverlay = new DDCOLORKEY();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.ddckCKDestBlt = new DDCOLORKEY();  				desc.ddckCKDestBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKDestBlt.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay = new DDCOLORKEY();  				desc.ddckCKSrcOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt = new DDCOLORKEY();  				desc.ddckCKSrcBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.Union4 = new DDSURFACEDESC2.DUMMYUNIONNAMEN4();  				desc.Union4.ddpfPixelFormat = new DDPIXELFORMAT();  				desc.Union4.ddpfPixelFormat.dwSize = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFlags = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFourCC = reader.ReadUInt32();  				{  					desc.Union4.ddpfPixelFormat.Union1 = new DDPIXELFORMAT.DUMMYUNIONNAMEN1();  					desc.Union4.ddpfPixelFormat.Union1.dwRGBBitCount = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union2 = new DDPIXELFORMAT.DUMMYUNIONNAMEN2();  					desc.Union4.ddpfPixelFormat.Union2.dwRBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union3 = new DDPIXELFORMAT.DUMMYUNIONNAMEN3();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps = new DDPIXELFORMAT.DUMMYUNIONNAMEN3.Caps();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wFlipMSTypes = reader.ReadInt16();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wBltMSTypes = reader.ReadInt16();    					desc.Union4.ddpfPixelFormat.Union4 = new DDPIXELFORMAT.DUMMYUNIONNAMEN4();  					desc.Union4.ddpfPixelFormat.Union4.dwBBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union5 = new DDPIXELFORMAT.DUMMYUNIONNAMEN5();  					desc.Union4.ddpfPixelFormat.Union5.dwRGBAlphaBitMask = reader.ReadUInt32();  				}    				desc.ddsCaps = new DDSCAPS2();  				desc.ddsCaps.dwCaps = reader.ReadUInt32();  				desc.ddsCaps.dwCaps2 = reader.ReadUInt32();  				desc.ddsCaps.dwCaps3 = reader.ReadUInt32();  				desc.ddsCaps.Union = new DDSCAPS2.DUMMYUNIONNAMEN();  				desc.ddsCaps.Union.dwCaps4 = reader.ReadUInt32();    				desc.dwTextureStage = reader.ReadUInt32();  			  				// Check file ext  				if (desc.MagicNumber != 0x20534444u)  				{  					Debug.ThrowError("ImageDDS"' "Not a DDS file");  				}    				// Get file caps  				bool isCubemap = ((desc.ddsCaps.dwCaps & DDSCAPS_COMPLEX) != 0) && ((desc.ddsCaps.dwCaps2 & DDSCAPS2_CUBEMAP) != 0);  				bool isVolumeTexture = ((desc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) != 0);  				bool hasAlphaChannel = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) != 0);  				Compressed = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_FOURCC) != 0);    				// Get pixel format  				Size = new Size2((int)desc.dwWidth' (int)desc.dwHeight);  				int blockSize = 0' blockDev = 1;  				if (Compressed)  				{  					FormatD3D = desc.Union4.ddpfPixelFormat.dwFourCC;  					switch (desc.Union4.ddpfPixelFormat.dwFourCC)  					{  						case FOURCC_DXT1:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.DXT1;  							ImageFormat = ImageFormats.DXT1;  							break;    						case FOURCC_DXT3:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT3;  							ImageFormat = ImageFormats.DXT3;  							break;    						case FOURCC_DXT5:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT5;  							ImageFormat = ImageFormats.DXT5;  							break;    						case FOURCC_ATC_RGB:  							FormatGL = ATC_RGB_AMD;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.ATC_RGB;  							ImageFormat = ImageFormats.ATC_RGB;  							break;    						case FOURCC_ATC_RGBA_EXPLICIT:  							FormatGL = ATC_RGBA_EXPLICIT_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Explicit;  							ImageFormat = ImageFormats.ATC_RGBA_Explicit;  							break;    						case FOURCC_ATC_RGBA_INTERPOLATED:  							FormatGL = ATC_RGBA_INTERPOLATED_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Interpolated;  							ImageFormat = ImageFormats.ATC_RGBA_Interpolated;  							break;    						default:  							Debug.ThrowError("ImageDDS"' "Unsuported DDS Format");  							break;  					}  				}  				else  				{  					Debug.ThrowError("ImageDDS"' "Uncompressed textures not supported yet");  				}    				if (isCubemap || isVolumeTexture) Debug.ThrowError("ImageDDS"' "Cubemap and VolumeTextures not supported yet");    				// Create Mipmaps  				Mipmaps = new Mipmap[desc.Union2.dwMipMapCount == 0 ? 1 : desc.Union2.dwMipMapCount];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int dataSize = (((size.Width+3)/4) * ((size.Height+3)/4)) * blockSize;  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					if (flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5))  					{  						data = flipCompressedData(data' size.Width' size.Height' blockSize);  					}  					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.DDS;    				// Load Desc  				DDSURFACEDESC2 desc = new DDSURFACEDESC2();  				var reader = new BinaryReader(stream);  				desc.MagicNumber = reader.ReadUInt32();  				desc.dwSize = reader.ReadUInt32();  				desc.dwFlags = reader.ReadUInt32();  				desc.dwHeight = reader.ReadUInt32();  				desc.dwWidth = reader.ReadUInt32();    				desc.Union1 = new DDSURFACEDESC2.DUMMYUNIONNAMEN1();  				desc.Union1.lPitch = reader.ReadInt32();    				desc.Union5 = new DDSURFACEDESC2.DUMMYUNIONNAMEN5();  				desc.Union5.dwBackBufferCount = reader.ReadUInt32();    				desc.Union2 = new DDSURFACEDESC2.DUMMYUNIONNAMEN2();  				desc.Union2.dwMipMapCount = reader.ReadUInt32();    				desc.dwAlphaBitDepth = reader.ReadUInt32();  				desc.dwReserved = reader.ReadUInt32();  				desc.lpSurface = reader.ReadInt32();    				desc.Union3 = new DDSURFACEDESC2.DUMMYUNIONNAMEN3();  				desc.Union3.ddckCKDestOverlay = new DDCOLORKEY();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.Union3.ddckCKDestOverlay.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.ddckCKDestBlt = new DDCOLORKEY();  				desc.ddckCKDestBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKDestBlt.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay = new DDCOLORKEY();  				desc.ddckCKSrcOverlay.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcOverlay.dwColorSpaceHighValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt = new DDCOLORKEY();  				desc.ddckCKSrcBlt.dwColorSpaceLowValue = reader.ReadUInt32();  				desc.ddckCKSrcBlt.dwColorSpaceHighValue = reader.ReadUInt32();    				desc.Union4 = new DDSURFACEDESC2.DUMMYUNIONNAMEN4();  				desc.Union4.ddpfPixelFormat = new DDPIXELFORMAT();  				desc.Union4.ddpfPixelFormat.dwSize = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFlags = reader.ReadUInt32();  				desc.Union4.ddpfPixelFormat.dwFourCC = reader.ReadUInt32();  				{  					desc.Union4.ddpfPixelFormat.Union1 = new DDPIXELFORMAT.DUMMYUNIONNAMEN1();  					desc.Union4.ddpfPixelFormat.Union1.dwRGBBitCount = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union2 = new DDPIXELFORMAT.DUMMYUNIONNAMEN2();  					desc.Union4.ddpfPixelFormat.Union2.dwRBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union3 = new DDPIXELFORMAT.DUMMYUNIONNAMEN3();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps = new DDPIXELFORMAT.DUMMYUNIONNAMEN3.Caps();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wFlipMSTypes = reader.ReadInt16();  					desc.Union4.ddpfPixelFormat.Union3.MultiSampleCaps.wBltMSTypes = reader.ReadInt16();    					desc.Union4.ddpfPixelFormat.Union4 = new DDPIXELFORMAT.DUMMYUNIONNAMEN4();  					desc.Union4.ddpfPixelFormat.Union4.dwBBitMask = reader.ReadUInt32();    					desc.Union4.ddpfPixelFormat.Union5 = new DDPIXELFORMAT.DUMMYUNIONNAMEN5();  					desc.Union4.ddpfPixelFormat.Union5.dwRGBAlphaBitMask = reader.ReadUInt32();  				}    				desc.ddsCaps = new DDSCAPS2();  				desc.ddsCaps.dwCaps = reader.ReadUInt32();  				desc.ddsCaps.dwCaps2 = reader.ReadUInt32();  				desc.ddsCaps.dwCaps3 = reader.ReadUInt32();  				desc.ddsCaps.Union = new DDSCAPS2.DUMMYUNIONNAMEN();  				desc.ddsCaps.Union.dwCaps4 = reader.ReadUInt32();    				desc.dwTextureStage = reader.ReadUInt32();  			  				// Check file ext  				if (desc.MagicNumber != 0x20534444u)  				{  					Debug.ThrowError("ImageDDS"' "Not a DDS file");  				}    				// Get file caps  				bool isCubemap = ((desc.ddsCaps.dwCaps & DDSCAPS_COMPLEX) != 0) && ((desc.ddsCaps.dwCaps2 & DDSCAPS2_CUBEMAP) != 0);  				bool isVolumeTexture = ((desc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) != 0);  				bool hasAlphaChannel = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) != 0);  				Compressed = ((desc.Union4.ddpfPixelFormat.dwFlags & DDPF_FOURCC) != 0);    				// Get pixel format  				Size = new Size2((int)desc.dwWidth' (int)desc.dwHeight);  				int blockSize = 0' blockDev = 1;  				if (Compressed)  				{  					FormatD3D = desc.Union4.ddpfPixelFormat.dwFourCC;  					switch (desc.Union4.ddpfPixelFormat.dwFourCC)  					{  						case FOURCC_DXT1:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.DXT1;  							ImageFormat = ImageFormats.DXT1;  							break;    						case FOURCC_DXT3:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT3;  							ImageFormat = ImageFormats.DXT3;  							break;    						case FOURCC_DXT5:  							FormatGL = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.DXT5;  							ImageFormat = ImageFormats.DXT5;  							break;    						case FOURCC_ATC_RGB:  							FormatGL = ATC_RGB_AMD;  							blockSize = 8;  							blockDev = 2;  							SurfaceFormat = SurfaceFormats.ATC_RGB;  							ImageFormat = ImageFormats.ATC_RGB;  							break;    						case FOURCC_ATC_RGBA_EXPLICIT:  							FormatGL = ATC_RGBA_EXPLICIT_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Explicit;  							ImageFormat = ImageFormats.ATC_RGBA_Explicit;  							break;    						case FOURCC_ATC_RGBA_INTERPOLATED:  							FormatGL = ATC_RGBA_INTERPOLATED_ALPHA_AMD;  							blockSize = 16;  							SurfaceFormat = SurfaceFormats.ATC_RGBA_Interpolated;  							ImageFormat = ImageFormats.ATC_RGBA_Interpolated;  							break;    						default:  							Debug.ThrowError("ImageDDS"' "Unsuported DDS Format");  							break;  					}  				}  				else  				{  					Debug.ThrowError("ImageDDS"' "Uncompressed textures not supported yet");  				}    				if (isCubemap || isVolumeTexture) Debug.ThrowError("ImageDDS"' "Cubemap and VolumeTextures not supported yet");    				// Create Mipmaps  				Mipmaps = new Mipmap[desc.Union2.dwMipMapCount == 0 ? 1 : desc.Union2.dwMipMapCount];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int dataSize = (((size.Width+3)/4) * ((size.Height+3)/4)) * blockSize;  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					if (flip && (FormatD3D == FOURCC_DXT1 || FormatD3D == FOURCC_DXT3 || FormatD3D == FOURCC_DXT5))  					{  						data = flipCompressedData(data' size.Width' size.Height' blockSize);  					}  					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: int rowCount = (width + 3) / 4;
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: int rowCount = (width + 3) / 4;
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: int columnCount = (height + 3) / 4;
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: int columnCount = (height + 3) / 4;
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following statement contains a magic number: for (int column = 0; column < columnCount; ++column)  			{  				int targetColumn = columnCount - column - 1;  				for (int row = 0; row < rowCount; ++row)  				{  					int dst = (targetColumn * rowCount + row) * blockSize;  					int src = (column * rowCount + row) * blockSize;  					switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}  				}  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,GetUInt24,The following statement contains a magic number: return (uint)((input[offset + 2] * 256 + input[offset + 1]) * 256 + input[offset + 0]);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,GetUInt24,The following statement contains a magic number: return (uint)((input[offset + 2] * 256 + input[offset + 1]) * 256 + input[offset + 0]);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,GetUInt24,The following statement contains a magic number: return (uint)((input[offset + 2] * 256 + input[offset + 1]) * 256 + input[offset + 0]);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: byte[][] ThreeBits = new byte[2][];
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: for ( int i = 0; i < 2; i++ )  			{  				ThreeBits[i] = new byte[4];  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: for ( int i = 0; i < 2; i++ )  			{  				ThreeBits[i] = new byte[4];  			}
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[0][2] = (byte)(inputUInt24 & BitMask);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[0][3] = (byte)(inputUInt24 & BitMask);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[1][2] = (byte)(inputUInt24 & BitMask);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[1][3] = (byte)(inputUInt24 & BitMask);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits[1][1] << 3);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits[1][2] << 6);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits[1][2] << 6);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits[1][3] << 9);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits[1][3] << 9);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits[0][0] << 12);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits[0][1] << 15);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits[0][2] << 18);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits[0][2] << 18);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits[0][3] << 21);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits[0][3] << 21);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input[offset + 1] = (byte)((splitme & 0x0000ff00 ) >> 8);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input[offset + 2] = (byte)((splitme & 0x00ff0000 ) >> 16);
Magic Number,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input[offset + 2] = (byte)((splitme & 0x00ff0000 ) >> 16);
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImagePVR,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImagePVR.cs,init,The following statement contains a magic number: try  			{  				ImageType = ImageTypes.PVR;    				// Load Header  				var header = new PVRHeader();  				var reader = new BinaryReader(stream);  			  				// Read header version 2  				header.HeaderLength = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.NumMipmaps = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.DataLength = reader.ReadUInt32();  				header.BPP = reader.ReadUInt32();  				header.BitmaskRed = reader.ReadUInt32();  				header.BitmaskGreen = reader.ReadUInt32();  				header.BitmaskBlue = reader.ReadUInt32();  				header.BitmaskAlpha = reader.ReadUInt32();  				header.PVRTag = reader.ReadUInt32();  				header.NumSurfs = reader.ReadUInt32();  			  				// Read header version 3  				/*header.Version = reader.ReadUInt32();  				header.Flags = reader.ReadUInt32();  				header.PixelFormat = reader.ReadUInt64();  				header.ColorSpace = reader.ReadUInt32();  				header.ChannelType = reader.ReadUInt32();  				header.Height = reader.ReadUInt32();  				header.Width = reader.ReadUInt32();  				header.Depth = reader.ReadUInt32();  				header.NumSurfaces = reader.ReadUInt32();  				header.NumFaces = reader.ReadUInt32();  				header.MIPMapCount = reader.ReadUInt32();  				header.MetaDataSize = reader.ReadUInt32();  			  				while (stream.Position <= stream.Length)  				{  					if (stream.Position + sizeof(int) > stream.Length) Debug.ThrowError("ImagePVR"' "No data ID");  					if (reader.ReadInt32() == Streams.MakeFourCC('P'' 'V'' 'R'' (char)3)) break;  				}  			  				var key = reader.ReadUInt32();  				var dSize = reader.ReadUInt32();*/  			  				// Get Caps  				Compressed = true;  			  				// Get pixel format  				Size = new Size2((int)header.Width' (int)header.Height);  				int blockSize = 0' bpp = 0' blockWidth = 0' blockHeight = 0' blockDev = 1;  				//switch (header.PixelFormat)// version 3  				switch (header.Flags & PVR_TEXTURE_FLAG_TYPE_MASK)  				{  					case FOURCC_2BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGB_2;  						SurfaceFormat = SurfaceFormats.PVR_RGB_2;  						break;    					case FOURCC_2BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;  						blockSize = 8*4;  						blockWidth = 8;  						blockHeight = 4;  						bpp = 2;  						blockDev = 2;  						ImageFormat = ImageFormats.PVR_RGBA_2;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_2;  						break;    					case FOURCC_4BPP_RGB:  						FormatGL = GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGB_4;  						SurfaceFormat = SurfaceFormats.PVR_RGB_4;  						break;  					  					case FOURCC_4BPP_RGBA:  						FormatGL = GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;  						blockSize = 4*4;  						blockWidth = 4;  						blockHeight = 4;  						bpp = 4;  						ImageFormat = ImageFormats.PVR_RGBA_4;  						SurfaceFormat = SurfaceFormats.PVR_RGBA_4;  						break;    					default:  						Debug.ThrowError("ImagePVR"' "Unsuported PVR Format");  						break;  				}  			  				// Create Mipmaps  				header.NumMipmaps++;  				//Mipmaps = new Mipmap[header.MIPMapCount == 0 ? 1 : header.MIPMapCount];// version 3  				Mipmaps = new Mipmap[header.NumMipmaps == 0 ? 1 : header.NumMipmaps];  				var size = Size;  				for (int i = 0; i < Mipmaps.Length; ++i)  				{  					int width = (size.Width/blockWidth)' height = (size.Height/blockHeight);  					if (width < 2) width = 2;  					if (height < 2) height = 2;  					int dataSize = (width * height) * ((blockSize * bpp) / 8);  					var data = new byte[dataSize];  					stream.Read(data' 0' dataSize);    					Mipmaps[i] = new Mipmap(data' size.Width' size.Height' blockDev' 4);    					size /= 2;  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageIOS,C:\repos\reignstudios_ReignSDK\Platforms\iOS\Reign.Video\Image\ImageIOS.cs,init,The following statement contains a magic number: try  			{  				using (var imageData = NSData.FromStream(stream))  				using (var image = UIImage.LoadFromData(imageData))  				{  					int width = (int)image.Size.Width;  					int height = (int)image.Size.Height;  					Mipmaps = new Mipmap[1];  					Size = new Size2(width' height);  				  					var data = new byte[width * height * 4];  					using (CGContext imageContext = new CGBitmapContext(data' width' height' 8' width*4' CGColorSpace.CreateDeviceRGB()' CGImageAlphaInfo.PremultipliedLast))  					{  						imageContext.DrawImage(new RectangleF(0' 0' width' height)' image.CGImage);  					  						Mipmaps[0] = new Mipmap(data' width' height' 1' 4);  						if (flip) Mipmaps[0].FlipVertical();  					}  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageIOS,C:\repos\reignstudios_ReignSDK\Platforms\iOS\Reign.Video\Image\ImageIOS.cs,init,The following statement contains a magic number: try  			{  				using (var imageData = NSData.FromStream(stream))  				using (var image = UIImage.LoadFromData(imageData))  				{  					int width = (int)image.Size.Width;  					int height = (int)image.Size.Height;  					Mipmaps = new Mipmap[1];  					Size = new Size2(width' height);  				  					var data = new byte[width * height * 4];  					using (CGContext imageContext = new CGBitmapContext(data' width' height' 8' width*4' CGColorSpace.CreateDeviceRGB()' CGImageAlphaInfo.PremultipliedLast))  					{  						imageContext.DrawImage(new RectangleF(0' 0' width' height)' image.CGImage);  					  						Mipmaps[0] = new Mipmap(data' width' height' 1' 4);  						if (flip) Mipmaps[0].FlipVertical();  					}  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageIOS,C:\repos\reignstudios_ReignSDK\Platforms\iOS\Reign.Video\Image\ImageIOS.cs,init,The following statement contains a magic number: try  			{  				using (var imageData = NSData.FromStream(stream))  				using (var image = UIImage.LoadFromData(imageData))  				{  					int width = (int)image.Size.Width;  					int height = (int)image.Size.Height;  					Mipmaps = new Mipmap[1];  					Size = new Size2(width' height);  				  					var data = new byte[width * height * 4];  					using (CGContext imageContext = new CGBitmapContext(data' width' height' 8' width*4' CGColorSpace.CreateDeviceRGB()' CGImageAlphaInfo.PremultipliedLast))  					{  						imageContext.DrawImage(new RectangleF(0' 0' width' height)' image.CGImage);  					  						Mipmaps[0] = new Mipmap(data' width' height' 1' 4);  						if (flip) Mipmaps[0].FlipVertical();  					}  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Magic Number,Reign.Video,ImageIOS,C:\repos\reignstudios_ReignSDK\Platforms\iOS\Reign.Video\Image\ImageIOS.cs,init,The following statement contains a magic number: try  			{  				using (var imageData = NSData.FromStream(stream))  				using (var image = UIImage.LoadFromData(imageData))  				{  					int width = (int)image.Size.Width;  					int height = (int)image.Size.Height;  					Mipmaps = new Mipmap[1];  					Size = new Size2(width' height);  				  					var data = new byte[width * height * 4];  					using (CGContext imageContext = new CGBitmapContext(data' width' height' 8' width*4' CGColorSpace.CreateDeviceRGB()' CGImageAlphaInfo.PremultipliedLast))  					{  						imageContext.DrawImage(new RectangleF(0' 0' width' height)' image.CGImage);  					  						Mipmaps[0] = new Mipmap(data' width' height' 1' 4);  						if (flip) Mipmaps[0].FlipVertical();  					}  				}  			}  			catch (Exception e)  			{  				FailedToLoad = true;  				Loader.AddLoadableException(e);  				if (loadedCallback != null) loadedCallback(this' false);  				return;  			}
Missing Default,Reign.Video,IBufferLayoutDesc,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Buffers\BufferLayout.cs,IBufferLayoutDesc,The following switch statement is missing a default case: switch (bufferFormatType)  			{  				case BufferLayoutTypes.Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position2_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position2_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 2));  					break;    				case BufferLayoutTypes.Position3:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_UV2:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 1' 5));  					break;    				case BufferLayoutTypes.Position3_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 5));  					break;    				case BufferLayoutTypes.Position3_Color:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					break;    				case BufferLayoutTypes.Position3_Color_UV:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					break;    				case BufferLayoutTypes.Position3_Color_UV_Index:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.Index' 1' 0' 0));  					break;    				case BufferLayoutTypes.Position3_Color_UV_IndexClassic:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.RGBAx8' BufferLayoutElementUsages.Color' 0' 0' 3));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector2' BufferLayoutElementUsages.UV' 0' 0' 4));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Float' BufferLayoutElementUsages.IndexClassic' 0' 0' 6));  					break;    				case BufferLayoutTypes.Position3_Normal:  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Position' 0' 0' 0));  					Elements.Add(new BufferLayoutElement(BufferLayoutElementTypes.Vector3' BufferLayoutElementUsages.Normal' 0' 0' 3));  					break;  			}
Missing Default,Reign.Video,ImageDDS,C:\repos\reignstudios_ReignSDK\Platforms\Common\Reign.Video\Image\ImageDDS.cs,flipCompressedData,The following switch statement is missing a default case: switch (FormatD3D)  					{  						case FOURCC_DXT1:  							// Color only  							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];  							dataOut[dst + 2] = data[src + 2];  							dataOut[dst + 3] = data[src + 3];  							dataOut[dst + 4] = data[src + 7];  							dataOut[dst + 5] = data[src + 6];  							dataOut[dst + 6] = data[src + 5];  							dataOut[dst + 7] = data[src + 4];  							break;    						case FOURCC_DXT3:  							// Alpha  							dataOut[dst + 0] = data[src + 6];  							dataOut[dst + 1] = data[src + 7];  							dataOut[dst + 2] = data[src + 4];  							dataOut[dst + 3] = data[src + 5];  							dataOut[dst + 4] = data[src + 2];  							dataOut[dst + 5] = data[src + 3];  							dataOut[dst + 6] = data[src + 0];  							dataOut[dst + 7] = data[src + 1];    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;    						case FOURCC_DXT5:  							// Alpha' the first 2 bytes remain   							dataOut[dst + 0] = data[src + 0];  							dataOut[dst + 1] = data[src + 1];    							// extract 3 bits each and flip them  							GetBytesFromUInt24(ref dataOut' (uint)dst + 5' FlipUInt24(GetUInt24(ref data' (uint)src + 2)));  							GetBytesFromUInt24(ref dataOut' (uint)dst + 2' FlipUInt24(GetUInt24(ref data' (uint)src + 5)));    							// Color  							dataOut[dst + 8] = data[src + 8];  							dataOut[dst + 9] = data[src + 9];  							dataOut[dst + 10] = data[src + 10];  							dataOut[dst + 11] = data[src + 11];  							dataOut[dst + 12] = data[src + 15];  							dataOut[dst + 13] = data[src + 14];  							dataOut[dst + 14] = data[src + 13];  							dataOut[dst + 15] = data[src + 12];  							break;  					}
