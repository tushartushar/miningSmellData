Implementation smell,Namespace,Class,File,Method,Description
Complex Method,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,Cyclomatic complexity of the method is 17
Long Parameter List,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,WebPDecodeBGRAInto,The method has 5 parameters. Parameters: data' data_size' output_buffer' output_buffer_size' output_stride
Long Identifier,GameRes.Formats.Google,LibWebPLoader,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,,The length of the parameter LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR is 32.
Empty Catch Block,GameRes.Formats.CellWorks,IgsDbReader,C:\repos\morkt_GARbro\Experimental\CellWorks\ArcDB.cs,GetArchiveId,The method has an empty catch block.
Magic Number,GameRes.Formats.CellWorks,IgsDatOpener,C:\repos\morkt_GARbro\Experimental\CellWorks\ArcDB.cs,OpenEntry,The following statement contains a magic number: using (var aes = Aes.Create())              {                  var name_bytes = Encoding.UTF8.GetBytes (entry.Name);                  aes.Mode = CipherMode.CBC;                  aes.Padding = PaddingMode.PKCS7;                  aes.Key = CreateKey (32' name_bytes);                  aes.IV = CreateKey (16' name_bytes);                  using (var decryptor = aes.CreateDecryptor())                  using (var enc = arc.File.CreateStream (entry.Offset' 0x110))                  using (var input = new CryptoStream (enc' decryptor' CryptoStreamMode.Read))                  {                      var header = new byte[Math.Min (entry.Size' 0x100u)];                      input.Read (header' 0' header.Length);                      if (entry.Size <= 0x100)                          return new BinMemoryStream (header);                      var rest = arc.File.CreateStream (entry.Offset+0x110' entry.Size-0x100);                      return new PrefixStream (header' rest);                  }              }
Magic Number,GameRes.Formats.CellWorks,IgsDatOpener,C:\repos\morkt_GARbro\Experimental\CellWorks\ArcDB.cs,OpenEntry,The following statement contains a magic number: using (var aes = Aes.Create())              {                  var name_bytes = Encoding.UTF8.GetBytes (entry.Name);                  aes.Mode = CipherMode.CBC;                  aes.Padding = PaddingMode.PKCS7;                  aes.Key = CreateKey (32' name_bytes);                  aes.IV = CreateKey (16' name_bytes);                  using (var decryptor = aes.CreateDecryptor())                  using (var enc = arc.File.CreateStream (entry.Offset' 0x110))                  using (var input = new CryptoStream (enc' decryptor' CryptoStreamMode.Read))                  {                      var header = new byte[Math.Min (entry.Size' 0x100u)];                      input.Read (header' 0' header.Length);                      if (entry.Size <= 0x100)                          return new BinMemoryStream (header);                      var rest = arc.File.CreateStream (entry.Offset+0x110' entry.Size-0x100);                      return new PrefixStream (header' rest);                  }              }
Magic Number,GameRes.Formats.CellWorks,IgsDbReader,C:\repos\morkt_GARbro\Experimental\CellWorks\ArcDB.cs,ReadIndex,The following statement contains a magic number: using (var cmd = m_conn.CreateCommand())              {                  cmd.CommandText = @"SELECT filepath'offset'size FROM file_infos WHERE archiveID=?";                  cmd.Parameters.Add (cmd.CreateParameter());                  cmd.Parameters[0].Value = arc_id;                  using (var reader = cmd.ExecuteReader())                  {                      var dir = new List<Entry>();                      while (reader.Read())                      {                          var name = reader.GetString (0);                          var entry = FormatCatalog.Instance.Create<Entry> (name);                          entry.Offset = reader.GetInt64 (1);                          entry.Size = (uint)reader.GetInt32 (2);                          dir.Add (entry);                      }                      return dir;                  }              }
Magic Number,GameRes.Formats.Opus,OpusAudio,C:\repos\morkt_GARbro\Experimental\Opus\AudioOPUS.cs,TryOpen,The following statement contains a magic number: int channels = header[header_pos+9];
Magic Number,GameRes.Formats.Opus,OpusAudio,C:\repos\morkt_GARbro\Experimental\Opus\AudioOPUS.cs,TryOpen,The following statement contains a magic number: int rate = 48000;
Magic Number,GameRes.Formats.Opus,OpusAudio,C:\repos\morkt_GARbro\Experimental\Opus\AudioOPUS.cs,TryOpen,The following statement contains a magic number: try              {                  using (var output = new BinaryWriter (pcm' System.Text.Encoding.UTF8' true))                  {                      while (ogg_in.HasNextPacket)                      {                          var packet = ogg_in.DecodeNextPacket();                          if (packet != null)                          {                              for (int i = 0; i < packet.Length; ++i)                                  output.Write (packet[i]);                          }                      }                  }                  var format = new WaveFormat                  {                      FormatTag = 1'                      Channels = (ushort)channels'                      SamplesPerSecond = (uint)rate'                      BitsPerSample = 16'                  };                  format.BlockAlign = (ushort)(format.Channels*format.BitsPerSample/8);                  format.AverageBytesPerSecond = format.SamplesPerSecond*format.BlockAlign;                  pcm.Position = 0;                  var sound = new RawPcmInput (pcm' format);                  file.Dispose();                  return sound;              }              catch              {                  pcm.Dispose();                  throw;              }
Magic Number,GameRes.Formats.Opus,OpusAudio,C:\repos\morkt_GARbro\Experimental\Opus\AudioOPUS.cs,TryOpen,The following statement contains a magic number: try              {                  using (var output = new BinaryWriter (pcm' System.Text.Encoding.UTF8' true))                  {                      while (ogg_in.HasNextPacket)                      {                          var packet = ogg_in.DecodeNextPacket();                          if (packet != null)                          {                              for (int i = 0; i < packet.Length; ++i)                                  output.Write (packet[i]);                          }                      }                  }                  var format = new WaveFormat                  {                      FormatTag = 1'                      Channels = (ushort)channels'                      SamplesPerSecond = (uint)rate'                      BitsPerSample = 16'                  };                  format.BlockAlign = (ushort)(format.Channels*format.BitsPerSample/8);                  format.AverageBytesPerSecond = format.SamplesPerSecond*format.BlockAlign;                  pcm.Position = 0;                  var sound = new RawPcmInput (pcm' format);                  file.Dispose();                  return sound;              }              catch              {                  pcm.Dispose();                  throw;              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: if (!stream.ReadHeader (12).AsciiEqual (8' "WEBP"))                  return null;
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: if (!stream.ReadHeader (12).AsciiEqual (8' "WEBP"))                  return null;
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: var info = new WebPMetaData { BPP = 32 };
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,WebPFormat,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  if (8 != stream.Read (header' 0' 8))                      return null;                  chunk_size = LittleEndian.ToInt32 (header' 4);                  int aligned_size = (chunk_size + 1) & ~1;                  if (!found_vp8x && Binary.AsciiEqual (header' 0' "VP8X"))                  {                      found_vp8x = true;                      if (chunk_size < 10)                          return null;                      if (chunk_size > header.Length)                          header = new byte[chunk_size];                      if (chunk_size != stream.Read (header' 0' chunk_size))                          return null;                      info.Flags = (WebPFeature)LittleEndian.ToUInt32 (header' 0);                      info.Width  = 1 + (uint)header.ToInt24 (4);                      info.Height = 1 + (uint)header.ToInt24 (7);                      if ((long)info.Width * info.Height >= (1L << 32))                          return null;                      continue;                  }                  if (Binary.AsciiEqual (header' 0' "VP8 ") || Binary.AsciiEqual (header' 0' "VP8L"))                  {                      info.IsLossless = header[3] == 'L';                      info.DataOffset = stream.Position;                      info.DataSize = aligned_size;                      if (!found_vp8x)                      {                          if (chunk_size < 10 || 10 != stream.Read (header' 0' 10))                              return null;                          if (info.IsLossless)                          {                              if (header[0] != 0x2F || (header[4] >> 5) != 0)                                  return null;                              uint wh = LittleEndian.ToUInt32 (header' 1);                              info.Width  = (wh & 0x3FFFu) + 1;                              info.Height = ((wh >> 14) & 0x3FFFu) + 1;                              info.HasAlpha = 0 != (header[4] & 0x10);                          }                          else                          {                              if (header[3] != 0x9D || header[4] != 1 || header[5] != 0x2A)                                  return null;                              if (0 != (header[0] & 1)) // not a keyframe                                  return null;                              info.Width  = LittleEndian.ToUInt16 (header' 6) & 0x3FFFu;                              info.Height = LittleEndian.ToUInt16 (header' 8) & 0x3FFFu;                          }                      }                      break;                  }                  if (Binary.AsciiEqual (header' 0' "ALPH"))                  {                      info.AlphaOffset = stream.Position;                      info.AlphaSize   = chunk_size;                  }                  stream.Seek (aligned_size' SeekOrigin.Current);              }
Magic Number,GameRes.Formats.Google,LibWebPLoader,C:\repos\morkt_GARbro\Experimental\WebP\ImageWEBP.cs,Load,The following statement contains a magic number: folder = Path.Combine (folder' (IntPtr.Size == 4) ? "x86" : "x64");
