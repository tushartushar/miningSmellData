Implementation smell,Namespace,Class,File,Method,Description
Complex Method,GameRes,ArcViewStream,C:\repos\morkt_GARbro\GameRes\ArcStream.cs,ReadCString,Cyclomatic complexity of the method is 8
Complex Method,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,ReadRLE,Cyclomatic complexity of the method is 8
Complex Method,GameRes,FileSystemStack,C:\repos\morkt_GARbro\GameRes\FileSystem.cs,ChDir,Cyclomatic complexity of the method is 8
Complex Method,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,Cyclomatic complexity of the method is 9
Complex Method,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,Cyclomatic complexity of the method is 11
Long Parameter List,GameRes,ImageData,C:\repos\morkt_GARbro\GameRes\Image.cs,Create,The method has 5 parameters. Parameters: info' format' palette' pixel_data' stride
Long Parameter List,GameRes,ImageData,C:\repos\morkt_GARbro\GameRes\Image.cs,CreateFlipped,The method has 5 parameters. Parameters: info' format' palette' pixel_data' stride
Complex Conditional,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The conditional expression  "bpp != 1 && bpp != 2 && bpp != 4 && bpp != 8 && bpp != 16"  is complex.
Complex Conditional,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The conditional expression  "bpp != 32 && bpp != 24 && bpp != 16 && bpp != 15 && bpp != 8"  is complex.
Empty Catch Block,GameRes,ImageFormat,C:\repos\morkt_GARbro\GameRes\Image.cs,FindFormat,The method has an empty catch block.
Empty Catch Block,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,FindChunk,The method has an empty catch block.
Magic Number,GameRes,ArcFile,C:\repos\morkt_GARbro\GameRes\ArcFile.cs,TryOpen,The following statement contains a magic number: if (entry.Size < 4)                  return null;
Magic Number,GameRes,ArcViewStream,C:\repos\morkt_GARbro\GameRes\ArcStream.cs,ReadInt16,The following statement contains a magic number: EnsureAvailable (2);
Magic Number,GameRes,ArcViewStream,C:\repos\morkt_GARbro\GameRes\ArcStream.cs,ReadInt16,The following statement contains a magic number: m_buffer_pos += 2;
Magic Number,GameRes,ArcViewStream,C:\repos\morkt_GARbro\GameRes\ArcStream.cs,ReadInt24,The following statement contains a magic number: EnsureAvailable (3);
Magic Number,GameRes,ArcViewStream,C:\repos\morkt_GARbro\GameRes\ArcStream.cs,ReadInt24,The following statement contains a magic number: m_buffer_pos += 3;
Magic Number,GameRes,ArcViewStream,C:\repos\morkt_GARbro\GameRes\ArcStream.cs,ReadInt32,The following statement contains a magic number: EnsureAvailable (4);
Magic Number,GameRes,ArcViewStream,C:\repos\morkt_GARbro\GameRes\ArcStream.cs,ReadInt32,The following statement contains a magic number: m_buffer_pos += 4;
Magic Number,GameRes,ArcViewStream,C:\repos\morkt_GARbro\GameRes\ArcStream.cs,ReadInt64,The following statement contains a magic number: EnsureAvailable (8);
Magic Number,GameRes,ArcViewStream,C:\repos\morkt_GARbro\GameRes\ArcStream.cs,ReadInt64,The following statement contains a magic number: m_buffer_pos += 8;
Magic Number,GameRes,ArcViewStream,C:\repos\morkt_GARbro\GameRes\ArcStream.cs,ReadCString,The following statement contains a magic number: var string_buf = new byte[Math.Max (0x20' available * 2)];
Magic Number,GameRes,ArcViewStream,C:\repos\morkt_GARbro\GameRes\ArcStream.cs,ReadCString,The following statement contains a magic number: for (;;)              {                  int b = ReadByte();                  if (-1 == b || 0 == b)                      break;                  if (string_buf.Length == size)                  {                      Array.Resize (ref string_buf' checked(size*3/2));                  }                  string_buf[size++] = (byte)b;              }
Magic Number,GameRes,ArcViewStream,C:\repos\morkt_GARbro\GameRes\ArcStream.cs,ReadCString,The following statement contains a magic number: for (;;)              {                  int b = ReadByte();                  if (-1 == b || 0 == b)                      break;                  if (string_buf.Length == size)                  {                      Array.Resize (ref string_buf' checked(size*3/2));                  }                  string_buf[size++] = (byte)b;              }
Magic Number,GameRes,StreamExtension,C:\repos\morkt_GARbro\GameRes\ArcView.cs,ReadStringUntil,The following statement contains a magic number: byte[] buffer = new byte[16];
Magic Number,GameRes,StreamExtension,C:\repos\morkt_GARbro\GameRes\ArcView.cs,ReadStringUntil,The following statement contains a magic number: for (;;)              {                  int b = file.ReadByte ();                  if (-1 == b || delim == b)                      break;                  if (buffer.Length == size)                  {                      Array.Resize (ref buffer' checked(size/2*3));                  }                  buffer[size++] = (byte)b;              }
Magic Number,GameRes,StreamExtension,C:\repos\morkt_GARbro\GameRes\ArcView.cs,ReadStringUntil,The following statement contains a magic number: for (;;)              {                  int b = file.ReadByte ();                  if (-1 == b || delim == b)                      break;                  if (buffer.Length == size)                  {                      Array.Resize (ref buffer' checked(size/2*3));                  }                  buffer[size++] = (byte)b;              }
Magic Number,GameRes,ArcView,C:\repos\morkt_GARbro\GameRes\ArcView.cs,InitFromStream,The following statement contains a magic number: try              {                  using (var view = m_map.CreateViewAccessor (0' length' MemoryMappedFileAccess.Write))                  {                      var buffer = new byte[81920];                      unsafe                      {                          byte* ptr = view.GetPointer (0);                          try                          {                              uint total = 0;                              while (total < length)                              {                                  int read = input.Read (buffer' 0' buffer.Length);                                  if (0 == read)                                      break;                                  read = (int)Math.Min (read' length-total);                                  Marshal.Copy (buffer' 0' (IntPtr)(ptr+total)' read);                                  total += (uint)read;                              }                              MaxOffset = total;                          }                          finally                          {                              view.SafeMemoryMappedViewHandle.ReleasePointer();                          }                      }                  }                  View = new Frame (this);              }               catch              {                  m_map.Dispose();                  throw;              }
Magic Number,GameRes,Frame,C:\repos\morkt_GARbro\GameRes\ArcView.cs,ReadUInt16,The following statement contains a magic number: StrictReserve (offset' 2);
Magic Number,GameRes,Frame,C:\repos\morkt_GARbro\GameRes\ArcView.cs,ReadInt16,The following statement contains a magic number: StrictReserve (offset' 2);
Magic Number,GameRes,Frame,C:\repos\morkt_GARbro\GameRes\ArcView.cs,ReadUInt32,The following statement contains a magic number: StrictReserve (offset' 4);
Magic Number,GameRes,Frame,C:\repos\morkt_GARbro\GameRes\ArcView.cs,ReadInt32,The following statement contains a magic number: StrictReserve (offset' 4);
Magic Number,GameRes,Frame,C:\repos\morkt_GARbro\GameRes\ArcView.cs,ReadUInt64,The following statement contains a magic number: StrictReserve (offset' 8);
Magic Number,GameRes,Frame,C:\repos\morkt_GARbro\GameRes\ArcView.cs,ReadInt64,The following statement contains a magic number: StrictReserve (offset' 8);
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Reader,The following statement contains a magic number: switch (meta.BPP)                  {                  default: throw new InvalidFormatException();                  case 8:                      if (1 == meta.ColormapType)                          Format = PixelFormats.Indexed8;                      else                          Format = PixelFormats.Gray8;                      break;                  case 15: Format = PixelFormats.Bgr555; break;                  case 16: Format = PixelFormats.Bgr555; break;                  case 32: Format = PixelFormats.Bgra32; break;                  case 24:                      if (8 == (meta.Descriptor & 0xf))                          Format = PixelFormats.Bgr32;                      else                          Format = PixelFormats.Bgr24;                      break;                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Reader,The following statement contains a magic number: switch (meta.BPP)                  {                  default: throw new InvalidFormatException();                  case 8:                      if (1 == meta.ColormapType)                          Format = PixelFormats.Indexed8;                      else                          Format = PixelFormats.Gray8;                      break;                  case 15: Format = PixelFormats.Bgr555; break;                  case 16: Format = PixelFormats.Bgr555; break;                  case 32: Format = PixelFormats.Bgra32; break;                  case 24:                      if (8 == (meta.Descriptor & 0xf))                          Format = PixelFormats.Bgr32;                      else                          Format = PixelFormats.Bgr24;                      break;                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Reader,The following statement contains a magic number: switch (meta.BPP)                  {                  default: throw new InvalidFormatException();                  case 8:                      if (1 == meta.ColormapType)                          Format = PixelFormats.Indexed8;                      else                          Format = PixelFormats.Gray8;                      break;                  case 15: Format = PixelFormats.Bgr555; break;                  case 16: Format = PixelFormats.Bgr555; break;                  case 32: Format = PixelFormats.Bgra32; break;                  case 24:                      if (8 == (meta.Descriptor & 0xf))                          Format = PixelFormats.Bgr32;                      else                          Format = PixelFormats.Bgr24;                      break;                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Reader,The following statement contains a magic number: switch (meta.BPP)                  {                  default: throw new InvalidFormatException();                  case 8:                      if (1 == meta.ColormapType)                          Format = PixelFormats.Indexed8;                      else                          Format = PixelFormats.Gray8;                      break;                  case 15: Format = PixelFormats.Bgr555; break;                  case 16: Format = PixelFormats.Bgr555; break;                  case 32: Format = PixelFormats.Bgra32; break;                  case 24:                      if (8 == (meta.Descriptor & 0xf))                          Format = PixelFormats.Bgr32;                      else                          Format = PixelFormats.Bgr24;                      break;                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Reader,The following statement contains a magic number: switch (meta.BPP)                  {                  default: throw new InvalidFormatException();                  case 8:                      if (1 == meta.ColormapType)                          Format = PixelFormats.Indexed8;                      else                          Format = PixelFormats.Gray8;                      break;                  case 15: Format = PixelFormats.Bgr555; break;                  case 16: Format = PixelFormats.Bgr555; break;                  case 32: Format = PixelFormats.Bgra32; break;                  case 24:                      if (8 == (meta.Descriptor & 0xf))                          Format = PixelFormats.Bgr32;                      else                          Format = PixelFormats.Bgr24;                      break;                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Reader,The following statement contains a magic number: switch (meta.BPP)                  {                  default: throw new InvalidFormatException();                  case 8:                      if (1 == meta.ColormapType)                          Format = PixelFormats.Indexed8;                      else                          Format = PixelFormats.Gray8;                      break;                  case 15: Format = PixelFormats.Bgr555; break;                  case 16: Format = PixelFormats.Bgr555; break;                  case 32: Format = PixelFormats.Bgra32; break;                  case 24:                      if (8 == (meta.Descriptor & 0xf))                          Format = PixelFormats.Bgr32;                      else                          Format = PixelFormats.Bgr24;                      break;                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Reader,The following statement contains a magic number: int colormap_size = meta.ColormapLength * meta.ColormapDepth / 8;
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Reader,The following statement contains a magic number: m_stride = m_width * ((Format.BitsPerPixel+7) / 8);
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Reader,The following statement contains a magic number: m_stride = m_width * ((Format.BitsPerPixel+7) / 8);
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,ReadColormap,The following statement contains a magic number: if (24 != depth && 32 != depth)                      throw new NotImplementedException();
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,ReadColormap,The following statement contains a magic number: if (24 != depth && 32 != depth)                      throw new NotImplementedException();
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,ReadColormap,The following statement contains a magic number: int pixel_size = depth / 8;
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,ReadColormap,The following statement contains a magic number: for (int i = 0; i < palette.Length; ++i)                  {                      byte b = palette_data[i*pixel_size];                      byte g = palette_data[i*pixel_size+1];                      byte r = palette_data[i*pixel_size+2];                      palette[i] = Color.FromRgb (r' g' b);                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Unpack,The following statement contains a magic number: switch (m_meta.ImageType)                  {                  case 9:  // Runlength encoded color-mapped images.                  case 32: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.                  case 33: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.  4-pass quadtree-type process.                      throw new NotImplementedException();                  default:                      throw new InvalidFormatException();                  case 1:  // Uncompressed' color-mapped images.                  case 2:  // Uncompressed' RGB images.                  case 3:  // Uncompressed' black and white images.                      ReadRaw();                      break;                  case 10: // Runlength encoded RGB images.                  case 11: // Compressed' black and white images.                      ReadRLE ((m_meta.BPP+7)/8);                      break;                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Unpack,The following statement contains a magic number: switch (m_meta.ImageType)                  {                  case 9:  // Runlength encoded color-mapped images.                  case 32: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.                  case 33: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.  4-pass quadtree-type process.                      throw new NotImplementedException();                  default:                      throw new InvalidFormatException();                  case 1:  // Uncompressed' color-mapped images.                  case 2:  // Uncompressed' RGB images.                  case 3:  // Uncompressed' black and white images.                      ReadRaw();                      break;                  case 10: // Runlength encoded RGB images.                  case 11: // Compressed' black and white images.                      ReadRLE ((m_meta.BPP+7)/8);                      break;                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Unpack,The following statement contains a magic number: switch (m_meta.ImageType)                  {                  case 9:  // Runlength encoded color-mapped images.                  case 32: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.                  case 33: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.  4-pass quadtree-type process.                      throw new NotImplementedException();                  default:                      throw new InvalidFormatException();                  case 1:  // Uncompressed' color-mapped images.                  case 2:  // Uncompressed' RGB images.                  case 3:  // Uncompressed' black and white images.                      ReadRaw();                      break;                  case 10: // Runlength encoded RGB images.                  case 11: // Compressed' black and white images.                      ReadRLE ((m_meta.BPP+7)/8);                      break;                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Unpack,The following statement contains a magic number: switch (m_meta.ImageType)                  {                  case 9:  // Runlength encoded color-mapped images.                  case 32: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.                  case 33: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.  4-pass quadtree-type process.                      throw new NotImplementedException();                  default:                      throw new InvalidFormatException();                  case 1:  // Uncompressed' color-mapped images.                  case 2:  // Uncompressed' RGB images.                  case 3:  // Uncompressed' black and white images.                      ReadRaw();                      break;                  case 10: // Runlength encoded RGB images.                  case 11: // Compressed' black and white images.                      ReadRLE ((m_meta.BPP+7)/8);                      break;                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Unpack,The following statement contains a magic number: switch (m_meta.ImageType)                  {                  case 9:  // Runlength encoded color-mapped images.                  case 32: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.                  case 33: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.  4-pass quadtree-type process.                      throw new NotImplementedException();                  default:                      throw new InvalidFormatException();                  case 1:  // Uncompressed' color-mapped images.                  case 2:  // Uncompressed' RGB images.                  case 3:  // Uncompressed' black and white images.                      ReadRaw();                      break;                  case 10: // Runlength encoded RGB images.                  case 11: // Compressed' black and white images.                      ReadRLE ((m_meta.BPP+7)/8);                      break;                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Unpack,The following statement contains a magic number: switch (m_meta.ImageType)                  {                  case 9:  // Runlength encoded color-mapped images.                  case 32: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.                  case 33: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.  4-pass quadtree-type process.                      throw new NotImplementedException();                  default:                      throw new InvalidFormatException();                  case 1:  // Uncompressed' color-mapped images.                  case 2:  // Uncompressed' RGB images.                  case 3:  // Uncompressed' black and white images.                      ReadRaw();                      break;                  case 10: // Runlength encoded RGB images.                  case 11: // Compressed' black and white images.                      ReadRLE ((m_meta.BPP+7)/8);                      break;                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Unpack,The following statement contains a magic number: switch (m_meta.ImageType)                  {                  case 9:  // Runlength encoded color-mapped images.                  case 32: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.                  case 33: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.  4-pass quadtree-type process.                      throw new NotImplementedException();                  default:                      throw new InvalidFormatException();                  case 1:  // Uncompressed' color-mapped images.                  case 2:  // Uncompressed' RGB images.                  case 3:  // Uncompressed' black and white images.                      ReadRaw();                      break;                  case 10: // Runlength encoded RGB images.                  case 11: // Compressed' black and white images.                      ReadRLE ((m_meta.BPP+7)/8);                      break;                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Unpack,The following statement contains a magic number: switch (m_meta.ImageType)                  {                  case 9:  // Runlength encoded color-mapped images.                  case 32: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.                  case 33: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.  4-pass quadtree-type process.                      throw new NotImplementedException();                  default:                      throw new InvalidFormatException();                  case 1:  // Uncompressed' color-mapped images.                  case 2:  // Uncompressed' RGB images.                  case 3:  // Uncompressed' black and white images.                      ReadRaw();                      break;                  case 10: // Runlength encoded RGB images.                  case 11: // Compressed' black and white images.                      ReadRLE ((m_meta.BPP+7)/8);                      break;                  }
Magic Number,GameRes,Reader,C:\repos\morkt_GARbro\GameRes\ArcView.cs,Unpack,The following statement contains a magic number: switch (m_meta.ImageType)                  {                  case 9:  // Runlength encoded color-mapped images.                  case 32: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.                  case 33: // Compressed color-mapped data' using Huffman' Delta' and                          // runlength encoding.  4-pass quadtree-type process.                      throw new NotImplementedException();                  default:                      throw new InvalidFormatException();                  case 1:  // Uncompressed' color-mapped images.                  case 2:  // Uncompressed' RGB images.                  case 3:  // Uncompressed' black and white images.                      ReadRaw();                      break;                  case 10: // Runlength encoded RGB images.                  case 11: // Compressed' black and white images.                      ReadRLE ((m_meta.BPP+7)/8);                      break;                  }
Magic Number,GameRes,WaveFormat,C:\repos\morkt_GARbro\GameRes\Audio.cs,SetBPS,The following statement contains a magic number: AverageBytesPerSecond = (uint)(SamplesPerSecond * Channels * BitsPerSample / 8);
Magic Number,GameRes,WaveAudio,C:\repos\morkt_GARbro\GameRes\AudioWAV.cs,TryOpen,The following statement contains a magic number: var header = file.ReadHeader (12);
Magic Number,GameRes,WaveAudio,C:\repos\morkt_GARbro\GameRes\AudioWAV.cs,TryOpen,The following statement contains a magic number: if (!header.AsciiEqual (8' "WAVE"))                  return null;
Magic Number,GameRes,BinaryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,BinaryStream,The following statement contains a magic number: if (!m_source.CanSeek)              {                  m_buffer_end = m_source.Read (m_buffer' 0' 4);                  uint signature = LittleEndian.ToUInt32 (m_buffer' 0);                  m_signature = new Lazy<uint> (() => signature);              }              else              {                  m_signature = new Lazy<uint> (ReadSignature);              }
Magic Number,GameRes,BinaryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadSignature,The following statement contains a magic number: if (m_header_size >= 4)              {                  return LittleEndian.ToUInt32 (m_header' 0);              }
Magic Number,GameRes,BinaryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt16,The following statement contains a magic number: if (2 != FillBuffer (2))                  throw new EndOfStreamException();
Magic Number,GameRes,BinaryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt16,The following statement contains a magic number: if (2 != FillBuffer (2))                  throw new EndOfStreamException();
Magic Number,GameRes,BinaryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt16,The following statement contains a magic number: m_buffer_pos += 2;
Magic Number,GameRes,BinaryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt24,The following statement contains a magic number: if (3 != FillBuffer (3))                  throw new EndOfStreamException();
Magic Number,GameRes,BinaryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt24,The following statement contains a magic number: if (3 != FillBuffer (3))                  throw new EndOfStreamException();
Magic Number,GameRes,BinaryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt24,The following statement contains a magic number: m_buffer_pos += 3;
Magic Number,GameRes,BinaryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt32,The following statement contains a magic number: if (4 != FillBuffer (4))                  throw new EndOfStreamException();
Magic Number,GameRes,BinaryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt32,The following statement contains a magic number: if (4 != FillBuffer (4))                  throw new EndOfStreamException();
Magic Number,GameRes,BinaryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt32,The following statement contains a magic number: m_buffer_pos += 4;
Magic Number,GameRes,BinaryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt64,The following statement contains a magic number: if (8 != FillBuffer (8))                  throw new EndOfStreamException();
Magic Number,GameRes,BinaryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt64,The following statement contains a magic number: if (8 != FillBuffer (8))                  throw new EndOfStreamException();
Magic Number,GameRes,BinaryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt64,The following statement contains a magic number: m_buffer_pos += 8;
Magic Number,GameRes,BinMemoryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,Init,The following statement contains a magic number: if (m_length >= 4)                  m_signature = LittleEndian.ToUInt32 (m_source' m_start);
Magic Number,GameRes,BinMemoryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt16,The following statement contains a magic number: if (m_length - m_position < 2)                  throw new EndOfStreamException();
Magic Number,GameRes,BinMemoryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt16,The following statement contains a magic number: m_position += 2;
Magic Number,GameRes,BinMemoryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt24,The following statement contains a magic number: if (m_length - m_position < 3)                  throw new EndOfStreamException();
Magic Number,GameRes,BinMemoryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt24,The following statement contains a magic number: m_position += 3;
Magic Number,GameRes,BinMemoryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt32,The following statement contains a magic number: if (m_length - m_position < 4)                  throw new EndOfStreamException();
Magic Number,GameRes,BinMemoryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt32,The following statement contains a magic number: m_position += 4;
Magic Number,GameRes,BinMemoryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt64,The following statement contains a magic number: if (m_length - m_position < 8)                  throw new EndOfStreamException();
Magic Number,GameRes,BinMemoryStream,C:\repos\morkt_GARbro\GameRes\BinaryStream.cs,ReadInt64,The following statement contains a magic number: m_position += 8;
Magic Number,GameRes,ByteArrayExt,C:\repos\morkt_GARbro\GameRes\ByteArray.cs,ToUInt16,The following statement contains a magic number: return (ushort)(arr[index] | arr[index+1] << 8);
Magic Number,GameRes,ByteArrayExt,C:\repos\morkt_GARbro\GameRes\ByteArray.cs,ToInt16,The following statement contains a magic number: return (short)(arr[index] | arr[index+1] << 8);
Magic Number,GameRes,ByteArrayExt,C:\repos\morkt_GARbro\GameRes\ByteArray.cs,ToInt24,The following statement contains a magic number: return arr[index] | arr[index+1] << 8 | arr[index+2] << 16;
Magic Number,GameRes,ByteArrayExt,C:\repos\morkt_GARbro\GameRes\ByteArray.cs,ToInt24,The following statement contains a magic number: return arr[index] | arr[index+1] << 8 | arr[index+2] << 16;
Magic Number,GameRes,ByteArrayExt,C:\repos\morkt_GARbro\GameRes\ByteArray.cs,ToInt24,The following statement contains a magic number: return arr[index] | arr[index+1] << 8 | arr[index+2] << 16;
Magic Number,GameRes,ByteArrayExt,C:\repos\morkt_GARbro\GameRes\ByteArray.cs,ToUInt32,The following statement contains a magic number: return (uint)(arr[index] | arr[index+1] << 8 | arr[index+2] << 16 | arr[index+3] << 24);
Magic Number,GameRes,ByteArrayExt,C:\repos\morkt_GARbro\GameRes\ByteArray.cs,ToUInt32,The following statement contains a magic number: return (uint)(arr[index] | arr[index+1] << 8 | arr[index+2] << 16 | arr[index+3] << 24);
Magic Number,GameRes,ByteArrayExt,C:\repos\morkt_GARbro\GameRes\ByteArray.cs,ToUInt32,The following statement contains a magic number: return (uint)(arr[index] | arr[index+1] << 8 | arr[index+2] << 16 | arr[index+3] << 24);
Magic Number,GameRes,ByteArrayExt,C:\repos\morkt_GARbro\GameRes\ByteArray.cs,ToUInt32,The following statement contains a magic number: return (uint)(arr[index] | arr[index+1] << 8 | arr[index+2] << 16 | arr[index+3] << 24);
Magic Number,GameRes,ByteArrayExt,C:\repos\morkt_GARbro\GameRes\ByteArray.cs,ToUInt32,The following statement contains a magic number: return (uint)(arr[index] | arr[index+1] << 8 | arr[index+2] << 16 | arr[index+3] << 24);
Magic Number,GameRes,ByteArrayExt,C:\repos\morkt_GARbro\GameRes\ByteArray.cs,ToUInt64,The following statement contains a magic number: return (ulong)ToUInt32 (arr' index) | ((ulong)ToUInt32 (arr' index+4) << 32);
Magic Number,GameRes,ByteArrayExt,C:\repos\morkt_GARbro\GameRes\ByteArray.cs,ToUInt64,The following statement contains a magic number: return (ulong)ToUInt32 (arr' index) | ((ulong)ToUInt32 (arr' index+4) << 32);
Magic Number,GameRes,TreeArchiveFileSystem,C:\repos\morkt_GARbro\GameRes\FileSystem.cs,GetFiles,The following statement contains a magic number: foreach (var entry in dir)              {                  var match = path_re.Match (entry.Name' root_dir.Length);                  if (match.Success)                  {                      string name = match.Groups[1].Value;                      if (subdirs.Add (name))                      {                          PathDelimiter = match.Groups[2].Value;                          yield return new SubDirEntry (root_dir+name);                      }                  }                  else                  {                      yield return entry;                  }              }
Magic Number,GameRes,FileNameGlob,C:\repos\morkt_GARbro\GameRes\FileSystem.cs,FileNameGlob,The following statement contains a magic number: if (pattern.EndsWith (@"\.\*")) // "*" and "*.*" are equivalent                  pattern = pattern.Remove (pattern.Length-4) + @"(?:\..*)?";
Magic Number,GameRes,FormatCatalog,C:\repos\morkt_GARbro\GameRes\FormatCatalog.cs,ReadSignature,The following statement contains a magic number: signature |= (uint)file.ReadByte() << 8;
Magic Number,GameRes,FormatCatalog,C:\repos\morkt_GARbro\GameRes\FormatCatalog.cs,ReadSignature,The following statement contains a magic number: signature |= (uint)file.ReadByte() << 16;
Magic Number,GameRes,FormatCatalog,C:\repos\morkt_GARbro\GameRes\FormatCatalog.cs,ReadSignature,The following statement contains a magic number: signature |= (uint)file.ReadByte() << 24;
Magic Number,GameRes,ImageData,C:\repos\morkt_GARbro\GameRes\Image.cs,ImageData,The following statement contains a magic number: SetDefaultDpi (96' 96);
Magic Number,GameRes,ImageData,C:\repos\morkt_GARbro\GameRes\Image.cs,ImageData,The following statement contains a magic number: SetDefaultDpi (96' 96);
Magic Number,GameRes,ImageData,C:\repos\morkt_GARbro\GameRes\Image.cs,Create,The following statement contains a magic number: return Create (info' format' palette' pixel_data' (int)info.Width*((format.BitsPerPixel+7)/8));
Magic Number,GameRes,ImageData,C:\repos\morkt_GARbro\GameRes\Image.cs,Create,The following statement contains a magic number: return Create (info' format' palette' pixel_data' (int)info.Width*((format.BitsPerPixel+7)/8));
Magic Number,GameRes,ImageFormat,C:\repos\morkt_GARbro\GameRes\Image.cs,ReadColorMap,The following statement contains a magic number: int bpp = PaletteFormat.Rgb == format || PaletteFormat.Bgr == format ? 3 : 4;
Magic Number,GameRes,ImageFormat,C:\repos\morkt_GARbro\GameRes\Image.cs,ReadColorMap,The following statement contains a magic number: int bpp = PaletteFormat.Rgb == format || PaletteFormat.Bgr == format ? 3 : 4;
Magic Number,GameRes,ImageFormat,C:\repos\morkt_GARbro\GameRes\Image.cs,ReadColorMap,The following statement contains a magic number: if (PaletteFormat.Bgr == format || PaletteFormat.BgrX == format)                  get_color = x => Color.FromRgb (palette_data[x+2]' palette_data[x+1]' palette_data[x]);              else if (PaletteFormat.BgrA == format)                  get_color = x => Color.FromArgb (palette_data[x+3]' palette_data[x+2]' palette_data[x+1]' palette_data[x]);              else if (PaletteFormat.RgbA == format)                  get_color = x => Color.FromArgb (palette_data[x+3]' palette_data[x]' palette_data[x+1]' palette_data[x+2]);              else                  get_color = x => Color.FromRgb (palette_data[x]'   palette_data[x+1]' palette_data[x+2]);
Magic Number,GameRes,ImageFormat,C:\repos\morkt_GARbro\GameRes\Image.cs,ReadColorMap,The following statement contains a magic number: if (PaletteFormat.Bgr == format || PaletteFormat.BgrX == format)                  get_color = x => Color.FromRgb (palette_data[x+2]' palette_data[x+1]' palette_data[x]);              else if (PaletteFormat.BgrA == format)                  get_color = x => Color.FromArgb (palette_data[x+3]' palette_data[x+2]' palette_data[x+1]' palette_data[x]);              else if (PaletteFormat.RgbA == format)                  get_color = x => Color.FromArgb (palette_data[x+3]' palette_data[x]' palette_data[x+1]' palette_data[x+2]);              else                  get_color = x => Color.FromRgb (palette_data[x]'   palette_data[x+1]' palette_data[x+2]);
Magic Number,GameRes,ImageFormat,C:\repos\morkt_GARbro\GameRes\Image.cs,ReadColorMap,The following statement contains a magic number: if (PaletteFormat.Bgr == format || PaletteFormat.BgrX == format)                  get_color = x => Color.FromRgb (palette_data[x+2]' palette_data[x+1]' palette_data[x]);              else if (PaletteFormat.BgrA == format)                  get_color = x => Color.FromArgb (palette_data[x+3]' palette_data[x+2]' palette_data[x+1]' palette_data[x]);              else if (PaletteFormat.RgbA == format)                  get_color = x => Color.FromArgb (palette_data[x+3]' palette_data[x]' palette_data[x+1]' palette_data[x+2]);              else                  get_color = x => Color.FromRgb (palette_data[x]'   palette_data[x+1]' palette_data[x+2]);
Magic Number,GameRes,ImageFormat,C:\repos\morkt_GARbro\GameRes\Image.cs,ReadColorMap,The following statement contains a magic number: if (PaletteFormat.Bgr == format || PaletteFormat.BgrX == format)                  get_color = x => Color.FromRgb (palette_data[x+2]' palette_data[x+1]' palette_data[x]);              else if (PaletteFormat.BgrA == format)                  get_color = x => Color.FromArgb (palette_data[x+3]' palette_data[x+2]' palette_data[x+1]' palette_data[x]);              else if (PaletteFormat.RgbA == format)                  get_color = x => Color.FromArgb (palette_data[x+3]' palette_data[x]' palette_data[x+1]' palette_data[x+2]);              else                  get_color = x => Color.FromRgb (palette_data[x]'   palette_data[x+1]' palette_data[x+2]);
Magic Number,GameRes,ImageFormat,C:\repos\morkt_GARbro\GameRes\Image.cs,ReadColorMap,The following statement contains a magic number: if (PaletteFormat.Bgr == format || PaletteFormat.BgrX == format)                  get_color = x => Color.FromRgb (palette_data[x+2]' palette_data[x+1]' palette_data[x]);              else if (PaletteFormat.BgrA == format)                  get_color = x => Color.FromArgb (palette_data[x+3]' palette_data[x+2]' palette_data[x+1]' palette_data[x]);              else if (PaletteFormat.RgbA == format)                  get_color = x => Color.FromArgb (palette_data[x+3]' palette_data[x]' palette_data[x+1]' palette_data[x+2]);              else                  get_color = x => Color.FromRgb (palette_data[x]'   palette_data[x+1]' palette_data[x+2]);
Magic Number,GameRes,ImageFormat,C:\repos\morkt_GARbro\GameRes\Image.cs,ReadColorMap,The following statement contains a magic number: if (PaletteFormat.Bgr == format || PaletteFormat.BgrX == format)                  get_color = x => Color.FromRgb (palette_data[x+2]' palette_data[x+1]' palette_data[x]);              else if (PaletteFormat.BgrA == format)                  get_color = x => Color.FromArgb (palette_data[x+3]' palette_data[x+2]' palette_data[x+1]' palette_data[x]);              else if (PaletteFormat.RgbA == format)                  get_color = x => Color.FromArgb (palette_data[x+3]' palette_data[x]' palette_data[x+1]' palette_data[x+2]);              else                  get_color = x => Color.FromRgb (palette_data[x]'   palette_data[x+1]' palette_data[x+2]);
Magic Number,GameRes,ImageFormat,C:\repos\morkt_GARbro\GameRes\Image.cs,ReadPalette,The following statement contains a magic number: using (var input = file.CreateStream (offset' (uint)(4 * colors))) // largest possible size for palette                  return ReadPalette (input' colors' format);
Magic Number,GameRes,BmpFormat,C:\repos\morkt_GARbro\GameRes\ImageBMP.cs,SkipBytes,The following statement contains a magic number: if (file.AsStream.CanSeek)                  file.Seek (num' SeekOrigin.Current);              else              {                  for (int i = 0; i < num / 4; ++i)                      file.ReadInt32();                  for (int i = 0; i < num % 4; ++i)                      file.ReadByte();              }
Magic Number,GameRes,BmpFormat,C:\repos\morkt_GARbro\GameRes\ImageBMP.cs,SkipBytes,The following statement contains a magic number: if (file.AsStream.CanSeek)                  file.Seek (num' SeekOrigin.Current);              else              {                  for (int i = 0; i < num / 4; ++i)                      file.ReadInt32();                  for (int i = 0; i < num % 4; ++i)                      file.ReadByte();              }
Magic Number,GameRes,BmpFormat,C:\repos\morkt_GARbro\GameRes\ImageBMP.cs,ReadMetaData,The following statement contains a magic number: if (size < 14+header_size)              {                  // some otherwise valid bitmaps have size field set to zero                  if (size != 0 || !file.AsStream.CanSeek)                      return null;                  size = (uint)file.Length;              }
Magic Number,GameRes,BmpFormat,C:\repos\morkt_GARbro\GameRes\ImageBMP.cs,ReadMetaData,The following statement contains a magic number: if (0xC == header_size)              {                  width  = file.ReadUInt16();                  height = file.ReadUInt16();              }              else if (header_size < 40 || size-14 < header_size)              {                  return null;              }              else              {                  width  = file.ReadUInt32();                  height = file.ReadUInt32();              }
Magic Number,GameRes,BmpFormat,C:\repos\morkt_GARbro\GameRes\ImageBMP.cs,ReadMetaData,The following statement contains a magic number: if (0xC == header_size)              {                  width  = file.ReadUInt16();                  height = file.ReadUInt16();              }              else if (header_size < 40 || size-14 < header_size)              {                  return null;              }              else              {                  width  = file.ReadUInt32();                  height = file.ReadUInt32();              }
Magic Number,GameRes,BitmapWithAlpha,C:\repos\morkt_GARbro\GameRes\ImageBMP.cs,Read,The following statement contains a magic number: if (file.AsStream.CanSeek)              {                  var width_x_height = info.Width * info.Height;                  uint bmp_length = width_x_height * (uint)info.BPP/8 + info.ImageOffset;                  if (bmp_length == info.ImageLength || bmp_length+2 == info.ImageLength)                  {                      if (0x20 == info.BPP)                      {                          return ReadBitmapBGRA (file' info);                      }                      else if (0x18 == info.BPP && (info.ImageLength + width_x_height) == file.Length)                      {                          return ReadBitmapWithAlpha (file' info);                      }                  }              }
Magic Number,GameRes,BitmapWithAlpha,C:\repos\morkt_GARbro\GameRes\ImageBMP.cs,Read,The following statement contains a magic number: if (file.AsStream.CanSeek)              {                  var width_x_height = info.Width * info.Height;                  uint bmp_length = width_x_height * (uint)info.BPP/8 + info.ImageOffset;                  if (bmp_length == info.ImageLength || bmp_length+2 == info.ImageLength)                  {                      if (0x20 == info.BPP)                      {                          return ReadBitmapBGRA (file' info);                      }                      else if (0x18 == info.BPP && (info.ImageLength + width_x_height) == file.Length)                      {                          return ReadBitmapWithAlpha (file' info);                      }                  }              }
Magic Number,GameRes,BitmapWithAlpha,C:\repos\morkt_GARbro\GameRes\ImageBMP.cs,ReadBitmapWithAlpha,The following statement contains a magic number: int dst_stride = (int)info.Width * 4;
Magic Number,GameRes,BitmapWithAlpha,C:\repos\morkt_GARbro\GameRes\ImageBMP.cs,ReadBitmapWithAlpha,The following statement contains a magic number: for (int y = (int)info.Height-1; y >= 0; --y)              {                  int dst = dst_stride * y;                  for (int x = 0; x < dst_stride; x += 4)                  {                      file.Read (pixels' dst+x' 3);                      pixels[dst+x+3] = alpha[a_src++];                  }              }
Magic Number,GameRes,BitmapWithAlpha,C:\repos\morkt_GARbro\GameRes\ImageBMP.cs,ReadBitmapWithAlpha,The following statement contains a magic number: for (int y = (int)info.Height-1; y >= 0; --y)              {                  int dst = dst_stride * y;                  for (int x = 0; x < dst_stride; x += 4)                  {                      file.Read (pixels' dst+x' 3);                      pixels[dst+x+3] = alpha[a_src++];                  }              }
Magic Number,GameRes,BitmapWithAlpha,C:\repos\morkt_GARbro\GameRes\ImageBMP.cs,ReadBitmapWithAlpha,The following statement contains a magic number: for (int y = (int)info.Height-1; y >= 0; --y)              {                  int dst = dst_stride * y;                  for (int x = 0; x < dst_stride; x += 4)                  {                      file.Read (pixels' dst+x' 3);                      pixels[dst+x+3] = alpha[a_src++];                  }              }
Magic Number,GameRes,BitmapWithAlpha,C:\repos\morkt_GARbro\GameRes\ImageBMP.cs,ReadBitmapBGRA,The following statement contains a magic number: int stride = (int)info.Width * 4;
Magic Number,GameRes,BitmapWithAlpha,C:\repos\morkt_GARbro\GameRes\ImageBMP.cs,ReadBitmapBGRA,The following statement contains a magic number: for (int y = (int)info.Height-1; y >= 0; --y)              {                  int dst = stride * y;                  file.Read (pixels' dst' stride);                  for (int x = 3; !has_alpha && x < stride; x += 4)                      has_alpha = pixels[dst+x] != 0;              }
Magic Number,GameRes,BitmapWithAlpha,C:\repos\morkt_GARbro\GameRes\ImageBMP.cs,ReadBitmapBGRA,The following statement contains a magic number: for (int y = (int)info.Height-1; y >= 0; --y)              {                  int dst = stride * y;                  file.Read (pixels' dst' stride);                  for (int x = 3; !has_alpha && x < stride; x += 4)                      has_alpha = pixels[dst+x] != 0;              }
Magic Number,GameRes,JpegFormat,C:\repos\morkt_GARbro\GameRes\ImageJPEG.cs,JpegFormat,The following statement contains a magic number: Quality = 100;
Magic Number,GameRes,JpegFormat,C:\repos\morkt_GARbro\GameRes\ImageJPEG.cs,ReadMetaData,The following statement contains a magic number: while (-1 != file.PeekByte())              {                  ushort marker = Binary.BigEndian (file.ReadUInt16());                  if ((marker & 0xff00) != 0xff00)                      break;                  int length = Binary.BigEndian (file.ReadUInt16());                  if ((marker & 0x00f0) == 0xc0 && marker != 0xffc4)                  {                      if (length < 8)                          break;                      int bits = file.ReadByte();                      uint height = Binary.BigEndian (file.ReadUInt16());                      uint width  = Binary.BigEndian (file.ReadUInt16());                      int components = file.ReadByte();                      return new ImageMetaData {                          Width = width'                          Height = height'                          BPP = bits * components'                      };                  }                  file.Seek (length-2' SeekOrigin.Current);              }
Magic Number,GameRes,JpegFormat,C:\repos\morkt_GARbro\GameRes\ImageJPEG.cs,ReadMetaData,The following statement contains a magic number: while (-1 != file.PeekByte())              {                  ushort marker = Binary.BigEndian (file.ReadUInt16());                  if ((marker & 0xff00) != 0xff00)                      break;                  int length = Binary.BigEndian (file.ReadUInt16());                  if ((marker & 0x00f0) == 0xc0 && marker != 0xffc4)                  {                      if (length < 8)                          break;                      int bits = file.ReadByte();                      uint height = Binary.BigEndian (file.ReadUInt16());                      uint width  = Binary.BigEndian (file.ReadUInt16());                      int components = file.ReadByte();                      return new ImageMetaData {                          Width = width'                          Height = height'                          BPP = bits * components'                      };                  }                  file.Seek (length-2' SeekOrigin.Current);              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,Write,The following statement contains a magic number: using (var mem_stream = new MemoryStream())              {                  encoder.Save (mem_stream);                  byte[] buf = mem_stream.GetBuffer();                  long header_pos = 8;                  mem_stream.Position = header_pos;                  uint header_length = ReadChunkLength (mem_stream);                  file.Write (buf' 0' (int)(header_pos+header_length+12));                  WriteOffsChunk (file' image);                  mem_stream.Position = header_pos+header_length+12;                  mem_stream.CopyTo (file);              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,Write,The following statement contains a magic number: using (var mem_stream = new MemoryStream())              {                  encoder.Save (mem_stream);                  byte[] buf = mem_stream.GetBuffer();                  long header_pos = 8;                  mem_stream.Position = header_pos;                  uint header_length = ReadChunkLength (mem_stream);                  file.Write (buf' 0' (int)(header_pos+header_length+12));                  WriteOffsChunk (file' image);                  mem_stream.Position = header_pos+header_length+12;                  mem_stream.CopyTo (file);              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,Write,The following statement contains a magic number: using (var mem_stream = new MemoryStream())              {                  encoder.Save (mem_stream);                  byte[] buf = mem_stream.GetBuffer();                  long header_pos = 8;                  mem_stream.Position = header_pos;                  uint header_length = ReadChunkLength (mem_stream);                  file.Write (buf' 0' (int)(header_pos+header_length+12));                  WriteOffsChunk (file' image);                  mem_stream.Position = header_pos+header_length+12;                  mem_stream.CopyTo (file);              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadChunkLength,The following statement contains a magic number: int length = file.ReadByte() << 24;
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadChunkLength,The following statement contains a magic number: length |= file.ReadByte() << 16;
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadChunkLength,The following statement contains a magic number: length |= file.ReadByte() << 8;
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,WriteOffsChunk,The following statement contains a magic number: using (var membuf = new MemoryStream (32))              {                  using (var bin = new BinaryWriter (membuf' Encoding.ASCII' true))                  {                      bin.Write (Binary.BigEndian ((uint)9));                      char[] tag = { 'o'' 'F'' 'F'' 's' };                      bin.Write (tag);                      bin.Write (Binary.BigEndian ((uint)image.OffsetX));                      bin.Write (Binary.BigEndian ((uint)image.OffsetY));                      bin.Write ((byte)0);                      bin.Flush();                      uint crc = Crc32.Compute (membuf.GetBuffer()' 4' 13);                      bin.Write (Binary.BigEndian (crc));                  }                  file.Write (membuf.GetBuffer()' 0' 9+12); // chunk + size+id+crc              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,WriteOffsChunk,The following statement contains a magic number: using (var membuf = new MemoryStream (32))              {                  using (var bin = new BinaryWriter (membuf' Encoding.ASCII' true))                  {                      bin.Write (Binary.BigEndian ((uint)9));                      char[] tag = { 'o'' 'F'' 'F'' 's' };                      bin.Write (tag);                      bin.Write (Binary.BigEndian ((uint)image.OffsetX));                      bin.Write (Binary.BigEndian ((uint)image.OffsetY));                      bin.Write ((byte)0);                      bin.Flush();                      uint crc = Crc32.Compute (membuf.GetBuffer()' 4' 13);                      bin.Write (Binary.BigEndian (crc));                  }                  file.Write (membuf.GetBuffer()' 0' 9+12); // chunk + size+id+crc              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,WriteOffsChunk,The following statement contains a magic number: using (var membuf = new MemoryStream (32))              {                  using (var bin = new BinaryWriter (membuf' Encoding.ASCII' true))                  {                      bin.Write (Binary.BigEndian ((uint)9));                      char[] tag = { 'o'' 'F'' 'F'' 's' };                      bin.Write (tag);                      bin.Write (Binary.BigEndian ((uint)image.OffsetX));                      bin.Write (Binary.BigEndian ((uint)image.OffsetY));                      bin.Write ((byte)0);                      bin.Flush();                      uint crc = Crc32.Compute (membuf.GetBuffer()' 4' 13);                      bin.Write (Binary.BigEndian (crc));                  }                  file.Write (membuf.GetBuffer()' 0' 9+12); // chunk + size+id+crc              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,WriteOffsChunk,The following statement contains a magic number: using (var membuf = new MemoryStream (32))              {                  using (var bin = new BinaryWriter (membuf' Encoding.ASCII' true))                  {                      bin.Write (Binary.BigEndian ((uint)9));                      char[] tag = { 'o'' 'F'' 'F'' 's' };                      bin.Write (tag);                      bin.Write (Binary.BigEndian ((uint)image.OffsetX));                      bin.Write (Binary.BigEndian ((uint)image.OffsetY));                      bin.Write ((byte)0);                      bin.Flush();                      uint crc = Crc32.Compute (membuf.GetBuffer()' 4' 13);                      bin.Write (Binary.BigEndian (crc));                  }                  file.Write (membuf.GetBuffer()' 0' 9+12); // chunk + size+id+crc              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,WriteOffsChunk,The following statement contains a magic number: using (var membuf = new MemoryStream (32))              {                  using (var bin = new BinaryWriter (membuf' Encoding.ASCII' true))                  {                      bin.Write (Binary.BigEndian ((uint)9));                      char[] tag = { 'o'' 'F'' 'F'' 's' };                      bin.Write (tag);                      bin.Write (Binary.BigEndian ((uint)image.OffsetX));                      bin.Write (Binary.BigEndian ((uint)image.OffsetY));                      bin.Write ((byte)0);                      bin.Flush();                      uint crc = Crc32.Compute (membuf.GetBuffer()' 4' 13);                      bin.Write (Binary.BigEndian (crc));                  }                  file.Write (membuf.GetBuffer()' 0' 9+12); // chunk + size+id+crc              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,WriteOffsChunk,The following statement contains a magic number: using (var membuf = new MemoryStream (32))              {                  using (var bin = new BinaryWriter (membuf' Encoding.ASCII' true))                  {                      bin.Write (Binary.BigEndian ((uint)9));                      char[] tag = { 'o'' 'F'' 'F'' 's' };                      bin.Write (tag);                      bin.Write (Binary.BigEndian ((uint)image.OffsetX));                      bin.Write (Binary.BigEndian ((uint)image.OffsetY));                      bin.Write ((byte)0);                      bin.Flush();                      uint crc = Crc32.Compute (membuf.GetBuffer()' 4' 13);                      bin.Write (Binary.BigEndian (crc));                  }                  file.Write (membuf.GetBuffer()' 0' 9+12); // chunk + size+id+crc              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,SkipBytes,The following statement contains a magic number: if (file.CanSeek)                  file.Seek (num' SeekOrigin.Current);              else              {                  for (int i = 0; i < num / 4; ++i)                      file.ReadInt32();                  for (int i = 0; i < num % 4; ++i)                      file.ReadByte();              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,SkipBytes,The following statement contains a magic number: if (file.CanSeek)                  file.Seek (num' SeekOrigin.Current);              else              {                  for (int i = 0; i < num / 4; ++i)                      file.ReadInt32();                  for (int i = 0; i < num % 4; ++i)                      file.ReadByte();              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: byte[] chunk_type = file.ReadBytes (4);
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: if (bpp != 1 && bpp != 2 && bpp != 4 && bpp != 8 && bpp != 16)                  return null;
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: if (bpp != 1 && bpp != 2 && bpp != 4 && bpp != 8 && bpp != 16)                  return null;
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: if (bpp != 1 && bpp != 2 && bpp != 4 && bpp != 8 && bpp != 16)                  return null;
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: if (bpp != 1 && bpp != 2 && bpp != 4 && bpp != 8 && bpp != 16)                  return null;
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: switch (color_type)              {              case 2: meta.BPP = bpp*3; break;              case 3: meta.BPP = 24; break;              case 4: meta.BPP = bpp*2; break;              case 6: meta.BPP = bpp*4; break;              case 0: meta.BPP = bpp; break;              default: return null;              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: switch (color_type)              {              case 2: meta.BPP = bpp*3; break;              case 3: meta.BPP = 24; break;              case 4: meta.BPP = bpp*2; break;              case 6: meta.BPP = bpp*4; break;              case 0: meta.BPP = bpp; break;              default: return null;              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: switch (color_type)              {              case 2: meta.BPP = bpp*3; break;              case 3: meta.BPP = 24; break;              case 4: meta.BPP = bpp*2; break;              case 6: meta.BPP = bpp*4; break;              case 0: meta.BPP = bpp; break;              default: return null;              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: switch (color_type)              {              case 2: meta.BPP = bpp*3; break;              case 3: meta.BPP = 24; break;              case 4: meta.BPP = bpp*2; break;              case 6: meta.BPP = bpp*4; break;              case 0: meta.BPP = bpp; break;              default: return null;              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: switch (color_type)              {              case 2: meta.BPP = bpp*3; break;              case 3: meta.BPP = 24; break;              case 4: meta.BPP = bpp*2; break;              case 6: meta.BPP = bpp*4; break;              case 0: meta.BPP = bpp; break;              default: return null;              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: switch (color_type)              {              case 2: meta.BPP = bpp*3; break;              case 3: meta.BPP = 24; break;              case 4: meta.BPP = bpp*2; break;              case 6: meta.BPP = bpp*4; break;              case 0: meta.BPP = bpp; break;              default: return null;              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: switch (color_type)              {              case 2: meta.BPP = bpp*3; break;              case 3: meta.BPP = 24; break;              case 4: meta.BPP = bpp*2; break;              case 6: meta.BPP = bpp*4; break;              case 0: meta.BPP = bpp; break;              default: return null;              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: switch (color_type)              {              case 2: meta.BPP = bpp*3; break;              case 3: meta.BPP = 24; break;              case 4: meta.BPP = bpp*2; break;              case 6: meta.BPP = bpp*4; break;              case 0: meta.BPP = bpp; break;              default: return null;              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: SkipBytes (file' 7);
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  chunk_size = Binary.BigEndian (file.ReadUInt32());                  file.Read (chunk_type' 0' 4);                  if (Binary.AsciiEqual (chunk_type' "IDAT") || Binary.AsciiEqual (chunk_type' "IEND"))                      break;                  if (Binary.AsciiEqual (chunk_type' "oFFs"))                  {                      int x = Binary.BigEndian (file.ReadInt32());                      int y = Binary.BigEndian (file.ReadInt32());                      if (0 == file.ReadByte())                      {                          meta.OffsetX = x;                          meta.OffsetY = y;                      }                      break;                  }                  SkipBytes (file' chunk_size+4);              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,ReadMetaData,The following statement contains a magic number: for (;;)              {                  chunk_size = Binary.BigEndian (file.ReadUInt32());                  file.Read (chunk_type' 0' 4);                  if (Binary.AsciiEqual (chunk_type' "IDAT") || Binary.AsciiEqual (chunk_type' "IEND"))                      break;                  if (Binary.AsciiEqual (chunk_type' "oFFs"))                  {                      int x = Binary.BigEndian (file.ReadInt32());                      int y = Binary.BigEndian (file.ReadInt32());                      if (0 == file.ReadByte())                      {                          meta.OffsetX = x;                          meta.OffsetY = y;                      }                      break;                  }                  SkipBytes (file' chunk_size+4);              }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,FindChunk,The following statement contains a magic number: try              {                  var buf = new byte[4];                  file.Position = 8;                  while (-1 != file.PeekByte())                  {                      long chunk_offset = file.Position;                      uint chunk_size = Binary.BigEndian (file.ReadUInt32());                      if (4 != file.Read (buf' 0' 4))                          break;                      if (Binary.AsciiEqual (buf' chunk))                          return chunk_offset;                      file.Position += chunk_size + 4;                  }              }              catch { /* ignore errors */ }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,FindChunk,The following statement contains a magic number: try              {                  var buf = new byte[4];                  file.Position = 8;                  while (-1 != file.PeekByte())                  {                      long chunk_offset = file.Position;                      uint chunk_size = Binary.BigEndian (file.ReadUInt32());                      if (4 != file.Read (buf' 0' 4))                          break;                      if (Binary.AsciiEqual (buf' chunk))                          return chunk_offset;                      file.Position += chunk_size + 4;                  }              }              catch { /* ignore errors */ }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,FindChunk,The following statement contains a magic number: try              {                  var buf = new byte[4];                  file.Position = 8;                  while (-1 != file.PeekByte())                  {                      long chunk_offset = file.Position;                      uint chunk_size = Binary.BigEndian (file.ReadUInt32());                      if (4 != file.Read (buf' 0' 4))                          break;                      if (Binary.AsciiEqual (buf' chunk))                          return chunk_offset;                      file.Position += chunk_size + 4;                  }              }              catch { /* ignore errors */ }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,FindChunk,The following statement contains a magic number: try              {                  var buf = new byte[4];                  file.Position = 8;                  while (-1 != file.PeekByte())                  {                      long chunk_offset = file.Position;                      uint chunk_size = Binary.BigEndian (file.ReadUInt32());                      if (4 != file.Read (buf' 0' 4))                          break;                      if (Binary.AsciiEqual (buf' chunk))                          return chunk_offset;                      file.Position += chunk_size + 4;                  }              }              catch { /* ignore errors */ }
Magic Number,GameRes,PngFormat,C:\repos\morkt_GARbro\GameRes\ImagePNG.cs,FindChunk,The following statement contains a magic number: try              {                  var buf = new byte[4];                  file.Position = 8;                  while (-1 != file.PeekByte())                  {                      long chunk_offset = file.Position;                      uint chunk_size = Binary.BigEndian (file.ReadUInt32());                      if (4 != file.Read (buf' 0' 4))                          break;                      if (Binary.AsciiEqual (buf' chunk))                          return chunk_offset;                      file.Position += chunk_size + 4;                  }              }              catch { /* ignore errors */ }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,Write,The following statement contains a magic number: using (var file = new BinaryWriter (stream' System.Text.Encoding.ASCII' true))              {                  file.Write ((byte)0);   // idlength                  file.Write ((byte)0);   // colourmaptype                  file.Write ((byte)2);   // datatypecode                  file.Write ((short)0);  // colourmaporigin                  file.Write ((short)0);  // colourmaplength                  file.Write ((byte)0);   // colourmapdepth                  file.Write ((short)image.OffsetX);                  file.Write ((short)image.OffsetY);                  file.Write ((ushort)image.Width);                  file.Write ((ushort)image.Height);                    var bitmap = image.Bitmap;                  int bpp = 0;                  int stride = 0;                  byte descriptor = 0;                  if (PixelFormats.Bgr24 == bitmap.Format)                  {                      bpp = 24;                      stride = (int)image.Width*3;                  }                  else if (PixelFormats.Bgr32 == bitmap.Format)                  {                      bpp = 32;                      stride = (int)image.Width*4;                  }                  else                  {                      bpp = 32;                      stride = (int)image.Width*4;                      if (PixelFormats.Bgra32 != bitmap.Format)                      {                          var converted_bitmap = new FormatConvertedBitmap();                          converted_bitmap.BeginInit();                          converted_bitmap.Source = image.Bitmap;                          converted_bitmap.DestinationFormat = PixelFormats.Bgra32;                          converted_bitmap.EndInit();                          bitmap = converted_bitmap;                      }                  }                  file.Write ((byte)bpp);                  file.Write (descriptor);                  byte[] row_data = new byte[stride];                  Int32Rect rect = new Int32Rect (0' (int)image.Height' (int)image.Width' 1);                  for (uint row = 0; row < image.Height; ++row)                  {                      --rect.Y;                      bitmap.CopyPixels (rect' row_data' stride' 0);                      file.Write (row_data);                  }              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,Write,The following statement contains a magic number: using (var file = new BinaryWriter (stream' System.Text.Encoding.ASCII' true))              {                  file.Write ((byte)0);   // idlength                  file.Write ((byte)0);   // colourmaptype                  file.Write ((byte)2);   // datatypecode                  file.Write ((short)0);  // colourmaporigin                  file.Write ((short)0);  // colourmaplength                  file.Write ((byte)0);   // colourmapdepth                  file.Write ((short)image.OffsetX);                  file.Write ((short)image.OffsetY);                  file.Write ((ushort)image.Width);                  file.Write ((ushort)image.Height);                    var bitmap = image.Bitmap;                  int bpp = 0;                  int stride = 0;                  byte descriptor = 0;                  if (PixelFormats.Bgr24 == bitmap.Format)                  {                      bpp = 24;                      stride = (int)image.Width*3;                  }                  else if (PixelFormats.Bgr32 == bitmap.Format)                  {                      bpp = 32;                      stride = (int)image.Width*4;                  }                  else                  {                      bpp = 32;                      stride = (int)image.Width*4;                      if (PixelFormats.Bgra32 != bitmap.Format)                      {                          var converted_bitmap = new FormatConvertedBitmap();                          converted_bitmap.BeginInit();                          converted_bitmap.Source = image.Bitmap;                          converted_bitmap.DestinationFormat = PixelFormats.Bgra32;                          converted_bitmap.EndInit();                          bitmap = converted_bitmap;                      }                  }                  file.Write ((byte)bpp);                  file.Write (descriptor);                  byte[] row_data = new byte[stride];                  Int32Rect rect = new Int32Rect (0' (int)image.Height' (int)image.Width' 1);                  for (uint row = 0; row < image.Height; ++row)                  {                      --rect.Y;                      bitmap.CopyPixels (rect' row_data' stride' 0);                      file.Write (row_data);                  }              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,Write,The following statement contains a magic number: using (var file = new BinaryWriter (stream' System.Text.Encoding.ASCII' true))              {                  file.Write ((byte)0);   // idlength                  file.Write ((byte)0);   // colourmaptype                  file.Write ((byte)2);   // datatypecode                  file.Write ((short)0);  // colourmaporigin                  file.Write ((short)0);  // colourmaplength                  file.Write ((byte)0);   // colourmapdepth                  file.Write ((short)image.OffsetX);                  file.Write ((short)image.OffsetY);                  file.Write ((ushort)image.Width);                  file.Write ((ushort)image.Height);                    var bitmap = image.Bitmap;                  int bpp = 0;                  int stride = 0;                  byte descriptor = 0;                  if (PixelFormats.Bgr24 == bitmap.Format)                  {                      bpp = 24;                      stride = (int)image.Width*3;                  }                  else if (PixelFormats.Bgr32 == bitmap.Format)                  {                      bpp = 32;                      stride = (int)image.Width*4;                  }                  else                  {                      bpp = 32;                      stride = (int)image.Width*4;                      if (PixelFormats.Bgra32 != bitmap.Format)                      {                          var converted_bitmap = new FormatConvertedBitmap();                          converted_bitmap.BeginInit();                          converted_bitmap.Source = image.Bitmap;                          converted_bitmap.DestinationFormat = PixelFormats.Bgra32;                          converted_bitmap.EndInit();                          bitmap = converted_bitmap;                      }                  }                  file.Write ((byte)bpp);                  file.Write (descriptor);                  byte[] row_data = new byte[stride];                  Int32Rect rect = new Int32Rect (0' (int)image.Height' (int)image.Width' 1);                  for (uint row = 0; row < image.Height; ++row)                  {                      --rect.Y;                      bitmap.CopyPixels (rect' row_data' stride' 0);                      file.Write (row_data);                  }              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,Write,The following statement contains a magic number: using (var file = new BinaryWriter (stream' System.Text.Encoding.ASCII' true))              {                  file.Write ((byte)0);   // idlength                  file.Write ((byte)0);   // colourmaptype                  file.Write ((byte)2);   // datatypecode                  file.Write ((short)0);  // colourmaporigin                  file.Write ((short)0);  // colourmaplength                  file.Write ((byte)0);   // colourmapdepth                  file.Write ((short)image.OffsetX);                  file.Write ((short)image.OffsetY);                  file.Write ((ushort)image.Width);                  file.Write ((ushort)image.Height);                    var bitmap = image.Bitmap;                  int bpp = 0;                  int stride = 0;                  byte descriptor = 0;                  if (PixelFormats.Bgr24 == bitmap.Format)                  {                      bpp = 24;                      stride = (int)image.Width*3;                  }                  else if (PixelFormats.Bgr32 == bitmap.Format)                  {                      bpp = 32;                      stride = (int)image.Width*4;                  }                  else                  {                      bpp = 32;                      stride = (int)image.Width*4;                      if (PixelFormats.Bgra32 != bitmap.Format)                      {                          var converted_bitmap = new FormatConvertedBitmap();                          converted_bitmap.BeginInit();                          converted_bitmap.Source = image.Bitmap;                          converted_bitmap.DestinationFormat = PixelFormats.Bgra32;                          converted_bitmap.EndInit();                          bitmap = converted_bitmap;                      }                  }                  file.Write ((byte)bpp);                  file.Write (descriptor);                  byte[] row_data = new byte[stride];                  Int32Rect rect = new Int32Rect (0' (int)image.Height' (int)image.Width' 1);                  for (uint row = 0; row < image.Height; ++row)                  {                      --rect.Y;                      bitmap.CopyPixels (rect' row_data' stride' 0);                      file.Write (row_data);                  }              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,Write,The following statement contains a magic number: using (var file = new BinaryWriter (stream' System.Text.Encoding.ASCII' true))              {                  file.Write ((byte)0);   // idlength                  file.Write ((byte)0);   // colourmaptype                  file.Write ((byte)2);   // datatypecode                  file.Write ((short)0);  // colourmaporigin                  file.Write ((short)0);  // colourmaplength                  file.Write ((byte)0);   // colourmapdepth                  file.Write ((short)image.OffsetX);                  file.Write ((short)image.OffsetY);                  file.Write ((ushort)image.Width);                  file.Write ((ushort)image.Height);                    var bitmap = image.Bitmap;                  int bpp = 0;                  int stride = 0;                  byte descriptor = 0;                  if (PixelFormats.Bgr24 == bitmap.Format)                  {                      bpp = 24;                      stride = (int)image.Width*3;                  }                  else if (PixelFormats.Bgr32 == bitmap.Format)                  {                      bpp = 32;                      stride = (int)image.Width*4;                  }                  else                  {                      bpp = 32;                      stride = (int)image.Width*4;                      if (PixelFormats.Bgra32 != bitmap.Format)                      {                          var converted_bitmap = new FormatConvertedBitmap();                          converted_bitmap.BeginInit();                          converted_bitmap.Source = image.Bitmap;                          converted_bitmap.DestinationFormat = PixelFormats.Bgra32;                          converted_bitmap.EndInit();                          bitmap = converted_bitmap;                      }                  }                  file.Write ((byte)bpp);                  file.Write (descriptor);                  byte[] row_data = new byte[stride];                  Int32Rect rect = new Int32Rect (0' (int)image.Height' (int)image.Width' 1);                  for (uint row = 0; row < image.Height; ++row)                  {                      --rect.Y;                      bitmap.CopyPixels (rect' row_data' stride' 0);                      file.Write (row_data);                  }              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,Write,The following statement contains a magic number: using (var file = new BinaryWriter (stream' System.Text.Encoding.ASCII' true))              {                  file.Write ((byte)0);   // idlength                  file.Write ((byte)0);   // colourmaptype                  file.Write ((byte)2);   // datatypecode                  file.Write ((short)0);  // colourmaporigin                  file.Write ((short)0);  // colourmaplength                  file.Write ((byte)0);   // colourmapdepth                  file.Write ((short)image.OffsetX);                  file.Write ((short)image.OffsetY);                  file.Write ((ushort)image.Width);                  file.Write ((ushort)image.Height);                    var bitmap = image.Bitmap;                  int bpp = 0;                  int stride = 0;                  byte descriptor = 0;                  if (PixelFormats.Bgr24 == bitmap.Format)                  {                      bpp = 24;                      stride = (int)image.Width*3;                  }                  else if (PixelFormats.Bgr32 == bitmap.Format)                  {                      bpp = 32;                      stride = (int)image.Width*4;                  }                  else                  {                      bpp = 32;                      stride = (int)image.Width*4;                      if (PixelFormats.Bgra32 != bitmap.Format)                      {                          var converted_bitmap = new FormatConvertedBitmap();                          converted_bitmap.BeginInit();                          converted_bitmap.Source = image.Bitmap;                          converted_bitmap.DestinationFormat = PixelFormats.Bgra32;                          converted_bitmap.EndInit();                          bitmap = converted_bitmap;                      }                  }                  file.Write ((byte)bpp);                  file.Write (descriptor);                  byte[] row_data = new byte[stride];                  Int32Rect rect = new Int32Rect (0' (int)image.Height' (int)image.Width' 1);                  for (uint row = 0; row < image.Height; ++row)                  {                      --rect.Y;                      bitmap.CopyPixels (rect' row_data' stride' 0);                      file.Write (row_data);                  }              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,Write,The following statement contains a magic number: using (var file = new BinaryWriter (stream' System.Text.Encoding.ASCII' true))              {                  file.Write ((byte)0);   // idlength                  file.Write ((byte)0);   // colourmaptype                  file.Write ((byte)2);   // datatypecode                  file.Write ((short)0);  // colourmaporigin                  file.Write ((short)0);  // colourmaplength                  file.Write ((byte)0);   // colourmapdepth                  file.Write ((short)image.OffsetX);                  file.Write ((short)image.OffsetY);                  file.Write ((ushort)image.Width);                  file.Write ((ushort)image.Height);                    var bitmap = image.Bitmap;                  int bpp = 0;                  int stride = 0;                  byte descriptor = 0;                  if (PixelFormats.Bgr24 == bitmap.Format)                  {                      bpp = 24;                      stride = (int)image.Width*3;                  }                  else if (PixelFormats.Bgr32 == bitmap.Format)                  {                      bpp = 32;                      stride = (int)image.Width*4;                  }                  else                  {                      bpp = 32;                      stride = (int)image.Width*4;                      if (PixelFormats.Bgra32 != bitmap.Format)                      {                          var converted_bitmap = new FormatConvertedBitmap();                          converted_bitmap.BeginInit();                          converted_bitmap.Source = image.Bitmap;                          converted_bitmap.DestinationFormat = PixelFormats.Bgra32;                          converted_bitmap.EndInit();                          bitmap = converted_bitmap;                      }                  }                  file.Write ((byte)bpp);                  file.Write (descriptor);                  byte[] row_data = new byte[stride];                  Int32Rect rect = new Int32Rect (0' (int)image.Height' (int)image.Width' 1);                  for (uint row = 0; row < image.Height; ++row)                  {                      --rect.Y;                      bitmap.CopyPixels (rect' row_data' stride' 0);                      file.Write (row_data);                  }              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: if (bpp != 32 && bpp != 24 && bpp != 16 && bpp != 15 && bpp != 8)                  return null;
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: if (bpp != 32 && bpp != 24 && bpp != 16 && bpp != 15 && bpp != 8)                  return null;
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: if (bpp != 32 && bpp != 24 && bpp != 16 && bpp != 15 && bpp != 8)                  return null;
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: if (bpp != 32 && bpp != 24 && bpp != 16 && bpp != 15 && bpp != 8)                  return null;
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: if (bpp != 32 && bpp != 24 && bpp != 16 && bpp != 15 && bpp != 8)                  return null;
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: uint colormap_offset = (uint)(18 + id_length);
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: switch (image_type)              {              default: return null;              case 1:  // Uncompressed' color-mapped images.              case 9:  // Runlength encoded color-mapped images.              case 32: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.              case 33: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.  4-pass quadtree-type process.                  if (colormap_depth != 24 && colormap_depth != 32)                      return null;                  break;              case 2:  // Uncompressed' RGB images.              case 3:  // Uncompressed' black and white images.              case 10: // Runlength encoded RGB images.              case 11: // Compressed' black and white images.                  break;              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: switch (image_type)              {              default: return null;              case 1:  // Uncompressed' color-mapped images.              case 9:  // Runlength encoded color-mapped images.              case 32: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.              case 33: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.  4-pass quadtree-type process.                  if (colormap_depth != 24 && colormap_depth != 32)                      return null;                  break;              case 2:  // Uncompressed' RGB images.              case 3:  // Uncompressed' black and white images.              case 10: // Runlength encoded RGB images.              case 11: // Compressed' black and white images.                  break;              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: switch (image_type)              {              default: return null;              case 1:  // Uncompressed' color-mapped images.              case 9:  // Runlength encoded color-mapped images.              case 32: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.              case 33: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.  4-pass quadtree-type process.                  if (colormap_depth != 24 && colormap_depth != 32)                      return null;                  break;              case 2:  // Uncompressed' RGB images.              case 3:  // Uncompressed' black and white images.              case 10: // Runlength encoded RGB images.              case 11: // Compressed' black and white images.                  break;              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: switch (image_type)              {              default: return null;              case 1:  // Uncompressed' color-mapped images.              case 9:  // Runlength encoded color-mapped images.              case 32: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.              case 33: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.  4-pass quadtree-type process.                  if (colormap_depth != 24 && colormap_depth != 32)                      return null;                  break;              case 2:  // Uncompressed' RGB images.              case 3:  // Uncompressed' black and white images.              case 10: // Runlength encoded RGB images.              case 11: // Compressed' black and white images.                  break;              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: switch (image_type)              {              default: return null;              case 1:  // Uncompressed' color-mapped images.              case 9:  // Runlength encoded color-mapped images.              case 32: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.              case 33: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.  4-pass quadtree-type process.                  if (colormap_depth != 24 && colormap_depth != 32)                      return null;                  break;              case 2:  // Uncompressed' RGB images.              case 3:  // Uncompressed' black and white images.              case 10: // Runlength encoded RGB images.              case 11: // Compressed' black and white images.                  break;              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: switch (image_type)              {              default: return null;              case 1:  // Uncompressed' color-mapped images.              case 9:  // Runlength encoded color-mapped images.              case 32: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.              case 33: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.  4-pass quadtree-type process.                  if (colormap_depth != 24 && colormap_depth != 32)                      return null;                  break;              case 2:  // Uncompressed' RGB images.              case 3:  // Uncompressed' black and white images.              case 10: // Runlength encoded RGB images.              case 11: // Compressed' black and white images.                  break;              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: switch (image_type)              {              default: return null;              case 1:  // Uncompressed' color-mapped images.              case 9:  // Runlength encoded color-mapped images.              case 32: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.              case 33: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.  4-pass quadtree-type process.                  if (colormap_depth != 24 && colormap_depth != 32)                      return null;                  break;              case 2:  // Uncompressed' RGB images.              case 3:  // Uncompressed' black and white images.              case 10: // Runlength encoded RGB images.              case 11: // Compressed' black and white images.                  break;              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: switch (image_type)              {              default: return null;              case 1:  // Uncompressed' color-mapped images.              case 9:  // Runlength encoded color-mapped images.              case 32: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.              case 33: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.  4-pass quadtree-type process.                  if (colormap_depth != 24 && colormap_depth != 32)                      return null;                  break;              case 2:  // Uncompressed' RGB images.              case 3:  // Uncompressed' black and white images.              case 10: // Runlength encoded RGB images.              case 11: // Compressed' black and white images.                  break;              }
Magic Number,GameRes,TgaFormat,C:\repos\morkt_GARbro\GameRes\ImageTGA.cs,ReadMetaData,The following statement contains a magic number: switch (image_type)              {              default: return null;              case 1:  // Uncompressed' color-mapped images.              case 9:  // Runlength encoded color-mapped images.              case 32: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.              case 33: // Compressed color-mapped data' using Huffman' Delta' and                      // runlength encoding.  4-pass quadtree-type process.                  if (colormap_depth != 24 && colormap_depth != 32)                      return null;                  break;              case 2:  // Uncompressed' RGB images.              case 3:  // Uncompressed' black and white images.              case 10: // Runlength encoded RGB images.              case 11: // Compressed' black and white images.                  break;              }
Magic Number,GameRes,Parser,C:\repos\morkt_GARbro\GameRes\ImageTIFF.cs,Parser,The following statement contains a magic number: m_first_ifd = file.ReadHeader (8).ToUInt32 (4);
Magic Number,GameRes,Parser,C:\repos\morkt_GARbro\GameRes\ImageTIFF.cs,Parser,The following statement contains a magic number: m_first_ifd = file.ReadHeader (8).ToUInt32 (4);
Magic Number,GameRes,Parser,C:\repos\morkt_GARbro\GameRes\ImageTIFF.cs,FindLastIFD,The following statement contains a magic number: for (;;)                  {                      m_file.Position = ifd;                      uint tag_count = ReadUInt16();                      ifd += 2 + tag_count*12;                      uint ifd_next = ReadUInt32();                      if (0 == ifd_next)                          break;                      if (ifd_next == ifd || ifd_next >= m_file.Length)                          return -1;                      ifd = ifd_next;                  }
Magic Number,GameRes,Parser,C:\repos\morkt_GARbro\GameRes\ImageTIFF.cs,FindLastIFD,The following statement contains a magic number: for (;;)                  {                      m_file.Position = ifd;                      uint tag_count = ReadUInt16();                      ifd += 2 + tag_count*12;                      uint ifd_next = ReadUInt32();                      if (0 == ifd_next)                          break;                      if (ifd_next == ifd || ifd_next >= m_file.Length)                          return -1;                      ifd = ifd_next;                  }
Magic Number,GameRes,Parser,C:\repos\morkt_GARbro\GameRes\ImageTIFF.cs,ReadMetaData,The following statement contains a magic number: while (ifd != 0 && parsed != MetaParsed.Complete && !seen_ifd.Contains (ifd))                  {                      m_file.Position = ifd;                      seen_ifd.Add (ifd);                      uint tag_count = ReadUInt16();                      ifd += 2;                      for (uint i = 0; i < tag_count && parsed != MetaParsed.Complete; ++i)                      {                          ushort tag = ReadUInt16();                          TagType type = (TagType)ReadUInt16();                          uint count = ReadUInt32();                          if (0 != count && 0 != type && type <= TagType.LastKnown)                          {                              switch ((TIFF)tag)                              {                              case TIFF.ImageWidth:                                  if (1 == count)                                      if (ReadOffsetValue (type' out width))                                          parsed |= MetaParsed.Width;                                  break;                              case TIFF.ImageHeight:                                  if (1 == count)                                      if (ReadOffsetValue (type' out height))                                          parsed |= MetaParsed.Height;                                  break;                              case TIFF.XPosition:                                  if (1 == count)                                      if (ReadOffsetValue (type' out pos_x))                                          parsed |= MetaParsed.PosX;                                  break;                              case TIFF.YPosition:                                  if (1 == count)                                      if (ReadOffsetValue (type' out pos_y))                                          parsed |= MetaParsed.PosY;                                  break;                              case TIFF.BitsPerSample:                                  if (count * GetTypeSize (type) > 4)                                  {                                      var bpp_offset = ReadUInt32();                                      m_file.Position = bpp_offset;                                  }                                  bpp = 0;                                  for (uint b = 0; b < count; ++b)                                  {                                      int plane = 0;                                      ReadValue (type' out plane);                                      bpp += plane;                                  }                                  parsed |= MetaParsed.BPP;                                  break;                              default:                                  break;                              }                          }                          ifd += 12;                          m_file.Position = ifd;                      }                      ifd = ReadUInt32();                  }
Magic Number,GameRes,Parser,C:\repos\morkt_GARbro\GameRes\ImageTIFF.cs,ReadMetaData,The following statement contains a magic number: while (ifd != 0 && parsed != MetaParsed.Complete && !seen_ifd.Contains (ifd))                  {                      m_file.Position = ifd;                      seen_ifd.Add (ifd);                      uint tag_count = ReadUInt16();                      ifd += 2;                      for (uint i = 0; i < tag_count && parsed != MetaParsed.Complete; ++i)                      {                          ushort tag = ReadUInt16();                          TagType type = (TagType)ReadUInt16();                          uint count = ReadUInt32();                          if (0 != count && 0 != type && type <= TagType.LastKnown)                          {                              switch ((TIFF)tag)                              {                              case TIFF.ImageWidth:                                  if (1 == count)                                      if (ReadOffsetValue (type' out width))                                          parsed |= MetaParsed.Width;                                  break;                              case TIFF.ImageHeight:                                  if (1 == count)                                      if (ReadOffsetValue (type' out height))                                          parsed |= MetaParsed.Height;                                  break;                              case TIFF.XPosition:                                  if (1 == count)                                      if (ReadOffsetValue (type' out pos_x))                                          parsed |= MetaParsed.PosX;                                  break;                              case TIFF.YPosition:                                  if (1 == count)                                      if (ReadOffsetValue (type' out pos_y))                                          parsed |= MetaParsed.PosY;                                  break;                              case TIFF.BitsPerSample:                                  if (count * GetTypeSize (type) > 4)                                  {                                      var bpp_offset = ReadUInt32();                                      m_file.Position = bpp_offset;                                  }                                  bpp = 0;                                  for (uint b = 0; b < count; ++b)                                  {                                      int plane = 0;                                      ReadValue (type' out plane);                                      bpp += plane;                                  }                                  parsed |= MetaParsed.BPP;                                  break;                              default:                                  break;                              }                          }                          ifd += 12;                          m_file.Position = ifd;                      }                      ifd = ReadUInt32();                  }
Magic Number,GameRes,Parser,C:\repos\morkt_GARbro\GameRes\ImageTIFF.cs,ReadMetaData,The following statement contains a magic number: while (ifd != 0 && parsed != MetaParsed.Complete && !seen_ifd.Contains (ifd))                  {                      m_file.Position = ifd;                      seen_ifd.Add (ifd);                      uint tag_count = ReadUInt16();                      ifd += 2;                      for (uint i = 0; i < tag_count && parsed != MetaParsed.Complete; ++i)                      {                          ushort tag = ReadUInt16();                          TagType type = (TagType)ReadUInt16();                          uint count = ReadUInt32();                          if (0 != count && 0 != type && type <= TagType.LastKnown)                          {                              switch ((TIFF)tag)                              {                              case TIFF.ImageWidth:                                  if (1 == count)                                      if (ReadOffsetValue (type' out width))                                          parsed |= MetaParsed.Width;                                  break;                              case TIFF.ImageHeight:                                  if (1 == count)                                      if (ReadOffsetValue (type' out height))                                          parsed |= MetaParsed.Height;                                  break;                              case TIFF.XPosition:                                  if (1 == count)                                      if (ReadOffsetValue (type' out pos_x))                                          parsed |= MetaParsed.PosX;                                  break;                              case TIFF.YPosition:                                  if (1 == count)                                      if (ReadOffsetValue (type' out pos_y))                                          parsed |= MetaParsed.PosY;                                  break;                              case TIFF.BitsPerSample:                                  if (count * GetTypeSize (type) > 4)                                  {                                      var bpp_offset = ReadUInt32();                                      m_file.Position = bpp_offset;                                  }                                  bpp = 0;                                  for (uint b = 0; b < count; ++b)                                  {                                      int plane = 0;                                      ReadValue (type' out plane);                                      bpp += plane;                                  }                                  parsed |= MetaParsed.BPP;                                  break;                              default:                                  break;                              }                          }                          ifd += 12;                          m_file.Position = ifd;                      }                      ifd = ReadUInt32();                  }
Magic Number,GameRes,Parser,C:\repos\morkt_GARbro\GameRes\ImageTIFF.cs,ReadOffsetValue,The following statement contains a magic number: if (GetTypeSize (type) > 4)                      m_file.Position = ReadUInt32();
Magic Number,GameRes,Parser,C:\repos\morkt_GARbro\GameRes\ImageTIFF.cs,ReadFloat,The following statement contains a magic number: var convert_buffer = new byte[4];
Magic Number,GameRes,Parser,C:\repos\morkt_GARbro\GameRes\ImageTIFF.cs,ReadFloat,The following statement contains a magic number: if (4 != m_file.Read (convert_buffer' 0' 4))                  {                      value = 0;                      return false;                  }
Magic Number,GameRes,Parser,C:\repos\morkt_GARbro\GameRes\ImageTIFF.cs,ReadFloat,The following statement contains a magic number: if (4 != m_file.Read (convert_buffer' 0' 4))                  {                      value = 0;                      return false;                  }
Magic Number,GameRes,Parser,C:\repos\morkt_GARbro\GameRes\ImageTIFF.cs,ReadDouble,The following statement contains a magic number: var convert_buffer = new byte[8];
Magic Number,GameRes,Parser,C:\repos\morkt_GARbro\GameRes\ImageTIFF.cs,ReadDouble,The following statement contains a magic number: if (8 != m_file.Read (convert_buffer' 0' 8))                  {                      value = 0;                      return false;                  }
Magic Number,GameRes,Parser,C:\repos\morkt_GARbro\GameRes\ImageTIFF.cs,ReadDouble,The following statement contains a magic number: if (8 != m_file.Read (convert_buffer' 0' 8))                  {                      value = 0;                      return false;                  }
Magic Number,GameRes.Utility,Crc32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,InitializeTable,The following statement contains a magic number: uint[] table = new uint[256];
Magic Number,GameRes.Utility,Crc32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,InitializeTable,The following statement contains a magic number: for (uint n = 0; n < 256; n++)              {                  uint c = n;                  for (int k = 0; k < 8; k++)                  {                      if (0 != (c & 1))                          c = 0xedb88320 ^ (c >> 1);                      else                          c = c >> 1;                  }                  table[n] = c;              }
Magic Number,GameRes.Utility,Crc32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,InitializeTable,The following statement contains a magic number: for (uint n = 0; n < 256; n++)              {                  uint c = n;                  for (int k = 0; k < 8; k++)                  {                      if (0 != (c & 1))                          c = 0xedb88320 ^ (c >> 1);                      else                          c = c >> 1;                  }                  table[n] = c;              }
Magic Number,GameRes.Utility,Crc32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,UpdateCrc,The following statement contains a magic number: for (int n = 0; n < len; n++)                  c = crc_table[(c ^ buf[pos+n]) & 0xff] ^ (c >> 8);
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: uint sum2 = (adler >> 16) & 0xffff;
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (1 == len) {                  adler += *buf;                  if (adler >= BASE)                      adler -= BASE;                  sum2 += adler;                  if (sum2 >= BASE)                      sum2 -= BASE;                  return adler | (sum2 << 16);              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (len < 16) {                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  if (adler >= BASE)                      adler -= BASE;                  sum2 %= BASE;            /* only added so many BASE's */                  return adler | (sum2 << 16);              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (len < 16) {                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  if (adler >= BASE)                      adler -= BASE;                  sum2 %= BASE;            /* only added so many BASE's */                  return adler | (sum2 << 16);              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: while (len >= NMAX) {                  len -= NMAX;                  int n = NMAX / 16;          /* NMAX is divisible by 16 */                  do {                      /* 16 sums unrolled */                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  } while (0 != --n);                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: if (0 != len) {                  /* avoid modulos if none remaining */                  while (len >= 16) {                      len -= 16;                      adler += buf[0];  sum2 += adler;                      adler += buf[1];  sum2 += adler;                      adler += buf[2];  sum2 += adler;                      adler += buf[3];  sum2 += adler;                      adler += buf[4];  sum2 += adler;                      adler += buf[5];  sum2 += adler;                      adler += buf[6];  sum2 += adler;                      adler += buf[7];  sum2 += adler;                      adler += buf[8];  sum2 += adler;                      adler += buf[9];  sum2 += adler;                      adler += buf[10]; sum2 += adler;                      adler += buf[11]; sum2 += adler;                      adler += buf[12]; sum2 += adler;                      adler += buf[13]; sum2 += adler;                      adler += buf[14]; sum2 += adler;                      adler += buf[15]; sum2 += adler;                      buf += 16;                  }                  while (0 != len--) {                      adler += *buf++;                      sum2 += adler;                  }                  adler %= BASE;                  sum2 %= BASE;              }
Magic Number,GameRes.Utility,Adler32,C:\repos\morkt_GARbro\GameRes\Checksum.cs,Update,The following statement contains a magic number: return adler | (sum2 << 16);
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,BigEndian,The following statement contains a magic number: return u << 24 | (u & 0xff00) << 8 | (u & 0xff0000) >> 8 | u >> 24;
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,BigEndian,The following statement contains a magic number: return u << 24 | (u & 0xff00) << 8 | (u & 0xff0000) >> 8 | u >> 24;
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,BigEndian,The following statement contains a magic number: return u << 24 | (u & 0xff00) << 8 | (u & 0xff0000) >> 8 | u >> 24;
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,BigEndian,The following statement contains a magic number: return u << 24 | (u & 0xff00) << 8 | (u & 0xff0000) >> 8 | u >> 24;
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,BigEndian,The following statement contains a magic number: return (ushort)(u << 8 | u >> 8);
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,BigEndian,The following statement contains a magic number: return (ushort)(u << 8 | u >> 8);
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,BigEndian,The following statement contains a magic number: return (ulong)BigEndian((uint)(u & 0xffffffff)) << 32                   | (ulong)BigEndian((uint)(u >> 32));
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,BigEndian,The following statement contains a magic number: return (ulong)BigEndian((uint)(u & 0xffffffff)) << 32                   | (ulong)BigEndian((uint)(u >> 32));
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,RotR,The following statement contains a magic number: return v >> count | v << (32-count);
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,RotL,The following statement contains a magic number: return v << count | v >> (32-count);
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,RotR,The following statement contains a magic number: return v >> count | v << (64-count);
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,RotL,The following statement contains a magic number: return v << count | v >> (64-count);
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,RotByteR,The following statement contains a magic number: count &= 7;
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,RotByteR,The following statement contains a magic number: return (byte)(v >> count | v << (8-count));
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,RotByteL,The following statement contains a magic number: count &= 7;
Magic Number,GameRes.Utility,Binary,C:\repos\morkt_GARbro\GameRes\Utility.cs,RotByteL,The following statement contains a magic number: return (byte)(v << count | v >> (8-count));
Magic Number,GameRes.Utility,BigEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToUInt16,The following statement contains a magic number: return (ushort)(value[index] << 8 | value[index+1]);
Magic Number,GameRes.Utility,BigEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToInt16,The following statement contains a magic number: return (short)(value[index] << 8 | value[index+1]);
Magic Number,GameRes.Utility,BigEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToUInt32,The following statement contains a magic number: return (uint)(value[index] << 24 | value[index+1] << 16 | value[index+2] << 8 | value[index+3]);
Magic Number,GameRes.Utility,BigEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToUInt32,The following statement contains a magic number: return (uint)(value[index] << 24 | value[index+1] << 16 | value[index+2] << 8 | value[index+3]);
Magic Number,GameRes.Utility,BigEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToUInt32,The following statement contains a magic number: return (uint)(value[index] << 24 | value[index+1] << 16 | value[index+2] << 8 | value[index+3]);
Magic Number,GameRes.Utility,BigEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToUInt32,The following statement contains a magic number: return (uint)(value[index] << 24 | value[index+1] << 16 | value[index+2] << 8 | value[index+3]);
Magic Number,GameRes.Utility,BigEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToUInt32,The following statement contains a magic number: return (uint)(value[index] << 24 | value[index+1] << 16 | value[index+2] << 8 | value[index+3]);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToUInt16,The following statement contains a magic number: return (ushort)(value[index] | value[index+1] << 8);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToInt16,The following statement contains a magic number: return (short)(value[index] | value[index+1] << 8);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToUInt32,The following statement contains a magic number: return (uint)(value[index] | value[index+1] << 8 | value[index+2] << 16 | value[index+3] << 24);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToUInt32,The following statement contains a magic number: return (uint)(value[index] | value[index+1] << 8 | value[index+2] << 16 | value[index+3] << 24);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToUInt32,The following statement contains a magic number: return (uint)(value[index] | value[index+1] << 8 | value[index+2] << 16 | value[index+3] << 24);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToUInt32,The following statement contains a magic number: return (uint)(value[index] | value[index+1] << 8 | value[index+2] << 16 | value[index+3] << 24);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToUInt32,The following statement contains a magic number: return (uint)(value[index] | value[index+1] << 8 | value[index+2] << 16 | value[index+3] << 24);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToUInt64,The following statement contains a magic number: return (ulong)ToUInt32 (value' index) | ((ulong)ToUInt32 (value' index+4) << 32);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,ToUInt64,The following statement contains a magic number: return (ulong)ToUInt32 (value' index) | ((ulong)ToUInt32 (value' index+4) << 32);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,Pack,The following statement contains a magic number: buf[index+1] = (byte)(value >> 8);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,Pack,The following statement contains a magic number: buf[index+1] = (byte)(value >> 8);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,Pack,The following statement contains a magic number: buf[index+2] = (byte)(value >> 16);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,Pack,The following statement contains a magic number: buf[index+2] = (byte)(value >> 16);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,Pack,The following statement contains a magic number: buf[index+3] = (byte)(value >> 24);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,Pack,The following statement contains a magic number: buf[index+3] = (byte)(value >> 24);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,Pack,The following statement contains a magic number: Pack ((uint)(value >> 32)' buf' index+4);
Magic Number,GameRes.Utility,LittleEndian,C:\repos\morkt_GARbro\GameRes\Utility.cs,Pack,The following statement contains a magic number: Pack ((uint)(value >> 32)' buf' index+4);
Magic Number,GameRes.Utility,AsciiString,C:\repos\morkt_GARbro\GameRes\Utility.cs,GetHashCode,The following statement contains a magic number: int hash = 5381;
Magic Number,GameRes.Utility,AsciiString,C:\repos\morkt_GARbro\GameRes\Utility.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < Value.Length; ++i)              {                  hash = ((hash << 5) + hash) ^ Value[i];              }
Magic Number,GameRes.Utility,AsciiString,C:\repos\morkt_GARbro\GameRes\Utility.cs,GetHashCode,The following statement contains a magic number: return hash ^ (hash * 1566083941);
Magic Number,GameRes.Compression,ZLibStream,C:\repos\morkt_GARbro\GameRes\ZLibStream.cs,InitDecompress,The following statement contains a magic number: if ((0x78 != b1 && 0x58 != b1) || 0 != (b1 << 8 | b2) % 31)                  throw new InvalidDataException ("Data not recoginzed as zlib-compressed stream");
Magic Number,GameRes.Compression,ZLibStream,C:\repos\morkt_GARbro\GameRes\ZLibStream.cs,InitDecompress,The following statement contains a magic number: if ((0x78 != b1 && 0x58 != b1) || 0 != (b1 << 8 | b2) % 31)                  throw new InvalidDataException ("Data not recoginzed as zlib-compressed stream");
Magic Number,GameRes.Compression,ZLibStream,C:\repos\morkt_GARbro\GameRes\ZLibStream.cs,InitCompress,The following statement contains a magic number: if (0 == flevel)              {                  sys_level = System.IO.Compression.CompressionLevel.NoCompression;              }              else if (flevel > 5)              {                  sys_level = System.IO.Compression.CompressionLevel.Optimal;                  flevel = 3;              }              else              {                  sys_level = System.IO.Compression.CompressionLevel.Fastest;                  flevel = 1;              }
Magic Number,GameRes.Compression,ZLibStream,C:\repos\morkt_GARbro\GameRes\ZLibStream.cs,InitCompress,The following statement contains a magic number: if (0 == flevel)              {                  sys_level = System.IO.Compression.CompressionLevel.NoCompression;              }              else if (flevel > 5)              {                  sys_level = System.IO.Compression.CompressionLevel.Optimal;                  flevel = 3;              }              else              {                  sys_level = System.IO.Compression.CompressionLevel.Fastest;                  flevel = 1;              }
Magic Number,GameRes.Compression,ZLibStream,C:\repos\morkt_GARbro\GameRes\ZLibStream.cs,InitCompress,The following statement contains a magic number: int cmf = 0x7800 | flevel << 6;
Magic Number,GameRes.Compression,ZLibStream,C:\repos\morkt_GARbro\GameRes\ZLibStream.cs,InitCompress,The following statement contains a magic number: cmf = ((cmf + 30) / 31) * 31;
Magic Number,GameRes.Compression,ZLibStream,C:\repos\morkt_GARbro\GameRes\ZLibStream.cs,InitCompress,The following statement contains a magic number: cmf = ((cmf + 30) / 31) * 31;
Magic Number,GameRes.Compression,ZLibStream,C:\repos\morkt_GARbro\GameRes\ZLibStream.cs,InitCompress,The following statement contains a magic number: cmf = ((cmf + 30) / 31) * 31;
Magic Number,GameRes.Compression,ZLibStream,C:\repos\morkt_GARbro\GameRes\ZLibStream.cs,InitCompress,The following statement contains a magic number: stream.WriteByte ((byte)(cmf >> 8));
Magic Number,GameRes.Compression,ZLibStream,C:\repos\morkt_GARbro\GameRes\ZLibStream.cs,WriteCheckSum,The following statement contains a magic number: output.WriteByte ((byte)(checksum >> 24));
Magic Number,GameRes.Compression,ZLibStream,C:\repos\morkt_GARbro\GameRes\ZLibStream.cs,WriteCheckSum,The following statement contains a magic number: output.WriteByte ((byte)(checksum >> 16));
Magic Number,GameRes.Compression,ZLibStream,C:\repos\morkt_GARbro\GameRes\ZLibStream.cs,WriteCheckSum,The following statement contains a magic number: output.WriteByte ((byte)(checksum >> 8));
Missing Default,GameRes,ArcViewStream,C:\repos\morkt_GARbro\GameRes\ArcStream.cs,Seek,The following switch statement is missing a default case: switch (origin)              {              case SeekOrigin.Current:    offset += Position; break;              case SeekOrigin.End:        offset += m_size; break;              }
