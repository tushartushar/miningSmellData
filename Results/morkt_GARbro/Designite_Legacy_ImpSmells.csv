Implementation smell,Namespace,Class,File,Method,Description
Complex Method,GameRes.Formats.QSoft,BpeFormat,C:\repos\morkt_GARbro\Legacy\QSoft\ImageBPE.cs,Decompress,Cyclomatic complexity of the method is 13
Complex Method,GameRes.Formats.Tsd,McdOpener,C:\repos\morkt_GARbro\Legacy\Tsd\ArcMCD.cs,TryOpen,Cyclomatic complexity of the method is 8
Complex Conditional,GameRes.Formats.Nabe,YpfFormat,C:\repos\morkt_GARbro\Legacy\Nabe\ImageYPF.cs,ReadMetaData,The conditional expression  "0 == w || w > 0x8000 || 0 == h || h > 0x8000"  is complex.
Complex Conditional,GameRes.Formats.System21,BetFormat,C:\repos\morkt_GARbro\Legacy\System21\ImageBET.cs,ReadMetaData,The conditional expression  "(bpp != 24 && bpp != 8) || 0 == w || w > 0x8000 || 0 == h || h > 0x8000"  is complex.
Magic Number,GameRes.Formats.ApplePie,ArcOpener,C:\repos\morkt_GARbro\Legacy\ApplePie\ArcARC.cs,TryOpen,The following statement contains a magic number: int count = file.View.ReadInt32 (4);
Magic Number,GameRes.Formats.ApplePie,ArcOpener,C:\repos\morkt_GARbro\Legacy\ApplePie\ArcARC.cs,TryOpen,The following statement contains a magic number: uint index_size = (uint)count * 24;
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,ReadMetaData,The following statement contains a magic number: bool has_alpha = (header[3] & 8) != 0;
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,ReadMetaData,The following statement contains a magic number: bool has_alpha = (header[3] & 8) != 0;
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,ReadMetaData,The following statement contains a magic number: bool grayscale = (header[3] & 3) == 1;
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,ReadMetaData,The following statement contains a magic number: bool grayscale = (header[3] & 3) == 1;
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,ReadMetaData,The following statement contains a magic number: return new GtMetaData {                  Width = header.ToUInt16 (4)'                  Height = header.ToUInt16 (6)'                  BPP = grayscale ? 8 : has_alpha ? 32 : 24'                  Flags = header[3]'                  DataOffset = header.ToUInt32 (8)'              };
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,ReadMetaData,The following statement contains a magic number: return new GtMetaData {                  Width = header.ToUInt16 (4)'                  Height = header.ToUInt16 (6)'                  BPP = grayscale ? 8 : has_alpha ? 32 : 24'                  Flags = header[3]'                  DataOffset = header.ToUInt32 (8)'              };
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,ReadMetaData,The following statement contains a magic number: return new GtMetaData {                  Width = header.ToUInt16 (4)'                  Height = header.ToUInt16 (6)'                  BPP = grayscale ? 8 : has_alpha ? 32 : 24'                  Flags = header[3]'                  DataOffset = header.ToUInt32 (8)'              };
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,ReadMetaData,The following statement contains a magic number: return new GtMetaData {                  Width = header.ToUInt16 (4)'                  Height = header.ToUInt16 (6)'                  BPP = grayscale ? 8 : has_alpha ? 32 : 24'                  Flags = header[3]'                  DataOffset = header.ToUInt32 (8)'              };
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,ReadMetaData,The following statement contains a magic number: return new GtMetaData {                  Width = header.ToUInt16 (4)'                  Height = header.ToUInt16 (6)'                  BPP = grayscale ? 8 : has_alpha ? 32 : 24'                  Flags = header[3]'                  DataOffset = header.ToUInt32 (8)'              };
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,ReadMetaData,The following statement contains a magic number: return new GtMetaData {                  Width = header.ToUInt16 (4)'                  Height = header.ToUInt16 (6)'                  BPP = grayscale ? 8 : has_alpha ? 32 : 24'                  Flags = header[3]'                  DataOffset = header.ToUInt32 (8)'              };
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,ReadMetaData,The following statement contains a magic number: return new GtMetaData {                  Width = header.ToUInt16 (4)'                  Height = header.ToUInt16 (6)'                  BPP = grayscale ? 8 : has_alpha ? 32 : 24'                  Flags = header[3]'                  DataOffset = header.ToUInt32 (8)'              };
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,Read,The following statement contains a magic number: if (0 != (meta.Flags & 8))              {                  var pixels = UnpackRle (file' (int)meta.Width * (int)meta.Height);                  return ImageData.Create (info' PixelFormats.Bgra32' null' pixels);              }              else if (1 == (meta.Flags & 3))              {                  var pixels = file.ReadBytes ((int)meta.Width * (int)meta.Height);                  return ImageData.Create (info' PixelFormats.Gray8' null' pixels);              }              else              {                  int stride = (int)meta.Width * 3;                  var pixels = file.ReadBytes (stride * (int)meta.Height);                  return ImageData.Create (info' PixelFormats.Bgr24' null' pixels' stride);              }
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,Read,The following statement contains a magic number: if (0 != (meta.Flags & 8))              {                  var pixels = UnpackRle (file' (int)meta.Width * (int)meta.Height);                  return ImageData.Create (info' PixelFormats.Bgra32' null' pixels);              }              else if (1 == (meta.Flags & 3))              {                  var pixels = file.ReadBytes ((int)meta.Width * (int)meta.Height);                  return ImageData.Create (info' PixelFormats.Gray8' null' pixels);              }              else              {                  int stride = (int)meta.Width * 3;                  var pixels = file.ReadBytes (stride * (int)meta.Height);                  return ImageData.Create (info' PixelFormats.Bgr24' null' pixels' stride);              }
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,Read,The following statement contains a magic number: if (0 != (meta.Flags & 8))              {                  var pixels = UnpackRle (file' (int)meta.Width * (int)meta.Height);                  return ImageData.Create (info' PixelFormats.Bgra32' null' pixels);              }              else if (1 == (meta.Flags & 3))              {                  var pixels = file.ReadBytes ((int)meta.Width * (int)meta.Height);                  return ImageData.Create (info' PixelFormats.Gray8' null' pixels);              }              else              {                  int stride = (int)meta.Width * 3;                  var pixels = file.ReadBytes (stride * (int)meta.Height);                  return ImageData.Create (info' PixelFormats.Bgr24' null' pixels' stride);              }
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,UnpackRle,The following statement contains a magic number: var output = new byte[count * 4];
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,UnpackRle,The following statement contains a magic number: while (count > 0)              {                  int length = input.ReadInt32();                  count -= length;                  dst += length * 4;                  length = input.ReadInt32();                  count -= length;                  input.Read (output' dst' length * 4);                  dst += length * 4;              }
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,UnpackRle,The following statement contains a magic number: while (count > 0)              {                  int length = input.ReadInt32();                  count -= length;                  dst += length * 4;                  length = input.ReadInt32();                  count -= length;                  input.Read (output' dst' length * 4);                  dst += length * 4;              }
Magic Number,GameRes.Formats.ApplePie,GtFormat,C:\repos\morkt_GARbro\Legacy\ApplePie\ImageGT.cs,UnpackRle,The following statement contains a magic number: while (count > 0)              {                  int length = input.ReadInt32();                  count -= length;                  dst += length * 4;                  length = input.ReadInt32();                  count -= length;                  input.Read (output' dst' length * 4);                  dst += length * 4;              }
Magic Number,GameRes.Formats.Clio,PacOpener,C:\repos\morkt_GARbro\Legacy\Clio\ArcPAC.cs,TryOpen,The following statement contains a magic number: uint index_offset = 4;
Magic Number,GameRes.Formats.Clio,ExpFormat,C:\repos\morkt_GARbro\Legacy\Clio\ImageEXP.cs,ReadMetaData,The following statement contains a magic number: file.Position = 4;
Magic Number,GameRes.Formats.Clio,ExpReader,C:\repos\morkt_GARbro\Legacy\Clio\ImageEXP.cs,Unpack,The following statement contains a magic number: var table = new byte[2'256];
Magic Number,GameRes.Formats.Clio,ExpReader,C:\repos\morkt_GARbro\Legacy\Clio\ImageEXP.cs,Unpack,The following statement contains a magic number: var table = new byte[2'256];
Magic Number,GameRes.Formats.Clio,ExpReader,C:\repos\morkt_GARbro\Legacy\Clio\ImageEXP.cs,Unpack,The following statement contains a magic number: while (dst < unpacked_size && m_input.PeekByte() != -1)              {                  for (int i = 0; i < 256; ++i)                      table[0'i] = (byte)i;                  int count;                  int t_idx = 0;                  do                  {                      byte ctl = m_input.ReadUInt8();                      if (ctl > 127)                      {                          t_idx += ctl - 127;                          ctl = 0;                      }                      if (t_idx != 256)                      {                          count = ctl + 1;                          while (count --> 0)                          {                              ctl = (byte)t_idx;                              table[0't_idx] = m_input.ReadUInt8();                              if (t_idx != table[0't_idx])                              {                                  table[1't_idx] = m_input.ReadUInt8();                              }                              ++t_idx;                          }                      }                  }                  while (t_idx != 256);                  byte hi = m_input.ReadUInt8();                  byte lo = m_input.ReadUInt8();                  count = hi << 8 | lo;                  int pos = 0;                  for (;;)                  {                      byte b;                      if (pos != 0)                      {                          b = m_filename[--pos];                      }                      else                      {                          if (0 == count--)                              break;                          b = m_input.ReadUInt8();                      }                      if (b == table[0'b])                      {                          output[dst++] = b;                          if (dst >= output.Length)                              break;                      }                      else                      {                          m_filename[pos++] = table[1'b];                          m_filename[pos++] = table[0'b];                      }                  }              }
Magic Number,GameRes.Formats.Clio,ExpReader,C:\repos\morkt_GARbro\Legacy\Clio\ImageEXP.cs,Unpack,The following statement contains a magic number: while (dst < unpacked_size && m_input.PeekByte() != -1)              {                  for (int i = 0; i < 256; ++i)                      table[0'i] = (byte)i;                  int count;                  int t_idx = 0;                  do                  {                      byte ctl = m_input.ReadUInt8();                      if (ctl > 127)                      {                          t_idx += ctl - 127;                          ctl = 0;                      }                      if (t_idx != 256)                      {                          count = ctl + 1;                          while (count --> 0)                          {                              ctl = (byte)t_idx;                              table[0't_idx] = m_input.ReadUInt8();                              if (t_idx != table[0't_idx])                              {                                  table[1't_idx] = m_input.ReadUInt8();                              }                              ++t_idx;                          }                      }                  }                  while (t_idx != 256);                  byte hi = m_input.ReadUInt8();                  byte lo = m_input.ReadUInt8();                  count = hi << 8 | lo;                  int pos = 0;                  for (;;)                  {                      byte b;                      if (pos != 0)                      {                          b = m_filename[--pos];                      }                      else                      {                          if (0 == count--)                              break;                          b = m_input.ReadUInt8();                      }                      if (b == table[0'b])                      {                          output[dst++] = b;                          if (dst >= output.Length)                              break;                      }                      else                      {                          m_filename[pos++] = table[1'b];                          m_filename[pos++] = table[0'b];                      }                  }              }
Magic Number,GameRes.Formats.Clio,ExpReader,C:\repos\morkt_GARbro\Legacy\Clio\ImageEXP.cs,Unpack,The following statement contains a magic number: while (dst < unpacked_size && m_input.PeekByte() != -1)              {                  for (int i = 0; i < 256; ++i)                      table[0'i] = (byte)i;                  int count;                  int t_idx = 0;                  do                  {                      byte ctl = m_input.ReadUInt8();                      if (ctl > 127)                      {                          t_idx += ctl - 127;                          ctl = 0;                      }                      if (t_idx != 256)                      {                          count = ctl + 1;                          while (count --> 0)                          {                              ctl = (byte)t_idx;                              table[0't_idx] = m_input.ReadUInt8();                              if (t_idx != table[0't_idx])                              {                                  table[1't_idx] = m_input.ReadUInt8();                              }                              ++t_idx;                          }                      }                  }                  while (t_idx != 256);                  byte hi = m_input.ReadUInt8();                  byte lo = m_input.ReadUInt8();                  count = hi << 8 | lo;                  int pos = 0;                  for (;;)                  {                      byte b;                      if (pos != 0)                      {                          b = m_filename[--pos];                      }                      else                      {                          if (0 == count--)                              break;                          b = m_input.ReadUInt8();                      }                      if (b == table[0'b])                      {                          output[dst++] = b;                          if (dst >= output.Length)                              break;                      }                      else                      {                          m_filename[pos++] = table[1'b];                          m_filename[pos++] = table[0'b];                      }                  }              }
Magic Number,GameRes.Formats.Clio,ExpReader,C:\repos\morkt_GARbro\Legacy\Clio\ImageEXP.cs,Unpack,The following statement contains a magic number: while (dst < unpacked_size && m_input.PeekByte() != -1)              {                  for (int i = 0; i < 256; ++i)                      table[0'i] = (byte)i;                  int count;                  int t_idx = 0;                  do                  {                      byte ctl = m_input.ReadUInt8();                      if (ctl > 127)                      {                          t_idx += ctl - 127;                          ctl = 0;                      }                      if (t_idx != 256)                      {                          count = ctl + 1;                          while (count --> 0)                          {                              ctl = (byte)t_idx;                              table[0't_idx] = m_input.ReadUInt8();                              if (t_idx != table[0't_idx])                              {                                  table[1't_idx] = m_input.ReadUInt8();                              }                              ++t_idx;                          }                      }                  }                  while (t_idx != 256);                  byte hi = m_input.ReadUInt8();                  byte lo = m_input.ReadUInt8();                  count = hi << 8 | lo;                  int pos = 0;                  for (;;)                  {                      byte b;                      if (pos != 0)                      {                          b = m_filename[--pos];                      }                      else                      {                          if (0 == count--)                              break;                          b = m_input.ReadUInt8();                      }                      if (b == table[0'b])                      {                          output[dst++] = b;                          if (dst >= output.Length)                              break;                      }                      else                      {                          m_filename[pos++] = table[1'b];                          m_filename[pos++] = table[0'b];                      }                  }              }
Magic Number,GameRes.Formats.Clio,ExpReader,C:\repos\morkt_GARbro\Legacy\Clio\ImageEXP.cs,Unpack,The following statement contains a magic number: while (dst < unpacked_size && m_input.PeekByte() != -1)              {                  for (int i = 0; i < 256; ++i)                      table[0'i] = (byte)i;                  int count;                  int t_idx = 0;                  do                  {                      byte ctl = m_input.ReadUInt8();                      if (ctl > 127)                      {                          t_idx += ctl - 127;                          ctl = 0;                      }                      if (t_idx != 256)                      {                          count = ctl + 1;                          while (count --> 0)                          {                              ctl = (byte)t_idx;                              table[0't_idx] = m_input.ReadUInt8();                              if (t_idx != table[0't_idx])                              {                                  table[1't_idx] = m_input.ReadUInt8();                              }                              ++t_idx;                          }                      }                  }                  while (t_idx != 256);                  byte hi = m_input.ReadUInt8();                  byte lo = m_input.ReadUInt8();                  count = hi << 8 | lo;                  int pos = 0;                  for (;;)                  {                      byte b;                      if (pos != 0)                      {                          b = m_filename[--pos];                      }                      else                      {                          if (0 == count--)                              break;                          b = m_input.ReadUInt8();                      }                      if (b == table[0'b])                      {                          output[dst++] = b;                          if (dst >= output.Length)                              break;                      }                      else                      {                          m_filename[pos++] = table[1'b];                          m_filename[pos++] = table[0'b];                      }                  }              }
Magic Number,GameRes.Formats.Clio,ExpReader,C:\repos\morkt_GARbro\Legacy\Clio\ImageEXP.cs,Unpack,The following statement contains a magic number: while (dst < unpacked_size && m_input.PeekByte() != -1)              {                  for (int i = 0; i < 256; ++i)                      table[0'i] = (byte)i;                  int count;                  int t_idx = 0;                  do                  {                      byte ctl = m_input.ReadUInt8();                      if (ctl > 127)                      {                          t_idx += ctl - 127;                          ctl = 0;                      }                      if (t_idx != 256)                      {                          count = ctl + 1;                          while (count --> 0)                          {                              ctl = (byte)t_idx;                              table[0't_idx] = m_input.ReadUInt8();                              if (t_idx != table[0't_idx])                              {                                  table[1't_idx] = m_input.ReadUInt8();                              }                              ++t_idx;                          }                      }                  }                  while (t_idx != 256);                  byte hi = m_input.ReadUInt8();                  byte lo = m_input.ReadUInt8();                  count = hi << 8 | lo;                  int pos = 0;                  for (;;)                  {                      byte b;                      if (pos != 0)                      {                          b = m_filename[--pos];                      }                      else                      {                          if (0 == count--)                              break;                          b = m_input.ReadUInt8();                      }                      if (b == table[0'b])                      {                          output[dst++] = b;                          if (dst >= output.Length)                              break;                      }                      else                      {                          m_filename[pos++] = table[1'b];                          m_filename[pos++] = table[0'b];                      }                  }              }
Magic Number,GameRes.Formats.Dice,RlzOpener,C:\repos\morkt_GARbro\Legacy\Dice\ArcRLZ.cs,TryOpen,The following statement contains a magic number: int count = file.View.ReadInt32 (4);
Magic Number,GameRes.Formats.Dice,RlzOpener,C:\repos\morkt_GARbro\Legacy\Dice\ArcRLZ.cs,LzUnpack,The following statement contains a magic number: int ctl_bits = 2;
Magic Number,GameRes.Formats.Dice,RlzOpener,C:\repos\morkt_GARbro\Legacy\Dice\ArcRLZ.cs,LzUnpack,The following statement contains a magic number: while (dst < output.Length)              {                  ctl_bits >>= 1;                  if (1 == ctl_bits)                  {                      ctl_bits = input.ReadByte();                      if (-1 == ctl_bits)                          break;                      ctl_bits |= 0x100;                  }                  if (0 != (ctl_bits & 1))                  {                      byte v = input.ReadUInt8();                      output[dst++] = v;                      frame[frame_pos++ & 0x7FF] = v;                  }                  else                  {                      byte lo = input.ReadUInt8();                      byte hi = input.ReadUInt8();                      int offset = (hi & 0xF0) << 4 | lo;                      int count = (hi & 0xF) + 2;                      for (int i = 0; i < count; ++i)                      {                          byte v = frame[(offset + i) & 0x7FF];                          output[dst++] = v;                          frame[frame_pos++ & 0x7FF] = v;                      }                  }              }
Magic Number,GameRes.Formats.Dice,RlzOpener,C:\repos\morkt_GARbro\Legacy\Dice\ArcRLZ.cs,LzUnpack,The following statement contains a magic number: while (dst < output.Length)              {                  ctl_bits >>= 1;                  if (1 == ctl_bits)                  {                      ctl_bits = input.ReadByte();                      if (-1 == ctl_bits)                          break;                      ctl_bits |= 0x100;                  }                  if (0 != (ctl_bits & 1))                  {                      byte v = input.ReadUInt8();                      output[dst++] = v;                      frame[frame_pos++ & 0x7FF] = v;                  }                  else                  {                      byte lo = input.ReadUInt8();                      byte hi = input.ReadUInt8();                      int offset = (hi & 0xF0) << 4 | lo;                      int count = (hi & 0xF) + 2;                      for (int i = 0; i < count; ++i)                      {                          byte v = frame[(offset + i) & 0x7FF];                          output[dst++] = v;                          frame[frame_pos++ & 0x7FF] = v;                      }                  }              }
Magic Number,GameRes.Formats.Dice,KwfAudio,C:\repos\morkt_GARbro\Legacy\Dice\AudioKWF.cs,TryOpen,The following statement contains a magic number: int method = header.ToInt32 (4);
Magic Number,GameRes.Formats.Dice,KwfAudio,C:\repos\morkt_GARbro\Legacy\Dice\AudioKWF.cs,TryOpen,The following statement contains a magic number: if (method != 3)                  throw new NotImplementedException();
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,ReadMetaData,The following statement contains a magic number: return new RbpMetaData {                  BPP = header.ToInt32 (4) == 1 ? 24 : 32'                  Width = header.ToUInt32 (8)'                  Height = header.ToUInt32 (0xC)'                  DataOffset = header.ToInt32 (0x10)'              };
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,ReadMetaData,The following statement contains a magic number: return new RbpMetaData {                  BPP = header.ToInt32 (4) == 1 ? 24 : 32'                  Width = header.ToUInt32 (8)'                  Height = header.ToUInt32 (0xC)'                  DataOffset = header.ToInt32 (0x10)'              };
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,ReadMetaData,The following statement contains a magic number: return new RbpMetaData {                  BPP = header.ToInt32 (4) == 1 ? 24 : 32'                  Width = header.ToUInt32 (8)'                  Height = header.ToUInt32 (0xC)'                  DataOffset = header.ToInt32 (0x10)'              };
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,ReadMetaData,The following statement contains a magic number: return new RbpMetaData {                  BPP = header.ToInt32 (4) == 1 ? 24 : 32'                  Width = header.ToUInt32 (8)'                  Height = header.ToUInt32 (0xC)'                  DataOffset = header.ToInt32 (0x10)'              };
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,Read,The following statement contains a magic number: int stride = 4 * (int)meta.Width;
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,Read,The following statement contains a magic number: if (24 == meta.BPP)              {                  for (int i = 0; i < pixels.Length; i += 4)                  {                      int pixel = file.ReadInt24();                      pixels[i  ] = (byte) (pixel << 3);                      pixels[i+1] = (byte)((pixel >> 3) & 0xFC);                      pixels[i+2] = (byte)((pixel >> 8) & 0xF8);                      pixels[i+3] = (byte)((pixel >> 16) * 0xFF / 0x3F);                  }              }              else              {                  file.Read (pixels' 0' pixels.Length);                  for (int i = 3; i < pixels.Length; i += 4)                  {                      byte alpha = pixels[i];                      if (alpha != 0)                          pixels[i] = (byte)(alpha * 0xFF / 0x3F);                  }              }
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,Read,The following statement contains a magic number: if (24 == meta.BPP)              {                  for (int i = 0; i < pixels.Length; i += 4)                  {                      int pixel = file.ReadInt24();                      pixels[i  ] = (byte) (pixel << 3);                      pixels[i+1] = (byte)((pixel >> 3) & 0xFC);                      pixels[i+2] = (byte)((pixel >> 8) & 0xF8);                      pixels[i+3] = (byte)((pixel >> 16) * 0xFF / 0x3F);                  }              }              else              {                  file.Read (pixels' 0' pixels.Length);                  for (int i = 3; i < pixels.Length; i += 4)                  {                      byte alpha = pixels[i];                      if (alpha != 0)                          pixels[i] = (byte)(alpha * 0xFF / 0x3F);                  }              }
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,Read,The following statement contains a magic number: if (24 == meta.BPP)              {                  for (int i = 0; i < pixels.Length; i += 4)                  {                      int pixel = file.ReadInt24();                      pixels[i  ] = (byte) (pixel << 3);                      pixels[i+1] = (byte)((pixel >> 3) & 0xFC);                      pixels[i+2] = (byte)((pixel >> 8) & 0xF8);                      pixels[i+3] = (byte)((pixel >> 16) * 0xFF / 0x3F);                  }              }              else              {                  file.Read (pixels' 0' pixels.Length);                  for (int i = 3; i < pixels.Length; i += 4)                  {                      byte alpha = pixels[i];                      if (alpha != 0)                          pixels[i] = (byte)(alpha * 0xFF / 0x3F);                  }              }
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,Read,The following statement contains a magic number: if (24 == meta.BPP)              {                  for (int i = 0; i < pixels.Length; i += 4)                  {                      int pixel = file.ReadInt24();                      pixels[i  ] = (byte) (pixel << 3);                      pixels[i+1] = (byte)((pixel >> 3) & 0xFC);                      pixels[i+2] = (byte)((pixel >> 8) & 0xF8);                      pixels[i+3] = (byte)((pixel >> 16) * 0xFF / 0x3F);                  }              }              else              {                  file.Read (pixels' 0' pixels.Length);                  for (int i = 3; i < pixels.Length; i += 4)                  {                      byte alpha = pixels[i];                      if (alpha != 0)                          pixels[i] = (byte)(alpha * 0xFF / 0x3F);                  }              }
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,Read,The following statement contains a magic number: if (24 == meta.BPP)              {                  for (int i = 0; i < pixels.Length; i += 4)                  {                      int pixel = file.ReadInt24();                      pixels[i  ] = (byte) (pixel << 3);                      pixels[i+1] = (byte)((pixel >> 3) & 0xFC);                      pixels[i+2] = (byte)((pixel >> 8) & 0xF8);                      pixels[i+3] = (byte)((pixel >> 16) * 0xFF / 0x3F);                  }              }              else              {                  file.Read (pixels' 0' pixels.Length);                  for (int i = 3; i < pixels.Length; i += 4)                  {                      byte alpha = pixels[i];                      if (alpha != 0)                          pixels[i] = (byte)(alpha * 0xFF / 0x3F);                  }              }
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,Read,The following statement contains a magic number: if (24 == meta.BPP)              {                  for (int i = 0; i < pixels.Length; i += 4)                  {                      int pixel = file.ReadInt24();                      pixels[i  ] = (byte) (pixel << 3);                      pixels[i+1] = (byte)((pixel >> 3) & 0xFC);                      pixels[i+2] = (byte)((pixel >> 8) & 0xF8);                      pixels[i+3] = (byte)((pixel >> 16) * 0xFF / 0x3F);                  }              }              else              {                  file.Read (pixels' 0' pixels.Length);                  for (int i = 3; i < pixels.Length; i += 4)                  {                      byte alpha = pixels[i];                      if (alpha != 0)                          pixels[i] = (byte)(alpha * 0xFF / 0x3F);                  }              }
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,Read,The following statement contains a magic number: if (24 == meta.BPP)              {                  for (int i = 0; i < pixels.Length; i += 4)                  {                      int pixel = file.ReadInt24();                      pixels[i  ] = (byte) (pixel << 3);                      pixels[i+1] = (byte)((pixel >> 3) & 0xFC);                      pixels[i+2] = (byte)((pixel >> 8) & 0xF8);                      pixels[i+3] = (byte)((pixel >> 16) * 0xFF / 0x3F);                  }              }              else              {                  file.Read (pixels' 0' pixels.Length);                  for (int i = 3; i < pixels.Length; i += 4)                  {                      byte alpha = pixels[i];                      if (alpha != 0)                          pixels[i] = (byte)(alpha * 0xFF / 0x3F);                  }              }
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,Read,The following statement contains a magic number: if (24 == meta.BPP)              {                  for (int i = 0; i < pixels.Length; i += 4)                  {                      int pixel = file.ReadInt24();                      pixels[i  ] = (byte) (pixel << 3);                      pixels[i+1] = (byte)((pixel >> 3) & 0xFC);                      pixels[i+2] = (byte)((pixel >> 8) & 0xF8);                      pixels[i+3] = (byte)((pixel >> 16) * 0xFF / 0x3F);                  }              }              else              {                  file.Read (pixels' 0' pixels.Length);                  for (int i = 3; i < pixels.Length; i += 4)                  {                      byte alpha = pixels[i];                      if (alpha != 0)                          pixels[i] = (byte)(alpha * 0xFF / 0x3F);                  }              }
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,Read,The following statement contains a magic number: if (24 == meta.BPP)              {                  for (int i = 0; i < pixels.Length; i += 4)                  {                      int pixel = file.ReadInt24();                      pixels[i  ] = (byte) (pixel << 3);                      pixels[i+1] = (byte)((pixel >> 3) & 0xFC);                      pixels[i+2] = (byte)((pixel >> 8) & 0xF8);                      pixels[i+3] = (byte)((pixel >> 16) * 0xFF / 0x3F);                  }              }              else              {                  file.Read (pixels' 0' pixels.Length);                  for (int i = 3; i < pixels.Length; i += 4)                  {                      byte alpha = pixels[i];                      if (alpha != 0)                          pixels[i] = (byte)(alpha * 0xFF / 0x3F);                  }              }
Magic Number,GameRes.Formats.Dice,RbpFormat,C:\repos\morkt_GARbro\Legacy\Dice\ImageRBP.cs,Read,The following statement contains a magic number: if (24 == meta.BPP)              {                  for (int i = 0; i < pixels.Length; i += 4)                  {                      int pixel = file.ReadInt24();                      pixels[i  ] = (byte) (pixel << 3);                      pixels[i+1] = (byte)((pixel >> 3) & 0xFC);                      pixels[i+2] = (byte)((pixel >> 8) & 0xF8);                      pixels[i+3] = (byte)((pixel >> 16) * 0xFF / 0x3F);                  }              }              else              {                  file.Read (pixels' 0' pixels.Length);                  for (int i = 3; i < pixels.Length; i += 4)                  {                      byte alpha = pixels[i];                      if (alpha != 0)                          pixels[i] = (byte)(alpha * 0xFF / 0x3F);                  }              }
Magic Number,GameRes.Formats.Factor,PackOpener,C:\repos\morkt_GARbro\Legacy\Factor\ArcRES.cs,TryOpen,The following statement contains a magic number: while (offset < file.MaxOffset)              {                  uint size = file.View.ReadUInt32 (offset);                  offset += 4;                  string name;                  if (i < names.Count)                      name = names[i];                  else                      name = string.Format ("{0}#{1:D4}{2}"' base_name' i' pack_ext);                  var entry = FormatCatalog.Instance.Create<Entry> (name);                  entry.Offset = offset;                  entry.Size   = size;                  if (!entry.CheckPlacement (file.MaxOffset))                      return null;                  dir.Add (entry);                  ++i;                  offset += size;              }
Magic Number,GameRes.Formats.Factor,PackOpener,C:\repos\morkt_GARbro\Legacy\Factor\ArcRES.cs,ReadNames,The following statement contains a magic number: using (var pack = VFS.OpenView (res_name))              {                  uint offset = 4 + pack.View.ReadUInt32 (0);                  offset += 4 + pack.View.ReadUInt32 (offset);                  uint size = pack.View.ReadUInt32 (offset);                  offset += 4;                  if (offset >= pack.MaxOffset)                      yield break;                  using (var res = pack.CreateStream (offset' size))                  using (var decrypted = new XoredStream (res' 0x80))                  using (var input = new StreamReader (decrypted' Encodings.cp932))                  {                      var line = input.ReadLine();                      if (string.IsNullOrEmpty (line))                          yield break;                      var match = FirstLineRe.Match (line);                      if (!match.Success || match.Groups[1].Value != num)                          yield break;                      while ((line = input.ReadLine()) != null)                      {                          yield return line;                      }                  }              }
Magic Number,GameRes.Formats.Factor,PackOpener,C:\repos\morkt_GARbro\Legacy\Factor\ArcRES.cs,ReadNames,The following statement contains a magic number: using (var pack = VFS.OpenView (res_name))              {                  uint offset = 4 + pack.View.ReadUInt32 (0);                  offset += 4 + pack.View.ReadUInt32 (offset);                  uint size = pack.View.ReadUInt32 (offset);                  offset += 4;                  if (offset >= pack.MaxOffset)                      yield break;                  using (var res = pack.CreateStream (offset' size))                  using (var decrypted = new XoredStream (res' 0x80))                  using (var input = new StreamReader (decrypted' Encodings.cp932))                  {                      var line = input.ReadLine();                      if (string.IsNullOrEmpty (line))                          yield break;                      var match = FirstLineRe.Match (line);                      if (!match.Success || match.Groups[1].Value != num)                          yield break;                      while ((line = input.ReadLine()) != null)                      {                          yield return line;                      }                  }              }
Magic Number,GameRes.Formats.Factor,PackOpener,C:\repos\morkt_GARbro\Legacy\Factor\ArcRES.cs,ReadNames,The following statement contains a magic number: using (var pack = VFS.OpenView (res_name))              {                  uint offset = 4 + pack.View.ReadUInt32 (0);                  offset += 4 + pack.View.ReadUInt32 (offset);                  uint size = pack.View.ReadUInt32 (offset);                  offset += 4;                  if (offset >= pack.MaxOffset)                      yield break;                  using (var res = pack.CreateStream (offset' size))                  using (var decrypted = new XoredStream (res' 0x80))                  using (var input = new StreamReader (decrypted' Encodings.cp932))                  {                      var line = input.ReadLine();                      if (string.IsNullOrEmpty (line))                          yield break;                      var match = FirstLineRe.Match (line);                      if (!match.Success || match.Groups[1].Value != num)                          yield break;                      while ((line = input.ReadLine()) != null)                      {                          yield return line;                      }                  }              }
Magic Number,GameRes.Formats.Nabe,YpfFormat,C:\repos\morkt_GARbro\Legacy\Nabe\ImageYPF.cs,YpfFormat,The following statement contains a magic number: Signatures = new uint[] { 0' 1' 2' 3 };
Magic Number,GameRes.Formats.Nabe,YpfFormat,C:\repos\morkt_GARbro\Legacy\Nabe\ImageYPF.cs,YpfFormat,The following statement contains a magic number: Signatures = new uint[] { 0' 1' 2' 3 };
Magic Number,GameRes.Formats.Nabe,YpfFormat,C:\repos\morkt_GARbro\Legacy\Nabe\ImageYPF.cs,ReadMetaData,The following statement contains a magic number: if (header[0] != 1 && header[0] != 3)                  return null;
Magic Number,GameRes.Formats.Nabe,YpfFormat,C:\repos\morkt_GARbro\Legacy\Nabe\ImageYPF.cs,ReadMetaData,The following statement contains a magic number: uint w = header.ToUInt32 (4);
Magic Number,GameRes.Formats.Nabe,YpfFormat,C:\repos\morkt_GARbro\Legacy\Nabe\ImageYPF.cs,ReadMetaData,The following statement contains a magic number: uint h = header.ToUInt32 (8);
Magic Number,GameRes.Formats.Nabe,YpfFormat,C:\repos\morkt_GARbro\Legacy\Nabe\ImageYPF.cs,ReadMetaData,The following statement contains a magic number: return new ImageMetaData {                  Width = w'                  Height = h'                  BPP = 1 == header[0] ? 24 : 32'              };
Magic Number,GameRes.Formats.Nabe,YpfFormat,C:\repos\morkt_GARbro\Legacy\Nabe\ImageYPF.cs,ReadMetaData,The following statement contains a magic number: return new ImageMetaData {                  Width = w'                  Height = h'                  BPP = 1 == header[0] ? 24 : 32'              };
Magic Number,GameRes.Formats.Nabe,YpfFormat,C:\repos\morkt_GARbro\Legacy\Nabe\ImageYPF.cs,Read,The following statement contains a magic number: var pixels = file.ReadBytes (pixel_count * 3);
Magic Number,GameRes.Formats.Nabe,YpfFormat,C:\repos\morkt_GARbro\Legacy\Nabe\ImageYPF.cs,Read,The following statement contains a magic number: if (32 == info.BPP)              {                  var alpha = file.ReadBytes (pixel_count);                  var output = new byte[pixel_count * 4];                  int src = 0;                  int dst = 0;                  for (int i = 0; i < pixel_count; ++i)                  {                      output[dst++] = pixels[src++];                      output[dst++] = pixels[src++];                      output[dst++] = pixels[src++];                      output[dst++] = alpha[i];                  }                  pixels = output;              }
Magic Number,GameRes.Formats.Nabe,YpfFormat,C:\repos\morkt_GARbro\Legacy\Nabe\ImageYPF.cs,Read,The following statement contains a magic number: if (32 == info.BPP)              {                  var alpha = file.ReadBytes (pixel_count);                  var output = new byte[pixel_count * 4];                  int src = 0;                  int dst = 0;                  for (int i = 0; i < pixel_count; ++i)                  {                      output[dst++] = pixels[src++];                      output[dst++] = pixels[src++];                      output[dst++] = pixels[src++];                      output[dst++] = alpha[i];                  }                  pixels = output;              }
Magic Number,GameRes.Formats.Nabe,YpfFormat,C:\repos\morkt_GARbro\Legacy\Nabe\ImageYPF.cs,Read,The following statement contains a magic number: PixelFormat format = 24 == info.BPP ? PixelFormats.Bgr24 : PixelFormats.Bgra32;
Magic Number,GameRes.Formats.Nekotaro,NscOpener,C:\repos\morkt_GARbro\Legacy\Nekotaro\ArcNSC.cs,TryOpen,The following statement contains a magic number: uint prev_offset = file.View.ReadUInt32 (4);
Magic Number,GameRes.Formats.Nekotaro,NscOpener,C:\repos\morkt_GARbro\Legacy\Nekotaro\ArcNSC.cs,TryOpen,The following statement contains a magic number: for (uint index_offset = 8; index_offset < file.MaxOffset; index_offset += 4)              {                  uint offset = file.View.ReadUInt32 (index_offset);                  if (offset <= prev_offset || offset > file.MaxOffset)                      return null;                  uint size = offset - prev_offset;                  var name = string.Format ("{0}#{1:D4}"' base_name' dir.Count);                  Entry entry;                  if (size > 4)                      entry = AutoEntry.Create (file' prev_offset' name);                  else                      entry = new Entry { Name = name' Offset = prev_offset };                  entry.Size = size;                  if (!entry.CheckPlacement (file.MaxOffset))                      return null;                  dir.Add (entry);                  if (file.MaxOffset == offset)                      break;                  prev_offset = offset;              }
Magic Number,GameRes.Formats.Nekotaro,NscOpener,C:\repos\morkt_GARbro\Legacy\Nekotaro\ArcNSC.cs,TryOpen,The following statement contains a magic number: for (uint index_offset = 8; index_offset < file.MaxOffset; index_offset += 4)              {                  uint offset = file.View.ReadUInt32 (index_offset);                  if (offset <= prev_offset || offset > file.MaxOffset)                      return null;                  uint size = offset - prev_offset;                  var name = string.Format ("{0}#{1:D4}"' base_name' dir.Count);                  Entry entry;                  if (size > 4)                      entry = AutoEntry.Create (file' prev_offset' name);                  else                      entry = new Entry { Name = name' Offset = prev_offset };                  entry.Size = size;                  if (!entry.CheckPlacement (file.MaxOffset))                      return null;                  dir.Add (entry);                  if (file.MaxOffset == offset)                      break;                  prev_offset = offset;              }
Magic Number,GameRes.Formats.Nekotaro,NscOpener,C:\repos\morkt_GARbro\Legacy\Nekotaro\ArcNSC.cs,TryOpen,The following statement contains a magic number: for (uint index_offset = 8; index_offset < file.MaxOffset; index_offset += 4)              {                  uint offset = file.View.ReadUInt32 (index_offset);                  if (offset <= prev_offset || offset > file.MaxOffset)                      return null;                  uint size = offset - prev_offset;                  var name = string.Format ("{0}#{1:D4}"' base_name' dir.Count);                  Entry entry;                  if (size > 4)                      entry = AutoEntry.Create (file' prev_offset' name);                  else                      entry = new Entry { Name = name' Offset = prev_offset };                  entry.Size = size;                  if (!entry.CheckPlacement (file.MaxOffset))                      return null;                  dir.Add (entry);                  if (file.MaxOffset == offset)                      break;                  prev_offset = offset;              }
Magic Number,GameRes.Formats.Nekotaro,GCmpFormat,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,ReadMetaData,The following statement contains a magic number: int bpp = header[12];
Magic Number,GameRes.Formats.Nekotaro,GCmpFormat,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,ReadMetaData,The following statement contains a magic number: if (bpp != 24 && bpp != 8 && bpp != 1)                  return null;
Magic Number,GameRes.Formats.Nekotaro,GCmpFormat,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,ReadMetaData,The following statement contains a magic number: if (bpp != 24 && bpp != 8 && bpp != 1)                  return null;
Magic Number,GameRes.Formats.Nekotaro,GCmpFormat,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,ReadMetaData,The following statement contains a magic number: return new ImageMetaData {                  Width = header.ToUInt16 (8)'                  Height = header.ToUInt16 (10)'                  BPP = bpp'              };
Magic Number,GameRes.Formats.Nekotaro,GCmpFormat,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,ReadMetaData,The following statement contains a magic number: return new ImageMetaData {                  Width = header.ToUInt16 (8)'                  Height = header.ToUInt16 (10)'                  BPP = bpp'              };
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,GCmpDecoder,The following statement contains a magic number: if (info.BPP > 1)                  Stride = (int)info.Width * info.BPP / 8;              else                  Stride = ((int)info.Width + 7) / 8;
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,GCmpDecoder,The following statement contains a magic number: if (info.BPP > 1)                  Stride = (int)info.Width * info.BPP / 8;              else                  Stride = ((int)info.Width + 7) / 8;
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,GCmpDecoder,The following statement contains a magic number: if (info.BPP > 1)                  Stride = (int)info.Width * info.BPP / 8;              else                  Stride = ((int)info.Width + 7) / 8;
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack,The following statement contains a magic number: if (24 == Info.BPP)                  return Unpack24bpp();              else                  return Unpack8bpp();
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: var output = new byte[pixel_count * Info.BPP / 8 + 1];
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: var frame = new byte[384];
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack24bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  int count' frame_pos' pixel;                  if (v19 != 0)                  {                      pixel = m_input.ReadInt24();                      count = 1;                      frame_pos = 127;                      --v19;                  }                  else                  {                      count = m_input.ReadUInt8();                      int lo = count & 0x1F;                      if (0 != (count & 0x80))                      {                          count = ((byte)count >> 5) & 3;                          if (count != 0)                          {                              frame_pos = lo;                          }                          else                          {                              count = lo << 1;                              frame_pos = m_input.ReadUInt8();                              if (0 != (frame_pos & 0x80))                                  ++count;                              frame_pos &= 0x7F;                          }                          if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          int fpos = 3 * frame_pos;                          pixel = frame[fpos] | frame[fpos+1] << 8 | frame[fpos+2] << 16;                      }                      else                      {                          if (1 == count)                          {                              v19 = m_input.ReadUInt8() - 1;                          }                          else if (0 == count)                          {                              count = m_input.ReadInt32();                          }                          pixel = m_input.ReadInt24();                          frame_pos = 127;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  LittleEndian.Pack (pixel' output' dst);                  dst += 3;                  if (--count > 0)                  {                      count *= 3;                      Binary.CopyOverlapped (output' dst - 3' dst' count);                      dst += count;                  }                  if (frame_pos != 0)                      Buffer.BlockCopy (frame' 0' frame' 3' 3 * frame_pos);                  frame[0] = (byte)pixel;                  frame[1] = (byte)(pixel >> 8);                  frame[2] = (byte)(pixel >> 16);              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: Format = 8 == Info.BPP ? PixelFormats.Gray8 : PixelFormats.BlackWhite;
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: byte[] frame = { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 0xFF };
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: byte[] frame = { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 0xFF };
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: byte[] frame = { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 0xFF };
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: byte[] frame = { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 0xFF };
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: byte[] frame = { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 0xFF };
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: byte[] frame = { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 0xFF };
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: byte[] frame = { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 0xFF };
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: byte[] frame = { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 0xFF };
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: byte[] frame = { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 0xFF };
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: byte[] frame = { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 0xFF };
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: byte[] frame = { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 0xFF };
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: byte[] frame = { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 0xFF };
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  byte pixel;                  int frame_pos;                  byte ctl = m_input.ReadUInt8();                  int hi = ctl >> 4;                  int lo = ctl & 0xF;                  if (hi != 0)                  {                      frame_pos = hi - 1;                      pixel = frame[frame_pos];                      count = lo + 1;                  }                  else                  {                      switch (lo)                      {                      default:                          count = lo + 1;                          break;                      case 10:                          count = m_input.ReadUInt8() + 11;                          break;                      case 11:                          count = m_input.ReadUInt16() + 267;                          break;                      case 12:                          count = m_input.ReadInt32() + 65803;                          break;                      case 13:                          extra_count = 0x10;                          count = m_input.ReadUInt8();                          break;                      case 14:                          extra_count = 0x120;                          count = m_input.ReadUInt16();                          break;                      case 15:                          extra_count = 0x10130;                          count = m_input.ReadInt32();                          break;                      }                      pixel = m_input.ReadUInt8();                      if (lo < 13)                      {                          frame_pos = 14;                      }                      else                      {                          lo = pixel & 0xF;                          frame_pos = (pixel >> 4) - 1;                          pixel = frame[frame_pos];                          count = extra_count + 16 * count + lo + 1;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  for (int i = 0; i < count; ++i)                      output[dst++] = pixel;                  Buffer.BlockCopy (frame' 0' frame' 1' frame_pos);                  frame[0] = pixel;              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  byte pixel;                  int frame_pos;                  byte ctl = m_input.ReadUInt8();                  int hi = ctl >> 4;                  int lo = ctl & 0xF;                  if (hi != 0)                  {                      frame_pos = hi - 1;                      pixel = frame[frame_pos];                      count = lo + 1;                  }                  else                  {                      switch (lo)                      {                      default:                          count = lo + 1;                          break;                      case 10:                          count = m_input.ReadUInt8() + 11;                          break;                      case 11:                          count = m_input.ReadUInt16() + 267;                          break;                      case 12:                          count = m_input.ReadInt32() + 65803;                          break;                      case 13:                          extra_count = 0x10;                          count = m_input.ReadUInt8();                          break;                      case 14:                          extra_count = 0x120;                          count = m_input.ReadUInt16();                          break;                      case 15:                          extra_count = 0x10130;                          count = m_input.ReadInt32();                          break;                      }                      pixel = m_input.ReadUInt8();                      if (lo < 13)                      {                          frame_pos = 14;                      }                      else                      {                          lo = pixel & 0xF;                          frame_pos = (pixel >> 4) - 1;                          pixel = frame[frame_pos];                          count = extra_count + 16 * count + lo + 1;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  for (int i = 0; i < count; ++i)                      output[dst++] = pixel;                  Buffer.BlockCopy (frame' 0' frame' 1' frame_pos);                  frame[0] = pixel;              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  byte pixel;                  int frame_pos;                  byte ctl = m_input.ReadUInt8();                  int hi = ctl >> 4;                  int lo = ctl & 0xF;                  if (hi != 0)                  {                      frame_pos = hi - 1;                      pixel = frame[frame_pos];                      count = lo + 1;                  }                  else                  {                      switch (lo)                      {                      default:                          count = lo + 1;                          break;                      case 10:                          count = m_input.ReadUInt8() + 11;                          break;                      case 11:                          count = m_input.ReadUInt16() + 267;                          break;                      case 12:                          count = m_input.ReadInt32() + 65803;                          break;                      case 13:                          extra_count = 0x10;                          count = m_input.ReadUInt8();                          break;                      case 14:                          extra_count = 0x120;                          count = m_input.ReadUInt16();                          break;                      case 15:                          extra_count = 0x10130;                          count = m_input.ReadInt32();                          break;                      }                      pixel = m_input.ReadUInt8();                      if (lo < 13)                      {                          frame_pos = 14;                      }                      else                      {                          lo = pixel & 0xF;                          frame_pos = (pixel >> 4) - 1;                          pixel = frame[frame_pos];                          count = extra_count + 16 * count + lo + 1;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  for (int i = 0; i < count; ++i)                      output[dst++] = pixel;                  Buffer.BlockCopy (frame' 0' frame' 1' frame_pos);                  frame[0] = pixel;              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  byte pixel;                  int frame_pos;                  byte ctl = m_input.ReadUInt8();                  int hi = ctl >> 4;                  int lo = ctl & 0xF;                  if (hi != 0)                  {                      frame_pos = hi - 1;                      pixel = frame[frame_pos];                      count = lo + 1;                  }                  else                  {                      switch (lo)                      {                      default:                          count = lo + 1;                          break;                      case 10:                          count = m_input.ReadUInt8() + 11;                          break;                      case 11:                          count = m_input.ReadUInt16() + 267;                          break;                      case 12:                          count = m_input.ReadInt32() + 65803;                          break;                      case 13:                          extra_count = 0x10;                          count = m_input.ReadUInt8();                          break;                      case 14:                          extra_count = 0x120;                          count = m_input.ReadUInt16();                          break;                      case 15:                          extra_count = 0x10130;                          count = m_input.ReadInt32();                          break;                      }                      pixel = m_input.ReadUInt8();                      if (lo < 13)                      {                          frame_pos = 14;                      }                      else                      {                          lo = pixel & 0xF;                          frame_pos = (pixel >> 4) - 1;                          pixel = frame[frame_pos];                          count = extra_count + 16 * count + lo + 1;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  for (int i = 0; i < count; ++i)                      output[dst++] = pixel;                  Buffer.BlockCopy (frame' 0' frame' 1' frame_pos);                  frame[0] = pixel;              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  byte pixel;                  int frame_pos;                  byte ctl = m_input.ReadUInt8();                  int hi = ctl >> 4;                  int lo = ctl & 0xF;                  if (hi != 0)                  {                      frame_pos = hi - 1;                      pixel = frame[frame_pos];                      count = lo + 1;                  }                  else                  {                      switch (lo)                      {                      default:                          count = lo + 1;                          break;                      case 10:                          count = m_input.ReadUInt8() + 11;                          break;                      case 11:                          count = m_input.ReadUInt16() + 267;                          break;                      case 12:                          count = m_input.ReadInt32() + 65803;                          break;                      case 13:                          extra_count = 0x10;                          count = m_input.ReadUInt8();                          break;                      case 14:                          extra_count = 0x120;                          count = m_input.ReadUInt16();                          break;                      case 15:                          extra_count = 0x10130;                          count = m_input.ReadInt32();                          break;                      }                      pixel = m_input.ReadUInt8();                      if (lo < 13)                      {                          frame_pos = 14;                      }                      else                      {                          lo = pixel & 0xF;                          frame_pos = (pixel >> 4) - 1;                          pixel = frame[frame_pos];                          count = extra_count + 16 * count + lo + 1;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  for (int i = 0; i < count; ++i)                      output[dst++] = pixel;                  Buffer.BlockCopy (frame' 0' frame' 1' frame_pos);                  frame[0] = pixel;              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  byte pixel;                  int frame_pos;                  byte ctl = m_input.ReadUInt8();                  int hi = ctl >> 4;                  int lo = ctl & 0xF;                  if (hi != 0)                  {                      frame_pos = hi - 1;                      pixel = frame[frame_pos];                      count = lo + 1;                  }                  else                  {                      switch (lo)                      {                      default:                          count = lo + 1;                          break;                      case 10:                          count = m_input.ReadUInt8() + 11;                          break;                      case 11:                          count = m_input.ReadUInt16() + 267;                          break;                      case 12:                          count = m_input.ReadInt32() + 65803;                          break;                      case 13:                          extra_count = 0x10;                          count = m_input.ReadUInt8();                          break;                      case 14:                          extra_count = 0x120;                          count = m_input.ReadUInt16();                          break;                      case 15:                          extra_count = 0x10130;                          count = m_input.ReadInt32();                          break;                      }                      pixel = m_input.ReadUInt8();                      if (lo < 13)                      {                          frame_pos = 14;                      }                      else                      {                          lo = pixel & 0xF;                          frame_pos = (pixel >> 4) - 1;                          pixel = frame[frame_pos];                          count = extra_count + 16 * count + lo + 1;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  for (int i = 0; i < count; ++i)                      output[dst++] = pixel;                  Buffer.BlockCopy (frame' 0' frame' 1' frame_pos);                  frame[0] = pixel;              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  byte pixel;                  int frame_pos;                  byte ctl = m_input.ReadUInt8();                  int hi = ctl >> 4;                  int lo = ctl & 0xF;                  if (hi != 0)                  {                      frame_pos = hi - 1;                      pixel = frame[frame_pos];                      count = lo + 1;                  }                  else                  {                      switch (lo)                      {                      default:                          count = lo + 1;                          break;                      case 10:                          count = m_input.ReadUInt8() + 11;                          break;                      case 11:                          count = m_input.ReadUInt16() + 267;                          break;                      case 12:                          count = m_input.ReadInt32() + 65803;                          break;                      case 13:                          extra_count = 0x10;                          count = m_input.ReadUInt8();                          break;                      case 14:                          extra_count = 0x120;                          count = m_input.ReadUInt16();                          break;                      case 15:                          extra_count = 0x10130;                          count = m_input.ReadInt32();                          break;                      }                      pixel = m_input.ReadUInt8();                      if (lo < 13)                      {                          frame_pos = 14;                      }                      else                      {                          lo = pixel & 0xF;                          frame_pos = (pixel >> 4) - 1;                          pixel = frame[frame_pos];                          count = extra_count + 16 * count + lo + 1;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  for (int i = 0; i < count; ++i)                      output[dst++] = pixel;                  Buffer.BlockCopy (frame' 0' frame' 1' frame_pos);                  frame[0] = pixel;              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  byte pixel;                  int frame_pos;                  byte ctl = m_input.ReadUInt8();                  int hi = ctl >> 4;                  int lo = ctl & 0xF;                  if (hi != 0)                  {                      frame_pos = hi - 1;                      pixel = frame[frame_pos];                      count = lo + 1;                  }                  else                  {                      switch (lo)                      {                      default:                          count = lo + 1;                          break;                      case 10:                          count = m_input.ReadUInt8() + 11;                          break;                      case 11:                          count = m_input.ReadUInt16() + 267;                          break;                      case 12:                          count = m_input.ReadInt32() + 65803;                          break;                      case 13:                          extra_count = 0x10;                          count = m_input.ReadUInt8();                          break;                      case 14:                          extra_count = 0x120;                          count = m_input.ReadUInt16();                          break;                      case 15:                          extra_count = 0x10130;                          count = m_input.ReadInt32();                          break;                      }                      pixel = m_input.ReadUInt8();                      if (lo < 13)                      {                          frame_pos = 14;                      }                      else                      {                          lo = pixel & 0xF;                          frame_pos = (pixel >> 4) - 1;                          pixel = frame[frame_pos];                          count = extra_count + 16 * count + lo + 1;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  for (int i = 0; i < count; ++i)                      output[dst++] = pixel;                  Buffer.BlockCopy (frame' 0' frame' 1' frame_pos);                  frame[0] = pixel;              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  byte pixel;                  int frame_pos;                  byte ctl = m_input.ReadUInt8();                  int hi = ctl >> 4;                  int lo = ctl & 0xF;                  if (hi != 0)                  {                      frame_pos = hi - 1;                      pixel = frame[frame_pos];                      count = lo + 1;                  }                  else                  {                      switch (lo)                      {                      default:                          count = lo + 1;                          break;                      case 10:                          count = m_input.ReadUInt8() + 11;                          break;                      case 11:                          count = m_input.ReadUInt16() + 267;                          break;                      case 12:                          count = m_input.ReadInt32() + 65803;                          break;                      case 13:                          extra_count = 0x10;                          count = m_input.ReadUInt8();                          break;                      case 14:                          extra_count = 0x120;                          count = m_input.ReadUInt16();                          break;                      case 15:                          extra_count = 0x10130;                          count = m_input.ReadInt32();                          break;                      }                      pixel = m_input.ReadUInt8();                      if (lo < 13)                      {                          frame_pos = 14;                      }                      else                      {                          lo = pixel & 0xF;                          frame_pos = (pixel >> 4) - 1;                          pixel = frame[frame_pos];                          count = extra_count + 16 * count + lo + 1;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  for (int i = 0; i < count; ++i)                      output[dst++] = pixel;                  Buffer.BlockCopy (frame' 0' frame' 1' frame_pos);                  frame[0] = pixel;              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  byte pixel;                  int frame_pos;                  byte ctl = m_input.ReadUInt8();                  int hi = ctl >> 4;                  int lo = ctl & 0xF;                  if (hi != 0)                  {                      frame_pos = hi - 1;                      pixel = frame[frame_pos];                      count = lo + 1;                  }                  else                  {                      switch (lo)                      {                      default:                          count = lo + 1;                          break;                      case 10:                          count = m_input.ReadUInt8() + 11;                          break;                      case 11:                          count = m_input.ReadUInt16() + 267;                          break;                      case 12:                          count = m_input.ReadInt32() + 65803;                          break;                      case 13:                          extra_count = 0x10;                          count = m_input.ReadUInt8();                          break;                      case 14:                          extra_count = 0x120;                          count = m_input.ReadUInt16();                          break;                      case 15:                          extra_count = 0x10130;                          count = m_input.ReadInt32();                          break;                      }                      pixel = m_input.ReadUInt8();                      if (lo < 13)                      {                          frame_pos = 14;                      }                      else                      {                          lo = pixel & 0xF;                          frame_pos = (pixel >> 4) - 1;                          pixel = frame[frame_pos];                          count = extra_count + 16 * count + lo + 1;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  for (int i = 0; i < count; ++i)                      output[dst++] = pixel;                  Buffer.BlockCopy (frame' 0' frame' 1' frame_pos);                  frame[0] = pixel;              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  byte pixel;                  int frame_pos;                  byte ctl = m_input.ReadUInt8();                  int hi = ctl >> 4;                  int lo = ctl & 0xF;                  if (hi != 0)                  {                      frame_pos = hi - 1;                      pixel = frame[frame_pos];                      count = lo + 1;                  }                  else                  {                      switch (lo)                      {                      default:                          count = lo + 1;                          break;                      case 10:                          count = m_input.ReadUInt8() + 11;                          break;                      case 11:                          count = m_input.ReadUInt16() + 267;                          break;                      case 12:                          count = m_input.ReadInt32() + 65803;                          break;                      case 13:                          extra_count = 0x10;                          count = m_input.ReadUInt8();                          break;                      case 14:                          extra_count = 0x120;                          count = m_input.ReadUInt16();                          break;                      case 15:                          extra_count = 0x10130;                          count = m_input.ReadInt32();                          break;                      }                      pixel = m_input.ReadUInt8();                      if (lo < 13)                      {                          frame_pos = 14;                      }                      else                      {                          lo = pixel & 0xF;                          frame_pos = (pixel >> 4) - 1;                          pixel = frame[frame_pos];                          count = extra_count + 16 * count + lo + 1;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  for (int i = 0; i < count; ++i)                      output[dst++] = pixel;                  Buffer.BlockCopy (frame' 0' frame' 1' frame_pos);                  frame[0] = pixel;              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  byte pixel;                  int frame_pos;                  byte ctl = m_input.ReadUInt8();                  int hi = ctl >> 4;                  int lo = ctl & 0xF;                  if (hi != 0)                  {                      frame_pos = hi - 1;                      pixel = frame[frame_pos];                      count = lo + 1;                  }                  else                  {                      switch (lo)                      {                      default:                          count = lo + 1;                          break;                      case 10:                          count = m_input.ReadUInt8() + 11;                          break;                      case 11:                          count = m_input.ReadUInt16() + 267;                          break;                      case 12:                          count = m_input.ReadInt32() + 65803;                          break;                      case 13:                          extra_count = 0x10;                          count = m_input.ReadUInt8();                          break;                      case 14:                          extra_count = 0x120;                          count = m_input.ReadUInt16();                          break;                      case 15:                          extra_count = 0x10130;                          count = m_input.ReadInt32();                          break;                      }                      pixel = m_input.ReadUInt8();                      if (lo < 13)                      {                          frame_pos = 14;                      }                      else                      {                          lo = pixel & 0xF;                          frame_pos = (pixel >> 4) - 1;                          pixel = frame[frame_pos];                          count = extra_count + 16 * count + lo + 1;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  for (int i = 0; i < count; ++i)                      output[dst++] = pixel;                  Buffer.BlockCopy (frame' 0' frame' 1' frame_pos);                  frame[0] = pixel;              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  byte pixel;                  int frame_pos;                  byte ctl = m_input.ReadUInt8();                  int hi = ctl >> 4;                  int lo = ctl & 0xF;                  if (hi != 0)                  {                      frame_pos = hi - 1;                      pixel = frame[frame_pos];                      count = lo + 1;                  }                  else                  {                      switch (lo)                      {                      default:                          count = lo + 1;                          break;                      case 10:                          count = m_input.ReadUInt8() + 11;                          break;                      case 11:                          count = m_input.ReadUInt16() + 267;                          break;                      case 12:                          count = m_input.ReadInt32() + 65803;                          break;                      case 13:                          extra_count = 0x10;                          count = m_input.ReadUInt8();                          break;                      case 14:                          extra_count = 0x120;                          count = m_input.ReadUInt16();                          break;                      case 15:                          extra_count = 0x10130;                          count = m_input.ReadInt32();                          break;                      }                      pixel = m_input.ReadUInt8();                      if (lo < 13)                      {                          frame_pos = 14;                      }                      else                      {                          lo = pixel & 0xF;                          frame_pos = (pixel >> 4) - 1;                          pixel = frame[frame_pos];                          count = extra_count + 16 * count + lo + 1;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  for (int i = 0; i < count; ++i)                      output[dst++] = pixel;                  Buffer.BlockCopy (frame' 0' frame' 1' frame_pos);                  frame[0] = pixel;              }
Magic Number,GameRes.Formats.Nekotaro,GCmpDecoder,C:\repos\morkt_GARbro\Legacy\Nekotaro\ImageGCmp.cs,Unpack8bpp,The following statement contains a magic number: while (pixel_count > 0)              {                  byte pixel;                  int frame_pos;                  byte ctl = m_input.ReadUInt8();                  int hi = ctl >> 4;                  int lo = ctl & 0xF;                  if (hi != 0)                  {                      frame_pos = hi - 1;                      pixel = frame[frame_pos];                      count = lo + 1;                  }                  else                  {                      switch (lo)                      {                      default:                          count = lo + 1;                          break;                      case 10:                          count = m_input.ReadUInt8() + 11;                          break;                      case 11:                          count = m_input.ReadUInt16() + 267;                          break;                      case 12:                          count = m_input.ReadInt32() + 65803;                          break;                      case 13:                          extra_count = 0x10;                          count = m_input.ReadUInt8();                          break;                      case 14:                          extra_count = 0x120;                          count = m_input.ReadUInt16();                          break;                      case 15:                          extra_count = 0x10130;                          count = m_input.ReadInt32();                          break;                      }                      pixel = m_input.ReadUInt8();                      if (lo < 13)                      {                          frame_pos = 14;                      }                      else                      {                          lo = pixel & 0xF;                          frame_pos = (pixel >> 4) - 1;                          pixel = frame[frame_pos];                          count = extra_count + 16 * count + lo + 1;                      }                  }                  if (count > pixel_count)                      count = pixel_count;                  pixel_count -= count;                  for (int i = 0; i < count; ++i)                      output[dst++] = pixel;                  Buffer.BlockCopy (frame' 0' frame' 1' frame_pos);                  frame[0] = pixel;              }
Magic Number,GameRes.Formats.QSoft,BpeFormat,C:\repos\morkt_GARbro\Legacy\QSoft\ImageBPE.cs,ReadMetaData,The following statement contains a magic number: file.Position = 4;
Magic Number,GameRes.Formats.QSoft,BpeFormat,C:\repos\morkt_GARbro\Legacy\QSoft\ImageBPE.cs,Read,The following statement contains a magic number: file.Position = 4;
Magic Number,GameRes.Formats.QSoft,BpeFormat,C:\repos\morkt_GARbro\Legacy\QSoft\ImageBPE.cs,Decompress,The following statement contains a magic number: var lhs_nodes = new byte[256];
Magic Number,GameRes.Formats.QSoft,BpeFormat,C:\repos\morkt_GARbro\Legacy\QSoft\ImageBPE.cs,Decompress,The following statement contains a magic number: var rhs_nodes = new byte[256];
Magic Number,GameRes.Formats.QSoft,BpeFormat,C:\repos\morkt_GARbro\Legacy\QSoft\ImageBPE.cs,Decompress,The following statement contains a magic number: var seq = new byte[1024];
Magic Number,GameRes.Formats.QSoft,BpeFormat,C:\repos\morkt_GARbro\Legacy\QSoft\ImageBPE.cs,Decompress,The following statement contains a magic number: while ((ctl = input.ReadByte()) != -1)              {                  for (int i = 0; i < 256; ++i)                      lhs_nodes[i] = (byte)i;                  int token = 0;                  for (;;)                  {                      if (ctl > 127)                      {                          token += ctl - 127;                          ctl = 0;                      }                      if (256 == token)                          break;                      for (int i = 0; i <= ctl; ++i)                      {                          lhs_nodes[token] = (byte)input.ReadByte();                          if (token != lhs_nodes[token])                              rhs_nodes[token] = (byte)input.ReadByte();                            ++token;                      }                      if (256 == token)                          break;                      ctl = input.ReadByte() & 0xFF;                  }                  int chunk_size = Binary.BigEndian (input.ReadUInt16());                  int x = 0;                  for (;;)                  {                      if (x != 0)                      {                          token = seq[--x];                      }                      else                      {                          if (chunk_size-- == 0)                              break;                          token = input.ReadByte();                          if (-1 == token)                              break;                      }                      if (token != lhs_nodes[token])                      {                          if (x+1 >= 1024)                              throw new InvalidFormatException();                          seq[x++] = rhs_nodes[token];                          seq[x++] = lhs_nodes[token];                      }                      else                      {                          output[dst++] = (byte)token;                          if (output.Length == dst)                              return output;                      }                  }              }
Magic Number,GameRes.Formats.QSoft,BpeFormat,C:\repos\morkt_GARbro\Legacy\QSoft\ImageBPE.cs,Decompress,The following statement contains a magic number: while ((ctl = input.ReadByte()) != -1)              {                  for (int i = 0; i < 256; ++i)                      lhs_nodes[i] = (byte)i;                  int token = 0;                  for (;;)                  {                      if (ctl > 127)                      {                          token += ctl - 127;                          ctl = 0;                      }                      if (256 == token)                          break;                      for (int i = 0; i <= ctl; ++i)                      {                          lhs_nodes[token] = (byte)input.ReadByte();                          if (token != lhs_nodes[token])                              rhs_nodes[token] = (byte)input.ReadByte();                            ++token;                      }                      if (256 == token)                          break;                      ctl = input.ReadByte() & 0xFF;                  }                  int chunk_size = Binary.BigEndian (input.ReadUInt16());                  int x = 0;                  for (;;)                  {                      if (x != 0)                      {                          token = seq[--x];                      }                      else                      {                          if (chunk_size-- == 0)                              break;                          token = input.ReadByte();                          if (-1 == token)                              break;                      }                      if (token != lhs_nodes[token])                      {                          if (x+1 >= 1024)                              throw new InvalidFormatException();                          seq[x++] = rhs_nodes[token];                          seq[x++] = lhs_nodes[token];                      }                      else                      {                          output[dst++] = (byte)token;                          if (output.Length == dst)                              return output;                      }                  }              }
Magic Number,GameRes.Formats.QSoft,BpeFormat,C:\repos\morkt_GARbro\Legacy\QSoft\ImageBPE.cs,Decompress,The following statement contains a magic number: while ((ctl = input.ReadByte()) != -1)              {                  for (int i = 0; i < 256; ++i)                      lhs_nodes[i] = (byte)i;                  int token = 0;                  for (;;)                  {                      if (ctl > 127)                      {                          token += ctl - 127;                          ctl = 0;                      }                      if (256 == token)                          break;                      for (int i = 0; i <= ctl; ++i)                      {                          lhs_nodes[token] = (byte)input.ReadByte();                          if (token != lhs_nodes[token])                              rhs_nodes[token] = (byte)input.ReadByte();                            ++token;                      }                      if (256 == token)                          break;                      ctl = input.ReadByte() & 0xFF;                  }                  int chunk_size = Binary.BigEndian (input.ReadUInt16());                  int x = 0;                  for (;;)                  {                      if (x != 0)                      {                          token = seq[--x];                      }                      else                      {                          if (chunk_size-- == 0)                              break;                          token = input.ReadByte();                          if (-1 == token)                              break;                      }                      if (token != lhs_nodes[token])                      {                          if (x+1 >= 1024)                              throw new InvalidFormatException();                          seq[x++] = rhs_nodes[token];                          seq[x++] = lhs_nodes[token];                      }                      else                      {                          output[dst++] = (byte)token;                          if (output.Length == dst)                              return output;                      }                  }              }
Magic Number,GameRes.Formats.QSoft,BpeFormat,C:\repos\morkt_GARbro\Legacy\QSoft\ImageBPE.cs,Decompress,The following statement contains a magic number: while ((ctl = input.ReadByte()) != -1)              {                  for (int i = 0; i < 256; ++i)                      lhs_nodes[i] = (byte)i;                  int token = 0;                  for (;;)                  {                      if (ctl > 127)                      {                          token += ctl - 127;                          ctl = 0;                      }                      if (256 == token)                          break;                      for (int i = 0; i <= ctl; ++i)                      {                          lhs_nodes[token] = (byte)input.ReadByte();                          if (token != lhs_nodes[token])                              rhs_nodes[token] = (byte)input.ReadByte();                            ++token;                      }                      if (256 == token)                          break;                      ctl = input.ReadByte() & 0xFF;                  }                  int chunk_size = Binary.BigEndian (input.ReadUInt16());                  int x = 0;                  for (;;)                  {                      if (x != 0)                      {                          token = seq[--x];                      }                      else                      {                          if (chunk_size-- == 0)                              break;                          token = input.ReadByte();                          if (-1 == token)                              break;                      }                      if (token != lhs_nodes[token])                      {                          if (x+1 >= 1024)                              throw new InvalidFormatException();                          seq[x++] = rhs_nodes[token];                          seq[x++] = lhs_nodes[token];                      }                      else                      {                          output[dst++] = (byte)token;                          if (output.Length == dst)                              return output;                      }                  }              }
Magic Number,GameRes.Formats.QSoft,BpeFormat,C:\repos\morkt_GARbro\Legacy\QSoft\ImageBPE.cs,Decompress,The following statement contains a magic number: while ((ctl = input.ReadByte()) != -1)              {                  for (int i = 0; i < 256; ++i)                      lhs_nodes[i] = (byte)i;                  int token = 0;                  for (;;)                  {                      if (ctl > 127)                      {                          token += ctl - 127;                          ctl = 0;                      }                      if (256 == token)                          break;                      for (int i = 0; i <= ctl; ++i)                      {                          lhs_nodes[token] = (byte)input.ReadByte();                          if (token != lhs_nodes[token])                              rhs_nodes[token] = (byte)input.ReadByte();                            ++token;                      }                      if (256 == token)                          break;                      ctl = input.ReadByte() & 0xFF;                  }                  int chunk_size = Binary.BigEndian (input.ReadUInt16());                  int x = 0;                  for (;;)                  {                      if (x != 0)                      {                          token = seq[--x];                      }                      else                      {                          if (chunk_size-- == 0)                              break;                          token = input.ReadByte();                          if (-1 == token)                              break;                      }                      if (token != lhs_nodes[token])                      {                          if (x+1 >= 1024)                              throw new InvalidFormatException();                          seq[x++] = rhs_nodes[token];                          seq[x++] = lhs_nodes[token];                      }                      else                      {                          output[dst++] = (byte)token;                          if (output.Length == dst)                              return output;                      }                  }              }
Magic Number,GameRes.Formats.QSoft,BpeFormat,C:\repos\morkt_GARbro\Legacy\QSoft\ImageBPE.cs,Decompress,The following statement contains a magic number: while ((ctl = input.ReadByte()) != -1)              {                  for (int i = 0; i < 256; ++i)                      lhs_nodes[i] = (byte)i;                  int token = 0;                  for (;;)                  {                      if (ctl > 127)                      {                          token += ctl - 127;                          ctl = 0;                      }                      if (256 == token)                          break;                      for (int i = 0; i <= ctl; ++i)                      {                          lhs_nodes[token] = (byte)input.ReadByte();                          if (token != lhs_nodes[token])                              rhs_nodes[token] = (byte)input.ReadByte();                            ++token;                      }                      if (256 == token)                          break;                      ctl = input.ReadByte() & 0xFF;                  }                  int chunk_size = Binary.BigEndian (input.ReadUInt16());                  int x = 0;                  for (;;)                  {                      if (x != 0)                      {                          token = seq[--x];                      }                      else                      {                          if (chunk_size-- == 0)                              break;                          token = input.ReadByte();                          if (-1 == token)                              break;                      }                      if (token != lhs_nodes[token])                      {                          if (x+1 >= 1024)                              throw new InvalidFormatException();                          seq[x++] = rhs_nodes[token];                          seq[x++] = lhs_nodes[token];                      }                      else                      {                          output[dst++] = (byte)token;                          if (output.Length == dst)                              return output;                      }                  }              }
Magic Number,GameRes.Formats.Rain,BinOpener,C:\repos\morkt_GARbro\Legacy\Rain\ArcBIN.cs,TryOpen,The following statement contains a magic number: uint index_size = (uint)count * 12;
Magic Number,GameRes.Formats.Rain,BinOpener,C:\repos\morkt_GARbro\Legacy\Rain\ArcBIN.cs,TryOpen,The following statement contains a magic number: if (index_size > file.View.Reserve (4' index_size))                  return null;
Magic Number,GameRes.Formats.Rain,BinOpener,C:\repos\morkt_GARbro\Legacy\Rain\ArcBIN.cs,TryOpen,The following statement contains a magic number: uint index_offset = 4;
Magic Number,GameRes.Formats.Rain,BinOpener,C:\repos\morkt_GARbro\Legacy\Rain\ArcBIN.cs,TryOpen,The following statement contains a magic number: uint data_offset = 4 + index_size;
Magic Number,GameRes.Formats.Rain,BinOpener,C:\repos\morkt_GARbro\Legacy\Rain\ArcBIN.cs,TryOpen,The following statement contains a magic number: for (int i = 0; i < count; ++i)              {                  uint num = file.View.ReadUInt32 (index_offset);                  if (num > 0xFFFFFF || !seen_nums.Add (num))                      return null;                  var name = string.Format ("{0:D5}.{1}"' num' ext);                  var entry = FormatCatalog.Instance.Create<Entry> (name);                  entry.Offset = file.View.ReadUInt32 (index_offset+4);                  entry.Size   = file.View.ReadUInt32 (index_offset+8);                  if (entry.Offset < data_offset || !entry.CheckPlacement (file.MaxOffset))                      return null;                  dir.Add (entry);                  index_offset += 12;              }
Magic Number,GameRes.Formats.Rain,BinOpener,C:\repos\morkt_GARbro\Legacy\Rain\ArcBIN.cs,TryOpen,The following statement contains a magic number: for (int i = 0; i < count; ++i)              {                  uint num = file.View.ReadUInt32 (index_offset);                  if (num > 0xFFFFFF || !seen_nums.Add (num))                      return null;                  var name = string.Format ("{0:D5}.{1}"' num' ext);                  var entry = FormatCatalog.Instance.Create<Entry> (name);                  entry.Offset = file.View.ReadUInt32 (index_offset+4);                  entry.Size   = file.View.ReadUInt32 (index_offset+8);                  if (entry.Offset < data_offset || !entry.CheckPlacement (file.MaxOffset))                      return null;                  dir.Add (entry);                  index_offset += 12;              }
Magic Number,GameRes.Formats.Rain,BinOpener,C:\repos\morkt_GARbro\Legacy\Rain\ArcBIN.cs,TryOpen,The following statement contains a magic number: for (int i = 0; i < count; ++i)              {                  uint num = file.View.ReadUInt32 (index_offset);                  if (num > 0xFFFFFF || !seen_nums.Add (num))                      return null;                  var name = string.Format ("{0:D5}.{1}"' num' ext);                  var entry = FormatCatalog.Instance.Create<Entry> (name);                  entry.Offset = file.View.ReadUInt32 (index_offset+4);                  entry.Size   = file.View.ReadUInt32 (index_offset+8);                  if (entry.Offset < data_offset || !entry.CheckPlacement (file.MaxOffset))                      return null;                  dir.Add (entry);                  index_offset += 12;              }
Magic Number,GameRes.Formats.Rain,BinOpener,C:\repos\morkt_GARbro\Legacy\Rain\ArcBIN.cs,OpenEntry,The following statement contains a magic number: var input = arc.File.CreateStream (entry.Offset+12' entry.Size-12);
Magic Number,GameRes.Formats.Rain,BinOpener,C:\repos\morkt_GARbro\Legacy\Rain\ArcBIN.cs,OpenEntry,The following statement contains a magic number: var input = arc.File.CreateStream (entry.Offset+12' entry.Size-12);
Magic Number,GameRes.Formats.Saiki,ObfuscatedImageFormat,C:\repos\morkt_GARbro\Legacy\Saiki\ImageJPX.cs,OpenEncrypted,The following statement contains a magic number: var header = input.ReadBytes (encrypted_length+2);
Magic Number,GameRes.Formats.Saiki,ObfuscatedImageFormat,C:\repos\morkt_GARbro\Legacy\Saiki\ImageJPX.cs,OpenEncrypted,The following statement contains a magic number: for (int i = 2; i < header.Length; ++i)              {                  header[i] = Binary.RotByteL (header[i]' shift);                  if (++shift >= 7)                      shift = 1;                  if (--count == 0)                  {                      if (shift <= 4)                          count = header[1];                      else                          count = header[0];                      shift = 1;                  }              }
Magic Number,GameRes.Formats.Saiki,ObfuscatedImageFormat,C:\repos\morkt_GARbro\Legacy\Saiki\ImageJPX.cs,OpenEncrypted,The following statement contains a magic number: for (int i = 2; i < header.Length; ++i)              {                  header[i] = Binary.RotByteL (header[i]' shift);                  if (++shift >= 7)                      shift = 1;                  if (--count == 0)                  {                      if (shift <= 4)                          count = header[1];                      else                          count = header[0];                      shift = 1;                  }              }
Magic Number,GameRes.Formats.Saiki,ObfuscatedImageFormat,C:\repos\morkt_GARbro\Legacy\Saiki\ImageJPX.cs,OpenEncrypted,The following statement contains a magic number: for (int i = 2; i < header.Length; ++i)              {                  header[i] = Binary.RotByteL (header[i]' shift);                  if (++shift >= 7)                      shift = 1;                  if (--count == 0)                  {                      if (shift <= 4)                          count = header[1];                      else                          count = header[0];                      shift = 1;                  }              }
Magic Number,GameRes.Formats.Saiki,JpxFormat,C:\repos\morkt_GARbro\Legacy\Saiki\ImageJPX.cs,ReadMetaData,The following statement contains a magic number: var header = stream.ReadHeader (2);
Magic Number,GameRes.Formats.Saiki,BmxFormat,C:\repos\morkt_GARbro\Legacy\Saiki\ImageJPX.cs,ReadMetaData,The following statement contains a magic number: var header = stream.ReadHeader (2);
Magic Number,GameRes.Formats.Sceplay,PakOpener,C:\repos\morkt_GARbro\Legacy\Sceplay\ArcPAK.cs,TryOpen,The following statement contains a magic number: int count = file.View.ReadInt32 (4);
Magic Number,GameRes.Formats.Sceplay,PakOpener,C:\repos\morkt_GARbro\Legacy\Sceplay\ArcPAK.cs,TryOpen,The following statement contains a magic number: using (var index = file.CreateStream())              {                  index.Position = 8;                  var dir = new List<Entry> (count);                  for (int i = 0; i < count; ++i)                  {                      var name = index.ReadCString (0x18);                      if (string.IsNullOrEmpty (name))                          return null;                      var entry = FormatCatalog.Instance.Create<Entry> (name);                      dir.Add (entry);                  }                  for (int i = 0; i < count; ++i)                      dir[i].Size = index.ReadUInt32();                  for (int i = 0; i < count; ++i)                      dir[i].Offset = index.ReadUInt32();                  dir = dir.Where (e => e.Offset != uint.MaxValue).ToList();                  if (dir.Any (e => !e.CheckPlacement (file.MaxOffset)))                      return null;                  return new ArcFile (file' this' dir);              }
Magic Number,GameRes.Formats.Sceplayer,G24AFormat,C:\repos\morkt_GARbro\Legacy\Sceplay\ImageG24.cs,ReadMetaData,The following statement contains a magic number: return new ImageMetaData {                   Width = header.ToUInt32 (8)'                  Height = header.ToUInt32 (0xC)'                  BPP = 24'              };
Magic Number,GameRes.Formats.Sceplayer,G24AFormat,C:\repos\morkt_GARbro\Legacy\Sceplay\ImageG24.cs,ReadMetaData,The following statement contains a magic number: return new ImageMetaData {                   Width = header.ToUInt32 (8)'                  Height = header.ToUInt32 (0xC)'                  BPP = 24'              };
Magic Number,GameRes.Formats.Sceplayer,G24AFormat,C:\repos\morkt_GARbro\Legacy\Sceplay\ImageG24.cs,Read,The following statement contains a magic number: byte r = pixels[2];
Magic Number,GameRes.Formats.Sceplayer,G24AFormat,C:\repos\morkt_GARbro\Legacy\Sceplay\ImageG24.cs,Read,The following statement contains a magic number: for (int i = 3; i < pixels.Length; i += 3)              {                  pixels[i  ] += b;                  pixels[i+1] += g;                  pixels[i+2] += r;                  b = pixels[i  ];                  g = pixels[i+1];                  r = pixels[i+2];              }
Magic Number,GameRes.Formats.Sceplayer,G24AFormat,C:\repos\morkt_GARbro\Legacy\Sceplay\ImageG24.cs,Read,The following statement contains a magic number: for (int i = 3; i < pixels.Length; i += 3)              {                  pixels[i  ] += b;                  pixels[i+1] += g;                  pixels[i+2] += r;                  b = pixels[i  ];                  g = pixels[i+1];                  r = pixels[i+2];              }
Magic Number,GameRes.Formats.Sceplayer,G24AFormat,C:\repos\morkt_GARbro\Legacy\Sceplay\ImageG24.cs,Read,The following statement contains a magic number: for (int i = 3; i < pixels.Length; i += 3)              {                  pixels[i  ] += b;                  pixels[i+1] += g;                  pixels[i+2] += r;                  b = pixels[i  ];                  g = pixels[i+1];                  r = pixels[i+2];              }
Magic Number,GameRes.Formats.Sceplayer,G24AFormat,C:\repos\morkt_GARbro\Legacy\Sceplay\ImageG24.cs,Read,The following statement contains a magic number: for (int i = 3; i < pixels.Length; i += 3)              {                  pixels[i  ] += b;                  pixels[i+1] += g;                  pixels[i+2] += r;                  b = pixels[i  ];                  g = pixels[i+1];                  r = pixels[i+2];              }
Magic Number,GameRes.Formats.Sceplayer,G24AFormat,C:\repos\morkt_GARbro\Legacy\Sceplay\ImageG24.cs,Read,The following statement contains a magic number: return ImageData.CreateFlipped (info' PixelFormats.Bgr24' null' pixels' (int)info.Width * 3);
Magic Number,GameRes.Formats.Sceplayer,G2408Format,C:\repos\morkt_GARbro\Legacy\Sceplay\ImageG24.cs,ReadMetaData,The following statement contains a magic number: byte type = header[5];
Magic Number,GameRes.Formats.Sceplayer,G2408Format,C:\repos\morkt_GARbro\Legacy\Sceplay\ImageG24.cs,ReadMetaData,The following statement contains a magic number: return new G24MetaData {                   Width = header.ToUInt32 (0xC)'                  Height = header.ToUInt32 (0x10)'                  BPP = 8'                  Type = type              };
Magic Number,GameRes.Formats.Sceplayer,G2408Format,C:\repos\morkt_GARbro\Legacy\Sceplay\ImageG24.cs,Read,The following statement contains a magic number: if ('a' == meta.Type)              {                  byte p = pixels[pixels.Length-1];                  for (int i = pixels.Length-2; i >= 0; --i)                  {                      p += pixels[i];                      pixels[i] = p;                  }              }
Magic Number,GameRes.Formats.Sceplayer,G24Reader,C:\repos\morkt_GARbro\Legacy\Sceplay\ImageG24.cs,UnpackRle,The following statement contains a magic number: while (m_input.PeekByte() != -1 && dst < output.Length)              {                  byte ctl = m_input.ReadUInt8();                  if (ctl != 0xF0)                  {                      output[dst++] = (byte)ctl;                  }                  else                  {                      byte count = m_input.ReadUInt8();                      if (0 == count)                      {                          output[dst++] = (byte)ctl;                      }                      else if (1 == count)                      {                          output[dst++] = 0xF0;                      }                      else if (2 == count)                      {                          output[dst++] = 0xF0;                          output[dst++] = 0xF0;                      }                      else                      {                          byte v = m_input.ReadUInt8();                          while (count --> 0)                              output[dst++] = v;                      }                  }              }
Magic Number,GameRes.Formats.ShapeShifter,BndOpener,C:\repos\morkt_GARbro\Legacy\ShapeShifter\ArcBND.cs,TryOpen,The following statement contains a magic number: uint first_offset = file.View.ReadUInt32 (4);
Magic Number,GameRes.Formats.ShapeShifter,BndOpener,C:\repos\morkt_GARbro\Legacy\ShapeShifter\ArcBND.cs,TryOpen,The following statement contains a magic number: if (first_offset != 4 +(uint)count * 12)                  return null;
Magic Number,GameRes.Formats.ShapeShifter,BndOpener,C:\repos\morkt_GARbro\Legacy\ShapeShifter\ArcBND.cs,TryOpen,The following statement contains a magic number: if (first_offset != 4 +(uint)count * 12)                  return null;
Magic Number,GameRes.Formats.ShapeShifter,BndOpener,C:\repos\morkt_GARbro\Legacy\ShapeShifter\ArcBND.cs,TryOpen,The following statement contains a magic number: uint index_offset = 4;
Magic Number,GameRes.Formats.ShapeShifter,BndOpener,C:\repos\morkt_GARbro\Legacy\ShapeShifter\ArcBND.cs,TryOpen,The following statement contains a magic number: for (int i = 0; i < count; ++i)              {                  uint offset = file.View.ReadUInt32 (index_offset);                  var entry = new PackedEntry {                      Name = string.Format ("{0}#{1:D4}"' base_name' i)'                      Type = default_type'                      Offset = file.View.ReadUInt32 (index_offset)'                      UnpackedSize = file.View.ReadUInt32 (index_offset+4)'                      Size = file.View.ReadUInt32 (index_offset+8)'                  };                  if (!entry.CheckPlacement (file.MaxOffset))                      return null;                  entry.IsPacked = entry.UnpackedSize != entry.Size;                  dir.Add (entry);                  index_offset += 12;              }
Magic Number,GameRes.Formats.ShapeShifter,BndOpener,C:\repos\morkt_GARbro\Legacy\ShapeShifter\ArcBND.cs,TryOpen,The following statement contains a magic number: for (int i = 0; i < count; ++i)              {                  uint offset = file.View.ReadUInt32 (index_offset);                  var entry = new PackedEntry {                      Name = string.Format ("{0}#{1:D4}"' base_name' i)'                      Type = default_type'                      Offset = file.View.ReadUInt32 (index_offset)'                      UnpackedSize = file.View.ReadUInt32 (index_offset+4)'                      Size = file.View.ReadUInt32 (index_offset+8)'                  };                  if (!entry.CheckPlacement (file.MaxOffset))                      return null;                  entry.IsPacked = entry.UnpackedSize != entry.Size;                  dir.Add (entry);                  index_offset += 12;              }
Magic Number,GameRes.Formats.ShapeShifter,BndOpener,C:\repos\morkt_GARbro\Legacy\ShapeShifter\ArcBND.cs,TryOpen,The following statement contains a magic number: for (int i = 0; i < count; ++i)              {                  uint offset = file.View.ReadUInt32 (index_offset);                  var entry = new PackedEntry {                      Name = string.Format ("{0}#{1:D4}"' base_name' i)'                      Type = default_type'                      Offset = file.View.ReadUInt32 (index_offset)'                      UnpackedSize = file.View.ReadUInt32 (index_offset+4)'                      Size = file.View.ReadUInt32 (index_offset+8)'                  };                  if (!entry.CheckPlacement (file.MaxOffset))                      return null;                  entry.IsPacked = entry.UnpackedSize != entry.Size;                  dir.Add (entry);                  index_offset += 12;              }
Magic Number,GameRes.Formats.System21,PakOpener,C:\repos\morkt_GARbro\Legacy\System21\ArcPAK.cs,TryOpen,The following statement contains a magic number: uint data_offset = file.View.ReadUInt32 (4);
Magic Number,GameRes.Formats.System21,PakOpener,C:\repos\morkt_GARbro\Legacy\System21\ArcPAK.cs,TryOpen,The following statement contains a magic number: int count = (int)((data_offset - 12) / (name_size + 4));
Magic Number,GameRes.Formats.System21,PakOpener,C:\repos\morkt_GARbro\Legacy\System21\ArcPAK.cs,TryOpen,The following statement contains a magic number: int count = (int)((data_offset - 12) / (name_size + 4));
Magic Number,GameRes.Formats.System21,PakOpener,C:\repos\morkt_GARbro\Legacy\System21\ArcPAK.cs,TryOpen,The following statement contains a magic number: uint index_offset = 12;
Magic Number,GameRes.Formats.System21,PakOpener,C:\repos\morkt_GARbro\Legacy\System21\ArcPAK.cs,TryOpen,The following statement contains a magic number: for (int i = 0; i < count; ++i)              {                  var name = file.View.ReadString (index_offset' name_size);                  var entry = FormatCatalog.Instance.Create<Entry> (name);                  entry.Offset = data_offset;                  entry.Size = file.View.ReadUInt32 (index_offset + name_size);                  if (!entry.CheckPlacement (file.MaxOffset))                      return null;                  dir.Add (entry);                  index_offset += name_size + 4;                  data_offset += entry.Size;              }
Magic Number,GameRes.Formats.System21,BetFormat,C:\repos\morkt_GARbro\Legacy\System21\ImageBET.cs,ReadMetaData,The following statement contains a magic number: using (var lz = OpenLzStream (file.AsStream))              using (var input = new BinaryStream (lz' file.Name))              {                  uint w = input.ReadUInt32();                  uint h = input.ReadUInt32();                  int bpp = input.ReadUInt16();                  if ((bpp != 24 && bpp != 8) || 0 == w || w > 0x8000 || 0 == h || h > 0x8000)                      return null;                  return new ImageMetaData { Width = w' Height = h' BPP = bpp };              }
Magic Number,GameRes.Formats.System21,BetFormat,C:\repos\morkt_GARbro\Legacy\System21\ImageBET.cs,ReadMetaData,The following statement contains a magic number: using (var lz = OpenLzStream (file.AsStream))              using (var input = new BinaryStream (lz' file.Name))              {                  uint w = input.ReadUInt32();                  uint h = input.ReadUInt32();                  int bpp = input.ReadUInt16();                  if ((bpp != 24 && bpp != 8) || 0 == w || w > 0x8000 || 0 == h || h > 0x8000)                      return null;                  return new ImageMetaData { Width = w' Height = h' BPP = bpp };              }
Magic Number,GameRes.Formats.System21,BetFormat,C:\repos\morkt_GARbro\Legacy\System21\ImageBET.cs,Read,The following statement contains a magic number: using (var input = OpenLzStream (file.AsStream))              {                  int stride = (int)info.Width * info.BPP / 8;                  var pixels = new byte[stride * (int)info.Height];                  for (int i = 0; i < 10; ++i)                      input.ReadByte();                  BitmapPalette palette = null;                  if (8 == info.BPP)                      palette = ReadPalette (input);                  if (input.Read (pixels' 0' pixels.Length) != pixels.Length)                      throw new InvalidFormatException();                  for (int i = 0; i < pixels.Length; ++i)                      pixels[i] ^= 0xFF;                  PixelFormat format = 8 == info.BPP ? PixelFormats.Indexed8 : PixelFormats.Bgr24;                  return ImageData.CreateFlipped (info' format' palette' pixels' stride);              }
Magic Number,GameRes.Formats.System21,BetFormat,C:\repos\morkt_GARbro\Legacy\System21\ImageBET.cs,Read,The following statement contains a magic number: using (var input = OpenLzStream (file.AsStream))              {                  int stride = (int)info.Width * info.BPP / 8;                  var pixels = new byte[stride * (int)info.Height];                  for (int i = 0; i < 10; ++i)                      input.ReadByte();                  BitmapPalette palette = null;                  if (8 == info.BPP)                      palette = ReadPalette (input);                  if (input.Read (pixels' 0' pixels.Length) != pixels.Length)                      throw new InvalidFormatException();                  for (int i = 0; i < pixels.Length; ++i)                      pixels[i] ^= 0xFF;                  PixelFormat format = 8 == info.BPP ? PixelFormats.Indexed8 : PixelFormats.Bgr24;                  return ImageData.CreateFlipped (info' format' palette' pixels' stride);              }
Magic Number,GameRes.Formats.System21,BetFormat,C:\repos\morkt_GARbro\Legacy\System21\ImageBET.cs,Read,The following statement contains a magic number: using (var input = OpenLzStream (file.AsStream))              {                  int stride = (int)info.Width * info.BPP / 8;                  var pixels = new byte[stride * (int)info.Height];                  for (int i = 0; i < 10; ++i)                      input.ReadByte();                  BitmapPalette palette = null;                  if (8 == info.BPP)                      palette = ReadPalette (input);                  if (input.Read (pixels' 0' pixels.Length) != pixels.Length)                      throw new InvalidFormatException();                  for (int i = 0; i < pixels.Length; ++i)                      pixels[i] ^= 0xFF;                  PixelFormat format = 8 == info.BPP ? PixelFormats.Indexed8 : PixelFormats.Bgr24;                  return ImageData.CreateFlipped (info' format' palette' pixels' stride);              }
Magic Number,GameRes.Formats.System21,BetFormat,C:\repos\morkt_GARbro\Legacy\System21\ImageBET.cs,Read,The following statement contains a magic number: using (var input = OpenLzStream (file.AsStream))              {                  int stride = (int)info.Width * info.BPP / 8;                  var pixels = new byte[stride * (int)info.Height];                  for (int i = 0; i < 10; ++i)                      input.ReadByte();                  BitmapPalette palette = null;                  if (8 == info.BPP)                      palette = ReadPalette (input);                  if (input.Read (pixels' 0' pixels.Length) != pixels.Length)                      throw new InvalidFormatException();                  for (int i = 0; i < pixels.Length; ++i)                      pixels[i] ^= 0xFF;                  PixelFormat format = 8 == info.BPP ? PixelFormats.Indexed8 : PixelFormats.Bgr24;                  return ImageData.CreateFlipped (info' format' palette' pixels' stride);              }
Magic Number,GameRes.Formats.Tsd,McdOpener,C:\repos\morkt_GARbro\Legacy\Tsd\ArcMCD.cs,TryOpen,The following statement contains a magic number: if (!file.View.AsciiEqual (4' "for Win"))                  return null;
Magic Number,GameRes.Formats.Tsd,McdOpener,C:\repos\morkt_GARbro\Legacy\Tsd\ArcMCD.cs,TryOpen,The following statement contains a magic number: uint index_offset = file.View.ReadUInt32 (file.MaxOffset-8);
Magic Number,GameRes.Formats.Tsd,McdOpener,C:\repos\morkt_GARbro\Legacy\Tsd\ArcMCD.cs,TryOpen,The following statement contains a magic number: int count = file.View.ReadInt32 (file.MaxOffset-4);
Magic Number,GameRes.Formats.Tsd,McdOpener,C:\repos\morkt_GARbro\Legacy\Tsd\ArcMCD.cs,TryOpen,The following statement contains a magic number: for (int i = 0; i < count; ++i)              {                  var entry = new Entry {                      Name = string.Format ("{0}#{1:D4}"' base_name' i)'                      Offset = file.View.ReadUInt32 (index_offset)'                      Size   = file.View.ReadUInt32 (index_offset+4)'                  };                  if (!entry.CheckPlacement (file.MaxOffset))                      return null;                  dir.Add (entry);                  index_offset += 8;              }
Magic Number,GameRes.Formats.Tsd,McdOpener,C:\repos\morkt_GARbro\Legacy\Tsd\ArcMCD.cs,TryOpen,The following statement contains a magic number: for (int i = 0; i < count; ++i)              {                  var entry = new Entry {                      Name = string.Format ("{0}#{1:D4}"' base_name' i)'                      Offset = file.View.ReadUInt32 (index_offset)'                      Size   = file.View.ReadUInt32 (index_offset+4)'                  };                  if (!entry.CheckPlacement (file.MaxOffset))                      return null;                  dir.Add (entry);                  index_offset += 8;              }
Magic Number,GameRes.Formats.Tsd,McdOpener,C:\repos\morkt_GARbro\Legacy\Tsd\ArcMCD.cs,OpenImage,The following statement contains a magic number: var header = arc.File.View.ReadBytes (entry.Offset' 2);
Magic Number,GameRes.Formats.Tsd,McdOpener,C:\repos\morkt_GARbro\Legacy\Tsd\ArcMCD.cs,OpenImage,The following statement contains a magic number: Stream input = arc.File.CreateStream (entry.Offset+2' entry.Size-2);
Magic Number,GameRes.Formats.Tsd,McdOpener,C:\repos\morkt_GARbro\Legacy\Tsd\ArcMCD.cs,OpenImage,The following statement contains a magic number: Stream input = arc.File.CreateStream (entry.Offset+2' entry.Size-2);
