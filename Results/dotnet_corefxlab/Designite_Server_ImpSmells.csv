Implementation smell,Namespace,Class,File,Method,Description
Long Method,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The method has 120 lines of code.
Complex Method,SimpleHttpServer,Connection,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,OnRead,Cyclomatic complexity of the method is 13
Complex Method,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,Cyclomatic complexity of the method is 26
Long Statement,SimpleHttpServer,Connection,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,DoRead,The length of the statement  "                        int bytesRead = _socket.Receive(_readEventArgs.Buffer' tailBytes' _readEventArgs.Buffer.Length - tailBytes' SocketFlags.None); " is 126.
Long Statement,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The length of the statement  "            if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ') " is 147.
Long Statement,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The length of the statement  "                if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P' " is 146.
Long Statement,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The length of the statement  "                                   && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1') " is 128.
Complex Conditional,SimpleHttpServer,Connection,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,FindEndRequestBackwards,The conditional expression  "buffer[len - 1] == (byte)'\n' && buffer[len - 2] == (byte)'\r' &&                          buffer[len - 3] == (byte)'\n' && buffer[len - 4] == (byte)'\r'"  is complex.
Complex Conditional,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The conditional expression  "end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' '"  is complex.
Complex Conditional,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The conditional expression  "end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1'"  is complex.
Magic Number,SimpleHttpServer,Program,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,Start,The following statement contains a magic number: s_listenSocket.Bind(new IPEndPoint(IPAddress.Any' 5000));
Magic Number,SimpleHttpServer,Program,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,Start,The following statement contains a magic number: s_listenSocket.Listen(1000);
Magic Number,SimpleHttpServer,Response,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,GrowBuffer,The following statement contains a magic number: int newLength = oldBuffer.Length * 2 < minLength ? minLength : oldBuffer.Length * 2;
Magic Number,SimpleHttpServer,Response,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,GrowBuffer,The following statement contains a magic number: int newLength = oldBuffer.Length * 2 < minLength ? minLength : oldBuffer.Length * 2;
Magic Number,SimpleHttpServer,Response,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,AppendUnsigned,The following statement contains a magic number: if (i >= 10)                      AppendUnsigned(i / 10);
Magic Number,SimpleHttpServer,Response,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,AppendUnsigned,The following statement contains a magic number: if (i >= 10)                      AppendUnsigned(i / 10);
Magic Number,SimpleHttpServer,Response,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,AppendUnsigned,The following statement contains a magic number: AppendByte((byte)(0x30 + (i % 10)));
Magic Number,SimpleHttpServer,Connection,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,Connection,The following statement contains a magic number: _readEventArgs.SetBuffer(new byte[4096]' 0' 4096);
Magic Number,SimpleHttpServer,Connection,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,Connection,The following statement contains a magic number: _readEventArgs.SetBuffer(new byte[4096]' 0' 4096);
Magic Number,SimpleHttpServer,Connection,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,Connection,The following statement contains a magic number: _writeEventArgs.SetBuffer(new byte[4096]' 0' 4096);
Magic Number,SimpleHttpServer,Connection,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,Connection,The following statement contains a magic number: _writeEventArgs.SetBuffer(new byte[4096]' 0' 4096);
Magic Number,SimpleHttpServer,Connection,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,FindEndRequestBackwards,The following statement contains a magic number: while (len >= 4)                  {                      if (buffer[len - 1] == (byte)'\n' && buffer[len - 2] == (byte)'\r' &&                          buffer[len - 3] == (byte)'\n' && buffer[len - 4] == (byte)'\r')                      {                          return len;                      }                      len -= 1;                  }
Magic Number,SimpleHttpServer,Connection,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,FindEndRequestBackwards,The following statement contains a magic number: while (len >= 4)                  {                      if (buffer[len - 1] == (byte)'\n' && buffer[len - 2] == (byte)'\r' &&                          buffer[len - 3] == (byte)'\n' && buffer[len - 4] == (byte)'\r')                      {                          return len;                      }                      len -= 1;                  }
Magic Number,SimpleHttpServer,Connection,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,FindEndRequestBackwards,The following statement contains a magic number: while (len >= 4)                  {                      if (buffer[len - 1] == (byte)'\n' && buffer[len - 2] == (byte)'\r' &&                          buffer[len - 3] == (byte)'\n' && buffer[len - 4] == (byte)'\r')                      {                          return len;                      }                      len -= 1;                  }
Magic Number,SimpleHttpServer,Connection,C:\repos\dotnet_corefxlab\samples\SimpleHttp\Program.cs,FindEndRequestBackwards,The following statement contains a magic number: while (len >= 4)                  {                      if (buffer[len - 1] == (byte)'\n' && buffer[len - 2] == (byte)'\r' &&                          buffer[len - 3] == (byte)'\n' && buffer[len - 4] == (byte)'\r')                      {                          return len;                      }                      len -= 1;                  }
Magic Number,SimpleHttpServer,ParseResult,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,GrowArray,The following statement contains a magic number: if (a == null)                  a = new int[5];
Magic Number,SimpleHttpServer,ParseResult,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,GrowArray,The following statement contains a magic number: if (a.Length <= length)              {                  int[] n = new int[length * 2];                  for (int i = 0; i < a.Length; i++)                  {                      n[i] = a[i];                  }                  a = n;              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttp\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
