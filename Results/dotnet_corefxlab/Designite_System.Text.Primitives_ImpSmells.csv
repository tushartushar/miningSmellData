Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The method has 245 lines of code.
Long Method,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The method has 285 lines of code.
Long Method,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The method has 487 lines of code.
Long Method,System.Buffers.Text,Utf8Utility,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The method has 151 lines of code.
Long Method,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The method has 162 lines of code.
Long Method,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt32,The method has 105 lines of code.
Complex Method,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,Cyclomatic complexity of the method is 32
Complex Method,System.Buffers.Text,Utf8Utility,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,Cyclomatic complexity of the method is 16
Complex Method,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatNumber,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatUInt64,Cyclomatic complexity of the method is 9
Complex Method,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimalInvariantCultureUtf16,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimalInvariantCultureUtf8,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf8,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,Cyclomatic complexity of the method is 28
Complex Method,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,Cyclomatic complexity of the method is 10
Complex Method,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,Cyclomatic complexity of the method is 9
Complex Method,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatHexUInt64,Cyclomatic complexity of the method is 9
Complex Method,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatTimeSpan,Cyclomatic complexity of the method is 9
Complex Method,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseSByte,Cyclomatic complexity of the method is 16
Complex Method,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt16,Cyclomatic complexity of the method is 16
Complex Method,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt32,Cyclomatic complexity of the method is 18
Complex Method,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt64,Cyclomatic complexity of the method is 16
Complex Method,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseByte,Cyclomatic complexity of the method is 13
Complex Method,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt16,Cyclomatic complexity of the method is 13
Complex Method,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt32,Cyclomatic complexity of the method is 13
Complex Method,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt64,Cyclomatic complexity of the method is 13
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,Cyclomatic complexity of the method is 19
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,Cyclomatic complexity of the method is 13
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,Cyclomatic complexity of the method is 13
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,Cyclomatic complexity of the method is 14
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,Cyclomatic complexity of the method is 13
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,Cyclomatic complexity of the method is 13
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,Cyclomatic complexity of the method is 14
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,Cyclomatic complexity of the method is 13
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,Cyclomatic complexity of the method is 13
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,Cyclomatic complexity of the method is 14
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,Cyclomatic complexity of the method is 13
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,Cyclomatic complexity of the method is 13
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,Cyclomatic complexity of the method is 13
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,Cyclomatic complexity of the method is 13
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseDecimal,Cyclomatic complexity of the method is 10
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,ParsingTrie,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,CreateParsingTrieNodeAndChildren,Cyclomatic complexity of the method is 10
Complex Method,System.Buffers.Text,ParsingTrie,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,Create,Cyclomatic complexity of the method is 10
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatNumber,The method has 6 parameters. Parameters: value' isSingle' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatInt64,The method has 6 parameters. Parameters: value' mask' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatUInt64,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatCore,The method has 5 parameters. Parameters: value' mask' buffer' bytesWritten' format
Long Parameter List,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatHexUInt64,The method has 5 parameters. Parameters: value' precision' useLower' buffer' bytesWritten
Long Parameter List,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseSByte,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt16,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt32,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt64,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseByte,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt16,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt32,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt64,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The method has 6 parameters. Parameters: text' ends' begin' end' value' charactersConsumed
Long Identifier,System.Buffers.Text,EncodingHelper,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\EncodingHelper.cs,,The length of the parameter BasicMultilingualPlaneEndMarker is 31.
Long Identifier,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,ConsumeAsciiBytesVectorized,The length of the parameter pbFinalPosAtWhichCanReadTwoVectors is 34.
Long Identifier,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the parameter inputBufferFinalOffsetAtWhichCanSafelyLoop is 42.
Long Identifier,System.Buffers.Text,Utf8Validator,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Validator.cs,ConsumeDataWithExistingPartialSequence,The length of the parameter partialSequenceOriginalByteCount is 32.
Long Identifier,System.Buffers.Text,Utf8Validator,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Validator.cs,ConsumeDataWithExistingPartialSequence,The length of the parameter numBytesToCopyFromInputToPartialSequence is 40.
Long Identifier,System.Buffers.Text,Utf8Validator,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Validator.cs,ConsumeDataWithExistingPartialSequence,The length of the parameter numBytesRequiredFromInputBufferToFinishPartialSequence is 54.
Long Identifier,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The length of the parameter trailingZerosAfterDecimalCount is 30.
Long Statement,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The length of the statement  "                // KEEP THIS IMPLEMENTATION IN SYNC WITH https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Text/UTF8Encoding.cs " is 144.
Long Statement,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The length of the statement  "                            Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U); " is 121.
Long Statement,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The length of the statement  "                            Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U); " is 122.
Long Statement,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The length of the statement  "                            Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U); " is 125.
Long Statement,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The length of the statement  "                            Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U); " is 122.
Long Statement,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The length of the statement  "                            Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U); " is 126.
Long Statement,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The length of the statement  "                            Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U); " is 125.
Long Statement,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16,The length of the statement  "                            Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten)) = (char)(((codePoint - 0x010000u) >> 10) + EncodingHelper.HighSurrogateStart); " is 139.
Long Statement,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16,The length of the statement  "                            Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten + 2)) = (char)((codePoint & 0x3FF) + EncodingHelper.LowSurrogateStart); " is 130.
Long Statement,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,ConsumeAsciiBytesVectorized,The length of the statement  "                    if (((Unsafe.Read<Vector<byte>>(pbAlignedBuffer) | Unsafe.Read<Vector<byte>>(pbAlignedBuffer + Vector<byte>.Count)) & mask) != Vector<byte>.Zero) " is 145.
Long Statement,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "                    if ((inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer))) " is 137.
Long Statement,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "                        inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong); " is 160.
Long Statement,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "                    if ((inputLength >= 2 * sizeof(uint) + 3 * Vector<byte>.Count) && DWordAllBytesAreAscii(ReadAndFoldTwoDWordsUnaligned(ref inputBuffer))) " is 136.
Long Statement,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "                        inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(uint))' inputLength - 2 * sizeof(uint)) + 2 * sizeof(uint); " is 157.
Long Statement,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "                Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read."); " is 129.
Long Statement,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "                        || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord)))) " is 135.
Long Statement,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "                        if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong)))) " is 160.
Long Statement,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "            scalarCount = tempScalarCount - inputBufferRemainingBytes; // we assumed earlier each byte corresponded to a single scalar' perform fixup now to account for unread bytes " is 169.
Long Statement,System.Buffers.Text,Utf8Validator,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Validator.cs,ConsumeDataWithExistingPartialSequence,The length of the statement  "            utf8Bytes.Slice(0' numBytesToCopyFromInputToPartialSequence).CopyTo(partialSequenceAsBytes.Slice(partialSequenceOriginalByteCount)); " is 132.
Long Statement,System.Buffers.Text,Utf8Validator,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Validator.cs,ConsumeDataWithExistingPartialSequence,The length of the statement  "            var validity = Utf8Utility.PeekFirstSequence(partialSequenceAsBytes.Slice(0' partialSequenceNewByteCount)' out int numBytesConsumed' out _); " is 140.
Long Statement,System.Buffers.Text,Utf8Validator,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Validator.cs,ConsumeDataWithExistingPartialSequence,The length of the statement  "                return ConsumeDataWithoutExistingPartialSequence(utf8Bytes.Slice(numBytesRequiredFromInputBufferToFinishPartialSequence)); " is 122.
Long Statement,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The length of the statement  "                // Count amount of digits before first group separator. It will be reset to groupSize every time digitsLeftInGroup == zero " is 122.
Long Statement,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseSByte,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt16,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt32,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt64,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseByte,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt16,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt32,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt64,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The length of the statement  "            if (!Hex.TryParseUInt32(text.Slice(0' 8)' out uint i1' out int justConsumed) || justConsumed != 8) return false; // 8 digits " is 124.
Long Statement,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The length of the statement  "            if (!Hex.TryParseUInt16(text.Slice(8' 4)' out ushort i2' out justConsumed) || justConsumed != 4) return false; // next 4 digfits " is 128.
Long Statement,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The length of the statement  "            if (!Hex.TryParseUInt16(text.Slice(12' 4)' out ushort i3' out justConsumed) || justConsumed != 4) return false; // next 4 digits " is 128.
Long Statement,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The length of the statement  "            if (!Hex.TryParseUInt16(text.Slice(16' 4)' out ushort i4' out justConsumed) || justConsumed != 4) return false; // next 4 digits " is 128.
Long Statement,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The length of the statement  "            if (!Hex.TryParseUInt64(text.Slice(20)' out ulong i5' out justConsumed) || justConsumed != 12) return false; // next 12 digits " is 126.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,ParsingTrie,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,CreateParsingTrieNodeAndChildren,The length of the statement  "            // Reserve space in list for child nodes. In this algorithm' all parent nodes are created first' leaving gaps for the child nodes " is 129.
Long Statement,System.Buffers.Text,SymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,TryParse,The length of the statement  "                if (_parsingTrie[trieIndex].ValueOrNumChildren == 0)    // if numChildren == 0' we're on a leaf & we've found our value and completed the code unit " is 147.
Long Statement,System.Buffers.Text,SymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,TryParse,The length of the statement  "                    int search = BinarySearch(trieIndex' codeUnitIndex' source[codeUnitIndex]);    // we search the _parsingTrie for the nextByte " is 125.
Long Statement,System.Buffers.Text,SymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,TryEncode,The length of the statement  "                if(TextEncodings.Utf16.ToUtf8(srcBytes' temp' out int consumed' out int written) == OperationStatus.InvalidData)                     goto ExitFailed; " is 149.
Complex Conditional,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The conditional expression  "(BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord)))"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseDecimal,The conditional expression  "(decimalPlace && signed && charactersConsumed == 2) || ((signed || decimalPlace) && charactersConsumed == 1)"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseDecimal,The conditional expression  "(decimalPlace && signed && charactersConsumed == 2) || ((signed || decimalPlace) && charactersConsumed == 1)"  is complex.
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,ToLowerInPlace,The following statement contains a magic number: next > 127
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,ToLower,The following statement contains a magic number: next > 127
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,ToUpperInPlace,The following statement contains a magic number: next > 127
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,ToUpper,The following statement contains a magic number: next > 127
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: i += 12;
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 2) = (char)*(input + 2);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 2) = (char)*(input + 2);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 3) = (char)*(input + 3);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 3) = (char)*(input + 3);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 4) = (char)*(input + 4);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 4) = (char)*(input + 4);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 5) = (char)*(input + 5);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 5) = (char)*(input + 5);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 6) = (char)*(input + 6);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 6) = (char)*(input + 6);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 7) = (char)*(input + 7);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 7) = (char)*(input + 7);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 8) = (char)*(input + 8);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 8) = (char)*(input + 8);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 9) = (char)*(input + 9);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 9) = (char)*(input + 9);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 10) = (char)*(input + 10);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 10) = (char)*(input + 10);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 11) = (char)*(input + 11);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 11) = (char)*(input + 11);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: output += 12;
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: input += 12;
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: i < count - 11
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: i += 6;
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 2) = (char)*(input + 2);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 2) = (char)*(input + 2);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 3) = (char)*(input + 3);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 3) = (char)*(input + 3);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 4) = (char)*(input + 4);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 4) = (char)*(input + 4);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 5) = (char)*(input + 5);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 5) = (char)*(input + 5);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: output += 6;
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: input += 6;
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: i < count - 5
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: i += 4;
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 2) = (char)*(input + 2);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 2) = (char)*(input + 2);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 3) = (char)*(input + 3);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: *(output + 3) = (char)*(input + 3);
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: output += 4;
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: input += 4;
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: i < count - 3
Magic Number,System.Buffers.Text,Ascii,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: return isValid <= 127;
Magic Number,System.Buffers.Text,EncodingHelper,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\EncodingHelper.cs,GetUtf8DecodedBytes,The following statement contains a magic number: return 2;
Magic Number,System.Buffers.Text,EncodingHelper,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\EncodingHelper.cs,GetUtf8DecodedBytes,The following statement contains a magic number: return 3;
Magic Number,System.Buffers.Text,EncodingHelper,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\EncodingHelper.cs,GetUtf8DecodedBytes,The following statement contains a magic number: return 4;
Magic Number,System.Buffers.Text,EncodingHelper,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\EncodingHelper.cs,GetUtf8EncodedBytes,The following statement contains a magic number: return 2;
Magic Number,System.Buffers.Text,EncodingHelper,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\EncodingHelper.cs,GetUtf8EncodedBytes,The following statement contains a magic number: return 3;
Magic Number,System.Buffers.Text,EncodingHelper,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\EncodingHelper.cs,GetUtf8EncodedBytes,The following statement contains a magic number: return 4;
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* bytes = &MemoryMarshal.GetReference(destination))                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32Length,The following statement contains a magic number: srcLength - srcIndex < sizeof(char) * 2
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32Length,The following statement contains a magic number: uint lowSurrogate = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' srcIndex + 2));
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32Length,The following statement contains a magic number: srcIndex += 2;
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32Length,The following statement contains a magic number: srcIndex += 2;
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32Length,The following statement contains a magic number: bytesNeeded += 4;
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32,The following statement contains a magic number: srcLength - bytesConsumed < sizeof(char) * 2
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32,The following statement contains a magic number: uint lowSurrogate = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' bytesConsumed + 2));
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32,The following statement contains a magic number: codePoint = ((codePoint << 10) | lowSurrogate) + 0x010000u;
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32,The following statement contains a magic number: bytesConsumed += 2;
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32,The following statement contains a magic number: bytesConsumed += 2;
Magic Number,System.Buffers.Text,Utf16,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32,The following statement contains a magic number: bytesWritten += 4;
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8Length,The following statement contains a magic number: int utf32Length = source.Length >> 2;
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8Length,The following statement contains a magic number: utf32Length << 2 != source.Length
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: bytesConsumed += 4;
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16Length,The following statement contains a magic number: bytesNeeded += EncodingHelper.IsBmp(codePoint) ? 2 : 4;
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16Length,The following statement contains a magic number: bytesNeeded += EncodingHelper.IsBmp(codePoint) ? 2 : 4;
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16Length,The following statement contains a magic number: index += 4;
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16Length,The following statement contains a magic number: length - index >= 4
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16,The following statement contains a magic number: int written = EncodingHelper.IsBmp(codePoint) ? 2 : 4;
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16,The following statement contains a magic number: int written = EncodingHelper.IsBmp(codePoint) ? 2 : 4;
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16,The following statement contains a magic number: written == 2
Magic Number,System.Buffers.Text,Utf32,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16,The following statement contains a magic number: bytesConsumed += 4;
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16Length,The following statement contains a magic number: bytesNeeded = checked(numCodeUnits * 2);
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf16 = &MemoryMarshal.GetReference(destination))                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf32Length,The following statement contains a magic number: bytesNeeded = checked(scalarCount * 4);
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf32,The following statement contains a magic number: codePoint = (codePoint << 6) | (uint)(EncodingHelper.b0011_1111U & next);
Magic Number,System.Buffers.Text,Utf8,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf32,The following statement contains a magic number: bytesWritten += 4;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,ConvertIntPtrToInt32WithoutOverflowCheck,The following statement contains a magic number: IntPtr.Size == 4
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,CountNumberOfLeadingAsciiBytesFrom24BitInteger,The following statement contains a magic number: uint allBytesUpToNowAreAscii = (value >>= 7) & 1;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,CountNumberOfLeadingAsciiBytesFrom24BitInteger,The following statement contains a magic number: allBytesUpToNowAreAscii &= (value >>= 8);
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,CountNumberOfLeadingAsciiBytesFrom24BitInteger,The following statement contains a magic number: allBytesUpToNowAreAscii &= (value >>= 8);
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,ConsumeAsciiBytesVectorized,The following statement contains a magic number: !Vector.IsHardwareAccelerated || length < 3 * Vector<byte>.Count
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,ConsumeAsciiBytesVectorized,The following statement contains a magic number: IntPtr.Size >= 8
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,ConsumeAsciiBytesVectorized,The following statement contains a magic number: byte* pbFinalPosAtWhichCanReadTwoVectors = &pbBuffer[length - 2 * Vector<byte>.Count];
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong);
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong);
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong);
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: (inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer))
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: (inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer))
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: IntPtr.Size >= 8
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferCurrentOffset += 4;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferRemainingBytes -= 4;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferCurrentOffset += 2 * sizeof(uint);
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: !DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3))
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: !DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3))
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferCurrentOffset += 4 * sizeof(uint);
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferCurrentOffset += 4;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferRemainingBytes >= 5 * sizeof(uint)
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferCurrentOffset += 3;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferRemainingBytes -= 3;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: tempScalarCount -= 2;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: comparand = (uint)(thisQWord >> 24) & 0x200FU;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: comparand = (uint)(thisQWord >> 48) & 0x200FU;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferCurrentOffset += 9;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferRemainingBytes -= 9;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: tempScalarCount -= 6;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: comparand = (uint)(thisQWord >> 24) & 0x200FU;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferCurrentOffset += 6;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferRemainingBytes -= 6;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: tempScalarCount -= 4;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: toCheck = (toCheck << 24) | (toCheck >> 8);
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: toCheck = (toCheck << 24) | (toCheck >> 8);
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferCurrentOffset += 4;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: inputBufferRemainingBytes -= 4;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: tempScalarCount -= 3;
Magic Number,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: Debug.Assert(inputBufferRemainingBytes < 4);
Magic Number,System.Buffers.Text,Utf8Utility,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: data.Length < 2
Magic Number,System.Buffers.Text,Utf8Utility,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: scalarValue = UnicodeScalar.CreateWithoutValidation((((uint)firstByte & 0x1FU) << 6) | ((uint)secondByte & 0x3FU));
Magic Number,System.Buffers.Text,Utf8Utility,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: numBytesConsumed = 2;
Magic Number,System.Buffers.Text,Utf8Utility,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: uint scalar = (((uint)firstByte & 0x0FU) << 12) | (((uint)secondByte & 0x3FU) << 6);
Magic Number,System.Buffers.Text,Utf8Utility,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: uint scalar = (((uint)firstByte & 0x0FU) << 12) | (((uint)secondByte & 0x3FU) << 6);
Magic Number,System.Buffers.Text,Utf8Utility,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: data.Length < 3
Magic Number,System.Buffers.Text,Utf8Utility,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: uint scalar = (((uint)firstByte & 0x07U) << 18) | (((uint)secondByte & 0x3FU) << 12);
Magic Number,System.Buffers.Text,Utf8Utility,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: uint scalar = (((uint)firstByte & 0x07U) << 18) | (((uint)secondByte & 0x3FU) << 12);
Magic Number,System.Buffers.Text,Utf8Utility,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: OverlongOutOfRangeOrSurrogateSequence:              numBytesConsumed = 2;
Magic Number,System.Buffers.Text,Utf8Utility,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: numBytesConsumed = 3;
Magic Number,System.Buffers.Text,Utf8Utility,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: numBytesConsumed = 2;
Magic Number,System.Buffers.Text,Utf8Utility,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: numBytesConsumed = 3;
Magic Number,System.Buffers.Text,Utf8Validator,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Validator.cs,ConsumeDataWithExistingPartialSequence,The following statement contains a magic number: partialSequence >>= 8;
Magic Number,System.Buffers.Text,Utf8Validator,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Validator.cs,ConsumeDataWithExistingPartialSequence,The following statement contains a magic number: int numBytesToCopyFromInputToPartialSequence = Math.Min(4 - partialSequenceOriginalByteCount' utf8Bytes.Length);
Magic Number,System.Buffers.Text,Utf8Validator,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Validator.cs,ConsumeDataWithExistingPartialSequence,The following statement contains a magic number: Debug.Assert(1 <= numBytesConsumed && numBytesConsumed <= 4);
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimalInvariantCultureUtf16,The following statement contains a magic number: valueToCountDigits = valueToCountDigits / 10UL;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimalInvariantCultureUtf16,The following statement contains a magic number: valueToCountDigits >= 10UL
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimalInvariantCultureUtf16,The following statement contains a magic number: var bytesCount = digitsCount * 2;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimalInvariantCultureUtf16,The following statement contains a magic number: bytesCount += leadingZerosCount * 2;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimalInvariantCultureUtf16,The following statement contains a magic number: ulong digit = value % 10UL;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimalInvariantCultureUtf16,The following statement contains a magic number: value /= 10UL;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimalInvariantCultureUtf8,The following statement contains a magic number: valueToCountDigits = valueToCountDigits / 10UL;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimalInvariantCultureUtf8,The following statement contains a magic number: valueToCountDigits >= 10UL
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimalInvariantCultureUtf8,The following statement contains a magic number: ulong digit = value % 10UL;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimalInvariantCultureUtf8,The following statement contains a magic number: value /= 10UL;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,The following statement contains a magic number: firstHexCharOffset -= 10;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,The following statement contains a magic number: hexDigitsCount += 8;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,The following statement contains a magic number: hexDigitsCount += 4;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,The following statement contains a magic number: hexDigitsCount += 2;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,The following statement contains a magic number: var bytesCount = hexDigitsCount * 2;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,The following statement contains a magic number: bytesCount += leadingZerosCount > 0 ? leadingZerosCount * 2 : 0;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,The following statement contains a magic number: digit += digit < 10 ? firstDigitOffset : firstHexCharOffset;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf8,The following statement contains a magic number: firstHexCharOffset -= 10;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf8,The following statement contains a magic number: hexDigitsCount += 8;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf8,The following statement contains a magic number: hexDigitsCount += 4;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf8,The following statement contains a magic number: hexDigitsCount += 2;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf8,The following statement contains a magic number: digit += digit < 10 ? firstDigitOffset : firstHexCharOffset;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The following statement contains a magic number: var digit = value % 10UL;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The following statement contains a magic number: value = value / 10UL;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The following statement contains a magic number: value >= 10
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The following statement contains a magic number: const int GroupSize = 3;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The following statement contains a magic number: var nextDigit = reversedValueExceptFirst % 10UL;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The following statement contains a magic number: reversedValueExceptFirst = reversedValueExceptFirst / 10UL;
Magic Number,System.Buffers.Text,CustomFormatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The following statement contains a magic number: int trailingZerosAfterDecimalCount = format.HasPrecision ? format.Precision : 2;
Magic Number,System.Buffers.Text,FormattingHelpers,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\FormattingHelpers.cs,WriteHexByte,The following statement contains a magic number: Unsafe.Add(ref buffer' index) = HexTable[value >> 4];
Magic Number,System.Buffers.Text,FormattingHelpers,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\FormattingHelpers.cs,WriteFractionDigits,The following statement contains a magic number: value /= 10;
Magic Number,System.Buffers.Text,FormattingHelpers,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\FormattingHelpers.cs,WriteDigits,The following statement contains a magic number: left = DivMod(left' 10' out long num);
Magic Number,System.Buffers.Text,FormattingHelpers,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\FormattingHelpers.cs,WriteDigits,The following statement contains a magic number: left = DivMod(left' 10' out ulong num);
Magic Number,System.Buffers.Text,FormattingHelpers,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: n /= 10;
Magic Number,System.Buffers.Text,FormattingHelpers,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: n /= 10;
Magic Number,System.Buffers.Text,FormattingHelpers,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\FormattingHelpers.cs,CountFractionDigits,The following statement contains a magic number: left = DivMod(left' 10' out m);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: bytesWritten = text.Length * 2;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: buffer.Length < 8
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: bytesWritten = (GuidChars + (dash ? 4 : 0) + (bookEnds ? 2 : 0)) * sizeof(char);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: bytesWritten = (GuidChars + (dash ? 4 : 0) + (bookEnds ? 2 : 0)) * sizeof(char);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[3]' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[2]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[2]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[1]' ref utf16Bytes' idx + 4);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[0]' ref utf16Bytes' idx + 6);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: idx += 8;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[5]' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[4]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[4]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: idx += 4;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[7]' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[6]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[6]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: idx += 4;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[8]' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[9]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[9]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: idx += 4;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[10]' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[11]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[11]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[12]' ref utf16Bytes' idx + 4);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[12]' ref utf16Bytes' idx + 4);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[13]' ref utf16Bytes' idx + 6);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[13]' ref utf16Bytes' idx + 6);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[14]' ref utf16Bytes' idx + 8);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[14]' ref utf16Bytes' idx + 8);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[15]' ref utf16Bytes' idx + 10);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[15]' ref utf16Bytes' idx + 10);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: idx += 12;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatDecimalInt64,The following statement contains a magic number: int charsNeeded = digitCount + (int)((value >> 63) & 1);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatDecimalInt64,The following statement contains a magic number: !TryFormatDecimalUInt64((ulong)long.MaxValue + 1' precision' buffer.Slice(2)' out bytesWritten)
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatDecimalUInt64,The following statement contains a magic number: value = FormattingHelpers.DivMod(value' 10' out ulong lastDigit);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: firstGroup = 3;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: int trailingZeros = (precision == StandardFormat.NoPrecision) ? 2 : precision;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: int charsNeeded = (int)((value >> 63) & 1) + digitCount + groupSeperators;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: !TryFormatNumericUInt64((ulong)long.MaxValue + 1' precision' buffer.Slice(2)' out bytesWritten)
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: idx -= 3;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: v = FormattingHelpers.DivMod(v' 1000' out long groupValue);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: FormattingHelpers.WriteDigits(groupValue' 3' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: digitCount -= 3;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: digitCount > 3
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericUInt64,The following statement contains a magic number: value = FormattingHelpers.DivMod(value' 1000' out ulong lastGroup);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericUInt64,The following statement contains a magic number: precision = 2;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericUInt64,The following statement contains a magic number: int extraChars = 4;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericUInt64,The following statement contains a magic number: idx += FormattingHelpers.WriteDigits(lastGroup' 3' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatHexUInt64,The following statement contains a magic number: digits += 8;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatHexUInt64,The following statement contains a magic number: digits += 4;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatHexUInt64,The following statement contains a magic number: digits += 2;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: const int MinimumCharsNeeded = 19;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: charsNeeded += 7;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Month' 2' ref utf16Bytes' 0);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 2) = Slash;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 3);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 3);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 5) = Slash;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf16Bytes' 6);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf16Bytes' 6);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 10) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 11);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 11);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 13) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 14);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 14);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 16) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 19) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 20) = Minus;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(offset.Hours' 2' ref utf16Bytes' 21);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(offset.Hours' 2' ref utf16Bytes' 21);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 23) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 24);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 24);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: const int MinimumCharsNeeded = 27;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: charsNeeded += 6;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf16Bytes' 0);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 4) = Minus;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Month' 2' ref utf16Bytes' 5);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Month' 2' ref utf16Bytes' 5);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 7) = Minus;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 8);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 8);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 10) = TimeMarker;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 11);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 11);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 13) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 14);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 14);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 16) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 19) = Period;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteFractionDigits(fraction' DefaultFractionDigits' ref utf16Bytes' 20);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 27) = sign;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(offset.Hours' 2' ref utf16Bytes' 28);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(offset.Hours' 2' ref utf16Bytes' 28);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 30) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 31);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 31);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: const int CharsNeeded = 29;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 2) = dayAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 2) = dayAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 3) = Comma;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 4) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 5);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 5);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 7) = ' ';
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 8) = monthAbbrev[0];
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 9) = monthAbbrev[1];
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 10) = monthAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 10) = monthAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 11) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf16Bytes' 12);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf16Bytes' 12);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 16) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 19) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 20);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 20);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 22) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 23);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 23);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 25) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 26) = GMT1;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 27) = GMT2;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 28) = GMT3;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: const int CharsNeeded = 29;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 2) = dayAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 2) = dayAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 3) = Comma;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 4) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 5);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 5);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 7) = ' ';
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 8) = monthAbbrev[0];
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 9) = monthAbbrev[1];
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 10) = monthAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 10) = monthAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 11) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf16Bytes' 12);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf16Bytes' 12);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 16) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 19) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 20);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 20);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 22) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 23);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 23);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 25) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 26) = GMT1Lowercase;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 27) = GMT2Lowercase;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 28) = GMT3Lowercase;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatTimeSpan,The following statement contains a magic number: int hourDigits = (constant || longForm || hours > 9) ? 2 : 1;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatTimeSpan,The following statement contains a magic number: int hourDigits = (constant || longForm || hours > 9) ? 2 : 1;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatTimeSpan,The following statement contains a magic number: bytesWritten = hourDigits + 6;
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatTimeSpan,The following statement contains a magic number: idx += FormattingHelpers.WriteDigits(minutes' 2' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatTimeSpan,The following statement contains a magic number: idx += FormattingHelpers.WriteDigits(seconds' 2' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseSByte,The following statement contains a magic number: parsedValue > sbyte.MaxValue / 10 || (parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseSByte,The following statement contains a magic number: parsedValue > sbyte.MaxValue / 10 || (parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseSByte,The following statement contains a magic number: parsedValue = parsedValue * 10 + (int)nextSymbol;
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt16,The following statement contains a magic number: parsedValue > short.MaxValue / 10 || (parsedValue == short.MaxValue / 10 && nextDigitTooLarge)
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt16,The following statement contains a magic number: parsedValue > short.MaxValue / 10 || (parsedValue == short.MaxValue / 10 && nextDigitTooLarge)
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt16,The following statement contains a magic number: parsedValue = parsedValue * 10 + (int)nextSymbol;
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt32,The following statement contains a magic number: answer = answer * 10 + (int)symbol;
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt64,The following statement contains a magic number: parsedValue > long.MaxValue / 10 || (parsedValue == long.MaxValue / 10 && nextDigitTooLarge)
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt64,The following statement contains a magic number: parsedValue > long.MaxValue / 10 || (parsedValue == long.MaxValue / 10 && nextDigitTooLarge)
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt64,The following statement contains a magic number: parsedValue = parsedValue * 10 + (long)nextSymbol;
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseByte,The following statement contains a magic number: parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5)
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseByte,The following statement contains a magic number: parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5)
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseByte,The following statement contains a magic number: parsedValue = parsedValue * 10 + (uint)nextSymbol;
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt16,The following statement contains a magic number: parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5)
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt16,The following statement contains a magic number: parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5)
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt16,The following statement contains a magic number: parsedValue = parsedValue * 10 + (uint)nextSymbol;
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt32,The following statement contains a magic number: parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5)
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt32,The following statement contains a magic number: parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5)
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt32,The following statement contains a magic number: parsedValue = parsedValue * 10 + (uint)nextSymbol;
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt64,The following statement contains a magic number: parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5)
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt64,The following statement contains a magic number: parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5)
Magic Number,System.Buffers.Text,CustomParser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt64,The following statement contains a magic number: parsedValue = parsedValue * 10 + (uint)nextSymbol;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: text.Length < 32
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: !Hex.TryParseUInt32(text.Slice(0' 8)' out uint i1' out int justConsumed) || justConsumed != 8
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: !Hex.TryParseUInt32(text.Slice(0' 8)' out uint i1' out int justConsumed) || justConsumed != 8
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: !Hex.TryParseUInt16(text.Slice(8' 4)' out ushort i2' out justConsumed) || justConsumed != 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: !Hex.TryParseUInt16(text.Slice(8' 4)' out ushort i2' out justConsumed) || justConsumed != 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: !Hex.TryParseUInt16(text.Slice(8' 4)' out ushort i2' out justConsumed) || justConsumed != 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: !Hex.TryParseUInt16(text.Slice(12' 4)' out ushort i3' out justConsumed) || justConsumed != 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: !Hex.TryParseUInt16(text.Slice(12' 4)' out ushort i3' out justConsumed) || justConsumed != 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: !Hex.TryParseUInt16(text.Slice(12' 4)' out ushort i3' out justConsumed) || justConsumed != 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: !Hex.TryParseUInt16(text.Slice(16' 4)' out ushort i4' out justConsumed) || justConsumed != 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: !Hex.TryParseUInt16(text.Slice(16' 4)' out ushort i4' out justConsumed) || justConsumed != 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: !Hex.TryParseUInt16(text.Slice(16' 4)' out ushort i4' out justConsumed) || justConsumed != 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: !Hex.TryParseUInt64(text.Slice(20)' out ulong i5' out justConsumed) || justConsumed != 12
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: !Hex.TryParseUInt64(text.Slice(20)' out ulong i5' out justConsumed) || justConsumed != 12
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: charactersConsumed = 32;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: var expectedCodingUnits = 36 + (ends ? 2 : 0);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: var expectedCodingUnits = 36 + (ends ? 2 : 0);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: justConsumed != 8
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: text = text.Slice(9);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: justConsumed != 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: text = text.Slice(5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: justConsumed != 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: text = text.Slice(5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: justConsumed != 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: text = text.Slice(5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: justConsumed != 12
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: length >= 5
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: length >= 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: charactersConsumed = 4;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: charactersConsumed = 5;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: length >= 5
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: length >= 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: text.Length >= 5
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: text.Length >= 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: charactersConsumed = 4;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: charactersConsumed = 5;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: (text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: text.Length >= 5
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: text.Length >= 4
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: firstDigit < 0 || firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: int nextDigit = text[index] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: nextDigit < 0 || nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: firstDigit < 0 || firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: int nextDigit = text[index] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: nextDigit < 0 || nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: firstDigit < 0 || firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: int nextDigit = text[index] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: nextDigit < 0 || nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: firstDigit < 0 || firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: int nextDigit = text[index] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: nextDigit < 0 || nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: firstDigit < 0 || firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: int nextDigit = text[index] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: nextDigit < 0 || nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: firstDigit < 0 || firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: int nextDigit = text[index] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: nextDigit < 0 || nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: firstDigit < 0 || firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: int nextDigit = text[index] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: nextDigit < 0 || nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: firstDigit < 0 || firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: int nextDigit = text[index] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: nextDigit < 0 || nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: firstDigit < 0 || firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: int nextDigit = text[index] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: nextDigit < 0 || nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: long firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: firstDigit < 0 || firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: long nextDigit = text[index] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: nextDigit < 0 || nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: long firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: firstDigit < 0 || firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: long nextDigit = text[index] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: nextDigit < 0 || nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: long firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: firstDigit < 0 || firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: long nextDigit = text[index] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: nextDigit < 0 || nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: long firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: firstDigit < 0 || firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: long nextDigit = text[index] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: nextDigit < 0 || nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: uint firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: uint nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: uint firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: uint nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: uint firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: uint nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: uint firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: uint nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: uint firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: uint nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: uint firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: uint nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: uint firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: uint nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: uint firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: uint nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: uint firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: uint nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: uint firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: uint nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: uint firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: uint nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: uint firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: uint nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: ulong firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: ulong nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: ulong firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: ulong nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: ulong firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: ulong nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: ulong firstDigit = text[0] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: firstDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: ulong nextDigit = text[index] - 48u;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: nextDigit > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: parsedValue = parsedValue * 10 + nextDigit;
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseDecimal,The following statement contains a magic number: nextCharVal > 9
Magic Number,System.Buffers.Text,Utf16Parser,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseDecimal,The following statement contains a magic number: (decimalPlace && signed && charactersConsumed == 2) || ((signed || decimalPlace) && charactersConsumed == 1)
Magic Number,System.Buffers.Text,Parsers,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\ParsingHelpers.cs,WillOverFlow,The following statement contains a magic number: bool nextDigitTooLarge = nextDigit > 8 || (sign > 0 && nextDigit > 7);
Magic Number,System.Buffers.Text,Parsers,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\ParsingHelpers.cs,WillOverFlow,The following statement contains a magic number: bool nextDigitTooLarge = nextDigit > 8 || (sign > 0 && nextDigit > 7);
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: nextDigit == 0xFF || (nextCharacter >> 8) != 0
Magic Number,System.Buffers.Text,Hex,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: parsedValue = (parsedValue << 4) + nextDigit;
Magic Number,System.Buffers.Text,ParsingTrie,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,CreateParsingTrieNodeAndChildren,The following statement contains a magic number: longestSequence.Length > 5
Magic Number,System.Buffers.Text,ParsingTrie,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,Create,The following statement contains a magic number: List<Node> parsingTrieList = new List<Node>(100);
Magic Number,System.Buffers.Text,SuffixClump,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,SuffixClump,The following statement contains a magic number: Suffixes = new List<Suffix>(20);
Magic Number,System.Buffers.Text,Sequence,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,CreateSequenceMap,The following statement contains a magic number: sequenceMap += BeginningValue << 24;
Magic Number,System.Buffers.Text,Sequence,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,CreateSequenceMap,The following statement contains a magic number: sequenceMap += (BeginningIndex + 1) << 16;
Magic Number,System.Buffers.Text,Sequence,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,CreateSequenceMap,The following statement contains a magic number: sequenceMap += EndValue << 8;
Magic Number,System.Buffers.Text,SymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,TryEncode,The following statement contains a magic number: bytesWritten == 2
Magic Number,System.Buffers.Text,SymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,TryEncode,The following statement contains a magic number: const int BufferSize = 256;
Magic Number,System.Buffers.Text,SymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,BinarySearch,The following statement contains a magic number: return (int)(nodeIndex + ((uint)(maxMinLimits << 8) >> 24) + value - ((uint)maxMinLimits >> 24));
Magic Number,System.Buffers.Text,SymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,BinarySearch,The following statement contains a magic number: return (int)(nodeIndex + ((uint)(maxMinLimits << 8) >> 24) + value - ((uint)maxMinLimits >> 24));
Magic Number,System.Buffers.Text,SymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,BinarySearch,The following statement contains a magic number: return (int)(nodeIndex + ((uint)(maxMinLimits << 8) >> 24) + value - ((uint)maxMinLimits >> 24));
Magic Number,System.Buffers.Text,SymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,BinarySearch,The following statement contains a magic number: maxMinLimits != 0 && value > (uint)maxMinLimits >> 24 && value < (uint)(maxMinLimits << 16) >> 24
Magic Number,System.Buffers.Text,SymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,BinarySearch,The following statement contains a magic number: maxMinLimits != 0 && value > (uint)maxMinLimits >> 24 && value < (uint)(maxMinLimits << 16) >> 24
Magic Number,System.Buffers.Text,SymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,BinarySearch,The following statement contains a magic number: maxMinLimits != 0 && value > (uint)maxMinLimits >> 24 && value < (uint)(maxMinLimits << 16) >> 24
Magic Number,System.Buffers.Text,SymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,BinarySearch,The following statement contains a magic number: midIndex = (leftBound + rightBound) / 2;
Magic Number,System.Buffers.Text,Utf16InvariantSymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable_utf16.cs,TryEncode,The following statement contains a magic number: destination.Length < 2
Magic Number,System.Buffers.Text,Utf16InvariantSymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable_utf16.cs,TryEncode,The following statement contains a magic number: bytesWritten = 2;
Magic Number,System.Buffers.Text,Utf16InvariantSymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable_utf16.cs,TryParse,The following statement contains a magic number: source.Length < 2
Magic Number,System.Buffers.Text,Utf16InvariantSymbolTable,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable_utf16.cs,TryParse,The following statement contains a magic number: bytesConsumed = 2;
Duplicate Code,System.Buffers.Text,Utf8Util,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The method contains a code clone-set at the following line numbers (starting from the method definition): ((361' 382)' (406' 427))
